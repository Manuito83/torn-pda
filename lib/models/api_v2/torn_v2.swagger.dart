// ignore_for_file: type=lint, unused_import

import 'package:json_annotation/json_annotation.dart';
import 'package:json_annotation/json_annotation.dart' as json;
import 'package:collection/collection.dart';
import 'dart:convert';

import 'package:chopper/chopper.dart';
import 'package:torn_pda/providers/api/api_v2_calls.dart';

import 'client_mapping.dart';
import 'dart:async';
import 'package:http/http.dart' as http;
import 'package:http/http.dart' show MultipartFile;
import 'package:chopper/chopper.dart' as chopper;
import 'torn_v2.enums.swagger.dart' as enums;
export 'torn_v2.enums.swagger.dart';

part 'torn_v2.swagger.chopper.dart';
part 'torn_v2.swagger.g.dart';

// **************************************************************************
// SwaggerChopperGenerator
// **************************************************************************

@ChopperApi()
abstract class TornV2 extends ChopperService {
  static TornV2 create({
    ChopperClient? client,
    http.Client? httpClient,
    Authenticator? authenticator,
    ErrorConverter? errorConverter,
    Converter? converter,
    Uri? baseUrl,
    List<Interceptor>? interceptors,
  }) {
    if (client != null) {
      return _$TornV2(client);
    }

    final newClient = ChopperClient(
      services: [_$TornV2()],
      converter: converter ?? $JsonSerializableConverter(),
      interceptors: interceptors ?? [],
      client: httpClient,
      authenticator: authenticator,
      errorConverter: errorConverter,
      baseUrl: baseUrl ?? Uri.parse('http://'),
    );
    return _$TornV2(newClient);
  }

  ///Get your detailed attacks
  ///@param limit
  ///@param sort Sorted by the greatest timestamps
  ///@param to Timestamp that sets the upper limit for the data returned. Data returned will be up to and including this time
  ///@param from Timestamp that sets the lower limit for the data returned. Data returned will be after this time
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Limited).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<FactionAttacksResponse>> userAttacksGet({
    int? limit,
    enums.ApiSort? sort,
    int? to,
    int? from,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      FactionAttacksResponse,
      () => FactionAttacksResponse.fromJsonFactory,
    );

    return _userAttacksGet(
      limit: limit,
      sort: sort?.value?.toString(),
      to: to,
      from: from,
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get your detailed attacks
  ///@param limit
  ///@param sort Sorted by the greatest timestamps
  ///@param to Timestamp that sets the upper limit for the data returned. Data returned will be up to and including this time
  ///@param from Timestamp that sets the lower limit for the data returned. Data returned will be after this time
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Limited).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/user/attacks')
  Future<chopper.Response<FactionAttacksResponse>> _userAttacksGet({
    @Query('limit') int? limit,
    @Query('sort') String? sort,
    @Query('to') int? to,
    @Query('from') int? from,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get your simplified attacks
  ///@param limit
  ///@param sort Sorted by the greatest timestamps
  ///@param to Timestamp that sets the upper limit for the data returned. Data returned will be up to and including this time
  ///@param from Timestamp that sets the lower limit for the data returned. Data returned will be after this time
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Limited).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<FactionAttacksFullResponse>> userAttacksfullGet({
    int? limit,
    enums.ApiSort? sort,
    int? to,
    int? from,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      FactionAttacksFullResponse,
      () => FactionAttacksFullResponse.fromJsonFactory,
    );

    return _userAttacksfullGet(
      limit: limit,
      sort: sort?.value?.toString(),
      to: to,
      from: from,
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get your simplified attacks
  ///@param limit
  ///@param sort Sorted by the greatest timestamps
  ///@param to Timestamp that sets the upper limit for the data returned. Data returned will be up to and including this time
  ///@param from Timestamp that sets the lower limit for the data returned. Data returned will be after this time
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Limited).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/user/attacksfull')
  Future<chopper.Response<FactionAttacksFullResponse>> _userAttacksfullGet({
    @Query('limit') int? limit,
    @Query('sort') String? sort,
    @Query('to') int? to,
    @Query('from') int? from,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get bounties placed on you
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<UserBountiesResponse>> userBountiesGet({
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      UserBountiesResponse,
      () => UserBountiesResponse.fromJsonFactory,
    );

    return _userBountiesGet(timestamp: timestamp, comment: comment, key: key);
  }

  ///Get bounties placed on you
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/user/bounties')
  Future<chopper.Response<UserBountiesResponse>> _userBountiesGet({
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get bounties placed on a specific user
  ///@param id User id
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<UserBountiesResponse>> userIdBountiesGet({
    required int? id,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      UserBountiesResponse,
      () => UserBountiesResponse.fromJsonFactory,
    );

    return _userIdBountiesGet(
      id: id,
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get bounties placed on a specific user
  ///@param id User id
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/user/{id}/bounties')
  Future<chopper.Response<UserBountiesResponse>> _userIdBountiesGet({
    @Path('id') required int? id,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get your competition's event start time
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Minimal).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<UserCalendarResponse>> userCalendarGet({
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      UserCalendarResponse,
      () => UserCalendarResponse.fromJsonFactory,
    );

    return _userCalendarGet(timestamp: timestamp, comment: comment, key: key);
  }

  ///Get your competition's event start time
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Minimal).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/user/calendar')
  Future<chopper.Response<UserCalendarResponse>> _userCalendarGet({
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get your crime statistics
  ///@param crimeId Crime id
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Minimal).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<UserCrimesResponse>> userCrimeIdCrimesGet({
    required int? crimeId,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      UserCrimesResponse,
      () => UserCrimesResponse.fromJsonFactory,
    );

    return _userCrimeIdCrimesGet(
      crimeId: crimeId,
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get your crime statistics
  ///@param crimeId Crime id
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Minimal).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/user/{crimeId}/crimes')
  Future<chopper.Response<UserCrimesResponse>> _userCrimeIdCrimesGet({
    @Path('crimeId') required int? crimeId,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get your education information
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<UserEducationResponse>> userEducationGet({
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      UserEducationResponse,
      () => UserEducationResponse.fromJsonFactory,
    );

    return _userEducationGet(timestamp: timestamp, comment: comment, key: key);
  }

  ///Get your education information
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/user/education')
  Future<chopper.Response<UserEducationResponse>> _userEducationGet({
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get user enlisted cars
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Minimal).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<UserEnlistedCarsResponse>> userEnlistedcarsGet({
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      UserEnlistedCarsResponse,
      () => UserEnlistedCarsResponse.fromJsonFactory,
    );

    return _userEnlistedcarsGet(
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get user enlisted cars
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Minimal).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/user/enlistedcars')
  Future<chopper.Response<UserEnlistedCarsResponse>> _userEnlistedcarsGet({
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get your current faction balance
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Limited).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<UserFactionBalanceResponse>> userFactionbalanceGet({
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      UserFactionBalanceResponse,
      () => UserFactionBalanceResponse.fromJsonFactory,
    );

    return _userFactionbalanceGet(
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get your current faction balance
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Limited).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/user/factionbalance')
  Future<chopper.Response<UserFactionBalanceResponse>> _userFactionbalanceGet({
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get updates on your threads and posts
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Minimal).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<UserForumFeedResponse>> userForumfeedGet({
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      UserForumFeedResponse,
      () => UserForumFeedResponse.fromJsonFactory,
    );

    return _userForumfeedGet(timestamp: timestamp, comment: comment, key: key);
  }

  ///Get updates on your threads and posts
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Minimal).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/user/forumfeed')
  Future<chopper.Response<UserForumFeedResponse>> _userForumfeedGet({
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get updates on your friends' activity
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Minimal).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<UserForumFriendsResponse>> userForumfriendsGet({
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      UserForumFriendsResponse,
      () => UserForumFriendsResponse.fromJsonFactory,
    );

    return _userForumfriendsGet(
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get updates on your friends' activity
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Minimal).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/user/forumfriends')
  Future<chopper.Response<UserForumFriendsResponse>> _userForumfriendsGet({
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get your posts
  ///@param striptags Determines if fields include HTML or not ('Hospitalized by <a href=...>user</a>' vs 'Hospitalized by user').
  ///@param limit
  ///@param sort Sorted by the greatest timestamps
  ///@param from Timestamp that sets the lower limit for the data returned. Data returned will be after this time
  ///@param to Timestamp that sets the upper limit for the data returned. Data returned will be up to and including this time
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<UserForumPostsResponse>> userForumpostsGet({
    enums.ApiStripTagsTrue? striptags,
    int? limit,
    enums.ApiSort? sort,
    int? from,
    int? to,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      UserForumPostsResponse,
      () => UserForumPostsResponse.fromJsonFactory,
    );

    return _userForumpostsGet(
      striptags: striptags?.value?.toString(),
      limit: limit,
      sort: sort?.value?.toString(),
      from: from,
      to: to,
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get your posts
  ///@param striptags Determines if fields include HTML or not ('Hospitalized by <a href=...>user</a>' vs 'Hospitalized by user').
  ///@param limit
  ///@param sort Sorted by the greatest timestamps
  ///@param from Timestamp that sets the lower limit for the data returned. Data returned will be after this time
  ///@param to Timestamp that sets the upper limit for the data returned. Data returned will be up to and including this time
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/user/forumposts')
  Future<chopper.Response<UserForumPostsResponse>> _userForumpostsGet({
    @Query('striptags') String? striptags,
    @Query('limit') int? limit,
    @Query('sort') String? sort,
    @Query('from') int? from,
    @Query('to') int? to,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get posts for a specific player
  ///@param striptags Determines if fields include HTML or not ('Hospitalized by <a href=...>user</a>' vs 'Hospitalized by user').
  ///@param id User id
  ///@param limit
  ///@param sort Sorted by the greatest timestamps
  ///@param from Timestamp that sets the lower limit for the data returned. Data returned will be after this time
  ///@param to Timestamp that sets the upper limit for the data returned. Data returned will be up to and including this time
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<UserForumPostsResponse>> userIdForumpostsGet({
    enums.ApiStripTagsTrue? striptags,
    required int? id,
    int? limit,
    enums.ApiSort? sort,
    int? from,
    int? to,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      UserForumPostsResponse,
      () => UserForumPostsResponse.fromJsonFactory,
    );

    return _userIdForumpostsGet(
      striptags: striptags?.value?.toString(),
      id: id,
      limit: limit,
      sort: sort?.value?.toString(),
      from: from,
      to: to,
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get posts for a specific player
  ///@param striptags Determines if fields include HTML or not ('Hospitalized by <a href=...>user</a>' vs 'Hospitalized by user').
  ///@param id User id
  ///@param limit
  ///@param sort Sorted by the greatest timestamps
  ///@param from Timestamp that sets the lower limit for the data returned. Data returned will be after this time
  ///@param to Timestamp that sets the upper limit for the data returned. Data returned will be up to and including this time
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/user/{id}/forumposts')
  Future<chopper.Response<UserForumPostsResponse>> _userIdForumpostsGet({
    @Query('striptags') String? striptags,
    @Path('id') required int? id,
    @Query('limit') int? limit,
    @Query('sort') String? sort,
    @Query('from') int? from,
    @Query('to') int? to,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get updates on threads you subscribed to
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Minimal).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<UserForumSubscribedThreadsResponse>> userForumsubscribedthreadsGet({
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      UserForumSubscribedThreadsResponse,
      () => UserForumSubscribedThreadsResponse.fromJsonFactory,
    );

    return _userForumsubscribedthreadsGet(
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get updates on threads you subscribed to
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Minimal).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/user/forumsubscribedthreads')
  Future<chopper.Response<UserForumSubscribedThreadsResponse>> _userForumsubscribedthreadsGet({
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get your threads
  ///@param limit
  ///@param sort Sorted by the greatest timestamps
  ///@param from Timestamp that sets the lower limit for the data returned. Data returned will be after this time
  ///@param to Timestamp that sets the upper limit for the data returned. Data returned will be up to and including this time
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<UserForumThreadsResponse>> userForumthreadsGet({
    int? limit,
    enums.ApiSort? sort,
    int? from,
    int? to,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      UserForumThreadsResponse,
      () => UserForumThreadsResponse.fromJsonFactory,
    );

    return _userForumthreadsGet(
      limit: limit,
      sort: sort?.value?.toString(),
      from: from,
      to: to,
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get your threads
  ///@param limit
  ///@param sort Sorted by the greatest timestamps
  ///@param from Timestamp that sets the lower limit for the data returned. Data returned will be after this time
  ///@param to Timestamp that sets the upper limit for the data returned. Data returned will be up to and including this time
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/user/forumthreads')
  Future<chopper.Response<UserForumThreadsResponse>> _userForumthreadsGet({
    @Query('limit') int? limit,
    @Query('sort') String? sort,
    @Query('from') int? from,
    @Query('to') int? to,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get threads for a specific player
  ///@param id User id
  ///@param limit
  ///@param sort Sorted by the greatest timestamps
  ///@param from Timestamp that sets the lower limit for the data returned. Data returned will be after this time
  ///@param to Timestamp that sets the upper limit for the data returned. Data returned will be up to and including this time
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<UserForumThreadsResponse>> userIdForumthreadsGet({
    required int? id,
    int? limit,
    enums.ApiSort? sort,
    int? from,
    int? to,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      UserForumThreadsResponse,
      () => UserForumThreadsResponse.fromJsonFactory,
    );

    return _userIdForumthreadsGet(
      id: id,
      limit: limit,
      sort: sort?.value?.toString(),
      from: from,
      to: to,
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get threads for a specific player
  ///@param id User id
  ///@param limit
  ///@param sort Sorted by the greatest timestamps
  ///@param from Timestamp that sets the lower limit for the data returned. Data returned will be after this time
  ///@param to Timestamp that sets the upper limit for the data returned. Data returned will be up to and including this time
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/user/{id}/forumthreads')
  Future<chopper.Response<UserForumThreadsResponse>> _userIdForumthreadsGet({
    @Path('id') required int? id,
    @Query('limit') int? limit,
    @Query('sort') String? sort,
    @Query('from') int? from,
    @Query('to') int? to,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get your hall of fame rankings
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<UserHofResponse>> userHofGet({
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      UserHofResponse,
      () => UserHofResponse.fromJsonFactory,
    );

    return _userHofGet(timestamp: timestamp, comment: comment, key: key);
  }

  ///Get your hall of fame rankings
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/user/hof')
  Future<chopper.Response<UserHofResponse>> _userHofGet({
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get hall of fame rankings for a specific player
  ///@param id User id
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<UserHofResponse>> userIdHofGet({
    required int? id,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      UserHofResponse,
      () => UserHofResponse.fromJsonFactory,
    );

    return _userIdHofGet(
      id: id,
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get hall of fame rankings for a specific player
  ///@param id User id
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/user/{id}/hof')
  Future<chopper.Response<UserHofResponse>> _userIdHofGet({
    @Path('id') required int? id,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get your item market listings for a specific item
  ///@param offset
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Limited).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<UserItemMarketResponse>> userItemmarketGet({
    int? offset,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      UserItemMarketResponse,
      () => UserItemMarketResponse.fromJsonFactory,
    );

    return _userItemmarketGet(
      offset: offset,
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get your item market listings for a specific item
  ///@param offset
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Limited).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/user/itemmarket')
  Future<chopper.Response<UserItemMarketResponse>> _userItemmarketGet({
    @Query('offset') int? offset,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get your starter job positions
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Minimal).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<UserJobRanksResponse>> userJobranksGet({
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      UserJobRanksResponse,
      () => UserJobRanksResponse.fromJsonFactory,
    );

    return _userJobranksGet(timestamp: timestamp, comment: comment, key: key);
  }

  ///Get your starter job positions
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Minimal).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/user/jobranks')
  Future<chopper.Response<UserJobRanksResponse>> _userJobranksGet({
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get your friends, enemies or targets list
  ///@param cat Select list type
  ///@param limit
  ///@param offset
  ///@param sort Sort rows from newest to oldest<br>Default ordering is ascending
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Limited).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<UserListResponse>> userListGet({
    required enums.UserListEnum? cat,
    int? limit,
    int? offset,
    enums.ApiSortAsc? sort,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      UserListResponse,
      () => UserListResponse.fromJsonFactory,
    );

    return _userListGet(
      cat: cat?.value?.toString(),
      limit: limit,
      offset: offset,
      sort: sort?.value?.toString(),
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get your friends, enemies or targets list
  ///@param cat Select list type
  ///@param limit
  ///@param offset
  ///@param sort Sort rows from newest to oldest<br>Default ordering is ascending
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Limited).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/user/list')
  Future<chopper.Response<UserListResponse>> _userListGet({
    @Query('cat') required String? cat,
    @Query('limit') int? limit,
    @Query('offset') int? offset,
    @Query('sort') String? sort,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get your current ongoing organized crime
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Minimal).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<UserOrganizedCrimeResponse>> userOrganizedcrimeGet({
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      UserOrganizedCrimeResponse,
      () => UserOrganizedCrimeResponse.fromJsonFactory,
    );

    return _userOrganizedcrimeGet(
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get your current ongoing organized crime
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Minimal).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/user/organizedcrime')
  Future<chopper.Response<UserOrganizedCrimeResponse>> _userOrganizedcrimeGet({
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get your personal stats
  ///@param cat Stats category. Required unless requesting specific stats via 'stat' query parameter
  ///@param stat Stat names (10 maximum). Used to fetch historical stat values
  ///@param timestamp Returns stats until this timestamp (converted to nearest date).
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<UserPersonalStatsResponse>> userPersonalstatsGet({
    enums.PersonalStatsCategoryEnum? cat,
    List<enums.PersonalStatsStatName>? stat,
    int? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      UserPersonalStatsResponse,
      () => UserPersonalStatsResponse.fromJsonFactory,
    );

    return _userPersonalstatsGet(
      cat: cat?.value?.toString(),
      stat: personalStatsStatNameListToJson(stat),
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get your personal stats
  ///@param cat Stats category. Required unless requesting specific stats via 'stat' query parameter
  ///@param stat Stat names (10 maximum). Used to fetch historical stat values
  ///@param timestamp Returns stats until this timestamp (converted to nearest date).
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/user/personalstats')
  Future<chopper.Response<UserPersonalStatsResponse>> _userPersonalstatsGet({
    @Query('cat') String? cat,
    @Query('stat') List<Object?>? stat,
    @Query('timestamp') int? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get a player's personal stats
  ///@param id User id
  ///@param cat
  ///@param stat Stat names (10 maximum). Used to fetch historical stat values
  ///@param timestamp Returns stats until this timestamp (converted to nearest date).
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<UserPersonalStatsResponse>> userIdPersonalstatsGet({
    required int? id,
    enums.PersonalStatsCategoryEnum? cat,
    List<enums.PersonalStatsStatName>? stat,
    int? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      UserPersonalStatsResponse,
      () => UserPersonalStatsResponse.fromJsonFactory,
    );

    return _userIdPersonalstatsGet(
      id: id,
      cat: cat?.value?.toString(),
      stat: personalStatsStatNameListToJson(stat),
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get a player's personal stats
  ///@param id User id
  ///@param cat
  ///@param stat Stat names (10 maximum). Used to fetch historical stat values
  ///@param timestamp Returns stats until this timestamp (converted to nearest date).
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/user/{id}/personalstats')
  Future<chopper.Response<UserPersonalStatsResponse>> _userIdPersonalstatsGet({
    @Path('id') required int? id,
    @Query('cat') String? cat,
    @Query('stat') List<Object?>? stat,
    @Query('timestamp') int? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get your own properties
  ///@param offset
  ///@param limit
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<UserPropertiesResponse>> userPropertiesGet({
    int? offset,
    int? limit,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      UserPropertiesResponse,
      () => UserPropertiesResponse.fromJsonFactory,
    );

    return _userPropertiesGet(
      offset: offset,
      limit: limit,
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get your own properties
  ///@param offset
  ///@param limit
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/user/properties')
  Future<chopper.Response<UserPropertiesResponse>> _userPropertiesGet({
    @Query('offset') int? offset,
    @Query('limit') int? limit,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get specific user's properties
  ///@param id User id
  ///@param offset
  ///@param limit
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<UserPropertiesResponse>> userIdPropertiesGet({
    required int? id,
    int? offset,
    int? limit,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      UserPropertiesResponse,
      () => UserPropertiesResponse.fromJsonFactory,
    );

    return _userIdPropertiesGet(
      id: id,
      offset: offset,
      limit: limit,
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get specific user's properties
  ///@param id User id
  ///@param offset
  ///@param limit
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/user/{id}/properties')
  Future<chopper.Response<UserPropertiesResponse>> _userIdPropertiesGet({
    @Path('id') required int? id,
    @Query('offset') int? offset,
    @Query('limit') int? limit,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get your current property
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<UserPropertyResponse>> userPropertyGet({
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      UserPropertyResponse,
      () => UserPropertyResponse.fromJsonFactory,
    );

    return _userPropertyGet(timestamp: timestamp, comment: comment, key: key);
  }

  ///Get your current property
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/user/property')
  Future<chopper.Response<UserPropertyResponse>> _userPropertyGet({
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get specific user's property
  ///@param id User id
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<UserPropertyResponse>> userIdPropertyGet({
    required int? id,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      UserPropertyResponse,
      () => UserPropertyResponse.fromJsonFactory,
    );

    return _userIdPropertyGet(
      id: id,
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get specific user's property
  ///@param id User id
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/user/{id}/property')
  Future<chopper.Response<UserPropertyResponse>> _userIdPropertyGet({
    @Path('id') required int? id,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get user races
  ///@param limit
  ///@param sort Sorted by the greatest timestamps
  ///@param from Timestamp that sets the lower limit for the data returned. Data returned will be after this time
  ///@param to Timestamp that sets the upper limit for the data returned. Data returned will be up to and including this time
  ///@param cat Category of races returned
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Minimal).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<UserRacesResponse>> userRacesGet({
    int? limit,
    enums.ApiSort? sort,
    int? from,
    int? to,
    enums.RacingRaceTypeEnum? cat,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      UserRacesResponse,
      () => UserRacesResponse.fromJsonFactory,
    );

    return _userRacesGet(
      limit: limit,
      sort: sort?.value?.toString(),
      from: from,
      to: to,
      cat: cat?.value?.toString(),
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get user races
  ///@param limit
  ///@param sort Sorted by the greatest timestamps
  ///@param from Timestamp that sets the lower limit for the data returned. Data returned will be after this time
  ///@param to Timestamp that sets the upper limit for the data returned. Data returned will be up to and including this time
  ///@param cat Category of races returned
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Minimal).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/user/races')
  Future<chopper.Response<UserRacesResponse>> _userRacesGet({
    @Query('limit') int? limit,
    @Query('sort') String? sort,
    @Query('from') int? from,
    @Query('to') int? to,
    @Query('cat') String? cat,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get your current racing records
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Minimal).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<UserRacingRecordsResponse>> userRacingrecordsGet({
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      UserRacingRecordsResponse,
      () => UserRacingRecordsResponse.fromJsonFactory,
    );

    return _userRacingrecordsGet(
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get your current racing records
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Minimal).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/user/racingrecords')
  Future<chopper.Response<UserRacingRecordsResponse>> _userRacingrecordsGet({
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get your reports
  ///@param cat Used to filter reports with a specific type.
  ///@param target Get reports for a specific player by passing their player ID.
  ///@param limit
  ///@param offset
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Limited).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<ReportsResponse>> userReportsGet({
    enums.ReportTypeEnum? cat,
    int? target,
    int? limit,
    int? offset,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      ReportsResponse,
      () => ReportsResponse.fromJsonFactory,
    );

    return _userReportsGet(
      cat: cat?.value?.toString(),
      target: target,
      limit: limit,
      offset: offset,
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get your reports
  ///@param cat Used to filter reports with a specific type.
  ///@param target Get reports for a specific player by passing their player ID.
  ///@param limit
  ///@param offset
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Limited).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/user/reports')
  Future<chopper.Response<ReportsResponse>> _userReportsGet({
    @Query('cat') String? cat,
    @Query('target') int? target,
    @Query('limit') int? limit,
    @Query('offset') int? offset,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get your detailed revives
  ///@param limit
  ///@param sort Sorted by the greatest timestamps
  ///@param to Timestamp that sets the upper limit for the data returned. Data returned will be up to and including this time
  ///@param from Timestamp that sets the lower limit for the data returned. Data returned will be after this time
  ///@param striptags Determines if fields include HTML or not ('Hospitalized by <a href=...>user</a>' vs 'Hospitalized by user').
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Limited).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<RevivesResponse>> userRevivesGet({
    int? limit,
    enums.ApiSort? sort,
    int? to,
    int? from,
    enums.ApiStripTagsTrue? striptags,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      RevivesResponse,
      () => RevivesResponse.fromJsonFactory,
    );

    return _userRevivesGet(
      limit: limit,
      sort: sort?.value?.toString(),
      to: to,
      from: from,
      striptags: striptags?.value?.toString(),
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get your detailed revives
  ///@param limit
  ///@param sort Sorted by the greatest timestamps
  ///@param to Timestamp that sets the upper limit for the data returned. Data returned will be up to and including this time
  ///@param from Timestamp that sets the lower limit for the data returned. Data returned will be after this time
  ///@param striptags Determines if fields include HTML or not ('Hospitalized by <a href=...>user</a>' vs 'Hospitalized by user').
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Limited).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/user/revives')
  Future<chopper.Response<RevivesResponse>> _userRevivesGet({
    @Query('limit') int? limit,
    @Query('sort') String? sort,
    @Query('to') int? to,
    @Query('from') int? from,
    @Query('striptags') String? striptags,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get your simplified revives
  ///@param limit
  ///@param sort Sorted by the greatest timestamps
  ///@param to Timestamp that sets the upper limit for the data returned. Data returned will be up to and including this time
  ///@param from Timestamp that sets the lower limit for the data returned. Data returned will be after this time
  ///@param striptags Determines if fields include HTML or not ('Hospitalized by <a href=...>user</a>' vs 'Hospitalized by user').
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Limited).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<RevivesFullResponse>> userRevivesFullGet({
    int? limit,
    enums.ApiSort? sort,
    int? to,
    int? from,
    enums.ApiStripTagsTrue? striptags,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      RevivesFullResponse,
      () => RevivesFullResponse.fromJsonFactory,
    );

    return _userRevivesFullGet(
      limit: limit,
      sort: sort?.value?.toString(),
      to: to,
      from: from,
      striptags: striptags?.value?.toString(),
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get your simplified revives
  ///@param limit
  ///@param sort Sorted by the greatest timestamps
  ///@param to Timestamp that sets the upper limit for the data returned. Data returned will be up to and including this time
  ///@param from Timestamp that sets the lower limit for the data returned. Data returned will be after this time
  ///@param striptags Determines if fields include HTML or not ('Hospitalized by <a href=...>user</a>' vs 'Hospitalized by user').
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Limited).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/user/revivesFull')
  Future<chopper.Response<RevivesFullResponse>> _userRevivesFullGet({
    @Query('limit') int? limit,
    @Query('sort') String? sort,
    @Query('to') int? to,
    @Query('from') int? from,
    @Query('striptags') String? striptags,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get all available user selections
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<UserLookupResponse>> userLookupGet({
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      UserLookupResponse,
      () => UserLookupResponse.fromJsonFactory,
    );

    return _userLookupGet(timestamp: timestamp, comment: comment, key: key);
  }

  ///Get all available user selections
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/user/lookup')
  Future<chopper.Response<UserLookupResponse>> _userLookupGet({
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get current server time
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<TimestampResponse>> userTimestampGet({
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      TimestampResponse,
      () => TimestampResponse.fromJsonFactory,
    );

    return _userTimestampGet(timestamp: timestamp, comment: comment, key: key);
  }

  ///Get current server time
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/user/timestamp')
  Future<chopper.Response<TimestampResponse>> _userTimestampGet({
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get any User selection
  ///@param selections Selection names
  ///@param id selection id
  ///@param limit
  ///@param from Timestamp that sets the lower limit for the data returned. Data returned will be after this time
  ///@param to Timestamp that sets the upper limit for the data returned. Data returned will be up to and including this time
  ///@param sort Sorted by the greatest timestamps
  ///@param cat Selection category. Can belong to one of the specified types.
  ///@param stat Selection stat
  ///@param striptags Determines if fields include HTML or not ('Hospitalized by <a href=...>user</a>' vs 'Hospitalized by user').
  ///@param offset
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response> userGet({
    String? selections,
    String? id,
    int? limit,
    int? from,
    int? to,
    enums.ApiSort? sort,
    String? cat,
    List<enums.PersonalStatsStatName>? stat,
    enums.ApiStripTags? striptags,
    int? offset,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    return _userGet(
      selections: selections,
      id: id,
      limit: limit,
      from: from,
      to: to,
      sort: sort?.value?.toString(),
      cat: cat,
      stat: personalStatsStatNameListToJson(stat),
      striptags: striptags?.value?.toString(),
      offset: offset,
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get any User selection
  ///@param selections Selection names
  ///@param id selection id
  ///@param limit
  ///@param from Timestamp that sets the lower limit for the data returned. Data returned will be after this time
  ///@param to Timestamp that sets the upper limit for the data returned. Data returned will be up to and including this time
  ///@param sort Sorted by the greatest timestamps
  ///@param cat Selection category. Can belong to one of the specified types.
  ///@param stat Selection stat
  ///@param striptags Determines if fields include HTML or not ('Hospitalized by <a href=...>user</a>' vs 'Hospitalized by user').
  ///@param offset
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/user')
  Future<chopper.Response> _userGet({
    @Query('selections') String? selections,
    @Query('id') Object? id,
    @Query('limit') int? limit,
    @Query('from') int? from,
    @Query('to') int? to,
    @Query('sort') String? sort,
    @Query('cat') Object? cat,
    @Query('stat') List<Object?>? stat,
    @Query('striptags') String? striptags,
    @Query('offset') int? offset,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get your faction's applications
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Minimal).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<FactionApplicationsResponse>> factionApplicationsGet({
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      FactionApplicationsResponse,
      () => FactionApplicationsResponse.fromJsonFactory,
    );

    return _factionApplicationsGet(
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get your faction's applications
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Minimal).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/faction/applications')
  Future<chopper.Response<FactionApplicationsResponse>> _factionApplicationsGet({
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get your faction's detailed attacks
  ///@param limit
  ///@param sort Sorted by the greatest timestamps
  ///@param to Timestamp that sets the upper limit for the data returned. Data returned will be up to and including this time
  ///@param from Timestamp that sets the lower limit for the data returned. Data returned will be after this time
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Limited).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<FactionAttacksResponse>> factionAttacksGet({
    int? limit,
    enums.ApiSortDesc? sort,
    int? to,
    int? from,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      FactionAttacksResponse,
      () => FactionAttacksResponse.fromJsonFactory,
    );

    return _factionAttacksGet(
      limit: limit,
      sort: sort?.value?.toString(),
      to: to,
      from: from,
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get your faction's detailed attacks
  ///@param limit
  ///@param sort Sorted by the greatest timestamps
  ///@param to Timestamp that sets the upper limit for the data returned. Data returned will be up to and including this time
  ///@param from Timestamp that sets the lower limit for the data returned. Data returned will be after this time
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Limited).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/faction/attacks')
  Future<chopper.Response<FactionAttacksResponse>> _factionAttacksGet({
    @Query('limit') int? limit,
    @Query('sort') String? sort,
    @Query('to') int? to,
    @Query('from') int? from,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get your faction's simplified attacks
  ///@param limit
  ///@param sort Sorted by the greatest timestamps
  ///@param to Timestamp that sets the upper limit for the data returned. Data returned will be up to and including this time
  ///@param from Timestamp that sets the lower limit for the data returned. Data returned will be after this time
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Limited).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<FactionAttacksFullResponse>> factionAttacksfullGet({
    int? limit,
    enums.ApiSortDesc? sort,
    int? to,
    int? from,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      FactionAttacksFullResponse,
      () => FactionAttacksFullResponse.fromJsonFactory,
    );

    return _factionAttacksfullGet(
      limit: limit,
      sort: sort?.value?.toString(),
      to: to,
      from: from,
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get your faction's simplified attacks
  ///@param limit
  ///@param sort Sorted by the greatest timestamps
  ///@param to Timestamp that sets the upper limit for the data returned. Data returned will be up to and including this time
  ///@param from Timestamp that sets the lower limit for the data returned. Data returned will be after this time
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Limited).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/faction/attacksfull')
  Future<chopper.Response<FactionAttacksFullResponse>> _factionAttacksfullGet({
    @Query('limit') int? limit,
    @Query('sort') String? sort,
    @Query('to') int? to,
    @Query('from') int? from,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get your faction's & member's balance details
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Limited).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<FactionBalanceResponse>> factionBalanceGet({
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      FactionBalanceResponse,
      () => FactionBalanceResponse.fromJsonFactory,
    );

    return _factionBalanceGet(timestamp: timestamp, comment: comment, key: key);
  }

  ///Get your faction's & member's balance details
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Limited).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/faction/balance')
  Future<chopper.Response<FactionBalanceResponse>> _factionBalanceGet({
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get your faction's basic details
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<FactionBasicResponse>> factionBasicGet({
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      FactionBasicResponse,
      () => FactionBasicResponse.fromJsonFactory,
    );

    return _factionBasicGet(timestamp: timestamp, comment: comment, key: key);
  }

  ///Get your faction's basic details
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/faction/basic')
  Future<chopper.Response<FactionBasicResponse>> _factionBasicGet({
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get a faction's basic details
  ///@param id Faction id
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<FactionBasicResponse>> factionIdBasicGet({
    required int? id,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      FactionBasicResponse,
      () => FactionBasicResponse.fromJsonFactory,
    );

    return _factionIdBasicGet(
      id: id,
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get a faction's basic details
  ///@param id Faction id
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/faction/{id}/basic')
  Future<chopper.Response<FactionBasicResponse>> _factionIdBasicGet({
    @Path('id') required int? id,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get your faction's current chain
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<FactionOngoingChainResponse>> factionChainGet({
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      FactionOngoingChainResponse,
      () => FactionOngoingChainResponse.fromJsonFactory,
    );

    return _factionChainGet(timestamp: timestamp, comment: comment, key: key);
  }

  ///Get your faction's current chain
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/faction/chain')
  Future<chopper.Response<FactionOngoingChainResponse>> _factionChainGet({
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get a faction's current chain
  ///@param id Faction id
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<FactionOngoingChainResponse>> factionIdChainGet({
    required int? id,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      FactionOngoingChainResponse,
      () => FactionOngoingChainResponse.fromJsonFactory,
    );

    return _factionIdChainGet(
      id: id,
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get a faction's current chain
  ///@param id Faction id
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/faction/{id}/chain')
  Future<chopper.Response<FactionOngoingChainResponse>> _factionIdChainGet({
    @Path('id') required int? id,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get a list of your faction's completed chains
  ///@param limit
  ///@param sort Sorted by the greatest timestamps
  ///@param to Timestamp that sets the upper limit for the data returned. Data returned will be up to and including this time
  ///@param from Timestamp that sets the lower limit for the data returned. Data returned will be after this time
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<FactionChainsResponse>> factionChainsGet({
    int? limit,
    enums.ApiSortDesc? sort,
    int? to,
    int? from,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      FactionChainsResponse,
      () => FactionChainsResponse.fromJsonFactory,
    );

    return _factionChainsGet(
      limit: limit,
      sort: sort?.value?.toString(),
      to: to,
      from: from,
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get a list of your faction's completed chains
  ///@param limit
  ///@param sort Sorted by the greatest timestamps
  ///@param to Timestamp that sets the upper limit for the data returned. Data returned will be up to and including this time
  ///@param from Timestamp that sets the lower limit for the data returned. Data returned will be after this time
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/faction/chains')
  Future<chopper.Response<FactionChainsResponse>> _factionChainsGet({
    @Query('limit') int? limit,
    @Query('sort') String? sort,
    @Query('to') int? to,
    @Query('from') int? from,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get a list of a faction's completed chains
  ///@param id Faction id
  ///@param limit
  ///@param sort Sorted by the greatest timestamps
  ///@param to Timestamp that sets the upper limit for the data returned. Data returned will be up to and including this time
  ///@param from Timestamp that sets the lower limit for the data returned. Data returned will be after this time
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<FactionChainsResponse>> factionIdChainsGet({
    required int? id,
    int? limit,
    enums.ApiSortDesc? sort,
    int? to,
    int? from,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      FactionChainsResponse,
      () => FactionChainsResponse.fromJsonFactory,
    );

    return _factionIdChainsGet(
      id: id,
      limit: limit,
      sort: sort?.value?.toString(),
      to: to,
      from: from,
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get a list of a faction's completed chains
  ///@param id Faction id
  ///@param limit
  ///@param sort Sorted by the greatest timestamps
  ///@param to Timestamp that sets the upper limit for the data returned. Data returned will be up to and including this time
  ///@param from Timestamp that sets the lower limit for the data returned. Data returned will be after this time
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/faction/{id}/chains')
  Future<chopper.Response<FactionChainsResponse>> _factionIdChainsGet({
    @Path('id') required int? id,
    @Query('limit') int? limit,
    @Query('sort') String? sort,
    @Query('to') int? to,
    @Query('from') int? from,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get your faction's latest chain report
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<FactionChainReportResponse>> factionChainreportGet({
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      FactionChainReportResponse,
      () => FactionChainReportResponse.fromJsonFactory,
    );

    return _factionChainreportGet(
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get your faction's latest chain report
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/faction/chainreport')
  Future<chopper.Response<FactionChainReportResponse>> _factionChainreportGet({
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get a chain report
  ///@param chainId Chain id
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<FactionChainReportResponse>> factionChainIdChainreportGet({
    required int? chainId,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      FactionChainReportResponse,
      () => FactionChainReportResponse.fromJsonFactory,
    );

    return _factionChainIdChainreportGet(
      chainId: chainId,
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get a chain report
  ///@param chainId Chain id
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/faction/{chainId}/chainreport')
  Future<chopper.Response<FactionChainReportResponse>> _factionChainIdChainreportGet({
    @Path('chainId') required int? chainId,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get your faction's challenge contributors
  ///@param stat Get contributors for this field.
  ///@param cat By default, this selection will return only current faction's member contributions, and the option 'all' will return all contributors.
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<FactionContributorsResponse>> factionContributorsGet({
    required enums.FactionStatEnum? stat,
    enums.FactionContributorsGetCat? cat,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      FactionContributorsResponse,
      () => FactionContributorsResponse.fromJsonFactory,
    );

    return _factionContributorsGet(
      stat: stat?.value?.toString(),
      cat: cat?.value?.toString(),
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get your faction's challenge contributors
  ///@param stat Get contributors for this field.
  ///@param cat By default, this selection will return only current faction's member contributions, and the option 'all' will return all contributors.
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/faction/contributors')
  Future<chopper.Response<FactionContributorsResponse>> _factionContributorsGet({
    @Query('stat') required String? stat,
    @Query('cat') String? cat,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get your faction's organized crimes
  ///@param cat Category of organized crimes returned. Category 'available' includes both 'recruiting' & 'planning', and category 'completed' includes both 'successful' & 'failure'<br>Default category is 'all'.
  ///@param filters It's possible to set this parameter to specify a field used for the sort, from & to query parameters. If not specified, the field will default to the category sorting as described above.
  ///@param offset
  ///@param from Timestamp that sets the lower limit for the data returned. Data returned will be after this time
  ///@param to Timestamp that sets the upper limit for the data returned. Data returned will be up to and including this time
  ///@param sort Sorted by the greatest timestamps
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Minimal).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<FactionCrimesResponse>> factionCrimesGet({
    enums.FactionCrimesGetCat? cat,
    enums.FactionCrimesGetFilters? filters,
    int? offset,
    int? from,
    int? to,
    enums.ApiSortDesc? sort,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      FactionCrimesResponse,
      () => FactionCrimesResponse.fromJsonFactory,
    );

    return _factionCrimesGet(
      cat: cat?.value?.toString(),
      filters: filters?.value?.toString(),
      offset: offset,
      from: from,
      to: to,
      sort: sort?.value?.toString(),
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get your faction's organized crimes
  ///@param cat Category of organized crimes returned. Category 'available' includes both 'recruiting' & 'planning', and category 'completed' includes both 'successful' & 'failure'<br>Default category is 'all'.
  ///@param filters It's possible to set this parameter to specify a field used for the sort, from & to query parameters. If not specified, the field will default to the category sorting as described above.
  ///@param offset
  ///@param from Timestamp that sets the lower limit for the data returned. Data returned will be after this time
  ///@param to Timestamp that sets the upper limit for the data returned. Data returned will be up to and including this time
  ///@param sort Sorted by the greatest timestamps
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Minimal).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/faction/crimes')
  Future<chopper.Response<FactionCrimesResponse>> _factionCrimesGet({
    @Query('cat') String? cat,
    @Query('filters') String? filters,
    @Query('offset') int? offset,
    @Query('from') int? from,
    @Query('to') int? to,
    @Query('sort') String? sort,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get a specific organized crime
  ///@param crimeId Crime id
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Minimal).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<FactionCrimeResponse>> factionCrimeIdCrimeGet({
    required int? crimeId,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      FactionCrimeResponse,
      () => FactionCrimeResponse.fromJsonFactory,
    );

    return _factionCrimeIdCrimeGet(
      crimeId: crimeId,
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get a specific organized crime
  ///@param crimeId Crime id
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Minimal).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/faction/{crimeId}/crime')
  Future<chopper.Response<FactionCrimeResponse>> _factionCrimeIdCrimeGet({
    @Path('crimeId') required int? crimeId,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get your faction's hall of fame rankings.
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<FactionHofResponse>> factionHofGet({
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      FactionHofResponse,
      () => FactionHofResponse.fromJsonFactory,
    );

    return _factionHofGet(timestamp: timestamp, comment: comment, key: key);
  }

  ///Get your faction's hall of fame rankings.
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/faction/hof')
  Future<chopper.Response<FactionHofResponse>> _factionHofGet({
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get a faction's hall of fame rankings.
  ///@param id Faction id
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<FactionHofResponse>> factionIdHofGet({
    required int? id,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      FactionHofResponse,
      () => FactionHofResponse.fromJsonFactory,
    );

    return _factionIdHofGet(
      id: id,
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get a faction's hall of fame rankings.
  ///@param id Faction id
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/faction/{id}/hof')
  Future<chopper.Response<FactionHofResponse>> _factionIdHofGet({
    @Path('id') required int? id,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get a list of your faction's members
  ///@param striptags Determines if fields include HTML or not ('Hospitalized by <a href=...>user</a>' vs 'Hospitalized by user').
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<FactionMembersResponse>> factionMembersGet({
    enums.ApiStripTagsTrue? striptags,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      FactionMembersResponse,
      () => FactionMembersResponse.fromJsonFactory,
    );

    return _factionMembersGet(
      striptags: striptags?.value?.toString(),
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get a list of your faction's members
  ///@param striptags Determines if fields include HTML or not ('Hospitalized by <a href=...>user</a>' vs 'Hospitalized by user').
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/faction/members')
  Future<chopper.Response<FactionMembersResponse>> _factionMembersGet({
    @Query('striptags') String? striptags,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get a list of a faction's members
  ///@param id Faction id
  ///@param striptags Determines if fields include HTML or not ('Hospitalized by <a href=...>user</a>' vs 'Hospitalized by user').
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<FactionMembersResponse>> factionIdMembersGet({
    required int? id,
    enums.ApiStripTagsTrue? striptags,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      FactionMembersResponse,
      () => FactionMembersResponse.fromJsonFactory,
    );

    return _factionIdMembersGet(
      id: id,
      striptags: striptags?.value?.toString(),
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get a list of a faction's members
  ///@param id Faction id
  ///@param striptags Determines if fields include HTML or not ('Hospitalized by <a href=...>user</a>' vs 'Hospitalized by user').
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/faction/{id}/members')
  Future<chopper.Response<FactionMembersResponse>> _factionIdMembersGet({
    @Path('id') required int? id,
    @Query('striptags') String? striptags,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get your faction's news details
  ///@param striptags Determines if fields include HTML or not ('Hospitalized by <a href=...>user</a>' vs 'Hospitalized by user').
  ///@param limit
  ///@param sort Sorted by the greatest timestamps
  ///@param to Timestamp that sets the upper limit for the data returned. Data returned will be up to and including this time
  ///@param from Timestamp that sets the lower limit for the data returned. Data returned will be after this time
  ///@param cat News category type
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Minimal).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<FactionNewsResponse>> factionNewsGet({
    enums.ApiStripTagsFalse? striptags,
    int? limit,
    enums.ApiSortDesc? sort,
    int? to,
    int? from,
    required enums.FactionNewsCategory? cat,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      FactionNewsResponse,
      () => FactionNewsResponse.fromJsonFactory,
    );

    return _factionNewsGet(
      striptags: striptags?.value?.toString(),
      limit: limit,
      sort: sort?.value?.toString(),
      to: to,
      from: from,
      cat: cat?.value?.toString(),
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get your faction's news details
  ///@param striptags Determines if fields include HTML or not ('Hospitalized by <a href=...>user</a>' vs 'Hospitalized by user').
  ///@param limit
  ///@param sort Sorted by the greatest timestamps
  ///@param to Timestamp that sets the upper limit for the data returned. Data returned will be up to and including this time
  ///@param from Timestamp that sets the lower limit for the data returned. Data returned will be after this time
  ///@param cat News category type
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Minimal).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/faction/news')
  Future<chopper.Response<FactionNewsResponse>> _factionNewsGet({
    @Query('striptags') String? striptags,
    @Query('limit') int? limit,
    @Query('sort') String? sort,
    @Query('to') int? to,
    @Query('from') int? from,
    @Query('cat') required String? cat,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get your faction's positions details
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Minimal).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<FactionPositionsResponse>> factionPositionsGet({
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      FactionPositionsResponse,
      () => FactionPositionsResponse.fromJsonFactory,
    );

    return _factionPositionsGet(
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get your faction's positions details
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Minimal).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/faction/positions')
  Future<chopper.Response<FactionPositionsResponse>> _factionPositionsGet({
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get a list of current rackets
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<FactionRacketsResponse>> factionRacketsGet({
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      FactionRacketsResponse,
      () => FactionRacketsResponse.fromJsonFactory,
    );

    return _factionRacketsGet(timestamp: timestamp, comment: comment, key: key);
  }

  ///Get a list of current rackets
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/faction/rackets')
  Future<chopper.Response<FactionRacketsResponse>> _factionRacketsGet({
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get raid war details
  ///@param raidWarId Raid war id
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<FactionRaidWarReportResponse>> factionRaidWarIdRaidreportGet({
    required int? raidWarId,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      FactionRaidWarReportResponse,
      () => FactionRaidWarReportResponse.fromJsonFactory,
    );

    return _factionRaidWarIdRaidreportGet(
      raidWarId: raidWarId,
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get raid war details
  ///@param raidWarId Raid war id
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/faction/{raidWarId}/raidreport')
  Future<chopper.Response<FactionRaidWarReportResponse>> _factionRaidWarIdRaidreportGet({
    @Path('raidWarId') required int? raidWarId,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get raids history for your faction
  ///@param from Timestamp that sets the lower limit for the data returned. Data returned will be after this time
  ///@param to Timestamp that sets the upper limit for the data returned. Data returned will be up to and including this time
  ///@param sort Sorted by the greatest timestamps
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<FactionRaidsResponse>> factionRaidsGet({
    int? from,
    int? to,
    enums.ApiSortDesc? sort,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      FactionRaidsResponse,
      () => FactionRaidsResponse.fromJsonFactory,
    );

    return _factionRaidsGet(
      from: from,
      to: to,
      sort: sort?.value?.toString(),
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get raids history for your faction
  ///@param from Timestamp that sets the lower limit for the data returned. Data returned will be after this time
  ///@param to Timestamp that sets the upper limit for the data returned. Data returned will be up to and including this time
  ///@param sort Sorted by the greatest timestamps
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/faction/raids')
  Future<chopper.Response<FactionRaidsResponse>> _factionRaidsGet({
    @Query('from') int? from,
    @Query('to') int? to,
    @Query('sort') String? sort,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get a faction's raids history
  ///@param id Faction id
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<FactionRaidsResponse>> factionIdRaidsGet({
    required int? id,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      FactionRaidsResponse,
      () => FactionRaidsResponse.fromJsonFactory,
    );

    return _factionIdRaidsGet(
      id: id,
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get a faction's raids history
  ///@param id Faction id
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/faction/{id}/raids')
  Future<chopper.Response<FactionRaidsResponse>> _factionIdRaidsGet({
    @Path('id') required int? id,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get ranked wars history for your faction
  ///@param cat This parameter is deprecated. The ranked wars list can now instead be fetched via 'faction' -> 'warfare' endpoint. This functionality will be removed on 1st of September 2025.
  ///@param from Timestamp that sets the lower limit for the data returned. Data returned will be after this time
  ///@param to Timestamp that sets the upper limit for the data returned. Data returned will be up to and including this time
  ///@param sort Sorted by the greatest timestamps
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<FactionRankedWarResponse>> factionRankedwarsGet({
    enums.FactionRankedWarsCategoryEnum? cat,
    int? from,
    int? to,
    enums.ApiSortDesc? sort,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      FactionRankedWarResponse,
      () => FactionRankedWarResponse.fromJsonFactory,
    );

    return _factionRankedwarsGet(
      cat: cat?.value?.toString(),
      from: from,
      to: to,
      sort: sort?.value?.toString(),
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get ranked wars history for your faction
  ///@param cat This parameter is deprecated. The ranked wars list can now instead be fetched via 'faction' -> 'warfare' endpoint. This functionality will be removed on 1st of September 2025.
  ///@param from Timestamp that sets the lower limit for the data returned. Data returned will be after this time
  ///@param to Timestamp that sets the upper limit for the data returned. Data returned will be up to and including this time
  ///@param sort Sorted by the greatest timestamps
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/faction/rankedwars')
  Future<chopper.Response<FactionRankedWarResponse>> _factionRankedwarsGet({
    @Query('cat') String? cat,
    @Query('from') int? from,
    @Query('to') int? to,
    @Query('sort') String? sort,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get a faction's ranked wars history
  ///@param id Faction id
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<FactionRankedWarResponse>> factionIdRankedwarsGet({
    required int? id,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      FactionRankedWarResponse,
      () => FactionRankedWarResponse.fromJsonFactory,
    );

    return _factionIdRankedwarsGet(
      id: id,
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get a faction's ranked wars history
  ///@param id Faction id
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/faction/{id}/rankedwars')
  Future<chopper.Response<FactionRankedWarResponse>> _factionIdRankedwarsGet({
    @Path('id') required int? id,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get ranked war details
  ///@param rankedWarId Ranked war id
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<FactionRankedWarReportResponse>> factionRankedWarIdRankedwarreportGet({
    required int? rankedWarId,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      FactionRankedWarReportResponse,
      () => FactionRankedWarReportResponse.fromJsonFactory,
    );

    return _factionRankedWarIdRankedwarreportGet(
      rankedWarId: rankedWarId,
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get ranked war details
  ///@param rankedWarId Ranked war id
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/faction/{rankedWarId}/rankedwarreport')
  Future<chopper.Response<FactionRankedWarReportResponse>> _factionRankedWarIdRankedwarreportGet({
    @Path('rankedWarId') required int? rankedWarId,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get faction reports
  ///@param cat Used to filter reports with a specific type.
  ///@param target Get reports for a specific player by passing their player ID.
  ///@param limit
  ///@param offset
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Limited).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<ReportsResponse>> factionReportsGet({
    enums.ReportTypeEnum? cat,
    int? target,
    int? limit,
    int? offset,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      ReportsResponse,
      () => ReportsResponse.fromJsonFactory,
    );

    return _factionReportsGet(
      cat: cat?.value?.toString(),
      target: target,
      limit: limit,
      offset: offset,
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get faction reports
  ///@param cat Used to filter reports with a specific type.
  ///@param target Get reports for a specific player by passing their player ID.
  ///@param limit
  ///@param offset
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Limited).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/faction/reports')
  Future<chopper.Response<ReportsResponse>> _factionReportsGet({
    @Query('cat') String? cat,
    @Query('target') int? target,
    @Query('limit') int? limit,
    @Query('offset') int? offset,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get your faction's detailed revives
  ///@param limit
  ///@param sort Sorted by the greatest timestamps
  ///@param to Timestamp that sets the upper limit for the data returned. Data returned will be up to and including this time
  ///@param from Timestamp that sets the lower limit for the data returned. Data returned will be after this time
  ///@param striptags Determines if fields include HTML or not ('Hospitalized by <a href=...>user</a>' vs 'Hospitalized by user').
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Limited).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<RevivesResponse>> factionRevivesGet({
    int? limit,
    enums.ApiSortDesc? sort,
    int? to,
    int? from,
    enums.ApiStripTagsTrue? striptags,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      RevivesResponse,
      () => RevivesResponse.fromJsonFactory,
    );

    return _factionRevivesGet(
      limit: limit,
      sort: sort?.value?.toString(),
      to: to,
      from: from,
      striptags: striptags?.value?.toString(),
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get your faction's detailed revives
  ///@param limit
  ///@param sort Sorted by the greatest timestamps
  ///@param to Timestamp that sets the upper limit for the data returned. Data returned will be up to and including this time
  ///@param from Timestamp that sets the lower limit for the data returned. Data returned will be after this time
  ///@param striptags Determines if fields include HTML or not ('Hospitalized by <a href=...>user</a>' vs 'Hospitalized by user').
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Limited).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/faction/revives')
  Future<chopper.Response<RevivesResponse>> _factionRevivesGet({
    @Query('limit') int? limit,
    @Query('sort') String? sort,
    @Query('to') int? to,
    @Query('from') int? from,
    @Query('striptags') String? striptags,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get your faction's simplified revives
  ///@param limit
  ///@param sort Sorted by the greatest timestamps
  ///@param to Timestamp that sets the upper limit for the data returned. Data returned will be up to and including this time
  ///@param from Timestamp that sets the lower limit for the data returned. Data returned will be after this time
  ///@param striptags Determines if fields include HTML or not ('Hospitalized by <a href=...>user</a>' vs 'Hospitalized by user').
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Limited).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<RevivesFullResponse>> factionRevivesFullGet({
    int? limit,
    enums.ApiSortDesc? sort,
    int? to,
    int? from,
    enums.ApiStripTagsTrue? striptags,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      RevivesFullResponse,
      () => RevivesFullResponse.fromJsonFactory,
    );

    return _factionRevivesFullGet(
      limit: limit,
      sort: sort?.value?.toString(),
      to: to,
      from: from,
      striptags: striptags?.value?.toString(),
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get your faction's simplified revives
  ///@param limit
  ///@param sort Sorted by the greatest timestamps
  ///@param to Timestamp that sets the upper limit for the data returned. Data returned will be up to and including this time
  ///@param from Timestamp that sets the lower limit for the data returned. Data returned will be after this time
  ///@param striptags Determines if fields include HTML or not ('Hospitalized by <a href=...>user</a>' vs 'Hospitalized by user').
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Limited).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/faction/revivesFull')
  Future<chopper.Response<RevivesFullResponse>> _factionRevivesFullGet({
    @Query('limit') int? limit,
    @Query('sort') String? sort,
    @Query('to') int? to,
    @Query('from') int? from,
    @Query('striptags') String? striptags,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Search factions by name or other criteria
  ///@param name Name  to search for.
  ///@param filters A filtering query parameter allowing a comma-separated list of filters. <br>  * Each filter can be one of the following:  * Fixed options: 'destroyed', 'notDestroyed', 'recruiting', 'notRecruiting'  * Dynamic options: `fieldName`+`condition`+`number`, where:  * * `fieldName` is one of: `id`, `respect`, `members`  * * `condition` is one of: `Equal`, `NotEqual`, `Less`, `LessOrEqual`, `GreaterOrEqual`, `Greater`  * * `number`: any integer value  * Examples: `filters=destroyed`, `filters=notDestroyed,recruiting`, `filters=respectLessOrEqual20000,idGreater100,notRecruiting`
  ///@param limit
  ///@param offset
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<FactionSearchResponse>> factionSearchGet({
    String? name,
    List? filters,
    int? limit,
    int? offset,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      FactionSearchResponse,
      () => FactionSearchResponse.fromJsonFactory,
    );

    return _factionSearchGet(
      name: name,
      filters: filters,
      limit: limit,
      offset: offset,
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Search factions by name or other criteria
  ///@param name Name  to search for.
  ///@param filters A filtering query parameter allowing a comma-separated list of filters. <br>  * Each filter can be one of the following:  * Fixed options: 'destroyed', 'notDestroyed', 'recruiting', 'notRecruiting'  * Dynamic options: `fieldName`+`condition`+`number`, where:  * * `fieldName` is one of: `id`, `respect`, `members`  * * `condition` is one of: `Equal`, `NotEqual`, `Less`, `LessOrEqual`, `GreaterOrEqual`, `Greater`  * * `number`: any integer value  * Examples: `filters=destroyed`, `filters=notDestroyed,recruiting`, `filters=respectLessOrEqual20000,idGreater100,notRecruiting`
  ///@param limit
  ///@param offset
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/faction/search')
  Future<chopper.Response<FactionSearchResponse>> _factionSearchGet({
    @Query('name') String? name,
    @Query('filters') List? filters,
    @Query('limit') int? limit,
    @Query('offset') int? offset,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get your faction's challenges stats
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Minimal).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<FactionStatsResponse>> factionStatsGet({
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      FactionStatsResponse,
      () => FactionStatsResponse.fromJsonFactory,
    );

    return _factionStatsGet(timestamp: timestamp, comment: comment, key: key);
  }

  ///Get your faction's challenges stats
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Minimal).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/faction/stats')
  Future<chopper.Response<FactionStatsResponse>> _factionStatsGet({
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get a list of your faction's territories
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<FactionTerritoriesResponse>> factionTerritoryGet({
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      FactionTerritoriesResponse,
      () => FactionTerritoriesResponse.fromJsonFactory,
    );

    return _factionTerritoryGet(
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get a list of your faction's territories
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/faction/territory')
  Future<chopper.Response<FactionTerritoriesResponse>> _factionTerritoryGet({
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get a list of a faction's territories
  ///@param id Faction id
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<FactionTerritoriesResponse>> factionIdTerritoryGet({
    required int? id,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      FactionTerritoriesResponse,
      () => FactionTerritoriesResponse.fromJsonFactory,
    );

    return _factionIdTerritoryGet(
      id: id,
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get a list of a faction's territories
  ///@param id Faction id
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/faction/{id}/territory')
  Future<chopper.Response<FactionTerritoriesResponse>> _factionIdTerritoryGet({
    @Path('id') required int? id,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get a list of your faction's territories
  ///@param offset
  ///@param limit
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<FactionTerritoriesOwnershipResponse>> factionTerritoryownershipGet({
    int? offset,
    int? limit,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      FactionTerritoriesOwnershipResponse,
      () => FactionTerritoriesOwnershipResponse.fromJsonFactory,
    );

    return _factionTerritoryownershipGet(
      offset: offset,
      limit: limit,
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get a list of your faction's territories
  ///@param offset
  ///@param limit
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/faction/territoryownership')
  Future<chopper.Response<FactionTerritoriesOwnershipResponse>> _factionTerritoryownershipGet({
    @Query('offset') int? offset,
    @Query('limit') int? limit,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get territory wars history for your faction
  ///@param cat This parameter is deprecated. The territory wars list can now instead be fetched via 'faction' -> 'warfare' endpoint. This functionality will be removed on 1st of September 2025.
  ///@param from Timestamp that sets the lower limit for the data returned. Data returned will be after this time
  ///@param to Timestamp that sets the upper limit for the data returned. Data returned will be up to and including this time
  ///@param sort Sorted by the greatest timestamps
  ///@param limit
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<FactionTerritoryWarsResponse>> factionTerritorywarsGet({
    enums.FactionTerritoryWarsCategoryEnum? cat,
    int? from,
    int? to,
    enums.ApiSortDesc? sort,
    int? limit,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      FactionTerritoryWarsResponse,
      () => FactionTerritoryWarsResponse.fromJsonFactory,
    );

    return _factionTerritorywarsGet(
      cat: cat?.value?.toString(),
      from: from,
      to: to,
      sort: sort?.value?.toString(),
      limit: limit,
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get territory wars history for your faction
  ///@param cat This parameter is deprecated. The territory wars list can now instead be fetched via 'faction' -> 'warfare' endpoint. This functionality will be removed on 1st of September 2025.
  ///@param from Timestamp that sets the lower limit for the data returned. Data returned will be after this time
  ///@param to Timestamp that sets the upper limit for the data returned. Data returned will be up to and including this time
  ///@param sort Sorted by the greatest timestamps
  ///@param limit
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/faction/territorywars')
  Future<chopper.Response<FactionTerritoryWarsResponse>> _factionTerritorywarsGet({
    @Query('cat') String? cat,
    @Query('from') int? from,
    @Query('to') int? to,
    @Query('sort') String? sort,
    @Query('limit') int? limit,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get a faction's territory wars history
  ///@param id Faction id
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<FactionTerritoryWarsHistoryResponse>> factionIdTerritorywarsGet({
    required int? id,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      FactionTerritoryWarsHistoryResponse,
      () => FactionTerritoryWarsHistoryResponse.fromJsonFactory,
    );

    return _factionIdTerritorywarsGet(
      id: id,
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get a faction's territory wars history
  ///@param id Faction id
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/faction/{id}/territorywars')
  Future<chopper.Response<FactionTerritoryWarsHistoryResponse>> _factionIdTerritorywarsGet({
    @Path('id') required int? id,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get territory war details
  ///@param territoryWarId Territory war id
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<FactionTerritoryWarReportResponse>> factionTerritoryWarIdTerritorywarreportGet({
    required int? territoryWarId,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      FactionTerritoryWarReportResponse,
      () => FactionTerritoryWarReportResponse.fromJsonFactory,
    );

    return _factionTerritoryWarIdTerritorywarreportGet(
      territoryWarId: territoryWarId,
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get territory war details
  ///@param territoryWarId Territory war id
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/faction/{territoryWarId}/territorywarreport')
  Future<chopper.Response<FactionTerritoryWarReportResponse>> _factionTerritoryWarIdTerritorywarreportGet({
    @Path('territoryWarId') required int? territoryWarId,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get your faction's upgrades
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Minimal).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<FactionUpgradesResponse>> factionUpgradesGet({
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      FactionUpgradesResponse,
      () => FactionUpgradesResponse.fromJsonFactory,
    );

    return _factionUpgradesGet(
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get your faction's upgrades
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Minimal).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/faction/upgrades')
  Future<chopper.Response<FactionUpgradesResponse>> _factionUpgradesGet({
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get faction warfare
  ///@param cat
  ///@param limit
  ///@param sort Sorted by the greatest timestamps
  ///@param from Timestamp that sets the lower limit for the data returned. Data returned will be after this time
  ///@param to Timestamp that sets the upper limit for the data returned. Data returned will be up to and including this time
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<FactionWarfareResponse>> factionWarfareGet({
    required enums.FactionWarfareTypeEnum? cat,
    int? limit,
    enums.ApiSort? sort,
    int? from,
    int? to,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      FactionWarfareResponse,
      () => FactionWarfareResponse.fromJsonFactory,
    );

    return _factionWarfareGet(
      cat: cat?.value?.toString(),
      limit: limit,
      sort: sort?.value?.toString(),
      from: from,
      to: to,
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get faction warfare
  ///@param cat
  ///@param limit
  ///@param sort Sorted by the greatest timestamps
  ///@param from Timestamp that sets the lower limit for the data returned. Data returned will be after this time
  ///@param to Timestamp that sets the upper limit for the data returned. Data returned will be up to and including this time
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/faction/warfare')
  Future<chopper.Response<FactionWarfareResponse>> _factionWarfareGet({
    @Query('cat') required String? cat,
    @Query('limit') int? limit,
    @Query('sort') String? sort,
    @Query('from') int? from,
    @Query('to') int? to,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get your faction's wars & pacts details
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<FactionWarsResponse>> factionWarsGet({
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      FactionWarsResponse,
      () => FactionWarsResponse.fromJsonFactory,
    );

    return _factionWarsGet(timestamp: timestamp, comment: comment, key: key);
  }

  ///Get your faction's wars & pacts details
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/faction/wars')
  Future<chopper.Response<FactionWarsResponse>> _factionWarsGet({
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get a faction's wars & pacts details
  ///@param id Faction id
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<FactionWarsResponse>> factionIdWarsGet({
    required int? id,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      FactionWarsResponse,
      () => FactionWarsResponse.fromJsonFactory,
    );

    return _factionIdWarsGet(
      id: id,
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get a faction's wars & pacts details
  ///@param id Faction id
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/faction/{id}/wars')
  Future<chopper.Response<FactionWarsResponse>> _factionIdWarsGet({
    @Path('id') required int? id,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<FactionLookupResponse>> factionLookupGet({
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      FactionLookupResponse,
      () => FactionLookupResponse.fromJsonFactory,
    );

    return _factionLookupGet(timestamp: timestamp, comment: comment, key: key);
  }

  ///
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/faction/lookup')
  Future<chopper.Response<FactionLookupResponse>> _factionLookupGet({
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get current server time
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<TimestampResponse>> factionTimestampGet({
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      TimestampResponse,
      () => TimestampResponse.fromJsonFactory,
    );

    return _factionTimestampGet(
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get current server time
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/faction/timestamp')
  Future<chopper.Response<TimestampResponse>> _factionTimestampGet({
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get any Faction selection
  ///@param selections Selection names
  ///@param id selection id
  ///@param limit
  ///@param from Timestamp that sets the lower limit for the data returned. Data returned will be after this time
  ///@param to Timestamp that sets the upper limit for the data returned. Data returned will be up to and including this time
  ///@param cat Selection category
  ///@param stat Stat category
  ///@param filters
  ///@param striptags Determines if fields include HTML or not ('Hospitalized by <a href=...>user</a>' vs 'Hospitalized by user').
  ///@param sort Sorted by the greatest timestamps
  ///@param offset
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response> factionGet({
    List<FactionSelectionName>? selections,
    Object? id,
    int? limit,
    int? from,
    int? to,
    Object? cat,
    enums.FactionStatEnum? stat,
    enums.FactionGetFilters? filters,
    enums.ApiStripTags? striptags,
    enums.ApiSort? sort,
    int? offset,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    return _factionGet(
      selections: selections,
      id: id,
      limit: limit,
      from: from,
      to: to,
      cat: cat,
      stat: stat?.value?.toString(),
      filters: filters?.value?.toString(),
      striptags: striptags?.value?.toString(),
      sort: sort?.value?.toString(),
      offset: offset,
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get any Faction selection
  ///@param selections Selection names
  ///@param id selection id
  ///@param limit
  ///@param from Timestamp that sets the lower limit for the data returned. Data returned will be after this time
  ///@param to Timestamp that sets the upper limit for the data returned. Data returned will be up to and including this time
  ///@param cat Selection category
  ///@param stat Stat category
  ///@param filters
  ///@param striptags Determines if fields include HTML or not ('Hospitalized by <a href=...>user</a>' vs 'Hospitalized by user').
  ///@param sort Sorted by the greatest timestamps
  ///@param offset
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/faction')
  Future<chopper.Response> _factionGet({
    @Query('selections') List<FactionSelectionName>? selections,
    @Query('id') Object? id,
    @Query('limit') int? limit,
    @Query('from') int? from,
    @Query('to') int? to,
    @Query('cat') Object? cat,
    @Query('stat') String? stat,
    @Query('filters') String? filters,
    @Query('striptags') String? striptags,
    @Query('sort') String? sort,
    @Query('offset') int? offset,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get publicly available forum categories
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<ForumCategoriesResponse>> forumCategoriesGet({
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      ForumCategoriesResponse,
      () => ForumCategoriesResponse.fromJsonFactory,
    );

    return _forumCategoriesGet(
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get publicly available forum categories
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/forum/categories')
  Future<chopper.Response<ForumCategoriesResponse>> _forumCategoriesGet({
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get specific forum thread posts
  ///@param offset
  ///@param striptags Determines if fields include HTML or not ('Hospitalized by <a href=...>user</a>' vs 'Hospitalized by user').
  ///@param threadId Thread id
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<ForumPostsResponse>> forumThreadIdPostsGet({
    int? offset,
    enums.ApiStripTagsTrue? striptags,
    required int? threadId,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      ForumPostsResponse,
      () => ForumPostsResponse.fromJsonFactory,
    );

    return _forumThreadIdPostsGet(
      offset: offset,
      striptags: striptags?.value?.toString(),
      threadId: threadId,
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get specific forum thread posts
  ///@param offset
  ///@param striptags Determines if fields include HTML or not ('Hospitalized by <a href=...>user</a>' vs 'Hospitalized by user').
  ///@param threadId Thread id
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/forum/{threadId}/posts')
  Future<chopper.Response<ForumPostsResponse>> _forumThreadIdPostsGet({
    @Query('offset') int? offset,
    @Query('striptags') String? striptags,
    @Path('threadId') required int? threadId,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get specific thread details
  ///@param threadId Thread id
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<ForumThreadResponse>> forumThreadIdThreadGet({
    required int? threadId,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      ForumThreadResponse,
      () => ForumThreadResponse.fromJsonFactory,
    );

    return _forumThreadIdThreadGet(
      threadId: threadId,
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get specific thread details
  ///@param threadId Thread id
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/forum/{threadId}/thread')
  Future<chopper.Response<ForumThreadResponse>> _forumThreadIdThreadGet({
    @Path('threadId') required int? threadId,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get threads across all forum categories
  ///@param limit
  ///@param sort Sorted by the greatest timestamps
  ///@param from Timestamp that sets the lower limit for the data returned. Data returned will be after this time
  ///@param to Timestamp that sets the upper limit for the data returned. Data returned will be up to and including this time
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<ForumThreadsResponse>> forumThreadsGet({
    int? limit,
    enums.ApiSort? sort,
    int? from,
    int? to,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      ForumThreadsResponse,
      () => ForumThreadsResponse.fromJsonFactory,
    );

    return _forumThreadsGet(
      limit: limit,
      sort: sort?.value?.toString(),
      from: from,
      to: to,
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get threads across all forum categories
  ///@param limit
  ///@param sort Sorted by the greatest timestamps
  ///@param from Timestamp that sets the lower limit for the data returned. Data returned will be after this time
  ///@param to Timestamp that sets the upper limit for the data returned. Data returned will be up to and including this time
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/forum/threads')
  Future<chopper.Response<ForumThreadsResponse>> _forumThreadsGet({
    @Query('limit') int? limit,
    @Query('sort') String? sort,
    @Query('from') int? from,
    @Query('to') int? to,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get threads for specific public forum category or categories
  ///@param limit
  ///@param sort Sorted by the greatest timestamps
  ///@param from Timestamp that sets the lower limit for the data returned. Data returned will be after this time
  ///@param to Timestamp that sets the upper limit for the data returned. Data returned will be up to and including this time
  ///@param categoryIds Category id or a list of category ids (comma separated)
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<ForumThreadsResponse>> forumCategoryIdsThreadsGet({
    int? limit,
    enums.ApiSort? sort,
    int? from,
    int? to,
    required List<int>? categoryIds,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      ForumThreadsResponse,
      () => ForumThreadsResponse.fromJsonFactory,
    );

    return _forumCategoryIdsThreadsGet(
      limit: limit,
      sort: sort?.value?.toString(),
      from: from,
      to: to,
      categoryIds: categoryIds,
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get threads for specific public forum category or categories
  ///@param limit
  ///@param sort Sorted by the greatest timestamps
  ///@param from Timestamp that sets the lower limit for the data returned. Data returned will be after this time
  ///@param to Timestamp that sets the upper limit for the data returned. Data returned will be up to and including this time
  ///@param categoryIds Category id or a list of category ids (comma separated)
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/forum/{categoryIds}/threads')
  Future<chopper.Response<ForumThreadsResponse>> _forumCategoryIdsThreadsGet({
    @Query('limit') int? limit,
    @Query('sort') String? sort,
    @Query('from') int? from,
    @Query('to') int? to,
    @Path('categoryIds') required List<int>? categoryIds,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get all available forum selections
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<ForumLookupResponse>> forumLookupGet({
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      ForumLookupResponse,
      () => ForumLookupResponse.fromJsonFactory,
    );

    return _forumLookupGet(timestamp: timestamp, comment: comment, key: key);
  }

  ///Get all available forum selections
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/forum/lookup')
  Future<chopper.Response<ForumLookupResponse>> _forumLookupGet({
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get current server time
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<TimestampResponse>> forumTimestampGet({
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      TimestampResponse,
      () => TimestampResponse.fromJsonFactory,
    );

    return _forumTimestampGet(timestamp: timestamp, comment: comment, key: key);
  }

  ///Get current server time
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/forum/timestamp')
  Future<chopper.Response<TimestampResponse>> _forumTimestampGet({
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get any Forum selection
  ///@param selections Selection names
  ///@param id selection id
  ///@param striptags Determines if fields include HTML or not ('Hospitalized by <a href=...>user</a>' vs 'Hospitalized by user').
  ///@param limit
  ///@param sort Sorted by the greatest timestamps
  ///@param from Timestamp that sets the lower limit for the data returned. Data returned will be after this time
  ///@param to Timestamp that sets the upper limit for the data returned. Data returned will be up to and including this time
  ///@param offset
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response> forumGet({
    List<ForumSelectionName>? selections,
    Object? id,
    enums.ApiStripTags? striptags,
    int? limit,
    enums.ApiSort? sort,
    int? from,
    int? to,
    int? offset,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    return _forumGet(
      selections: selections,
      id: id,
      striptags: striptags?.value?.toString(),
      limit: limit,
      sort: sort?.value?.toString(),
      from: from,
      to: to,
      offset: offset,
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get any Forum selection
  ///@param selections Selection names
  ///@param id selection id
  ///@param striptags Determines if fields include HTML or not ('Hospitalized by <a href=...>user</a>' vs 'Hospitalized by user').
  ///@param limit
  ///@param sort Sorted by the greatest timestamps
  ///@param from Timestamp that sets the lower limit for the data returned. Data returned will be after this time
  ///@param to Timestamp that sets the upper limit for the data returned. Data returned will be up to and including this time
  ///@param offset
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/forum')
  Future<chopper.Response> _forumGet({
    @Query('selections') List<ForumSelectionName>? selections,
    @Query('id') Object? id,
    @Query('striptags') String? striptags,
    @Query('limit') int? limit,
    @Query('sort') String? sort,
    @Query('from') int? from,
    @Query('to') int? to,
    @Query('offset') int? offset,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get current key log history
  ///@param limit
  ///@param offset
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<KeyLogResponse>> keyLogGet({
    int? limit,
    int? offset,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      KeyLogResponse,
      () => KeyLogResponse.fromJsonFactory,
    );

    return _keyLogGet(
      limit: limit,
      offset: offset,
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get current key log history
  ///@param limit
  ///@param offset
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/key/log')
  Future<chopper.Response<KeyLogResponse>> _keyLogGet({
    @Query('limit') int? limit,
    @Query('offset') int? offset,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get current key info
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<KeyInfoResponse>> keyInfoGet({
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      KeyInfoResponse,
      () => KeyInfoResponse.fromJsonFactory,
    );

    return _keyInfoGet(timestamp: timestamp, comment: comment, key: key);
  }

  ///Get current key info
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/key/info')
  Future<chopper.Response<KeyInfoResponse>> _keyInfoGet({
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get any Key selection
  ///@param selections Selection names
  ///@param limit
  ///@param offset
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response> keyGet({
    List<KeySelectionName>? selections,
    int? limit,
    int? offset,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    return _keyGet(
      selections: selections,
      limit: limit,
      offset: offset,
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get any Key selection
  ///@param selections Selection names
  ///@param limit
  ///@param offset
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/key')
  Future<chopper.Response> _keyGet({
    @Query('selections') List<KeySelectionName>? selections,
    @Query('limit') int? limit,
    @Query('offset') int? offset,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get bazaar directory
  ///@param cat Category of specialized bazaars returned
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<BazaarResponse>> marketBazaarGet({
    enums.MarketSpecializedBazaarCategoryEnum? cat,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      BazaarResponse,
      () => BazaarResponse.fromJsonFactory,
    );

    return _marketBazaarGet(
      cat: cat?.value?.toString(),
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get bazaar directory
  ///@param cat Category of specialized bazaars returned
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/market/bazaar')
  Future<chopper.Response<BazaarResponse>> _marketBazaarGet({
    @Query('cat') String? cat,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get item specialized bazaar directory
  ///@param id Item id
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<BazaarResponseSpecialized>> marketIdBazaarGet({
    required int? id,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      BazaarResponseSpecialized,
      () => BazaarResponseSpecialized.fromJsonFactory,
    );

    return _marketIdBazaarGet(
      id: id,
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get item specialized bazaar directory
  ///@param id Item id
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/market/{id}/bazaar')
  Future<chopper.Response<BazaarResponseSpecialized>> _marketIdBazaarGet({
    @Path('id') required int? id,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get item market listings
  ///@param id Item id
  ///@param bonus Used to filter weapons with a specific bonus.
  ///@param offset
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<MarketItemMarketResponse>> marketIdItemmarketGet({
    required int? id,
    enums.WeaponBonusEnum? bonus,
    int? offset,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      MarketItemMarketResponse,
      () => MarketItemMarketResponse.fromJsonFactory,
    );

    return _marketIdItemmarketGet(
      id: id,
      bonus: bonus?.value?.toString(),
      offset: offset,
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get item market listings
  ///@param id Item id
  ///@param bonus Used to filter weapons with a specific bonus.
  ///@param offset
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/market/{id}/itemmarket')
  Future<chopper.Response<MarketItemMarketResponse>> _marketIdItemmarketGet({
    @Path('id') required int? id,
    @Query('bonus') String? bonus,
    @Query('offset') int? offset,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get properties market listings
  ///@param propertyTypeId Property type id
  ///@param offset
  ///@param limit
  ///@param sort Sorted by the greatest timestamps
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<MarketPropertiesResponse>> marketPropertyTypeIdPropertiesGet({
    required int? propertyTypeId,
    int? offset,
    int? limit,
    enums.ApiSort? sort,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      MarketPropertiesResponse,
      () => MarketPropertiesResponse.fromJsonFactory,
    );

    return _marketPropertyTypeIdPropertiesGet(
      propertyTypeId: propertyTypeId,
      offset: offset,
      limit: limit,
      sort: sort?.value?.toString(),
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get properties market listings
  ///@param propertyTypeId Property type id
  ///@param offset
  ///@param limit
  ///@param sort Sorted by the greatest timestamps
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/market/{propertyTypeId}/properties')
  Future<chopper.Response<MarketPropertiesResponse>> _marketPropertyTypeIdPropertiesGet({
    @Path('propertyTypeId') required int? propertyTypeId,
    @Query('offset') int? offset,
    @Query('limit') int? limit,
    @Query('sort') String? sort,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get properties rental listings
  ///@param propertyTypeId Property type id
  ///@param offset
  ///@param limit
  ///@param sort Sorted by the greatest timestamps
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<MarketRentalsResponse>> marketPropertyTypeIdRentalsGet({
    required int? propertyTypeId,
    int? offset,
    int? limit,
    enums.ApiSort? sort,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      MarketRentalsResponse,
      () => MarketRentalsResponse.fromJsonFactory,
    );

    return _marketPropertyTypeIdRentalsGet(
      propertyTypeId: propertyTypeId,
      offset: offset,
      limit: limit,
      sort: sort?.value?.toString(),
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get properties rental listings
  ///@param propertyTypeId Property type id
  ///@param offset
  ///@param limit
  ///@param sort Sorted by the greatest timestamps
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/market/{propertyTypeId}/rentals')
  Future<chopper.Response<MarketRentalsResponse>> _marketPropertyTypeIdRentalsGet({
    @Path('propertyTypeId') required int? propertyTypeId,
    @Query('offset') int? offset,
    @Query('limit') int? limit,
    @Query('sort') String? sort,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get all available market selections
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<MarketLookupResponse>> marketLookupGet({
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      MarketLookupResponse,
      () => MarketLookupResponse.fromJsonFactory,
    );

    return _marketLookupGet(timestamp: timestamp, comment: comment, key: key);
  }

  ///Get all available market selections
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/market/lookup')
  Future<chopper.Response<MarketLookupResponse>> _marketLookupGet({
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get current server time
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<TimestampResponse>> marketTimestampGet({
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      TimestampResponse,
      () => TimestampResponse.fromJsonFactory,
    );

    return _marketTimestampGet(
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get current server time
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/market/timestamp')
  Future<chopper.Response<TimestampResponse>> _marketTimestampGet({
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get any Market selection
  ///@param selections Selection names
  ///@param id selection id
  ///@param cat Category of specialized bazaars returned
  ///@param bonus Used to filter weapons with a specific bonus
  ///@param sort Direction to sort rows in
  ///@param offset
  ///@param limit
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response> marketGet({
    List<MarketSelectionName>? selections,
    Object? id,
    enums.MarketSpecializedBazaarCategoryEnum? cat,
    enums.WeaponBonusEnum? bonus,
    enums.MarketGetSort? sort,
    int? offset,
    int? limit,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    return _marketGet(
      selections: selections,
      id: id,
      cat: cat?.value?.toString(),
      bonus: bonus?.value?.toString(),
      sort: sort?.value?.toString(),
      offset: offset,
      limit: limit,
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get any Market selection
  ///@param selections Selection names
  ///@param id selection id
  ///@param cat Category of specialized bazaars returned
  ///@param bonus Used to filter weapons with a specific bonus
  ///@param sort Direction to sort rows in
  ///@param offset
  ///@param limit
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/market')
  Future<chopper.Response> _marketGet({
    @Query('selections') List<MarketSelectionName>? selections,
    @Query('id') Object? id,
    @Query('cat') String? cat,
    @Query('bonus') String? bonus,
    @Query('sort') String? sort,
    @Query('offset') int? offset,
    @Query('limit') int? limit,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get cars and their racing stats
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<RacingCarsResponse>> racingCarsGet({
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      RacingCarsResponse,
      () => RacingCarsResponse.fromJsonFactory,
    );

    return _racingCarsGet(timestamp: timestamp, comment: comment, key: key);
  }

  ///Get cars and their racing stats
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/racing/cars')
  Future<chopper.Response<RacingCarsResponse>> _racingCarsGet({
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get all possible car upgrades
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<RacingCarUpgradesResponse>> racingCarupgradesGet({
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      RacingCarUpgradesResponse,
      () => RacingCarUpgradesResponse.fromJsonFactory,
    );

    return _racingCarupgradesGet(
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get all possible car upgrades
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/racing/carupgrades')
  Future<chopper.Response<RacingCarUpgradesResponse>> _racingCarupgradesGet({
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get races
  ///@param limit
  ///@param sort Sorted by the greatest timestamps
  ///@param to Timestamp that sets the upper limit for the data returned. Data returned will be up to and including this time
  ///@param from Timestamp that sets the lower limit for the data returned. Data returned will be after this time
  ///@param cat Category of races returned
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<RacingRacesResponse>> racingRacesGet({
    int? limit,
    enums.ApiSortDesc? sort,
    int? to,
    int? from,
    enums.RacingRaceTypeEnum? cat,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      RacingRacesResponse,
      () => RacingRacesResponse.fromJsonFactory,
    );

    return _racingRacesGet(
      limit: limit,
      sort: sort?.value?.toString(),
      to: to,
      from: from,
      cat: cat?.value?.toString(),
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get races
  ///@param limit
  ///@param sort Sorted by the greatest timestamps
  ///@param to Timestamp that sets the upper limit for the data returned. Data returned will be up to and including this time
  ///@param from Timestamp that sets the lower limit for the data returned. Data returned will be after this time
  ///@param cat Category of races returned
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/racing/races')
  Future<chopper.Response<RacingRacesResponse>> _racingRacesGet({
    @Query('limit') int? limit,
    @Query('sort') String? sort,
    @Query('to') int? to,
    @Query('from') int? from,
    @Query('cat') String? cat,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get specific race details
  ///@param raceId Race id
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<RacingRaceDetailsResponse>> racingRaceIdRaceGet({
    required int? raceId,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      RacingRaceDetailsResponse,
      () => RacingRaceDetailsResponse.fromJsonFactory,
    );

    return _racingRaceIdRaceGet(
      raceId: raceId,
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get specific race details
  ///@param raceId Race id
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/racing/{raceId}/race')
  Future<chopper.Response<RacingRaceDetailsResponse>> _racingRaceIdRaceGet({
    @Path('raceId') required int? raceId,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get track records
  ///@param trackId Track id
  ///@param cat Car class
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<RacingTrackRecordsResponse>> racingTrackIdRecordsGet({
    required int? trackId,
    required enums.RaceClassEnum? cat,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      RacingTrackRecordsResponse,
      () => RacingTrackRecordsResponse.fromJsonFactory,
    );

    return _racingTrackIdRecordsGet(
      trackId: trackId,
      cat: cat?.value?.toString(),
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get track records
  ///@param trackId Track id
  ///@param cat Car class
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/racing/{trackId}/records')
  Future<chopper.Response<RacingTrackRecordsResponse>> _racingTrackIdRecordsGet({
    @Path('trackId') required int? trackId,
    @Query('cat') required String? cat,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get race tracks and descriptions
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<RacingTracksResponse>> racingTracksGet({
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      RacingTracksResponse,
      () => RacingTracksResponse.fromJsonFactory,
    );

    return _racingTracksGet(timestamp: timestamp, comment: comment, key: key);
  }

  ///Get race tracks and descriptions
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/racing/tracks')
  Future<chopper.Response<RacingTracksResponse>> _racingTracksGet({
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get all available racing selections
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<RacingLookupResponse>> racingLookupGet({
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      RacingLookupResponse,
      () => RacingLookupResponse.fromJsonFactory,
    );

    return _racingLookupGet(timestamp: timestamp, comment: comment, key: key);
  }

  ///Get all available racing selections
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/racing/lookup')
  Future<chopper.Response<RacingLookupResponse>> _racingLookupGet({
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get current server time
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<TimestampResponse>> racingTimestampGet({
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      TimestampResponse,
      () => TimestampResponse.fromJsonFactory,
    );

    return _racingTimestampGet(
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get current server time
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/racing/timestamp')
  Future<chopper.Response<TimestampResponse>> _racingTimestampGet({
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get any Racing selection
  ///@param selections Selection names
  ///@param id selection id
  ///@param limit
  ///@param sort Sorted by the greatest timestamps
  ///@param to Timestamp that sets the upper limit for the data returned. Data returned will be up to and including this time
  ///@param from Timestamp that sets the lower limit for the data returned. Data returned will be after this time
  ///@param cat Selection category
  ///@param offset
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response> racingGet({
    List<RacingSelectionName>? selections,
    Object? id,
    int? limit,
    enums.ApiSort? sort,
    int? to,
    int? from,
    Object? cat,
    int? offset,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    return _racingGet(
      selections: selections,
      id: id,
      limit: limit,
      sort: sort?.value?.toString(),
      to: to,
      from: from,
      cat: cat,
      offset: offset,
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get any Racing selection
  ///@param selections Selection names
  ///@param id selection id
  ///@param limit
  ///@param sort Sorted by the greatest timestamps
  ///@param to Timestamp that sets the upper limit for the data returned. Data returned will be up to and including this time
  ///@param from Timestamp that sets the lower limit for the data returned. Data returned will be after this time
  ///@param cat Selection category
  ///@param offset
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/racing')
  Future<chopper.Response> _racingGet({
    @Query('selections') List<RacingSelectionName>? selections,
    @Query('id') Object? id,
    @Query('limit') int? limit,
    @Query('sort') String? sort,
    @Query('to') int? to,
    @Query('from') int? from,
    @Query('cat') Object? cat,
    @Query('offset') int? offset,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get a specific property
  ///@param id Property id
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<UserPropertyResponse>> propertyIdPropertyGet({
    required int? id,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      UserPropertyResponse,
      () => UserPropertyResponse.fromJsonFactory,
    );

    return _propertyIdPropertyGet(
      id: id,
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get a specific property
  ///@param id Property id
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/property/{id}/property')
  Future<chopper.Response<UserPropertyResponse>> _propertyIdPropertyGet({
    @Path('id') required int? id,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get all available property selections
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<PropertyLookupResponse>> propertyLookupGet({
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      PropertyLookupResponse,
      () => PropertyLookupResponse.fromJsonFactory,
    );

    return _propertyLookupGet(timestamp: timestamp, comment: comment, key: key);
  }

  ///Get all available property selections
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/property/lookup')
  Future<chopper.Response<PropertyLookupResponse>> _propertyLookupGet({
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get current server time
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<TimestampResponse>> propertyTimestampGet({
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      TimestampResponse,
      () => TimestampResponse.fromJsonFactory,
    );

    return _propertyTimestampGet(
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get current server time
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/property/timestamp')
  Future<chopper.Response<TimestampResponse>> _propertyTimestampGet({
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get any property selection
  ///@param selections Selection names
  ///@param id Property id
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response> propertyGet({
    List<PropertySelectionName>? selections,
    required int? id,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    return _propertyGet(
      selections: selections,
      id: id,
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get any property selection
  ///@param selections Selection names
  ///@param id Property id
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/property')
  Future<chopper.Response> _propertyGet({
    @Query('selections') List<PropertySelectionName>? selections,
    @Query('id') required int? id,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get attack log details
  ///@param log Code of the attack log. E.g. d51ad4fe6be884b309b142e2d1d4f807
  ///@param offset
  ///@param sort Sorted by the greatest timestamps
  ///@param striptags Determines if fields include HTML or not ('Hospitalized by <a href=...>user</a>' vs 'Hospitalized by user').
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<AttackLogResponse>> tornAttacklogGet({
    required String? log,
    int? offset,
    enums.ApiSort? sort,
    enums.ApiStripTagsTrue? striptags,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      AttackLogResponse,
      () => AttackLogResponse.fromJsonFactory,
    );

    return _tornAttacklogGet(
      log: log,
      offset: offset,
      sort: sort?.value?.toString(),
      striptags: striptags?.value?.toString(),
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get attack log details
  ///@param log Code of the attack log. E.g. d51ad4fe6be884b309b142e2d1d4f807
  ///@param offset
  ///@param sort Sorted by the greatest timestamps
  ///@param striptags Determines if fields include HTML or not ('Hospitalized by <a href=...>user</a>' vs 'Hospitalized by user').
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/torn/attacklog')
  Future<chopper.Response<AttackLogResponse>> _tornAttacklogGet({
    @Query('log') required String? log,
    @Query('offset') int? offset,
    @Query('sort') String? sort,
    @Query('striptags') String? striptags,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get bounties
  ///@param limit
  ///@param offset
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<TornBountiesResponse>> tornBountiesGet({
    int? limit,
    int? offset,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      TornBountiesResponse,
      () => TornBountiesResponse.fromJsonFactory,
    );

    return _tornBountiesGet(
      limit: limit,
      offset: offset,
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get bounties
  ///@param limit
  ///@param offset
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/torn/bounties')
  Future<chopper.Response<TornBountiesResponse>> _tornBountiesGet({
    @Query('limit') int? limit,
    @Query('offset') int? offset,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get calendar information
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<TornCalendarResponse>> tornCalendarGet({
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      TornCalendarResponse,
      () => TornCalendarResponse.fromJsonFactory,
    );

    return _tornCalendarGet(timestamp: timestamp, comment: comment, key: key);
  }

  ///Get calendar information
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/torn/calendar')
  Future<chopper.Response<TornCalendarResponse>> _tornCalendarGet({
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get crimes information
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<TornCrimesResponse>> tornCrimesGet({
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      TornCrimesResponse,
      () => TornCrimesResponse.fromJsonFactory,
    );

    return _tornCrimesGet(timestamp: timestamp, comment: comment, key: key);
  }

  ///Get crimes information
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/torn/crimes')
  Future<chopper.Response<TornCrimesResponse>> _tornCrimesGet({
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get education information
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<TornEducationResponse>> tornEducationGet({
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      TornEducationResponse,
      () => TornEducationResponse.fromJsonFactory,
    );

    return _tornEducationGet(timestamp: timestamp, comment: comment, key: key);
  }

  ///Get education information
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/torn/education')
  Future<chopper.Response<TornEducationResponse>> _tornEducationGet({
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get faction hall of fame positions for a specific category
  ///@param limit
  ///@param offset
  ///@param cat Leaderboards category
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<TornFactionHofResponse>> tornFactionhofGet({
    int? limit,
    int? offset,
    required enums.TornFactionHofCategory? cat,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      TornFactionHofResponse,
      () => TornFactionHofResponse.fromJsonFactory,
    );

    return _tornFactionhofGet(
      limit: limit,
      offset: offset,
      cat: cat?.value?.toString(),
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get faction hall of fame positions for a specific category
  ///@param limit
  ///@param offset
  ///@param cat Leaderboards category
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/torn/factionhof')
  Future<chopper.Response<TornFactionHofResponse>> _tornFactionhofGet({
    @Query('limit') int? limit,
    @Query('offset') int? offset,
    @Query('cat') required String? cat,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get full faction tree
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<TornFactionTreeResponse>> tornFactiontreeGet({
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      TornFactionTreeResponse,
      () => TornFactionTreeResponse.fromJsonFactory,
    );

    return _tornFactiontreeGet(
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get full faction tree
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/torn/factiontree')
  Future<chopper.Response<TornFactionTreeResponse>> _tornFactiontreeGet({
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get player hall of fame positions for a specific category
  ///@param limit
  ///@param offset
  ///@param cat Leaderboards category
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<TornHofResponse>> tornHofGet({
    int? limit,
    int? offset,
    required enums.TornHofCategory? cat,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      TornHofResponse,
      () => TornHofResponse.fromJsonFactory,
    );

    return _tornHofGet(
      limit: limit,
      offset: offset,
      cat: cat?.value?.toString(),
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get player hall of fame positions for a specific category
  ///@param limit
  ///@param offset
  ///@param cat Leaderboards category
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/torn/hof')
  Future<chopper.Response<TornHofResponse>> _tornHofGet({
    @Query('limit') int? limit,
    @Query('offset') int? offset,
    @Query('cat') required String? cat,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get information about ammo
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<TornItemAmmoResponse>> tornItemammoGet({
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      TornItemAmmoResponse,
      () => TornItemAmmoResponse.fromJsonFactory,
    );

    return _tornItemammoGet(timestamp: timestamp, comment: comment, key: key);
  }

  ///Get information about ammo
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/torn/itemammo')
  Future<chopper.Response<TornItemAmmoResponse>> _tornItemammoGet({
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get information about weapon upgrades
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<TornItemModsResponse>> tornItemmodsGet({
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      TornItemModsResponse,
      () => TornItemModsResponse.fromJsonFactory,
    );

    return _tornItemmodsGet(timestamp: timestamp, comment: comment, key: key);
  }

  ///Get information about weapon upgrades
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/torn/itemmods')
  Future<chopper.Response<TornItemModsResponse>> _tornItemmodsGet({
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get information about items
  ///@param cat Item category type
  ///@param sort Sort rows from newest to oldest<br>Default ordering is ascending
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<TornItemsResponse>> tornItemsGet({
    enums.TornItemCategory? cat,
    enums.ApiSortAsc? sort,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      TornItemsResponse,
      () => TornItemsResponse.fromJsonFactory,
    );

    return _tornItemsGet(
      cat: cat?.value?.toString(),
      sort: sort?.value?.toString(),
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get information about items
  ///@param cat Item category type
  ///@param sort Sort rows from newest to oldest<br>Default ordering is ascending
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/torn/items')
  Future<chopper.Response<TornItemsResponse>> _tornItemsGet({
    @Query('cat') String? cat,
    @Query('sort') String? sort,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get information about items
  ///@param ids Item id or a list of item ids (comma separated)
  ///@param sort Sort rows from newest to oldest<br>Default ordering is ascending
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<TornItemsResponse>> tornIdsItemsGet({
    required List<int>? ids,
    enums.ApiSortAsc? sort,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      TornItemsResponse,
      () => TornItemsResponse.fromJsonFactory,
    );

    return _tornIdsItemsGet(
      ids: ids,
      sort: sort?.value?.toString(),
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get information about items
  ///@param ids Item id or a list of item ids (comma separated)
  ///@param sort Sort rows from newest to oldest<br>Default ordering is ascending
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/torn/{ids}/items')
  Future<chopper.Response<TornItemsResponse>> _tornIdsItemsGet({
    @Path('ids') required List<int>? ids,
    @Query('sort') String? sort,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get available log categories
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<TornLogCategoriesResponse>> tornLogcategoriesGet({
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      TornLogCategoriesResponse,
      () => TornLogCategoriesResponse.fromJsonFactory,
    );

    return _tornLogcategoriesGet(
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get available log categories
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/torn/logcategories')
  Future<chopper.Response<TornLogCategoriesResponse>> _tornLogcategoriesGet({
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get all available log ids
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<TornLogTypesResponse>> tornLogtypesGet({
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      TornLogTypesResponse,
      () => TornLogTypesResponse.fromJsonFactory,
    );

    return _tornLogtypesGet(timestamp: timestamp, comment: comment, key: key);
  }

  ///Get all available log ids
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/torn/logtypes')
  Future<chopper.Response<TornLogTypesResponse>> _tornLogtypesGet({
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get available log ids for a specific log category
  ///@param logCategoryId Log category id
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<TornLogTypesResponse>> tornLogCategoryIdLogtypesGet({
    required int? logCategoryId,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      TornLogTypesResponse,
      () => TornLogTypesResponse.fromJsonFactory,
    );

    return _tornLogCategoryIdLogtypesGet(
      logCategoryId: logCategoryId,
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get available log ids for a specific log category
  ///@param logCategoryId Log category id
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/torn/{logCategoryId}/logtypes')
  Future<chopper.Response<TornLogTypesResponse>> _tornLogCategoryIdLogtypesGet({
    @Path('logCategoryId') required int? logCategoryId,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get organized crimes information
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<TornOrganizedCrimeResponse>> tornOrganizedcrimesGet({
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      TornOrganizedCrimeResponse,
      () => TornOrganizedCrimeResponse.fromJsonFactory,
    );

    return _tornOrganizedcrimesGet(
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get organized crimes information
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/torn/organizedcrimes')
  Future<chopper.Response<TornOrganizedCrimeResponse>> _tornOrganizedcrimesGet({
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get properties details
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<TornProperties>> tornPropertiesGet({
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      TornProperties,
      () => TornProperties.fromJsonFactory,
    );

    return _tornPropertiesGet(timestamp: timestamp, comment: comment, key: key);
  }

  ///Get properties details
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/torn/properties')
  Future<chopper.Response<TornProperties>> _tornPropertiesGet({
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get Subcrimes information
  ///@param crimeId Crime id
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<TornSubcrimesResponse>> tornCrimeIdSubcrimesGet({
    required int? crimeId,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      TornSubcrimesResponse,
      () => TornSubcrimesResponse.fromJsonFactory,
    );

    return _tornCrimeIdSubcrimesGet(
      crimeId: crimeId,
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get Subcrimes information
  ///@param crimeId Crime id
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/torn/{crimeId}/subcrimes')
  Future<chopper.Response<TornSubcrimesResponse>> _tornCrimeIdSubcrimesGet({
    @Path('crimeId') required int? crimeId,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get territory details
  ///@param ids Specific territory id or a list of territory ids (comma separated)
  ///@param offset
  ///@param limit
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<TornTerritoriesResponse>> tornTerritoryGet({
    List<enums.FactionTerritoryEnum>? ids,
    int? offset,
    int? limit,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      TornTerritoriesResponse,
      () => TornTerritoriesResponse.fromJsonFactory,
    );

    return _tornTerritoryGet(
      ids: factionTerritoryEnumListToJson(ids),
      offset: offset,
      limit: limit,
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get territory details
  ///@param ids Specific territory id or a list of territory ids (comma separated)
  ///@param offset
  ///@param limit
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/torn/territory')
  Future<chopper.Response<TornTerritoriesResponse>> _tornTerritoryGet({
    @Query('ids') List<Object?>? ids,
    @Query('offset') int? offset,
    @Query('limit') int? limit,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get all available torn selections
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<TornLookupResponse>> tornLookupGet({
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      TornLookupResponse,
      () => TornLookupResponse.fromJsonFactory,
    );

    return _tornLookupGet(timestamp: timestamp, comment: comment, key: key);
  }

  ///Get all available torn selections
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/torn/lookup')
  Future<chopper.Response<TornLookupResponse>> _tornLookupGet({
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get current server time
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response<TimestampResponse>> tornTimestampGet({
    String? timestamp,
    String? comment,
    String? key,
  }) {
    generatedMapping.putIfAbsent(
      TimestampResponse,
      () => TimestampResponse.fromJsonFactory,
    );

    return _tornTimestampGet(timestamp: timestamp, comment: comment, key: key);
  }

  ///Get current server time
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/torn/timestamp')
  Future<chopper.Response<TimestampResponse>> _tornTimestampGet({
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });

  ///Get any Torn selection
  ///@param selections Selection names
  ///@param id selection id
  ///@param striptags Determines if fields include HTML or not ('Hospitalized by <a href=...>user</a>' vs 'Hospitalized by user').
  ///@param limit
  ///@param to Timestamp that sets the upper limit for the data returned. Data returned will be up to and including this time
  ///@param from Timestamp that sets the lower limit for the data returned. Data returned will be after this time
  ///@param sort Sorted by the greatest timestamps
  ///@param cat Selection category
  ///@param offset
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  Future<chopper.Response> tornGet({
    List<TornSelectionName>? selections,
    Object? id,
    enums.ApiStripTags? striptags,
    int? limit,
    int? to,
    int? from,
    enums.ApiSort? sort,
    Object? cat,
    int? offset,
    String? timestamp,
    String? comment,
    String? key,
  }) {
    return _tornGet(
      selections: selections,
      id: id,
      striptags: striptags?.value?.toString(),
      limit: limit,
      to: to,
      from: from,
      sort: sort?.value?.toString(),
      cat: cat,
      offset: offset,
      timestamp: timestamp,
      comment: comment,
      key: key,
    );
  }

  ///Get any Torn selection
  ///@param selections Selection names
  ///@param id selection id
  ///@param striptags Determines if fields include HTML or not ('Hospitalized by <a href=...>user</a>' vs 'Hospitalized by user').
  ///@param limit
  ///@param to Timestamp that sets the upper limit for the data returned. Data returned will be up to and including this time
  ///@param from Timestamp that sets the lower limit for the data returned. Data returned will be after this time
  ///@param sort Sorted by the greatest timestamps
  ///@param cat Selection category
  ///@param offset
  ///@param timestamp Timestamp to bypass cache
  ///@param comment Comment for your tool/service/bot/website to be visible in the logs.
  ///@param key API key (Public).<br>It's not required to use this parameter when passing the API key via the Authorization header.
  @GET(path: '/torn')
  Future<chopper.Response> _tornGet({
    @Query('selections') List<TornSelectionName>? selections,
    @Query('id') Object? id,
    @Query('striptags') String? striptags,
    @Query('limit') int? limit,
    @Query('to') int? to,
    @Query('from') int? from,
    @Query('sort') String? sort,
    @Query('cat') Object? cat,
    @Query('offset') int? offset,
    @Query('timestamp') String? timestamp,
    @Query('comment') String? comment,
    @Query('key') String? key,
  });
}

@JsonSerializable(explicitToJson: true)
class RequestLinks {
  const RequestLinks({required this.next, required this.prev});

  factory RequestLinks.fromJson(Map<String, dynamic> json) => _$RequestLinksFromJson(json);

  static const toJsonFactory = _$RequestLinksToJson;
  Map<String, dynamic> toJson() => _$RequestLinksToJson(this);

  @JsonKey(name: 'next')
  final dynamic next;
  @JsonKey(name: 'prev')
  final dynamic prev;
  static const fromJsonFactory = _$RequestLinksFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RequestLinks &&
            (identical(other.next, next) || const DeepCollectionEquality().equals(other.next, next)) &&
            (identical(other.prev, prev) || const DeepCollectionEquality().equals(other.prev, prev)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(next) ^ const DeepCollectionEquality().hash(prev) ^ runtimeType.hashCode;
}

extension $RequestLinksExtension on RequestLinks {
  RequestLinks copyWith({dynamic next, dynamic prev}) {
    return RequestLinks(next: next ?? this.next, prev: prev ?? this.prev);
  }

  RequestLinks copyWithWrapped({
    Wrapped<dynamic>? next,
    Wrapped<dynamic>? prev,
  }) {
    return RequestLinks(
      next: (next != null ? next.value : this.next),
      prev: (prev != null ? prev.value : this.prev),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class RequestMetadata {
  const RequestMetadata({required this.links});

  factory RequestMetadata.fromJson(Map<String, dynamic> json) => _$RequestMetadataFromJson(json);

  static const toJsonFactory = _$RequestMetadataToJson;
  Map<String, dynamic> toJson() => _$RequestMetadataToJson(this);

  @JsonKey(name: 'links')
  final RequestLinks links;
  static const fromJsonFactory = _$RequestMetadataFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RequestMetadata &&
            (identical(other.links, links) || const DeepCollectionEquality().equals(other.links, links)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(links) ^ runtimeType.hashCode;
}

extension $RequestMetadataExtension on RequestMetadata {
  RequestMetadata copyWith({RequestLinks? links}) {
    return RequestMetadata(links: links ?? this.links);
  }

  RequestMetadata copyWithWrapped({Wrapped<RequestLinks>? links}) {
    return RequestMetadata(links: (links != null ? links.value : this.links));
  }
}

@JsonSerializable(explicitToJson: true)
class RequestMetadataWithLinks {
  const RequestMetadataWithLinks({required this.links});

  factory RequestMetadataWithLinks.fromJson(Map<String, dynamic> json) => _$RequestMetadataWithLinksFromJson(json);

  static const toJsonFactory = _$RequestMetadataWithLinksToJson;
  Map<String, dynamic> toJson() => _$RequestMetadataWithLinksToJson(this);

  @JsonKey(name: 'links')
  final RequestLinks links;
  static const fromJsonFactory = _$RequestMetadataWithLinksFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RequestMetadataWithLinks &&
            (identical(other.links, links) || const DeepCollectionEquality().equals(other.links, links)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(links) ^ runtimeType.hashCode;
}

extension $RequestMetadataWithLinksExtension on RequestMetadataWithLinks {
  RequestMetadataWithLinks copyWith({RequestLinks? links}) {
    return RequestMetadataWithLinks(links: links ?? this.links);
  }

  RequestMetadataWithLinks copyWithWrapped({Wrapped<RequestLinks>? links}) {
    return RequestMetadataWithLinks(
      links: (links != null ? links.value : this.links),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class RequestMetadataWithLinksAndTotal {
  const RequestMetadataWithLinksAndTotal({required this.links, this.total});

  factory RequestMetadataWithLinksAndTotal.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$RequestMetadataWithLinksAndTotalFromJson(json);

  static const toJsonFactory = _$RequestMetadataWithLinksAndTotalToJson;
  Map<String, dynamic> toJson() => _$RequestMetadataWithLinksAndTotalToJson(this);

  @JsonKey(name: 'links')
  final RequestLinks links;
  @JsonKey(name: 'total')
  final int? total;
  static const fromJsonFactory = _$RequestMetadataWithLinksAndTotalFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RequestMetadataWithLinksAndTotal &&
            (identical(other.links, links) || const DeepCollectionEquality().equals(other.links, links)) &&
            (identical(other.total, total) || const DeepCollectionEquality().equals(other.total, total)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(links) ^ const DeepCollectionEquality().hash(total) ^ runtimeType.hashCode;
}

extension $RequestMetadataWithLinksAndTotalExtension on RequestMetadataWithLinksAndTotal {
  RequestMetadataWithLinksAndTotal copyWith({RequestLinks? links, int? total}) {
    return RequestMetadataWithLinksAndTotal(
      links: links ?? this.links,
      total: total ?? this.total,
    );
  }

  RequestMetadataWithLinksAndTotal copyWithWrapped({
    Wrapped<RequestLinks>? links,
    Wrapped<int?>? total,
  }) {
    return RequestMetadataWithLinksAndTotal(
      links: (links != null ? links.value : this.links),
      total: (total != null ? total.value : this.total),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class Parameters {
  const Parameters();

  factory Parameters.fromJson(Map<String, dynamic> json) => _$ParametersFromJson(json);

  static const toJsonFactory = _$ParametersToJson;
  Map<String, dynamic> toJson() => _$ParametersToJson(this);

  static const fromJsonFactory = _$ParametersFromJson;

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => runtimeType.hashCode;
}

@JsonSerializable(explicitToJson: true)
class AttackPlayerFaction {
  const AttackPlayerFaction({required this.id, required this.name});

  factory AttackPlayerFaction.fromJson(Map<String, dynamic> json) => _$AttackPlayerFactionFromJson(json);

  static const toJsonFactory = _$AttackPlayerFactionToJson;
  Map<String, dynamic> toJson() => _$AttackPlayerFactionToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'name')
  final String name;
  static const fromJsonFactory = _$AttackPlayerFactionFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AttackPlayerFaction &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^ const DeepCollectionEquality().hash(name) ^ runtimeType.hashCode;
}

extension $AttackPlayerFactionExtension on AttackPlayerFaction {
  AttackPlayerFaction copyWith({int? id, String? name}) {
    return AttackPlayerFaction(id: id ?? this.id, name: name ?? this.name);
  }

  AttackPlayerFaction copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<String>? name,
  }) {
    return AttackPlayerFaction(
      id: (id != null ? id.value : this.id),
      name: (name != null ? name.value : this.name),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class AttackPlayer {
  const AttackPlayer({
    required this.id,
    required this.name,
    required this.level,
    required this.faction,
  });

  factory AttackPlayer.fromJson(Map<String, dynamic> json) => _$AttackPlayerFromJson(json);

  static const toJsonFactory = _$AttackPlayerToJson;
  Map<String, dynamic> toJson() => _$AttackPlayerToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'level')
  final int level;
  @JsonKey(name: 'faction')
  final dynamic faction;
  static const fromJsonFactory = _$AttackPlayerFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AttackPlayer &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.level, level) || const DeepCollectionEquality().equals(other.level, level)) &&
            (identical(other.faction, faction) || const DeepCollectionEquality().equals(other.faction, faction)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(level) ^
      const DeepCollectionEquality().hash(faction) ^
      runtimeType.hashCode;
}

extension $AttackPlayerExtension on AttackPlayer {
  AttackPlayer copyWith({int? id, String? name, int? level, dynamic faction}) {
    return AttackPlayer(
      id: id ?? this.id,
      name: name ?? this.name,
      level: level ?? this.level,
      faction: faction ?? this.faction,
    );
  }

  AttackPlayer copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<String>? name,
    Wrapped<int>? level,
    Wrapped<dynamic>? faction,
  }) {
    return AttackPlayer(
      id: (id != null ? id.value : this.id),
      name: (name != null ? name.value : this.name),
      level: (level != null ? level.value : this.level),
      faction: (faction != null ? faction.value : this.faction),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class AttackPlayerSimplified {
  const AttackPlayerSimplified({required this.id, required this.factionId});

  factory AttackPlayerSimplified.fromJson(Map<String, dynamic> json) => _$AttackPlayerSimplifiedFromJson(json);

  static const toJsonFactory = _$AttackPlayerSimplifiedToJson;
  Map<String, dynamic> toJson() => _$AttackPlayerSimplifiedToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'faction_id')
  final dynamic factionId;
  static const fromJsonFactory = _$AttackPlayerSimplifiedFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AttackPlayerSimplified &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.factionId, factionId) ||
                const DeepCollectionEquality().equals(
                  other.factionId,
                  factionId,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^ const DeepCollectionEquality().hash(factionId) ^ runtimeType.hashCode;
}

extension $AttackPlayerSimplifiedExtension on AttackPlayerSimplified {
  AttackPlayerSimplified copyWith({int? id, dynamic factionId}) {
    return AttackPlayerSimplified(
      id: id ?? this.id,
      factionId: factionId ?? this.factionId,
    );
  }

  AttackPlayerSimplified copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<dynamic>? factionId,
  }) {
    return AttackPlayerSimplified(
      id: (id != null ? id.value : this.id),
      factionId: (factionId != null ? factionId.value : this.factionId),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class AttackingFinishingHitEffects {
  const AttackingFinishingHitEffects({
    required this.name,
    required this.$value,
  });

  factory AttackingFinishingHitEffects.fromJson(Map<String, dynamic> json) =>
      _$AttackingFinishingHitEffectsFromJson(json);

  static const toJsonFactory = _$AttackingFinishingHitEffectsToJson;
  Map<String, dynamic> toJson() => _$AttackingFinishingHitEffectsToJson(this);

  @JsonKey(
    name: 'name',
    toJson: attackFinishingHitEffectToJson,
    fromJson: attackFinishingHitEffectFromJson,
  )
  final enums.AttackFinishingHitEffect name;
  @JsonKey(name: 'value')
  final int $value;
  static const fromJsonFactory = _$AttackingFinishingHitEffectsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AttackingFinishingHitEffects &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.$value, $value) || const DeepCollectionEquality().equals(other.$value, $value)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^ const DeepCollectionEquality().hash($value) ^ runtimeType.hashCode;
}

extension $AttackingFinishingHitEffectsExtension on AttackingFinishingHitEffects {
  AttackingFinishingHitEffects copyWith({
    enums.AttackFinishingHitEffect? name,
    int? $value,
  }) {
    return AttackingFinishingHitEffects(
      name: name ?? this.name,
      $value: $value ?? this.$value,
    );
  }

  AttackingFinishingHitEffects copyWithWrapped({
    Wrapped<enums.AttackFinishingHitEffect>? name,
    Wrapped<int>? $value,
  }) {
    return AttackingFinishingHitEffects(
      name: (name != null ? name.value : this.name),
      $value: ($value != null ? $value.value : this.$value),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class Attack {
  const Attack({
    required this.id,
    required this.code,
    required this.started,
    required this.ended,
    required this.attacker,
    required this.defender,
    required this.result,
    required this.respectGain,
    required this.respectLoss,
    required this.chain,
    required this.isInterrupted,
    required this.isStealthed,
    required this.isRaid,
    required this.isRankedWar,
    required this.finishingHitEffects,
    required this.modifiers,
  });

  factory Attack.fromJson(Map<String, dynamic> json) => _$AttackFromJson(json);

  static const toJsonFactory = _$AttackToJson;
  Map<String, dynamic> toJson() => _$AttackToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'code')
  final String code;
  @JsonKey(name: 'started')
  final int started;
  @JsonKey(name: 'ended')
  final int ended;
  @JsonKey(name: 'attacker')
  final dynamic attacker;
  @JsonKey(name: 'defender')
  final AttackPlayer defender;
  @JsonKey(
    name: 'result',
    toJson: factionAttackResultToJson,
    fromJson: factionAttackResultFromJson,
  )
  final enums.FactionAttackResult result;
  @JsonKey(name: 'respect_gain')
  final double respectGain;
  @JsonKey(name: 'respect_loss')
  final double respectLoss;
  @JsonKey(name: 'chain')
  final int chain;
  @JsonKey(name: 'is_interrupted')
  final bool isInterrupted;
  @JsonKey(name: 'is_stealthed')
  final bool isStealthed;
  @JsonKey(name: 'is_raid')
  final bool isRaid;
  @JsonKey(name: 'is_ranked_war')
  final bool isRankedWar;
  @JsonKey(
    name: 'finishing_hit_effects',
    defaultValue: <AttackingFinishingHitEffects>[],
  )
  final List<AttackingFinishingHitEffects> finishingHitEffects;
  @JsonKey(name: 'modifiers')
  final Attack$Modifiers modifiers;
  static const fromJsonFactory = _$AttackFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Attack &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.code, code) || const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.started, started) ||
                const DeepCollectionEquality().equals(
                  other.started,
                  started,
                )) &&
            (identical(other.ended, ended) || const DeepCollectionEquality().equals(other.ended, ended)) &&
            (identical(other.attacker, attacker) ||
                const DeepCollectionEquality().equals(
                  other.attacker,
                  attacker,
                )) &&
            (identical(other.defender, defender) ||
                const DeepCollectionEquality().equals(
                  other.defender,
                  defender,
                )) &&
            (identical(other.result, result) || const DeepCollectionEquality().equals(other.result, result)) &&
            (identical(other.respectGain, respectGain) ||
                const DeepCollectionEquality().equals(
                  other.respectGain,
                  respectGain,
                )) &&
            (identical(other.respectLoss, respectLoss) ||
                const DeepCollectionEquality().equals(
                  other.respectLoss,
                  respectLoss,
                )) &&
            (identical(other.chain, chain) || const DeepCollectionEquality().equals(other.chain, chain)) &&
            (identical(other.isInterrupted, isInterrupted) ||
                const DeepCollectionEquality().equals(
                  other.isInterrupted,
                  isInterrupted,
                )) &&
            (identical(other.isStealthed, isStealthed) ||
                const DeepCollectionEquality().equals(
                  other.isStealthed,
                  isStealthed,
                )) &&
            (identical(other.isRaid, isRaid) || const DeepCollectionEquality().equals(other.isRaid, isRaid)) &&
            (identical(other.isRankedWar, isRankedWar) ||
                const DeepCollectionEquality().equals(
                  other.isRankedWar,
                  isRankedWar,
                )) &&
            (identical(other.finishingHitEffects, finishingHitEffects) ||
                const DeepCollectionEquality().equals(
                  other.finishingHitEffects,
                  finishingHitEffects,
                )) &&
            (identical(other.modifiers, modifiers) ||
                const DeepCollectionEquality().equals(
                  other.modifiers,
                  modifiers,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(started) ^
      const DeepCollectionEquality().hash(ended) ^
      const DeepCollectionEquality().hash(attacker) ^
      const DeepCollectionEquality().hash(defender) ^
      const DeepCollectionEquality().hash(result) ^
      const DeepCollectionEquality().hash(respectGain) ^
      const DeepCollectionEquality().hash(respectLoss) ^
      const DeepCollectionEquality().hash(chain) ^
      const DeepCollectionEquality().hash(isInterrupted) ^
      const DeepCollectionEquality().hash(isStealthed) ^
      const DeepCollectionEquality().hash(isRaid) ^
      const DeepCollectionEquality().hash(isRankedWar) ^
      const DeepCollectionEquality().hash(finishingHitEffects) ^
      const DeepCollectionEquality().hash(modifiers) ^
      runtimeType.hashCode;
}

extension $AttackExtension on Attack {
  Attack copyWith({
    int? id,
    String? code,
    int? started,
    int? ended,
    dynamic attacker,
    AttackPlayer? defender,
    enums.FactionAttackResult? result,
    double? respectGain,
    double? respectLoss,
    int? chain,
    bool? isInterrupted,
    bool? isStealthed,
    bool? isRaid,
    bool? isRankedWar,
    List<AttackingFinishingHitEffects>? finishingHitEffects,
    Attack$Modifiers? modifiers,
  }) {
    return Attack(
      id: id ?? this.id,
      code: code ?? this.code,
      started: started ?? this.started,
      ended: ended ?? this.ended,
      attacker: attacker ?? this.attacker,
      defender: defender ?? this.defender,
      result: result ?? this.result,
      respectGain: respectGain ?? this.respectGain,
      respectLoss: respectLoss ?? this.respectLoss,
      chain: chain ?? this.chain,
      isInterrupted: isInterrupted ?? this.isInterrupted,
      isStealthed: isStealthed ?? this.isStealthed,
      isRaid: isRaid ?? this.isRaid,
      isRankedWar: isRankedWar ?? this.isRankedWar,
      finishingHitEffects: finishingHitEffects ?? this.finishingHitEffects,
      modifiers: modifiers ?? this.modifiers,
    );
  }

  Attack copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<String>? code,
    Wrapped<int>? started,
    Wrapped<int>? ended,
    Wrapped<dynamic>? attacker,
    Wrapped<AttackPlayer>? defender,
    Wrapped<enums.FactionAttackResult>? result,
    Wrapped<double>? respectGain,
    Wrapped<double>? respectLoss,
    Wrapped<int>? chain,
    Wrapped<bool>? isInterrupted,
    Wrapped<bool>? isStealthed,
    Wrapped<bool>? isRaid,
    Wrapped<bool>? isRankedWar,
    Wrapped<List<AttackingFinishingHitEffects>>? finishingHitEffects,
    Wrapped<Attack$Modifiers>? modifiers,
  }) {
    return Attack(
      id: (id != null ? id.value : this.id),
      code: (code != null ? code.value : this.code),
      started: (started != null ? started.value : this.started),
      ended: (ended != null ? ended.value : this.ended),
      attacker: (attacker != null ? attacker.value : this.attacker),
      defender: (defender != null ? defender.value : this.defender),
      result: (result != null ? result.value : this.result),
      respectGain: (respectGain != null ? respectGain.value : this.respectGain),
      respectLoss: (respectLoss != null ? respectLoss.value : this.respectLoss),
      chain: (chain != null ? chain.value : this.chain),
      isInterrupted: (isInterrupted != null ? isInterrupted.value : this.isInterrupted),
      isStealthed: (isStealthed != null ? isStealthed.value : this.isStealthed),
      isRaid: (isRaid != null ? isRaid.value : this.isRaid),
      isRankedWar: (isRankedWar != null ? isRankedWar.value : this.isRankedWar),
      finishingHitEffects: (finishingHitEffects != null ? finishingHitEffects.value : this.finishingHitEffects),
      modifiers: (modifiers != null ? modifiers.value : this.modifiers),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class AttackSimplified {
  const AttackSimplified({
    required this.id,
    required this.code,
    required this.started,
    required this.ended,
    required this.attacker,
    required this.defender,
    required this.result,
    required this.respectGain,
    required this.respectLoss,
  });

  factory AttackSimplified.fromJson(Map<String, dynamic> json) => _$AttackSimplifiedFromJson(json);

  static const toJsonFactory = _$AttackSimplifiedToJson;
  Map<String, dynamic> toJson() => _$AttackSimplifiedToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'code')
  final String code;
  @JsonKey(name: 'started')
  final int started;
  @JsonKey(name: 'ended')
  final int ended;
  @JsonKey(name: 'attacker')
  final dynamic attacker;
  @JsonKey(name: 'defender')
  final AttackPlayerSimplified defender;
  @JsonKey(
    name: 'result',
    toJson: factionAttackResultToJson,
    fromJson: factionAttackResultFromJson,
  )
  final enums.FactionAttackResult result;
  @JsonKey(name: 'respect_gain')
  final double respectGain;
  @JsonKey(name: 'respect_loss')
  final double respectLoss;
  static const fromJsonFactory = _$AttackSimplifiedFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AttackSimplified &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.code, code) || const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.started, started) ||
                const DeepCollectionEquality().equals(
                  other.started,
                  started,
                )) &&
            (identical(other.ended, ended) || const DeepCollectionEquality().equals(other.ended, ended)) &&
            (identical(other.attacker, attacker) ||
                const DeepCollectionEquality().equals(
                  other.attacker,
                  attacker,
                )) &&
            (identical(other.defender, defender) ||
                const DeepCollectionEquality().equals(
                  other.defender,
                  defender,
                )) &&
            (identical(other.result, result) || const DeepCollectionEquality().equals(other.result, result)) &&
            (identical(other.respectGain, respectGain) ||
                const DeepCollectionEquality().equals(
                  other.respectGain,
                  respectGain,
                )) &&
            (identical(other.respectLoss, respectLoss) ||
                const DeepCollectionEquality().equals(
                  other.respectLoss,
                  respectLoss,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(started) ^
      const DeepCollectionEquality().hash(ended) ^
      const DeepCollectionEquality().hash(attacker) ^
      const DeepCollectionEquality().hash(defender) ^
      const DeepCollectionEquality().hash(result) ^
      const DeepCollectionEquality().hash(respectGain) ^
      const DeepCollectionEquality().hash(respectLoss) ^
      runtimeType.hashCode;
}

extension $AttackSimplifiedExtension on AttackSimplified {
  AttackSimplified copyWith({
    int? id,
    String? code,
    int? started,
    int? ended,
    dynamic attacker,
    AttackPlayerSimplified? defender,
    enums.FactionAttackResult? result,
    double? respectGain,
    double? respectLoss,
  }) {
    return AttackSimplified(
      id: id ?? this.id,
      code: code ?? this.code,
      started: started ?? this.started,
      ended: ended ?? this.ended,
      attacker: attacker ?? this.attacker,
      defender: defender ?? this.defender,
      result: result ?? this.result,
      respectGain: respectGain ?? this.respectGain,
      respectLoss: respectLoss ?? this.respectLoss,
    );
  }

  AttackSimplified copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<String>? code,
    Wrapped<int>? started,
    Wrapped<int>? ended,
    Wrapped<dynamic>? attacker,
    Wrapped<AttackPlayerSimplified>? defender,
    Wrapped<enums.FactionAttackResult>? result,
    Wrapped<double>? respectGain,
    Wrapped<double>? respectLoss,
  }) {
    return AttackSimplified(
      id: (id != null ? id.value : this.id),
      code: (code != null ? code.value : this.code),
      started: (started != null ? started.value : this.started),
      ended: (ended != null ? ended.value : this.ended),
      attacker: (attacker != null ? attacker.value : this.attacker),
      defender: (defender != null ? defender.value : this.defender),
      result: (result != null ? result.value : this.result),
      respectGain: (respectGain != null ? respectGain.value : this.respectGain),
      respectLoss: (respectLoss != null ? respectLoss.value : this.respectLoss),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ReviveSimplified {
  const ReviveSimplified({
    required this.id,
    required this.reviver,
    required this.target,
    required this.successChance,
    required this.result,
    required this.timestamp,
  });

  factory ReviveSimplified.fromJson(Map<String, dynamic> json) => _$ReviveSimplifiedFromJson(json);

  static const toJsonFactory = _$ReviveSimplifiedToJson;
  Map<String, dynamic> toJson() => _$ReviveSimplifiedToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'reviver')
  final ReviveSimplified$Reviver reviver;
  @JsonKey(name: 'target')
  final ReviveSimplified$Target target;
  @JsonKey(name: 'success_chance')
  final double successChance;
  @JsonKey(name: 'result')
  final String result;
  @JsonKey(name: 'timestamp')
  final int timestamp;
  static const fromJsonFactory = _$ReviveSimplifiedFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ReviveSimplified &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.reviver, reviver) ||
                const DeepCollectionEquality().equals(
                  other.reviver,
                  reviver,
                )) &&
            (identical(other.target, target) || const DeepCollectionEquality().equals(other.target, target)) &&
            (identical(other.successChance, successChance) ||
                const DeepCollectionEquality().equals(
                  other.successChance,
                  successChance,
                )) &&
            (identical(other.result, result) || const DeepCollectionEquality().equals(other.result, result)) &&
            (identical(other.timestamp, timestamp) ||
                const DeepCollectionEquality().equals(
                  other.timestamp,
                  timestamp,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(reviver) ^
      const DeepCollectionEquality().hash(target) ^
      const DeepCollectionEquality().hash(successChance) ^
      const DeepCollectionEquality().hash(result) ^
      const DeepCollectionEquality().hash(timestamp) ^
      runtimeType.hashCode;
}

extension $ReviveSimplifiedExtension on ReviveSimplified {
  ReviveSimplified copyWith({
    int? id,
    ReviveSimplified$Reviver? reviver,
    ReviveSimplified$Target? target,
    double? successChance,
    String? result,
    int? timestamp,
  }) {
    return ReviveSimplified(
      id: id ?? this.id,
      reviver: reviver ?? this.reviver,
      target: target ?? this.target,
      successChance: successChance ?? this.successChance,
      result: result ?? this.result,
      timestamp: timestamp ?? this.timestamp,
    );
  }

  ReviveSimplified copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<ReviveSimplified$Reviver>? reviver,
    Wrapped<ReviveSimplified$Target>? target,
    Wrapped<double>? successChance,
    Wrapped<String>? result,
    Wrapped<int>? timestamp,
  }) {
    return ReviveSimplified(
      id: (id != null ? id.value : this.id),
      reviver: (reviver != null ? reviver.value : this.reviver),
      target: (target != null ? target.value : this.target),
      successChance: (successChance != null ? successChance.value : this.successChance),
      result: (result != null ? result.value : this.result),
      timestamp: (timestamp != null ? timestamp.value : this.timestamp),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class Revive {
  const Revive({
    required this.id,
    required this.reviver,
    required this.target,
    required this.successChance,
    required this.result,
    required this.timestamp,
  });

  factory Revive.fromJson(Map<String, dynamic> json) => _$ReviveFromJson(json);

  static const toJsonFactory = _$ReviveToJson;
  Map<String, dynamic> toJson() => _$ReviveToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'reviver')
  final Revive$Reviver reviver;
  @JsonKey(name: 'target')
  final Revive$Target target;
  @JsonKey(name: 'success_chance')
  final double successChance;
  @JsonKey(name: 'result')
  final String result;
  @JsonKey(name: 'timestamp')
  final int timestamp;
  static const fromJsonFactory = _$ReviveFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Revive &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.reviver, reviver) ||
                const DeepCollectionEquality().equals(
                  other.reviver,
                  reviver,
                )) &&
            (identical(other.target, target) || const DeepCollectionEquality().equals(other.target, target)) &&
            (identical(other.successChance, successChance) ||
                const DeepCollectionEquality().equals(
                  other.successChance,
                  successChance,
                )) &&
            (identical(other.result, result) || const DeepCollectionEquality().equals(other.result, result)) &&
            (identical(other.timestamp, timestamp) ||
                const DeepCollectionEquality().equals(
                  other.timestamp,
                  timestamp,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(reviver) ^
      const DeepCollectionEquality().hash(target) ^
      const DeepCollectionEquality().hash(successChance) ^
      const DeepCollectionEquality().hash(result) ^
      const DeepCollectionEquality().hash(timestamp) ^
      runtimeType.hashCode;
}

extension $ReviveExtension on Revive {
  Revive copyWith({
    int? id,
    Revive$Reviver? reviver,
    Revive$Target? target,
    double? successChance,
    String? result,
    int? timestamp,
  }) {
    return Revive(
      id: id ?? this.id,
      reviver: reviver ?? this.reviver,
      target: target ?? this.target,
      successChance: successChance ?? this.successChance,
      result: result ?? this.result,
      timestamp: timestamp ?? this.timestamp,
    );
  }

  Revive copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<Revive$Reviver>? reviver,
    Wrapped<Revive$Target>? target,
    Wrapped<double>? successChance,
    Wrapped<String>? result,
    Wrapped<int>? timestamp,
  }) {
    return Revive(
      id: (id != null ? id.value : this.id),
      reviver: (reviver != null ? reviver.value : this.reviver),
      target: (target != null ? target.value : this.target),
      successChance: (successChance != null ? successChance.value : this.successChance),
      result: (result != null ? result.value : this.result),
      timestamp: (timestamp != null ? timestamp.value : this.timestamp),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class RevivesResponse {
  const RevivesResponse({required this.revives, required this.metadata});

  factory RevivesResponse.fromJson(Map<String, dynamic> json) => _$RevivesResponseFromJson(json);

  static const toJsonFactory = _$RevivesResponseToJson;
  Map<String, dynamic> toJson() => _$RevivesResponseToJson(this);

  @JsonKey(name: 'revives', defaultValue: <Revive>[])
  final List<Revive> revives;
  @JsonKey(name: '_metadata')
  final RequestMetadataWithLinks metadata;
  static const fromJsonFactory = _$RevivesResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RevivesResponse &&
            (identical(other.revives, revives) ||
                const DeepCollectionEquality().equals(
                  other.revives,
                  revives,
                )) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality().equals(
                  other.metadata,
                  metadata,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(revives) ^
      const DeepCollectionEquality().hash(metadata) ^
      runtimeType.hashCode;
}

extension $RevivesResponseExtension on RevivesResponse {
  RevivesResponse copyWith({
    List<Revive>? revives,
    RequestMetadataWithLinks? metadata,
  }) {
    return RevivesResponse(
      revives: revives ?? this.revives,
      metadata: metadata ?? this.metadata,
    );
  }

  RevivesResponse copyWithWrapped({
    Wrapped<List<Revive>>? revives,
    Wrapped<RequestMetadataWithLinks>? metadata,
  }) {
    return RevivesResponse(
      revives: (revives != null ? revives.value : this.revives),
      metadata: (metadata != null ? metadata.value : this.metadata),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class RevivesFullResponse {
  const RevivesFullResponse({required this.revives, required this.metadata});

  factory RevivesFullResponse.fromJson(Map<String, dynamic> json) => _$RevivesFullResponseFromJson(json);

  static const toJsonFactory = _$RevivesFullResponseToJson;
  Map<String, dynamic> toJson() => _$RevivesFullResponseToJson(this);

  @JsonKey(name: 'revives', defaultValue: <ReviveSimplified>[])
  final List<ReviveSimplified> revives;
  @JsonKey(name: '_metadata')
  final RequestMetadataWithLinks metadata;
  static const fromJsonFactory = _$RevivesFullResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RevivesFullResponse &&
            (identical(other.revives, revives) ||
                const DeepCollectionEquality().equals(
                  other.revives,
                  revives,
                )) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality().equals(
                  other.metadata,
                  metadata,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(revives) ^
      const DeepCollectionEquality().hash(metadata) ^
      runtimeType.hashCode;
}

extension $RevivesFullResponseExtension on RevivesFullResponse {
  RevivesFullResponse copyWith({
    List<ReviveSimplified>? revives,
    RequestMetadataWithLinks? metadata,
  }) {
    return RevivesFullResponse(
      revives: revives ?? this.revives,
      metadata: metadata ?? this.metadata,
    );
  }

  RevivesFullResponse copyWithWrapped({
    Wrapped<List<ReviveSimplified>>? revives,
    Wrapped<RequestMetadataWithLinks>? metadata,
  }) {
    return RevivesFullResponse(
      revives: (revives != null ? revives.value : this.revives),
      metadata: (metadata != null ? metadata.value : this.metadata),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TimestampResponse {
  const TimestampResponse({required this.timestamp});

  factory TimestampResponse.fromJson(Map<String, dynamic> json) => _$TimestampResponseFromJson(json);

  static const toJsonFactory = _$TimestampResponseToJson;
  Map<String, dynamic> toJson() => _$TimestampResponseToJson(this);

  @JsonKey(name: 'timestamp')
  final int timestamp;
  static const fromJsonFactory = _$TimestampResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TimestampResponse &&
            (identical(other.timestamp, timestamp) ||
                const DeepCollectionEquality().equals(
                  other.timestamp,
                  timestamp,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(timestamp) ^ runtimeType.hashCode;
}

extension $TimestampResponseExtension on TimestampResponse {
  TimestampResponse copyWith({int? timestamp}) {
    return TimestampResponse(timestamp: timestamp ?? this.timestamp);
  }

  TimestampResponse copyWithWrapped({Wrapped<int>? timestamp}) {
    return TimestampResponse(
      timestamp: (timestamp != null ? timestamp.value : this.timestamp),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ReportBase {
  const ReportBase({
    required this.type,
    required this.targetId,
    required this.reporterId,
    required this.factionId,
    required this.timestamp,
  });

  factory ReportBase.fromJson(Map<String, dynamic> json) => _$ReportBaseFromJson(json);

  static const toJsonFactory = _$ReportBaseToJson;
  Map<String, dynamic> toJson() => _$ReportBaseToJson(this);

  @JsonKey(
    name: 'type',
    toJson: reportTypeEnumToJson,
    fromJson: reportTypeEnumFromJson,
  )
  final enums.ReportTypeEnum type;
  @JsonKey(name: 'target_id')
  final dynamic targetId;
  @JsonKey(name: 'reporter_id')
  final int reporterId;
  @JsonKey(name: 'faction_id')
  final dynamic factionId;
  @JsonKey(name: 'timestamp')
  final int timestamp;
  static const fromJsonFactory = _$ReportBaseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ReportBase &&
            (identical(other.type, type) || const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.targetId, targetId) ||
                const DeepCollectionEquality().equals(
                  other.targetId,
                  targetId,
                )) &&
            (identical(other.reporterId, reporterId) ||
                const DeepCollectionEquality().equals(
                  other.reporterId,
                  reporterId,
                )) &&
            (identical(other.factionId, factionId) ||
                const DeepCollectionEquality().equals(
                  other.factionId,
                  factionId,
                )) &&
            (identical(other.timestamp, timestamp) ||
                const DeepCollectionEquality().equals(
                  other.timestamp,
                  timestamp,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(targetId) ^
      const DeepCollectionEquality().hash(reporterId) ^
      const DeepCollectionEquality().hash(factionId) ^
      const DeepCollectionEquality().hash(timestamp) ^
      runtimeType.hashCode;
}

extension $ReportBaseExtension on ReportBase {
  ReportBase copyWith({
    enums.ReportTypeEnum? type,
    dynamic targetId,
    int? reporterId,
    dynamic factionId,
    int? timestamp,
  }) {
    return ReportBase(
      type: type ?? this.type,
      targetId: targetId ?? this.targetId,
      reporterId: reporterId ?? this.reporterId,
      factionId: factionId ?? this.factionId,
      timestamp: timestamp ?? this.timestamp,
    );
  }

  ReportBase copyWithWrapped({
    Wrapped<enums.ReportTypeEnum>? type,
    Wrapped<dynamic>? targetId,
    Wrapped<int>? reporterId,
    Wrapped<dynamic>? factionId,
    Wrapped<int>? timestamp,
  }) {
    return ReportBase(
      type: (type != null ? type.value : this.type),
      targetId: (targetId != null ? targetId.value : this.targetId),
      reporterId: (reporterId != null ? reporterId.value : this.reporterId),
      factionId: (factionId != null ? factionId.value : this.factionId),
      timestamp: (timestamp != null ? timestamp.value : this.timestamp),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ReportWarrantDetails {
  const ReportWarrantDetails({
    required this.id,
    required this.name,
    required this.warrant,
  });

  factory ReportWarrantDetails.fromJson(Map<String, dynamic> json) => _$ReportWarrantDetailsFromJson(json);

  static const toJsonFactory = _$ReportWarrantDetailsToJson;
  Map<String, dynamic> toJson() => _$ReportWarrantDetailsToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'warrant')
  final int warrant;
  static const fromJsonFactory = _$ReportWarrantDetailsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ReportWarrantDetails &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.warrant, warrant) || const DeepCollectionEquality().equals(other.warrant, warrant)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(warrant) ^
      runtimeType.hashCode;
}

extension $ReportWarrantDetailsExtension on ReportWarrantDetails {
  ReportWarrantDetails copyWith({int? id, String? name, int? warrant}) {
    return ReportWarrantDetails(
      id: id ?? this.id,
      name: name ?? this.name,
      warrant: warrant ?? this.warrant,
    );
  }

  ReportWarrantDetails copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<String>? name,
    Wrapped<int>? warrant,
  }) {
    return ReportWarrantDetails(
      id: (id != null ? id.value : this.id),
      name: (name != null ? name.value : this.name),
      warrant: (warrant != null ? warrant.value : this.warrant),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ReportMostWanted {
  const ReportMostWanted({required this.top, required this.notable});

  factory ReportMostWanted.fromJson(Map<String, dynamic> json) => _$ReportMostWantedFromJson(json);

  static const toJsonFactory = _$ReportMostWantedToJson;
  Map<String, dynamic> toJson() => _$ReportMostWantedToJson(this);

  @JsonKey(name: 'top', defaultValue: <ReportWarrantDetails>[])
  final List<ReportWarrantDetails> top;
  @JsonKey(name: 'notable', defaultValue: <ReportWarrantDetails>[])
  final List<ReportWarrantDetails> notable;
  static const fromJsonFactory = _$ReportMostWantedFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ReportMostWanted &&
            (identical(other.top, top) || const DeepCollectionEquality().equals(other.top, top)) &&
            (identical(other.notable, notable) || const DeepCollectionEquality().equals(other.notable, notable)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(top) ^ const DeepCollectionEquality().hash(notable) ^ runtimeType.hashCode;
}

extension $ReportMostWantedExtension on ReportMostWanted {
  ReportMostWanted copyWith({
    List<ReportWarrantDetails>? top,
    List<ReportWarrantDetails>? notable,
  }) {
    return ReportMostWanted(
      top: top ?? this.top,
      notable: notable ?? this.notable,
    );
  }

  ReportMostWanted copyWithWrapped({
    Wrapped<List<ReportWarrantDetails>>? top,
    Wrapped<List<ReportWarrantDetails>>? notable,
  }) {
    return ReportMostWanted(
      top: (top != null ? top.value : this.top),
      notable: (notable != null ? notable.value : this.notable),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ReportMoney {
  const ReportMoney({required this.money});

  factory ReportMoney.fromJson(Map<String, dynamic> json) => _$ReportMoneyFromJson(json);

  static const toJsonFactory = _$ReportMoneyToJson;
  Map<String, dynamic> toJson() => _$ReportMoneyToJson(this);

  @JsonKey(name: 'money')
  final int money;
  static const fromJsonFactory = _$ReportMoneyFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ReportMoney &&
            (identical(other.money, money) || const DeepCollectionEquality().equals(other.money, money)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(money) ^ runtimeType.hashCode;
}

extension $ReportMoneyExtension on ReportMoney {
  ReportMoney copyWith({int? money}) {
    return ReportMoney(money: money ?? this.money);
  }

  ReportMoney copyWithWrapped({Wrapped<int>? money}) {
    return ReportMoney(money: (money != null ? money.value : this.money));
  }
}

@JsonSerializable(explicitToJson: true)
class ReportInvestment {
  const ReportInvestment({required this.amount, required this.until});

  factory ReportInvestment.fromJson(Map<String, dynamic> json) => _$ReportInvestmentFromJson(json);

  static const toJsonFactory = _$ReportInvestmentToJson;
  Map<String, dynamic> toJson() => _$ReportInvestmentToJson(this);

  @JsonKey(name: 'amount')
  final int amount;
  @JsonKey(name: 'until')
  final int until;
  static const fromJsonFactory = _$ReportInvestmentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ReportInvestment &&
            (identical(other.amount, amount) || const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.until, until) || const DeepCollectionEquality().equals(other.until, until)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(amount) ^ const DeepCollectionEquality().hash(until) ^ runtimeType.hashCode;
}

extension $ReportInvestmentExtension on ReportInvestment {
  ReportInvestment copyWith({int? amount, int? until}) {
    return ReportInvestment(
      amount: amount ?? this.amount,
      until: until ?? this.until,
    );
  }

  ReportInvestment copyWithWrapped({
    Wrapped<int>? amount,
    Wrapped<int>? until,
  }) {
    return ReportInvestment(
      amount: (amount != null ? amount.value : this.amount),
      until: (until != null ? until.value : this.until),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ReportTrueLevel {
  const ReportTrueLevel({required this.level});

  factory ReportTrueLevel.fromJson(Map<String, dynamic> json) => _$ReportTrueLevelFromJson(json);

  static const toJsonFactory = _$ReportTrueLevelToJson;
  Map<String, dynamic> toJson() => _$ReportTrueLevelToJson(this);

  @JsonKey(name: 'level')
  final int level;
  static const fromJsonFactory = _$ReportTrueLevelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ReportTrueLevel &&
            (identical(other.level, level) || const DeepCollectionEquality().equals(other.level, level)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(level) ^ runtimeType.hashCode;
}

extension $ReportTrueLevelExtension on ReportTrueLevel {
  ReportTrueLevel copyWith({int? level}) {
    return ReportTrueLevel(level: level ?? this.level);
  }

  ReportTrueLevel copyWithWrapped({Wrapped<int>? level}) {
    return ReportTrueLevel(level: (level != null ? level.value : this.level));
  }
}

@JsonSerializable(explicitToJson: true)
class ReportStats {
  const ReportStats({
    required this.strength,
    required this.speed,
    required this.dexterity,
    required this.defense,
    required this.total,
  });

  factory ReportStats.fromJson(Map<String, dynamic> json) => _$ReportStatsFromJson(json);

  static const toJsonFactory = _$ReportStatsToJson;
  Map<String, dynamic> toJson() => _$ReportStatsToJson(this);

  @JsonKey(name: 'strength')
  final dynamic strength;
  @JsonKey(name: 'speed')
  final dynamic speed;
  @JsonKey(name: 'dexterity')
  final dynamic dexterity;
  @JsonKey(name: 'defense')
  final dynamic defense;
  @JsonKey(name: 'total')
  final dynamic total;
  static const fromJsonFactory = _$ReportStatsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ReportStats &&
            (identical(other.strength, strength) ||
                const DeepCollectionEquality().equals(
                  other.strength,
                  strength,
                )) &&
            (identical(other.speed, speed) || const DeepCollectionEquality().equals(other.speed, speed)) &&
            (identical(other.dexterity, dexterity) ||
                const DeepCollectionEquality().equals(
                  other.dexterity,
                  dexterity,
                )) &&
            (identical(other.defense, defense) ||
                const DeepCollectionEquality().equals(
                  other.defense,
                  defense,
                )) &&
            (identical(other.total, total) || const DeepCollectionEquality().equals(other.total, total)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(strength) ^
      const DeepCollectionEquality().hash(speed) ^
      const DeepCollectionEquality().hash(dexterity) ^
      const DeepCollectionEquality().hash(defense) ^
      const DeepCollectionEquality().hash(total) ^
      runtimeType.hashCode;
}

extension $ReportStatsExtension on ReportStats {
  ReportStats copyWith({
    dynamic strength,
    dynamic speed,
    dynamic dexterity,
    dynamic defense,
    dynamic total,
  }) {
    return ReportStats(
      strength: strength ?? this.strength,
      speed: speed ?? this.speed,
      dexterity: dexterity ?? this.dexterity,
      defense: defense ?? this.defense,
      total: total ?? this.total,
    );
  }

  ReportStats copyWithWrapped({
    Wrapped<dynamic>? strength,
    Wrapped<dynamic>? speed,
    Wrapped<dynamic>? dexterity,
    Wrapped<dynamic>? defense,
    Wrapped<dynamic>? total,
  }) {
    return ReportStats(
      strength: (strength != null ? strength.value : this.strength),
      speed: (speed != null ? speed.value : this.speed),
      dexterity: (dexterity != null ? dexterity.value : this.dexterity),
      defense: (defense != null ? defense.value : this.defense),
      total: (total != null ? total.value : this.total),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ReportHistoryFaction {
  const ReportHistoryFaction({
    required this.id,
    required this.name,
    required this.joined,
    required this.left,
  });

  factory ReportHistoryFaction.fromJson(Map<String, dynamic> json) => _$ReportHistoryFactionFromJson(json);

  static const toJsonFactory = _$ReportHistoryFactionToJson;
  Map<String, dynamic> toJson() => _$ReportHistoryFactionToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'joined', toJson: _dateToJson)
  final DateTime joined;
  @JsonKey(name: 'left')
  final dynamic left;
  static const fromJsonFactory = _$ReportHistoryFactionFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ReportHistoryFaction &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.joined, joined) || const DeepCollectionEquality().equals(other.joined, joined)) &&
            (identical(other.left, left) || const DeepCollectionEquality().equals(other.left, left)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(joined) ^
      const DeepCollectionEquality().hash(left) ^
      runtimeType.hashCode;
}

extension $ReportHistoryFactionExtension on ReportHistoryFaction {
  ReportHistoryFaction copyWith({
    int? id,
    String? name,
    DateTime? joined,
    dynamic left,
  }) {
    return ReportHistoryFaction(
      id: id ?? this.id,
      name: name ?? this.name,
      joined: joined ?? this.joined,
      left: left ?? this.left,
    );
  }

  ReportHistoryFaction copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<String>? name,
    Wrapped<DateTime>? joined,
    Wrapped<dynamic>? left,
  }) {
    return ReportHistoryFaction(
      id: (id != null ? id.value : this.id),
      name: (name != null ? name.value : this.name),
      joined: (joined != null ? joined.value : this.joined),
      left: (left != null ? left.value : this.left),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ReportHistoryCompany {
  const ReportHistoryCompany({
    required this.id,
    required this.name,
    required this.joined,
    required this.left,
  });

  factory ReportHistoryCompany.fromJson(Map<String, dynamic> json) => _$ReportHistoryCompanyFromJson(json);

  static const toJsonFactory = _$ReportHistoryCompanyToJson;
  Map<String, dynamic> toJson() => _$ReportHistoryCompanyToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'joined', toJson: _dateToJson)
  final DateTime joined;
  @JsonKey(name: 'left')
  final dynamic left;
  static const fromJsonFactory = _$ReportHistoryCompanyFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ReportHistoryCompany &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.joined, joined) || const DeepCollectionEquality().equals(other.joined, joined)) &&
            (identical(other.left, left) || const DeepCollectionEquality().equals(other.left, left)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(joined) ^
      const DeepCollectionEquality().hash(left) ^
      runtimeType.hashCode;
}

extension $ReportHistoryCompanyExtension on ReportHistoryCompany {
  ReportHistoryCompany copyWith({
    int? id,
    String? name,
    DateTime? joined,
    dynamic left,
  }) {
    return ReportHistoryCompany(
      id: id ?? this.id,
      name: name ?? this.name,
      joined: joined ?? this.joined,
      left: left ?? this.left,
    );
  }

  ReportHistoryCompany copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<String>? name,
    Wrapped<DateTime>? joined,
    Wrapped<dynamic>? left,
  }) {
    return ReportHistoryCompany(
      id: (id != null ? id.value : this.id),
      name: (name != null ? name.value : this.name),
      joined: (joined != null ? joined.value : this.joined),
      left: (left != null ? left.value : this.left),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ReportHistory {
  const ReportHistory({required this.factions, required this.companies});

  factory ReportHistory.fromJson(Map<String, dynamic> json) => _$ReportHistoryFromJson(json);

  static const toJsonFactory = _$ReportHistoryToJson;
  Map<String, dynamic> toJson() => _$ReportHistoryToJson(this);

  @JsonKey(name: 'factions', defaultValue: <ReportHistoryFaction>[])
  final List<ReportHistoryFaction> factions;
  @JsonKey(name: 'companies', defaultValue: <ReportHistoryCompany>[])
  final List<ReportHistoryCompany> companies;
  static const fromJsonFactory = _$ReportHistoryFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ReportHistory &&
            (identical(other.factions, factions) ||
                const DeepCollectionEquality().equals(
                  other.factions,
                  factions,
                )) &&
            (identical(other.companies, companies) ||
                const DeepCollectionEquality().equals(
                  other.companies,
                  companies,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(factions) ^
      const DeepCollectionEquality().hash(companies) ^
      runtimeType.hashCode;
}

extension $ReportHistoryExtension on ReportHistory {
  ReportHistory copyWith({
    List<ReportHistoryFaction>? factions,
    List<ReportHistoryCompany>? companies,
  }) {
    return ReportHistory(
      factions: factions ?? this.factions,
      companies: companies ?? this.companies,
    );
  }

  ReportHistory copyWithWrapped({
    Wrapped<List<ReportHistoryFaction>>? factions,
    Wrapped<List<ReportHistoryCompany>>? companies,
  }) {
    return ReportHistory(
      factions: (factions != null ? factions.value : this.factions),
      companies: (companies != null ? companies.value : this.companies),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ReportFriendOrFoeUser {
  const ReportFriendOrFoeUser({required this.id, required this.name});

  factory ReportFriendOrFoeUser.fromJson(Map<String, dynamic> json) => _$ReportFriendOrFoeUserFromJson(json);

  static const toJsonFactory = _$ReportFriendOrFoeUserToJson;
  Map<String, dynamic> toJson() => _$ReportFriendOrFoeUserToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'name')
  final String name;
  static const fromJsonFactory = _$ReportFriendOrFoeUserFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ReportFriendOrFoeUser &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^ const DeepCollectionEquality().hash(name) ^ runtimeType.hashCode;
}

extension $ReportFriendOrFoeUserExtension on ReportFriendOrFoeUser {
  ReportFriendOrFoeUser copyWith({int? id, String? name}) {
    return ReportFriendOrFoeUser(id: id ?? this.id, name: name ?? this.name);
  }

  ReportFriendOrFoeUser copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<String>? name,
  }) {
    return ReportFriendOrFoeUser(
      id: (id != null ? id.value : this.id),
      name: (name != null ? name.value : this.name),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ReportFriendOrFoe {
  const ReportFriendOrFoe({required this.friends, required this.enemies});

  factory ReportFriendOrFoe.fromJson(Map<String, dynamic> json) => _$ReportFriendOrFoeFromJson(json);

  static const toJsonFactory = _$ReportFriendOrFoeToJson;
  Map<String, dynamic> toJson() => _$ReportFriendOrFoeToJson(this);

  @JsonKey(name: 'friends', defaultValue: <ReportFriendOrFoeUser>[])
  final List<ReportFriendOrFoeUser> friends;
  @JsonKey(name: 'enemies', defaultValue: <ReportFriendOrFoeUser>[])
  final List<ReportFriendOrFoeUser> enemies;
  static const fromJsonFactory = _$ReportFriendOrFoeFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ReportFriendOrFoe &&
            (identical(other.friends, friends) ||
                const DeepCollectionEquality().equals(
                  other.friends,
                  friends,
                )) &&
            (identical(other.enemies, enemies) || const DeepCollectionEquality().equals(other.enemies, enemies)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(friends) ^
      const DeepCollectionEquality().hash(enemies) ^
      runtimeType.hashCode;
}

extension $ReportFriendOrFoeExtension on ReportFriendOrFoe {
  ReportFriendOrFoe copyWith({
    List<ReportFriendOrFoeUser>? friends,
    List<ReportFriendOrFoeUser>? enemies,
  }) {
    return ReportFriendOrFoe(
      friends: friends ?? this.friends,
      enemies: enemies ?? this.enemies,
    );
  }

  ReportFriendOrFoe copyWithWrapped({
    Wrapped<List<ReportFriendOrFoeUser>>? friends,
    Wrapped<List<ReportFriendOrFoeUser>>? enemies,
  }) {
    return ReportFriendOrFoe(
      friends: (friends != null ? friends.value : this.friends),
      enemies: (enemies != null ? enemies.value : this.enemies),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ReportCompanyFinancials {
  const ReportCompanyFinancials({
    required this.balance,
    required this.employees,
    required this.wages,
  });

  factory ReportCompanyFinancials.fromJson(Map<String, dynamic> json) => _$ReportCompanyFinancialsFromJson(json);

  static const toJsonFactory = _$ReportCompanyFinancialsToJson;
  Map<String, dynamic> toJson() => _$ReportCompanyFinancialsToJson(this);

  @JsonKey(name: 'balance')
  final int balance;
  @JsonKey(name: 'employees')
  final int employees;
  @JsonKey(name: 'wages')
  final ReportCompanyFinancials$Wages wages;
  static const fromJsonFactory = _$ReportCompanyFinancialsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ReportCompanyFinancials &&
            (identical(other.balance, balance) ||
                const DeepCollectionEquality().equals(
                  other.balance,
                  balance,
                )) &&
            (identical(other.employees, employees) ||
                const DeepCollectionEquality().equals(
                  other.employees,
                  employees,
                )) &&
            (identical(other.wages, wages) || const DeepCollectionEquality().equals(other.wages, wages)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(balance) ^
      const DeepCollectionEquality().hash(employees) ^
      const DeepCollectionEquality().hash(wages) ^
      runtimeType.hashCode;
}

extension $ReportCompanyFinancialsExtension on ReportCompanyFinancials {
  ReportCompanyFinancials copyWith({
    int? balance,
    int? employees,
    ReportCompanyFinancials$Wages? wages,
  }) {
    return ReportCompanyFinancials(
      balance: balance ?? this.balance,
      employees: employees ?? this.employees,
      wages: wages ?? this.wages,
    );
  }

  ReportCompanyFinancials copyWithWrapped({
    Wrapped<int>? balance,
    Wrapped<int>? employees,
    Wrapped<ReportCompanyFinancials$Wages>? wages,
  }) {
    return ReportCompanyFinancials(
      balance: (balance != null ? balance.value : this.balance),
      employees: (employees != null ? employees.value : this.employees),
      wages: (wages != null ? wages.value : this.wages),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ReportStockAnalysis {
  const ReportStockAnalysis({required this.items});

  factory ReportStockAnalysis.fromJson(Map<String, dynamic> json) => _$ReportStockAnalysisFromJson(json);

  static const toJsonFactory = _$ReportStockAnalysisToJson;
  Map<String, dynamic> toJson() => _$ReportStockAnalysisToJson(this);

  @JsonKey(name: 'items')
  final List<ReportStockAnalysis$Items$Item> items;
  static const fromJsonFactory = _$ReportStockAnalysisFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ReportStockAnalysis &&
            (identical(other.items, items) || const DeepCollectionEquality().equals(other.items, items)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(items) ^ runtimeType.hashCode;
}

extension $ReportStockAnalysisExtension on ReportStockAnalysis {
  ReportStockAnalysis copyWith({List<ReportStockAnalysis$Items$Item>? items}) {
    return ReportStockAnalysis(items: items ?? this.items);
  }

  ReportStockAnalysis copyWithWrapped({
    Wrapped<List<ReportStockAnalysis$Items$Item>>? items,
  }) {
    return ReportStockAnalysis(
      items: (items != null ? items.value : this.items),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ReportAnonymousBounties {
  const ReportAnonymousBounties({required this.bounties});

  factory ReportAnonymousBounties.fromJson(Map<String, dynamic> json) => _$ReportAnonymousBountiesFromJson(json);

  static const toJsonFactory = _$ReportAnonymousBountiesToJson;
  Map<String, dynamic> toJson() => _$ReportAnonymousBountiesToJson(this);

  @JsonKey(name: 'bounties')
  final List<ReportAnonymousBounties$Bounties$Item> bounties;
  static const fromJsonFactory = _$ReportAnonymousBountiesFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ReportAnonymousBounties &&
            (identical(other.bounties, bounties) ||
                const DeepCollectionEquality().equals(
                  other.bounties,
                  bounties,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(bounties) ^ runtimeType.hashCode;
}

extension $ReportAnonymousBountiesExtension on ReportAnonymousBounties {
  ReportAnonymousBounties copyWith({
    List<ReportAnonymousBounties$Bounties$Item>? bounties,
  }) {
    return ReportAnonymousBounties(bounties: bounties ?? this.bounties);
  }

  ReportAnonymousBounties copyWithWrapped({
    Wrapped<List<ReportAnonymousBounties$Bounties$Item>>? bounties,
  }) {
    return ReportAnonymousBounties(
      bounties: (bounties != null ? bounties.value : this.bounties),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ReportReport {
  const ReportReport({required this.report});

  factory ReportReport.fromJson(Map<String, dynamic> json) => _$ReportReportFromJson(json);

  static const toJsonFactory = _$ReportReportToJson;
  Map<String, dynamic> toJson() => _$ReportReportToJson(this);

  @JsonKey(name: 'report')
  final dynamic report;
  static const fromJsonFactory = _$ReportReportFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ReportReport &&
            (identical(other.report, report) || const DeepCollectionEquality().equals(other.report, report)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(report) ^ runtimeType.hashCode;
}

extension $ReportReportExtension on ReportReport {
  ReportReport copyWith({dynamic report}) {
    return ReportReport(report: report ?? this.report);
  }

  ReportReport copyWithWrapped({Wrapped<dynamic>? report}) {
    return ReportReport(report: (report != null ? report.value : this.report));
  }
}

@JsonSerializable(explicitToJson: true)
class Report {
  const Report({
    required this.type,
    required this.targetId,
    required this.reporterId,
    required this.factionId,
    required this.timestamp,
    required this.report,
  });

  factory Report.fromJson(Map<String, dynamic> json) => _$ReportFromJson(json);

  static const toJsonFactory = _$ReportToJson;
  Map<String, dynamic> toJson() => _$ReportToJson(this);

  @JsonKey(
    name: 'type',
    toJson: reportTypeEnumToJson,
    fromJson: reportTypeEnumFromJson,
  )
  final enums.ReportTypeEnum type;
  @JsonKey(name: 'target_id')
  final dynamic targetId;
  @JsonKey(name: 'reporter_id')
  final int reporterId;
  @JsonKey(name: 'faction_id')
  final dynamic factionId;
  @JsonKey(name: 'timestamp')
  final int timestamp;
  @JsonKey(name: 'report')
  final dynamic report;
  static const fromJsonFactory = _$ReportFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Report &&
            (identical(other.type, type) || const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.targetId, targetId) ||
                const DeepCollectionEquality().equals(
                  other.targetId,
                  targetId,
                )) &&
            (identical(other.reporterId, reporterId) ||
                const DeepCollectionEquality().equals(
                  other.reporterId,
                  reporterId,
                )) &&
            (identical(other.factionId, factionId) ||
                const DeepCollectionEquality().equals(
                  other.factionId,
                  factionId,
                )) &&
            (identical(other.timestamp, timestamp) ||
                const DeepCollectionEquality().equals(
                  other.timestamp,
                  timestamp,
                )) &&
            (identical(other.report, report) || const DeepCollectionEquality().equals(other.report, report)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(targetId) ^
      const DeepCollectionEquality().hash(reporterId) ^
      const DeepCollectionEquality().hash(factionId) ^
      const DeepCollectionEquality().hash(timestamp) ^
      const DeepCollectionEquality().hash(report) ^
      runtimeType.hashCode;
}

extension $ReportExtension on Report {
  Report copyWith({
    enums.ReportTypeEnum? type,
    dynamic targetId,
    int? reporterId,
    dynamic factionId,
    int? timestamp,
    dynamic report,
  }) {
    return Report(
      type: type ?? this.type,
      targetId: targetId ?? this.targetId,
      reporterId: reporterId ?? this.reporterId,
      factionId: factionId ?? this.factionId,
      timestamp: timestamp ?? this.timestamp,
      report: report ?? this.report,
    );
  }

  Report copyWithWrapped({
    Wrapped<enums.ReportTypeEnum>? type,
    Wrapped<dynamic>? targetId,
    Wrapped<int>? reporterId,
    Wrapped<dynamic>? factionId,
    Wrapped<int>? timestamp,
    Wrapped<dynamic>? report,
  }) {
    return Report(
      type: (type != null ? type.value : this.type),
      targetId: (targetId != null ? targetId.value : this.targetId),
      reporterId: (reporterId != null ? reporterId.value : this.reporterId),
      factionId: (factionId != null ? factionId.value : this.factionId),
      timestamp: (timestamp != null ? timestamp.value : this.timestamp),
      report: (report != null ? report.value : this.report),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ReportsResponse {
  const ReportsResponse({required this.reports, required this.metadata});

  factory ReportsResponse.fromJson(Map<String, dynamic> json) => _$ReportsResponseFromJson(json);

  static const toJsonFactory = _$ReportsResponseToJson;
  Map<String, dynamic> toJson() => _$ReportsResponseToJson(this);

  @JsonKey(name: 'reports', defaultValue: <Report>[])
  final List<Report> reports;
  @JsonKey(name: '_metadata')
  final RequestMetadataWithLinks metadata;
  static const fromJsonFactory = _$ReportsResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ReportsResponse &&
            (identical(other.reports, reports) ||
                const DeepCollectionEquality().equals(
                  other.reports,
                  reports,
                )) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality().equals(
                  other.metadata,
                  metadata,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(reports) ^
      const DeepCollectionEquality().hash(metadata) ^
      runtimeType.hashCode;
}

extension $ReportsResponseExtension on ReportsResponse {
  ReportsResponse copyWith({
    List<Report>? reports,
    RequestMetadataWithLinks? metadata,
  }) {
    return ReportsResponse(
      reports: reports ?? this.reports,
      metadata: metadata ?? this.metadata,
    );
  }

  ReportsResponse copyWithWrapped({
    Wrapped<List<Report>>? reports,
    Wrapped<RequestMetadataWithLinks>? metadata,
  }) {
    return ReportsResponse(
      reports: (reports != null ? reports.value : this.reports),
      metadata: (metadata != null ? metadata.value : this.metadata),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class SelectionCategoryEnum {
  const SelectionCategoryEnum();

  factory SelectionCategoryEnum.fromJson(Map<String, dynamic> json) => _$SelectionCategoryEnumFromJson(json);

  static const toJsonFactory = _$SelectionCategoryEnumToJson;
  Map<String, dynamic> toJson() => _$SelectionCategoryEnumToJson(this);

  static const fromJsonFactory = _$SelectionCategoryEnumFromJson;

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => runtimeType.hashCode;
}

@JsonSerializable(explicitToJson: true)
class BasicUser {
  const BasicUser({required this.id, required this.name});

  factory BasicUser.fromJson(Map<String, dynamic> json) => _$BasicUserFromJson(json);

  static const toJsonFactory = _$BasicUserToJson;
  Map<String, dynamic> toJson() => _$BasicUserToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'name')
  final String name;
  static const fromJsonFactory = _$BasicUserFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BasicUser &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^ const DeepCollectionEquality().hash(name) ^ runtimeType.hashCode;
}

extension $BasicUserExtension on BasicUser {
  BasicUser copyWith({int? id, String? name}) {
    return BasicUser(id: id ?? this.id, name: name ?? this.name);
  }

  BasicUser copyWithWrapped({Wrapped<int>? id, Wrapped<String>? name}) {
    return BasicUser(
      id: (id != null ? id.value : this.id),
      name: (name != null ? name.value : this.name),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserPropertyBasicDetails {
  const UserPropertyBasicDetails({
    required this.id,
    required this.owner,
    required this.property,
    required this.happy,
    required this.upkeep,
    required this.marketPrice,
    required this.modifications,
    required this.staff,
  });

  factory UserPropertyBasicDetails.fromJson(Map<String, dynamic> json) => _$UserPropertyBasicDetailsFromJson(json);

  static const toJsonFactory = _$UserPropertyBasicDetailsToJson;
  Map<String, dynamic> toJson() => _$UserPropertyBasicDetailsToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'owner')
  final BasicUser owner;
  @JsonKey(name: 'property')
  final BasicProperty property;
  @JsonKey(name: 'happy')
  final int happy;
  @JsonKey(name: 'upkeep')
  final UserPropertyBasicDetails$Upkeep upkeep;
  @JsonKey(name: 'market_price')
  final int marketPrice;
  @JsonKey(
    name: 'modifications',
    toJson: propertyModificationEnumListToJson,
    fromJson: propertyModificationEnumListFromJson,
  )
  final List<enums.PropertyModificationEnum> modifications;
  @JsonKey(name: 'staff')
  final List<UserPropertyBasicDetails$Staff$Item> staff;
  static const fromJsonFactory = _$UserPropertyBasicDetailsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserPropertyBasicDetails &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.owner, owner) || const DeepCollectionEquality().equals(other.owner, owner)) &&
            (identical(other.property, property) ||
                const DeepCollectionEquality().equals(
                  other.property,
                  property,
                )) &&
            (identical(other.happy, happy) || const DeepCollectionEquality().equals(other.happy, happy)) &&
            (identical(other.upkeep, upkeep) || const DeepCollectionEquality().equals(other.upkeep, upkeep)) &&
            (identical(other.marketPrice, marketPrice) ||
                const DeepCollectionEquality().equals(
                  other.marketPrice,
                  marketPrice,
                )) &&
            (identical(other.modifications, modifications) ||
                const DeepCollectionEquality().equals(
                  other.modifications,
                  modifications,
                )) &&
            (identical(other.staff, staff) || const DeepCollectionEquality().equals(other.staff, staff)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(owner) ^
      const DeepCollectionEquality().hash(property) ^
      const DeepCollectionEquality().hash(happy) ^
      const DeepCollectionEquality().hash(upkeep) ^
      const DeepCollectionEquality().hash(marketPrice) ^
      const DeepCollectionEquality().hash(modifications) ^
      const DeepCollectionEquality().hash(staff) ^
      runtimeType.hashCode;
}

extension $UserPropertyBasicDetailsExtension on UserPropertyBasicDetails {
  UserPropertyBasicDetails copyWith({
    int? id,
    BasicUser? owner,
    BasicProperty? property,
    int? happy,
    UserPropertyBasicDetails$Upkeep? upkeep,
    int? marketPrice,
    List<enums.PropertyModificationEnum>? modifications,
    List<UserPropertyBasicDetails$Staff$Item>? staff,
  }) {
    return UserPropertyBasicDetails(
      id: id ?? this.id,
      owner: owner ?? this.owner,
      property: property ?? this.property,
      happy: happy ?? this.happy,
      upkeep: upkeep ?? this.upkeep,
      marketPrice: marketPrice ?? this.marketPrice,
      modifications: modifications ?? this.modifications,
      staff: staff ?? this.staff,
    );
  }

  UserPropertyBasicDetails copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<BasicUser>? owner,
    Wrapped<BasicProperty>? property,
    Wrapped<int>? happy,
    Wrapped<UserPropertyBasicDetails$Upkeep>? upkeep,
    Wrapped<int>? marketPrice,
    Wrapped<List<enums.PropertyModificationEnum>>? modifications,
    Wrapped<List<UserPropertyBasicDetails$Staff$Item>>? staff,
  }) {
    return UserPropertyBasicDetails(
      id: (id != null ? id.value : this.id),
      owner: (owner != null ? owner.value : this.owner),
      property: (property != null ? property.value : this.property),
      happy: (happy != null ? happy.value : this.happy),
      upkeep: (upkeep != null ? upkeep.value : this.upkeep),
      marketPrice: (marketPrice != null ? marketPrice.value : this.marketPrice),
      modifications: (modifications != null ? modifications.value : this.modifications),
      staff: (staff != null ? staff.value : this.staff),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserPropertyDetailsExtended {
  const UserPropertyDetailsExtended({
    required this.usedBy,
    required this.status,
    required this.id,
    required this.owner,
    required this.property,
    required this.happy,
    required this.upkeep,
    required this.marketPrice,
    required this.modifications,
    required this.staff,
  });

  factory UserPropertyDetailsExtended.fromJson(Map<String, dynamic> json) =>
      _$UserPropertyDetailsExtendedFromJson(json);

  static const toJsonFactory = _$UserPropertyDetailsExtendedToJson;
  Map<String, dynamic> toJson() => _$UserPropertyDetailsExtendedToJson(this);

  @JsonKey(name: 'used_by', defaultValue: <BasicUser>[])
  final List<BasicUser> usedBy;
  @JsonKey(
    name: 'status',
    toJson: userPropertyDetailsExtendedStatusToJson,
    fromJson: userPropertyDetailsExtendedStatusFromJson,
  )
  final enums.UserPropertyDetailsExtendedStatus status;
  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'owner')
  final BasicUser owner;
  @JsonKey(name: 'property')
  final BasicProperty property;
  @JsonKey(name: 'happy')
  final int happy;
  @JsonKey(name: 'upkeep')
  final UserPropertyDetailsExtended$Upkeep upkeep;
  @JsonKey(name: 'market_price')
  final int marketPrice;
  @JsonKey(
    name: 'modifications',
    toJson: propertyModificationEnumListToJson,
    fromJson: propertyModificationEnumListFromJson,
  )
  final List<enums.PropertyModificationEnum> modifications;
  @JsonKey(name: 'staff')
  final List<UserPropertyDetailsExtended$Staff$Item> staff;
  static const fromJsonFactory = _$UserPropertyDetailsExtendedFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserPropertyDetailsExtended &&
            (identical(other.usedBy, usedBy) || const DeepCollectionEquality().equals(other.usedBy, usedBy)) &&
            (identical(other.status, status) || const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.owner, owner) || const DeepCollectionEquality().equals(other.owner, owner)) &&
            (identical(other.property, property) ||
                const DeepCollectionEquality().equals(
                  other.property,
                  property,
                )) &&
            (identical(other.happy, happy) || const DeepCollectionEquality().equals(other.happy, happy)) &&
            (identical(other.upkeep, upkeep) || const DeepCollectionEquality().equals(other.upkeep, upkeep)) &&
            (identical(other.marketPrice, marketPrice) ||
                const DeepCollectionEquality().equals(
                  other.marketPrice,
                  marketPrice,
                )) &&
            (identical(other.modifications, modifications) ||
                const DeepCollectionEquality().equals(
                  other.modifications,
                  modifications,
                )) &&
            (identical(other.staff, staff) || const DeepCollectionEquality().equals(other.staff, staff)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(usedBy) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(owner) ^
      const DeepCollectionEquality().hash(property) ^
      const DeepCollectionEquality().hash(happy) ^
      const DeepCollectionEquality().hash(upkeep) ^
      const DeepCollectionEquality().hash(marketPrice) ^
      const DeepCollectionEquality().hash(modifications) ^
      const DeepCollectionEquality().hash(staff) ^
      runtimeType.hashCode;
}

extension $UserPropertyDetailsExtendedExtension on UserPropertyDetailsExtended {
  UserPropertyDetailsExtended copyWith({
    List<BasicUser>? usedBy,
    enums.UserPropertyDetailsExtendedStatus? status,
    int? id,
    BasicUser? owner,
    BasicProperty? property,
    int? happy,
    UserPropertyDetailsExtended$Upkeep? upkeep,
    int? marketPrice,
    List<enums.PropertyModificationEnum>? modifications,
    List<UserPropertyDetailsExtended$Staff$Item>? staff,
  }) {
    return UserPropertyDetailsExtended(
      usedBy: usedBy ?? this.usedBy,
      status: status ?? this.status,
      id: id ?? this.id,
      owner: owner ?? this.owner,
      property: property ?? this.property,
      happy: happy ?? this.happy,
      upkeep: upkeep ?? this.upkeep,
      marketPrice: marketPrice ?? this.marketPrice,
      modifications: modifications ?? this.modifications,
      staff: staff ?? this.staff,
    );
  }

  UserPropertyDetailsExtended copyWithWrapped({
    Wrapped<List<BasicUser>>? usedBy,
    Wrapped<enums.UserPropertyDetailsExtendedStatus>? status,
    Wrapped<int>? id,
    Wrapped<BasicUser>? owner,
    Wrapped<BasicProperty>? property,
    Wrapped<int>? happy,
    Wrapped<UserPropertyDetailsExtended$Upkeep>? upkeep,
    Wrapped<int>? marketPrice,
    Wrapped<List<enums.PropertyModificationEnum>>? modifications,
    Wrapped<List<UserPropertyDetailsExtended$Staff$Item>>? staff,
  }) {
    return UserPropertyDetailsExtended(
      usedBy: (usedBy != null ? usedBy.value : this.usedBy),
      status: (status != null ? status.value : this.status),
      id: (id != null ? id.value : this.id),
      owner: (owner != null ? owner.value : this.owner),
      property: (property != null ? property.value : this.property),
      happy: (happy != null ? happy.value : this.happy),
      upkeep: (upkeep != null ? upkeep.value : this.upkeep),
      marketPrice: (marketPrice != null ? marketPrice.value : this.marketPrice),
      modifications: (modifications != null ? modifications.value : this.modifications),
      staff: (staff != null ? staff.value : this.staff),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserPropertyDetails {
  const UserPropertyDetails({
    required this.usedBy,
    required this.id,
    required this.owner,
    required this.property,
    required this.happy,
    required this.upkeep,
    required this.marketPrice,
    required this.modifications,
    required this.staff,
  });

  factory UserPropertyDetails.fromJson(Map<String, dynamic> json) => _$UserPropertyDetailsFromJson(json);

  static const toJsonFactory = _$UserPropertyDetailsToJson;
  Map<String, dynamic> toJson() => _$UserPropertyDetailsToJson(this);

  @JsonKey(name: 'used_by', defaultValue: <BasicUser>[])
  final List<BasicUser> usedBy;
  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'owner')
  final BasicUser owner;
  @JsonKey(name: 'property')
  final BasicProperty property;
  @JsonKey(name: 'happy')
  final int happy;
  @JsonKey(name: 'upkeep')
  final UserPropertyDetails$Upkeep upkeep;
  @JsonKey(name: 'market_price')
  final int marketPrice;
  @JsonKey(
    name: 'modifications',
    toJson: propertyModificationEnumListToJson,
    fromJson: propertyModificationEnumListFromJson,
  )
  final List<enums.PropertyModificationEnum> modifications;
  @JsonKey(name: 'staff')
  final List<UserPropertyDetails$Staff$Item> staff;
  static const fromJsonFactory = _$UserPropertyDetailsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserPropertyDetails &&
            (identical(other.usedBy, usedBy) || const DeepCollectionEquality().equals(other.usedBy, usedBy)) &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.owner, owner) || const DeepCollectionEquality().equals(other.owner, owner)) &&
            (identical(other.property, property) ||
                const DeepCollectionEquality().equals(
                  other.property,
                  property,
                )) &&
            (identical(other.happy, happy) || const DeepCollectionEquality().equals(other.happy, happy)) &&
            (identical(other.upkeep, upkeep) || const DeepCollectionEquality().equals(other.upkeep, upkeep)) &&
            (identical(other.marketPrice, marketPrice) ||
                const DeepCollectionEquality().equals(
                  other.marketPrice,
                  marketPrice,
                )) &&
            (identical(other.modifications, modifications) ||
                const DeepCollectionEquality().equals(
                  other.modifications,
                  modifications,
                )) &&
            (identical(other.staff, staff) || const DeepCollectionEquality().equals(other.staff, staff)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(usedBy) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(owner) ^
      const DeepCollectionEquality().hash(property) ^
      const DeepCollectionEquality().hash(happy) ^
      const DeepCollectionEquality().hash(upkeep) ^
      const DeepCollectionEquality().hash(marketPrice) ^
      const DeepCollectionEquality().hash(modifications) ^
      const DeepCollectionEquality().hash(staff) ^
      runtimeType.hashCode;
}

extension $UserPropertyDetailsExtension on UserPropertyDetails {
  UserPropertyDetails copyWith({
    List<BasicUser>? usedBy,
    int? id,
    BasicUser? owner,
    BasicProperty? property,
    int? happy,
    UserPropertyDetails$Upkeep? upkeep,
    int? marketPrice,
    List<enums.PropertyModificationEnum>? modifications,
    List<UserPropertyDetails$Staff$Item>? staff,
  }) {
    return UserPropertyDetails(
      usedBy: usedBy ?? this.usedBy,
      id: id ?? this.id,
      owner: owner ?? this.owner,
      property: property ?? this.property,
      happy: happy ?? this.happy,
      upkeep: upkeep ?? this.upkeep,
      marketPrice: marketPrice ?? this.marketPrice,
      modifications: modifications ?? this.modifications,
      staff: staff ?? this.staff,
    );
  }

  UserPropertyDetails copyWithWrapped({
    Wrapped<List<BasicUser>>? usedBy,
    Wrapped<int>? id,
    Wrapped<BasicUser>? owner,
    Wrapped<BasicProperty>? property,
    Wrapped<int>? happy,
    Wrapped<UserPropertyDetails$Upkeep>? upkeep,
    Wrapped<int>? marketPrice,
    Wrapped<List<enums.PropertyModificationEnum>>? modifications,
    Wrapped<List<UserPropertyDetails$Staff$Item>>? staff,
  }) {
    return UserPropertyDetails(
      usedBy: (usedBy != null ? usedBy.value : this.usedBy),
      id: (id != null ? id.value : this.id),
      owner: (owner != null ? owner.value : this.owner),
      property: (property != null ? property.value : this.property),
      happy: (happy != null ? happy.value : this.happy),
      upkeep: (upkeep != null ? upkeep.value : this.upkeep),
      marketPrice: (marketPrice != null ? marketPrice.value : this.marketPrice),
      modifications: (modifications != null ? modifications.value : this.modifications),
      staff: (staff != null ? staff.value : this.staff),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserPropertyDetailsExtendedRented {
  const UserPropertyDetailsExtendedRented({
    required this.usedBy,
    required this.status,
    required this.cost,
    required this.costPerDay,
    required this.rentalPeriod,
    required this.rentalPeriodRemaining,
    required this.id,
    required this.owner,
    required this.property,
    required this.happy,
    required this.upkeep,
    required this.marketPrice,
    required this.modifications,
    required this.staff,
  });

  factory UserPropertyDetailsExtendedRented.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$UserPropertyDetailsExtendedRentedFromJson(json);

  static const toJsonFactory = _$UserPropertyDetailsExtendedRentedToJson;
  Map<String, dynamic> toJson() => _$UserPropertyDetailsExtendedRentedToJson(this);

  @JsonKey(name: 'used_by', defaultValue: <BasicUser>[])
  final List<BasicUser> usedBy;
  @JsonKey(
    name: 'status',
    toJson: userPropertyDetailsExtendedRentedStatusToJson,
    fromJson: userPropertyDetailsExtendedRentedStatusFromJson,
  )
  final enums.UserPropertyDetailsExtendedRentedStatus status;
  @JsonKey(name: 'cost')
  final int cost;
  @JsonKey(name: 'cost_per_day')
  final int costPerDay;
  @JsonKey(name: 'rental_period')
  final int rentalPeriod;
  @JsonKey(name: 'rental_period_remaining')
  final int rentalPeriodRemaining;
  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'owner')
  final BasicUser owner;
  @JsonKey(name: 'property')
  final BasicProperty property;
  @JsonKey(name: 'happy')
  final int happy;
  @JsonKey(name: 'upkeep')
  final UserPropertyDetailsExtendedRented$Upkeep upkeep;
  @JsonKey(name: 'market_price')
  final int marketPrice;
  @JsonKey(
    name: 'modifications',
    toJson: propertyModificationEnumListToJson,
    fromJson: propertyModificationEnumListFromJson,
  )
  final List<enums.PropertyModificationEnum> modifications;
  @JsonKey(name: 'staff')
  final List<UserPropertyDetailsExtendedRented$Staff$Item> staff;
  static const fromJsonFactory = _$UserPropertyDetailsExtendedRentedFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserPropertyDetailsExtendedRented &&
            (identical(other.usedBy, usedBy) || const DeepCollectionEquality().equals(other.usedBy, usedBy)) &&
            (identical(other.status, status) || const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.cost, cost) || const DeepCollectionEquality().equals(other.cost, cost)) &&
            (identical(other.costPerDay, costPerDay) ||
                const DeepCollectionEquality().equals(
                  other.costPerDay,
                  costPerDay,
                )) &&
            (identical(other.rentalPeriod, rentalPeriod) ||
                const DeepCollectionEquality().equals(
                  other.rentalPeriod,
                  rentalPeriod,
                )) &&
            (identical(other.rentalPeriodRemaining, rentalPeriodRemaining) ||
                const DeepCollectionEquality().equals(
                  other.rentalPeriodRemaining,
                  rentalPeriodRemaining,
                )) &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.owner, owner) || const DeepCollectionEquality().equals(other.owner, owner)) &&
            (identical(other.property, property) ||
                const DeepCollectionEquality().equals(
                  other.property,
                  property,
                )) &&
            (identical(other.happy, happy) || const DeepCollectionEquality().equals(other.happy, happy)) &&
            (identical(other.upkeep, upkeep) || const DeepCollectionEquality().equals(other.upkeep, upkeep)) &&
            (identical(other.marketPrice, marketPrice) ||
                const DeepCollectionEquality().equals(
                  other.marketPrice,
                  marketPrice,
                )) &&
            (identical(other.modifications, modifications) ||
                const DeepCollectionEquality().equals(
                  other.modifications,
                  modifications,
                )) &&
            (identical(other.staff, staff) || const DeepCollectionEquality().equals(other.staff, staff)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(usedBy) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(cost) ^
      const DeepCollectionEquality().hash(costPerDay) ^
      const DeepCollectionEquality().hash(rentalPeriod) ^
      const DeepCollectionEquality().hash(rentalPeriodRemaining) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(owner) ^
      const DeepCollectionEquality().hash(property) ^
      const DeepCollectionEquality().hash(happy) ^
      const DeepCollectionEquality().hash(upkeep) ^
      const DeepCollectionEquality().hash(marketPrice) ^
      const DeepCollectionEquality().hash(modifications) ^
      const DeepCollectionEquality().hash(staff) ^
      runtimeType.hashCode;
}

extension $UserPropertyDetailsExtendedRentedExtension on UserPropertyDetailsExtendedRented {
  UserPropertyDetailsExtendedRented copyWith({
    List<BasicUser>? usedBy,
    enums.UserPropertyDetailsExtendedRentedStatus? status,
    int? cost,
    int? costPerDay,
    int? rentalPeriod,
    int? rentalPeriodRemaining,
    int? id,
    BasicUser? owner,
    BasicProperty? property,
    int? happy,
    UserPropertyDetailsExtendedRented$Upkeep? upkeep,
    int? marketPrice,
    List<enums.PropertyModificationEnum>? modifications,
    List<UserPropertyDetailsExtendedRented$Staff$Item>? staff,
  }) {
    return UserPropertyDetailsExtendedRented(
      usedBy: usedBy ?? this.usedBy,
      status: status ?? this.status,
      cost: cost ?? this.cost,
      costPerDay: costPerDay ?? this.costPerDay,
      rentalPeriod: rentalPeriod ?? this.rentalPeriod,
      rentalPeriodRemaining: rentalPeriodRemaining ?? this.rentalPeriodRemaining,
      id: id ?? this.id,
      owner: owner ?? this.owner,
      property: property ?? this.property,
      happy: happy ?? this.happy,
      upkeep: upkeep ?? this.upkeep,
      marketPrice: marketPrice ?? this.marketPrice,
      modifications: modifications ?? this.modifications,
      staff: staff ?? this.staff,
    );
  }

  UserPropertyDetailsExtendedRented copyWithWrapped({
    Wrapped<List<BasicUser>>? usedBy,
    Wrapped<enums.UserPropertyDetailsExtendedRentedStatus>? status,
    Wrapped<int>? cost,
    Wrapped<int>? costPerDay,
    Wrapped<int>? rentalPeriod,
    Wrapped<int>? rentalPeriodRemaining,
    Wrapped<int>? id,
    Wrapped<BasicUser>? owner,
    Wrapped<BasicProperty>? property,
    Wrapped<int>? happy,
    Wrapped<UserPropertyDetailsExtendedRented$Upkeep>? upkeep,
    Wrapped<int>? marketPrice,
    Wrapped<List<enums.PropertyModificationEnum>>? modifications,
    Wrapped<List<UserPropertyDetailsExtendedRented$Staff$Item>>? staff,
  }) {
    return UserPropertyDetailsExtendedRented(
      usedBy: (usedBy != null ? usedBy.value : this.usedBy),
      status: (status != null ? status.value : this.status),
      cost: (cost != null ? cost.value : this.cost),
      costPerDay: (costPerDay != null ? costPerDay.value : this.costPerDay),
      rentalPeriod: (rentalPeriod != null ? rentalPeriod.value : this.rentalPeriod),
      rentalPeriodRemaining: (rentalPeriodRemaining != null ? rentalPeriodRemaining.value : this.rentalPeriodRemaining),
      id: (id != null ? id.value : this.id),
      owner: (owner != null ? owner.value : this.owner),
      property: (property != null ? property.value : this.property),
      happy: (happy != null ? happy.value : this.happy),
      upkeep: (upkeep != null ? upkeep.value : this.upkeep),
      marketPrice: (marketPrice != null ? marketPrice.value : this.marketPrice),
      modifications: (modifications != null ? modifications.value : this.modifications),
      staff: (staff != null ? staff.value : this.staff),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserPropertyDetailsExtendedForRent {
  const UserPropertyDetailsExtendedForRent({
    required this.usedBy,
    required this.status,
    required this.cost,
    required this.costPerDay,
    required this.rentalPeriod,
    this.renterAsked,
    required this.id,
    required this.owner,
    required this.property,
    required this.happy,
    required this.upkeep,
    required this.marketPrice,
    required this.modifications,
    required this.staff,
  });

  factory UserPropertyDetailsExtendedForRent.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$UserPropertyDetailsExtendedForRentFromJson(json);

  static const toJsonFactory = _$UserPropertyDetailsExtendedForRentToJson;
  Map<String, dynamic> toJson() => _$UserPropertyDetailsExtendedForRentToJson(this);

  @JsonKey(name: 'used_by', defaultValue: <BasicUser>[])
  final List<BasicUser> usedBy;
  @JsonKey(
    name: 'status',
    toJson: userPropertyDetailsExtendedForRentStatusToJson,
    fromJson: userPropertyDetailsExtendedForRentStatusFromJson,
  )
  final enums.UserPropertyDetailsExtendedForRentStatus status;
  @JsonKey(name: 'cost')
  final int cost;
  @JsonKey(name: 'cost_per_day')
  final int costPerDay;
  @JsonKey(name: 'rental_period')
  final int rentalPeriod;
  @JsonKey(name: 'renter_asked')
  final BasicUser? renterAsked;
  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'owner')
  final BasicUser owner;
  @JsonKey(name: 'property')
  final BasicProperty property;
  @JsonKey(name: 'happy')
  final int happy;
  @JsonKey(name: 'upkeep')
  final UserPropertyDetailsExtendedForRent$Upkeep upkeep;
  @JsonKey(name: 'market_price')
  final int marketPrice;
  @JsonKey(
    name: 'modifications',
    toJson: propertyModificationEnumListToJson,
    fromJson: propertyModificationEnumListFromJson,
  )
  final List<enums.PropertyModificationEnum> modifications;
  @JsonKey(name: 'staff')
  final List<UserPropertyDetailsExtendedForRent$Staff$Item> staff;
  static const fromJsonFactory = _$UserPropertyDetailsExtendedForRentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserPropertyDetailsExtendedForRent &&
            (identical(other.usedBy, usedBy) || const DeepCollectionEquality().equals(other.usedBy, usedBy)) &&
            (identical(other.status, status) || const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.cost, cost) || const DeepCollectionEquality().equals(other.cost, cost)) &&
            (identical(other.costPerDay, costPerDay) ||
                const DeepCollectionEquality().equals(
                  other.costPerDay,
                  costPerDay,
                )) &&
            (identical(other.rentalPeriod, rentalPeriod) ||
                const DeepCollectionEquality().equals(
                  other.rentalPeriod,
                  rentalPeriod,
                )) &&
            (identical(other.renterAsked, renterAsked) ||
                const DeepCollectionEquality().equals(
                  other.renterAsked,
                  renterAsked,
                )) &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.owner, owner) || const DeepCollectionEquality().equals(other.owner, owner)) &&
            (identical(other.property, property) ||
                const DeepCollectionEquality().equals(
                  other.property,
                  property,
                )) &&
            (identical(other.happy, happy) || const DeepCollectionEquality().equals(other.happy, happy)) &&
            (identical(other.upkeep, upkeep) || const DeepCollectionEquality().equals(other.upkeep, upkeep)) &&
            (identical(other.marketPrice, marketPrice) ||
                const DeepCollectionEquality().equals(
                  other.marketPrice,
                  marketPrice,
                )) &&
            (identical(other.modifications, modifications) ||
                const DeepCollectionEquality().equals(
                  other.modifications,
                  modifications,
                )) &&
            (identical(other.staff, staff) || const DeepCollectionEquality().equals(other.staff, staff)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(usedBy) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(cost) ^
      const DeepCollectionEquality().hash(costPerDay) ^
      const DeepCollectionEquality().hash(rentalPeriod) ^
      const DeepCollectionEquality().hash(renterAsked) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(owner) ^
      const DeepCollectionEquality().hash(property) ^
      const DeepCollectionEquality().hash(happy) ^
      const DeepCollectionEquality().hash(upkeep) ^
      const DeepCollectionEquality().hash(marketPrice) ^
      const DeepCollectionEquality().hash(modifications) ^
      const DeepCollectionEquality().hash(staff) ^
      runtimeType.hashCode;
}

extension $UserPropertyDetailsExtendedForRentExtension on UserPropertyDetailsExtendedForRent {
  UserPropertyDetailsExtendedForRent copyWith({
    List<BasicUser>? usedBy,
    enums.UserPropertyDetailsExtendedForRentStatus? status,
    int? cost,
    int? costPerDay,
    int? rentalPeriod,
    BasicUser? renterAsked,
    int? id,
    BasicUser? owner,
    BasicProperty? property,
    int? happy,
    UserPropertyDetailsExtendedForRent$Upkeep? upkeep,
    int? marketPrice,
    List<enums.PropertyModificationEnum>? modifications,
    List<UserPropertyDetailsExtendedForRent$Staff$Item>? staff,
  }) {
    return UserPropertyDetailsExtendedForRent(
      usedBy: usedBy ?? this.usedBy,
      status: status ?? this.status,
      cost: cost ?? this.cost,
      costPerDay: costPerDay ?? this.costPerDay,
      rentalPeriod: rentalPeriod ?? this.rentalPeriod,
      renterAsked: renterAsked ?? this.renterAsked,
      id: id ?? this.id,
      owner: owner ?? this.owner,
      property: property ?? this.property,
      happy: happy ?? this.happy,
      upkeep: upkeep ?? this.upkeep,
      marketPrice: marketPrice ?? this.marketPrice,
      modifications: modifications ?? this.modifications,
      staff: staff ?? this.staff,
    );
  }

  UserPropertyDetailsExtendedForRent copyWithWrapped({
    Wrapped<List<BasicUser>>? usedBy,
    Wrapped<enums.UserPropertyDetailsExtendedForRentStatus>? status,
    Wrapped<int>? cost,
    Wrapped<int>? costPerDay,
    Wrapped<int>? rentalPeriod,
    Wrapped<BasicUser?>? renterAsked,
    Wrapped<int>? id,
    Wrapped<BasicUser>? owner,
    Wrapped<BasicProperty>? property,
    Wrapped<int>? happy,
    Wrapped<UserPropertyDetailsExtendedForRent$Upkeep>? upkeep,
    Wrapped<int>? marketPrice,
    Wrapped<List<enums.PropertyModificationEnum>>? modifications,
    Wrapped<List<UserPropertyDetailsExtendedForRent$Staff$Item>>? staff,
  }) {
    return UserPropertyDetailsExtendedForRent(
      usedBy: (usedBy != null ? usedBy.value : this.usedBy),
      status: (status != null ? status.value : this.status),
      cost: (cost != null ? cost.value : this.cost),
      costPerDay: (costPerDay != null ? costPerDay.value : this.costPerDay),
      rentalPeriod: (rentalPeriod != null ? rentalPeriod.value : this.rentalPeriod),
      renterAsked: (renterAsked != null ? renterAsked.value : this.renterAsked),
      id: (id != null ? id.value : this.id),
      owner: (owner != null ? owner.value : this.owner),
      property: (property != null ? property.value : this.property),
      happy: (happy != null ? happy.value : this.happy),
      upkeep: (upkeep != null ? upkeep.value : this.upkeep),
      marketPrice: (marketPrice != null ? marketPrice.value : this.marketPrice),
      modifications: (modifications != null ? modifications.value : this.modifications),
      staff: (staff != null ? staff.value : this.staff),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserPropertyDetailsExtendedForSale {
  const UserPropertyDetailsExtendedForSale({
    required this.usedBy,
    required this.status,
    required this.cost,
    required this.id,
    required this.owner,
    required this.property,
    required this.happy,
    required this.upkeep,
    required this.marketPrice,
    required this.modifications,
    required this.staff,
  });

  factory UserPropertyDetailsExtendedForSale.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$UserPropertyDetailsExtendedForSaleFromJson(json);

  static const toJsonFactory = _$UserPropertyDetailsExtendedForSaleToJson;
  Map<String, dynamic> toJson() => _$UserPropertyDetailsExtendedForSaleToJson(this);

  @JsonKey(name: 'used_by', defaultValue: <BasicUser>[])
  final List<BasicUser> usedBy;
  @JsonKey(
    name: 'status',
    toJson: userPropertyDetailsExtendedForSaleStatusToJson,
    fromJson: userPropertyDetailsExtendedForSaleStatusFromJson,
  )
  final enums.UserPropertyDetailsExtendedForSaleStatus status;
  @JsonKey(name: 'cost')
  final int cost;
  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'owner')
  final BasicUser owner;
  @JsonKey(name: 'property')
  final BasicProperty property;
  @JsonKey(name: 'happy')
  final int happy;
  @JsonKey(name: 'upkeep')
  final UserPropertyDetailsExtendedForSale$Upkeep upkeep;
  @JsonKey(name: 'market_price')
  final int marketPrice;
  @JsonKey(
    name: 'modifications',
    toJson: propertyModificationEnumListToJson,
    fromJson: propertyModificationEnumListFromJson,
  )
  final List<enums.PropertyModificationEnum> modifications;
  @JsonKey(name: 'staff')
  final List<UserPropertyDetailsExtendedForSale$Staff$Item> staff;
  static const fromJsonFactory = _$UserPropertyDetailsExtendedForSaleFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserPropertyDetailsExtendedForSale &&
            (identical(other.usedBy, usedBy) || const DeepCollectionEquality().equals(other.usedBy, usedBy)) &&
            (identical(other.status, status) || const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.cost, cost) || const DeepCollectionEquality().equals(other.cost, cost)) &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.owner, owner) || const DeepCollectionEquality().equals(other.owner, owner)) &&
            (identical(other.property, property) ||
                const DeepCollectionEquality().equals(
                  other.property,
                  property,
                )) &&
            (identical(other.happy, happy) || const DeepCollectionEquality().equals(other.happy, happy)) &&
            (identical(other.upkeep, upkeep) || const DeepCollectionEquality().equals(other.upkeep, upkeep)) &&
            (identical(other.marketPrice, marketPrice) ||
                const DeepCollectionEquality().equals(
                  other.marketPrice,
                  marketPrice,
                )) &&
            (identical(other.modifications, modifications) ||
                const DeepCollectionEquality().equals(
                  other.modifications,
                  modifications,
                )) &&
            (identical(other.staff, staff) || const DeepCollectionEquality().equals(other.staff, staff)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(usedBy) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(cost) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(owner) ^
      const DeepCollectionEquality().hash(property) ^
      const DeepCollectionEquality().hash(happy) ^
      const DeepCollectionEquality().hash(upkeep) ^
      const DeepCollectionEquality().hash(marketPrice) ^
      const DeepCollectionEquality().hash(modifications) ^
      const DeepCollectionEquality().hash(staff) ^
      runtimeType.hashCode;
}

extension $UserPropertyDetailsExtendedForSaleExtension on UserPropertyDetailsExtendedForSale {
  UserPropertyDetailsExtendedForSale copyWith({
    List<BasicUser>? usedBy,
    enums.UserPropertyDetailsExtendedForSaleStatus? status,
    int? cost,
    int? id,
    BasicUser? owner,
    BasicProperty? property,
    int? happy,
    UserPropertyDetailsExtendedForSale$Upkeep? upkeep,
    int? marketPrice,
    List<enums.PropertyModificationEnum>? modifications,
    List<UserPropertyDetailsExtendedForSale$Staff$Item>? staff,
  }) {
    return UserPropertyDetailsExtendedForSale(
      usedBy: usedBy ?? this.usedBy,
      status: status ?? this.status,
      cost: cost ?? this.cost,
      id: id ?? this.id,
      owner: owner ?? this.owner,
      property: property ?? this.property,
      happy: happy ?? this.happy,
      upkeep: upkeep ?? this.upkeep,
      marketPrice: marketPrice ?? this.marketPrice,
      modifications: modifications ?? this.modifications,
      staff: staff ?? this.staff,
    );
  }

  UserPropertyDetailsExtendedForSale copyWithWrapped({
    Wrapped<List<BasicUser>>? usedBy,
    Wrapped<enums.UserPropertyDetailsExtendedForSaleStatus>? status,
    Wrapped<int>? cost,
    Wrapped<int>? id,
    Wrapped<BasicUser>? owner,
    Wrapped<BasicProperty>? property,
    Wrapped<int>? happy,
    Wrapped<UserPropertyDetailsExtendedForSale$Upkeep>? upkeep,
    Wrapped<int>? marketPrice,
    Wrapped<List<enums.PropertyModificationEnum>>? modifications,
    Wrapped<List<UserPropertyDetailsExtendedForSale$Staff$Item>>? staff,
  }) {
    return UserPropertyDetailsExtendedForSale(
      usedBy: (usedBy != null ? usedBy.value : this.usedBy),
      status: (status != null ? status.value : this.status),
      cost: (cost != null ? cost.value : this.cost),
      id: (id != null ? id.value : this.id),
      owner: (owner != null ? owner.value : this.owner),
      property: (property != null ? property.value : this.property),
      happy: (happy != null ? happy.value : this.happy),
      upkeep: (upkeep != null ? upkeep.value : this.upkeep),
      marketPrice: (marketPrice != null ? marketPrice.value : this.marketPrice),
      modifications: (modifications != null ? modifications.value : this.modifications),
      staff: (staff != null ? staff.value : this.staff),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserPropertiesResponse {
  const UserPropertiesResponse({
    required this.properties,
    required this.metadata,
  });

  factory UserPropertiesResponse.fromJson(Map<String, dynamic> json) => _$UserPropertiesResponseFromJson(json);

  static const toJsonFactory = _$UserPropertiesResponseToJson;
  Map<String, dynamic> toJson() => _$UserPropertiesResponseToJson(this);

  @JsonKey(name: 'properties', defaultValue: <Object>[])
  final List<Object> properties;
  @JsonKey(name: '_metadata')
  final RequestMetadataWithLinks metadata;
  static const fromJsonFactory = _$UserPropertiesResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserPropertiesResponse &&
            (identical(other.properties, properties) ||
                const DeepCollectionEquality().equals(
                  other.properties,
                  properties,
                )) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality().equals(
                  other.metadata,
                  metadata,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(properties) ^
      const DeepCollectionEquality().hash(metadata) ^
      runtimeType.hashCode;
}

extension $UserPropertiesResponseExtension on UserPropertiesResponse {
  UserPropertiesResponse copyWith({
    List<Object>? properties,
    RequestMetadataWithLinks? metadata,
  }) {
    return UserPropertiesResponse(
      properties: properties ?? this.properties,
      metadata: metadata ?? this.metadata,
    );
  }

  UserPropertiesResponse copyWithWrapped({
    Wrapped<List<Object>>? properties,
    Wrapped<RequestMetadataWithLinks>? metadata,
  }) {
    return UserPropertiesResponse(
      properties: (properties != null ? properties.value : this.properties),
      metadata: (metadata != null ? metadata.value : this.metadata),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserPropertyResponse {
  const UserPropertyResponse({required this.property});

  factory UserPropertyResponse.fromJson(Map<String, dynamic> json) => _$UserPropertyResponseFromJson(json);

  static const toJsonFactory = _$UserPropertyResponseToJson;
  Map<String, dynamic> toJson() => _$UserPropertyResponseToJson(this);

  @JsonKey(name: 'property')
  final UserPropertyDetails property;
  static const fromJsonFactory = _$UserPropertyResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserPropertyResponse &&
            (identical(other.property, property) ||
                const DeepCollectionEquality().equals(
                  other.property,
                  property,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(property) ^ runtimeType.hashCode;
}

extension $UserPropertyResponseExtension on UserPropertyResponse {
  UserPropertyResponse copyWith({UserPropertyDetails? property}) {
    return UserPropertyResponse(property: property ?? this.property);
  }

  UserPropertyResponse copyWithWrapped({
    Wrapped<UserPropertyDetails>? property,
  }) {
    return UserPropertyResponse(
      property: (property != null ? property.value : this.property),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserCurrentEducation {
  const UserCurrentEducation({required this.id, required this.until});

  factory UserCurrentEducation.fromJson(Map<String, dynamic> json) => _$UserCurrentEducationFromJson(json);

  static const toJsonFactory = _$UserCurrentEducationToJson;
  Map<String, dynamic> toJson() => _$UserCurrentEducationToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'until')
  final int until;
  static const fromJsonFactory = _$UserCurrentEducationFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserCurrentEducation &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.until, until) || const DeepCollectionEquality().equals(other.until, until)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^ const DeepCollectionEquality().hash(until) ^ runtimeType.hashCode;
}

extension $UserCurrentEducationExtension on UserCurrentEducation {
  UserCurrentEducation copyWith({int? id, int? until}) {
    return UserCurrentEducation(id: id ?? this.id, until: until ?? this.until);
  }

  UserCurrentEducation copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<int>? until,
  }) {
    return UserCurrentEducation(
      id: (id != null ? id.value : this.id),
      until: (until != null ? until.value : this.until),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserEducation {
  const UserEducation({required this.complete, required this.current});

  factory UserEducation.fromJson(Map<String, dynamic> json) => _$UserEducationFromJson(json);

  static const toJsonFactory = _$UserEducationToJson;
  Map<String, dynamic> toJson() => _$UserEducationToJson(this);

  @JsonKey(name: 'complete', defaultValue: <int>[])
  final List<int> complete;
  @JsonKey(name: 'current')
  final dynamic current;
  static const fromJsonFactory = _$UserEducationFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserEducation &&
            (identical(other.complete, complete) ||
                const DeepCollectionEquality().equals(
                  other.complete,
                  complete,
                )) &&
            (identical(other.current, current) || const DeepCollectionEquality().equals(other.current, current)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(complete) ^
      const DeepCollectionEquality().hash(current) ^
      runtimeType.hashCode;
}

extension $UserEducationExtension on UserEducation {
  UserEducation copyWith({List<int>? complete, dynamic current}) {
    return UserEducation(
      complete: complete ?? this.complete,
      current: current ?? this.current,
    );
  }

  UserEducation copyWithWrapped({
    Wrapped<List<int>>? complete,
    Wrapped<dynamic>? current,
  }) {
    return UserEducation(
      complete: (complete != null ? complete.value : this.complete),
      current: (current != null ? current.value : this.current),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserEducationResponse {
  const UserEducationResponse({required this.education});

  factory UserEducationResponse.fromJson(Map<String, dynamic> json) => _$UserEducationResponseFromJson(json);

  static const toJsonFactory = _$UserEducationResponseToJson;
  Map<String, dynamic> toJson() => _$UserEducationResponseToJson(this);

  @JsonKey(name: 'education')
  final UserEducation education;
  static const fromJsonFactory = _$UserEducationResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserEducationResponse &&
            (identical(other.education, education) ||
                const DeepCollectionEquality().equals(
                  other.education,
                  education,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(education) ^ runtimeType.hashCode;
}

extension $UserEducationResponseExtension on UserEducationResponse {
  UserEducationResponse copyWith({UserEducation? education}) {
    return UserEducationResponse(education: education ?? this.education);
  }

  UserEducationResponse copyWithWrapped({Wrapped<UserEducation>? education}) {
    return UserEducationResponse(
      education: (education != null ? education.value : this.education),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserCrimeDetailsBootlegging {
  const UserCrimeDetailsBootlegging({
    required this.onlineStore,
    required this.dvdSales,
    this.dvdsCopied,
  });

  factory UserCrimeDetailsBootlegging.fromJson(Map<String, dynamic> json) =>
      _$UserCrimeDetailsBootleggingFromJson(json);

  static const toJsonFactory = _$UserCrimeDetailsBootleggingToJson;
  Map<String, dynamic> toJson() => _$UserCrimeDetailsBootleggingToJson(this);

  @JsonKey(name: 'online_store')
  final UserCrimeDetailsBootlegging$OnlineStore onlineStore;
  @JsonKey(name: 'dvd_sales')
  final UserCrimeDetailsBootlegging$DvdSales dvdSales;
  @JsonKey(name: 'dvds_copied')
  final int? dvdsCopied;
  static const fromJsonFactory = _$UserCrimeDetailsBootleggingFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserCrimeDetailsBootlegging &&
            (identical(other.onlineStore, onlineStore) ||
                const DeepCollectionEquality().equals(
                  other.onlineStore,
                  onlineStore,
                )) &&
            (identical(other.dvdSales, dvdSales) ||
                const DeepCollectionEquality().equals(
                  other.dvdSales,
                  dvdSales,
                )) &&
            (identical(other.dvdsCopied, dvdsCopied) ||
                const DeepCollectionEquality().equals(
                  other.dvdsCopied,
                  dvdsCopied,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(onlineStore) ^
      const DeepCollectionEquality().hash(dvdSales) ^
      const DeepCollectionEquality().hash(dvdsCopied) ^
      runtimeType.hashCode;
}

extension $UserCrimeDetailsBootleggingExtension on UserCrimeDetailsBootlegging {
  UserCrimeDetailsBootlegging copyWith({
    UserCrimeDetailsBootlegging$OnlineStore? onlineStore,
    UserCrimeDetailsBootlegging$DvdSales? dvdSales,
    int? dvdsCopied,
  }) {
    return UserCrimeDetailsBootlegging(
      onlineStore: onlineStore ?? this.onlineStore,
      dvdSales: dvdSales ?? this.dvdSales,
      dvdsCopied: dvdsCopied ?? this.dvdsCopied,
    );
  }

  UserCrimeDetailsBootlegging copyWithWrapped({
    Wrapped<UserCrimeDetailsBootlegging$OnlineStore>? onlineStore,
    Wrapped<UserCrimeDetailsBootlegging$DvdSales>? dvdSales,
    Wrapped<int?>? dvdsCopied,
  }) {
    return UserCrimeDetailsBootlegging(
      onlineStore: (onlineStore != null ? onlineStore.value : this.onlineStore),
      dvdSales: (dvdSales != null ? dvdSales.value : this.dvdSales),
      dvdsCopied: (dvdsCopied != null ? dvdsCopied.value : this.dvdsCopied),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserCrimeDetailsGraffiti {
  const UserCrimeDetailsGraffiti({
    required this.cansUsed,
    required this.mostGraffitiInOneArea,
    required this.mostGraffitiSimultaneously,
    required this.graffitiRemoved,
    required this.costToCity,
  });

  factory UserCrimeDetailsGraffiti.fromJson(Map<String, dynamic> json) => _$UserCrimeDetailsGraffitiFromJson(json);

  static const toJsonFactory = _$UserCrimeDetailsGraffitiToJson;
  Map<String, dynamic> toJson() => _$UserCrimeDetailsGraffitiToJson(this);

  @JsonKey(name: 'cans_used')
  final int cansUsed;
  @JsonKey(name: 'most_graffiti_in_one_area')
  final int mostGraffitiInOneArea;
  @JsonKey(name: 'most_graffiti_simultaneously')
  final int mostGraffitiSimultaneously;
  @JsonKey(name: 'graffiti_removed')
  final int graffitiRemoved;
  @JsonKey(name: 'cost_to_city')
  final int costToCity;
  static const fromJsonFactory = _$UserCrimeDetailsGraffitiFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserCrimeDetailsGraffiti &&
            (identical(other.cansUsed, cansUsed) ||
                const DeepCollectionEquality().equals(
                  other.cansUsed,
                  cansUsed,
                )) &&
            (identical(other.mostGraffitiInOneArea, mostGraffitiInOneArea) ||
                const DeepCollectionEquality().equals(
                  other.mostGraffitiInOneArea,
                  mostGraffitiInOneArea,
                )) &&
            (identical(
                  other.mostGraffitiSimultaneously,
                  mostGraffitiSimultaneously,
                ) ||
                const DeepCollectionEquality().equals(
                  other.mostGraffitiSimultaneously,
                  mostGraffitiSimultaneously,
                )) &&
            (identical(other.graffitiRemoved, graffitiRemoved) ||
                const DeepCollectionEquality().equals(
                  other.graffitiRemoved,
                  graffitiRemoved,
                )) &&
            (identical(other.costToCity, costToCity) ||
                const DeepCollectionEquality().equals(
                  other.costToCity,
                  costToCity,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(cansUsed) ^
      const DeepCollectionEquality().hash(mostGraffitiInOneArea) ^
      const DeepCollectionEquality().hash(mostGraffitiSimultaneously) ^
      const DeepCollectionEquality().hash(graffitiRemoved) ^
      const DeepCollectionEquality().hash(costToCity) ^
      runtimeType.hashCode;
}

extension $UserCrimeDetailsGraffitiExtension on UserCrimeDetailsGraffiti {
  UserCrimeDetailsGraffiti copyWith({
    int? cansUsed,
    int? mostGraffitiInOneArea,
    int? mostGraffitiSimultaneously,
    int? graffitiRemoved,
    int? costToCity,
  }) {
    return UserCrimeDetailsGraffiti(
      cansUsed: cansUsed ?? this.cansUsed,
      mostGraffitiInOneArea: mostGraffitiInOneArea ?? this.mostGraffitiInOneArea,
      mostGraffitiSimultaneously: mostGraffitiSimultaneously ?? this.mostGraffitiSimultaneously,
      graffitiRemoved: graffitiRemoved ?? this.graffitiRemoved,
      costToCity: costToCity ?? this.costToCity,
    );
  }

  UserCrimeDetailsGraffiti copyWithWrapped({
    Wrapped<int>? cansUsed,
    Wrapped<int>? mostGraffitiInOneArea,
    Wrapped<int>? mostGraffitiSimultaneously,
    Wrapped<int>? graffitiRemoved,
    Wrapped<int>? costToCity,
  }) {
    return UserCrimeDetailsGraffiti(
      cansUsed: (cansUsed != null ? cansUsed.value : this.cansUsed),
      mostGraffitiInOneArea: (mostGraffitiInOneArea != null ? mostGraffitiInOneArea.value : this.mostGraffitiInOneArea),
      mostGraffitiSimultaneously:
          (mostGraffitiSimultaneously != null ? mostGraffitiSimultaneously.value : this.mostGraffitiSimultaneously),
      graffitiRemoved: (graffitiRemoved != null ? graffitiRemoved.value : this.graffitiRemoved),
      costToCity: (costToCity != null ? costToCity.value : this.costToCity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserCrimeDetailsShoplifting {
  const UserCrimeDetailsShoplifting({required this.averageNotoriety});

  factory UserCrimeDetailsShoplifting.fromJson(Map<String, dynamic> json) =>
      _$UserCrimeDetailsShopliftingFromJson(json);

  static const toJsonFactory = _$UserCrimeDetailsShopliftingToJson;
  Map<String, dynamic> toJson() => _$UserCrimeDetailsShopliftingToJson(this);

  @JsonKey(name: 'average_notoriety')
  final int averageNotoriety;
  static const fromJsonFactory = _$UserCrimeDetailsShopliftingFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserCrimeDetailsShoplifting &&
            (identical(other.averageNotoriety, averageNotoriety) ||
                const DeepCollectionEquality().equals(
                  other.averageNotoriety,
                  averageNotoriety,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(averageNotoriety) ^ runtimeType.hashCode;
}

extension $UserCrimeDetailsShopliftingExtension on UserCrimeDetailsShoplifting {
  UserCrimeDetailsShoplifting copyWith({int? averageNotoriety}) {
    return UserCrimeDetailsShoplifting(
      averageNotoriety: averageNotoriety ?? this.averageNotoriety,
    );
  }

  UserCrimeDetailsShoplifting copyWithWrapped({
    Wrapped<int>? averageNotoriety,
  }) {
    return UserCrimeDetailsShoplifting(
      averageNotoriety: (averageNotoriety != null ? averageNotoriety.value : this.averageNotoriety),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserCrimeDetailsCardSkimming {
  const UserCrimeDetailsCardSkimming({
    required this.cardDetails,
    required this.skimmers,
  });

  factory UserCrimeDetailsCardSkimming.fromJson(Map<String, dynamic> json) =>
      _$UserCrimeDetailsCardSkimmingFromJson(json);

  static const toJsonFactory = _$UserCrimeDetailsCardSkimmingToJson;
  Map<String, dynamic> toJson() => _$UserCrimeDetailsCardSkimmingToJson(this);

  @JsonKey(name: 'card_details')
  final UserCrimeDetailsCardSkimming$CardDetails cardDetails;
  @JsonKey(name: 'skimmers')
  final UserCrimeDetailsCardSkimming$Skimmers skimmers;
  static const fromJsonFactory = _$UserCrimeDetailsCardSkimmingFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserCrimeDetailsCardSkimming &&
            (identical(other.cardDetails, cardDetails) ||
                const DeepCollectionEquality().equals(
                  other.cardDetails,
                  cardDetails,
                )) &&
            (identical(other.skimmers, skimmers) ||
                const DeepCollectionEquality().equals(
                  other.skimmers,
                  skimmers,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(cardDetails) ^
      const DeepCollectionEquality().hash(skimmers) ^
      runtimeType.hashCode;
}

extension $UserCrimeDetailsCardSkimmingExtension on UserCrimeDetailsCardSkimming {
  UserCrimeDetailsCardSkimming copyWith({
    UserCrimeDetailsCardSkimming$CardDetails? cardDetails,
    UserCrimeDetailsCardSkimming$Skimmers? skimmers,
  }) {
    return UserCrimeDetailsCardSkimming(
      cardDetails: cardDetails ?? this.cardDetails,
      skimmers: skimmers ?? this.skimmers,
    );
  }

  UserCrimeDetailsCardSkimming copyWithWrapped({
    Wrapped<UserCrimeDetailsCardSkimming$CardDetails>? cardDetails,
    Wrapped<UserCrimeDetailsCardSkimming$Skimmers>? skimmers,
  }) {
    return UserCrimeDetailsCardSkimming(
      cardDetails: (cardDetails != null ? cardDetails.value : this.cardDetails),
      skimmers: (skimmers != null ? skimmers.value : this.skimmers),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserCrimeDetailsHustling {
  const UserCrimeDetailsHustling({
    required this.totalAudienceGathered,
    required this.biggestMoneyWon,
    required this.shillMoneyCollected,
    required this.pickpocketMoneyCollected,
  });

  factory UserCrimeDetailsHustling.fromJson(Map<String, dynamic> json) => _$UserCrimeDetailsHustlingFromJson(json);

  static const toJsonFactory = _$UserCrimeDetailsHustlingToJson;
  Map<String, dynamic> toJson() => _$UserCrimeDetailsHustlingToJson(this);

  @JsonKey(name: 'total_audience_gathered')
  final int totalAudienceGathered;
  @JsonKey(name: 'biggest_money_won')
  final int biggestMoneyWon;
  @JsonKey(name: 'shill_money_collected')
  final int shillMoneyCollected;
  @JsonKey(name: 'pickpocket_money_collected')
  final int pickpocketMoneyCollected;
  static const fromJsonFactory = _$UserCrimeDetailsHustlingFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserCrimeDetailsHustling &&
            (identical(other.totalAudienceGathered, totalAudienceGathered) ||
                const DeepCollectionEquality().equals(
                  other.totalAudienceGathered,
                  totalAudienceGathered,
                )) &&
            (identical(other.biggestMoneyWon, biggestMoneyWon) ||
                const DeepCollectionEquality().equals(
                  other.biggestMoneyWon,
                  biggestMoneyWon,
                )) &&
            (identical(other.shillMoneyCollected, shillMoneyCollected) ||
                const DeepCollectionEquality().equals(
                  other.shillMoneyCollected,
                  shillMoneyCollected,
                )) &&
            (identical(
                  other.pickpocketMoneyCollected,
                  pickpocketMoneyCollected,
                ) ||
                const DeepCollectionEquality().equals(
                  other.pickpocketMoneyCollected,
                  pickpocketMoneyCollected,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(totalAudienceGathered) ^
      const DeepCollectionEquality().hash(biggestMoneyWon) ^
      const DeepCollectionEquality().hash(shillMoneyCollected) ^
      const DeepCollectionEquality().hash(pickpocketMoneyCollected) ^
      runtimeType.hashCode;
}

extension $UserCrimeDetailsHustlingExtension on UserCrimeDetailsHustling {
  UserCrimeDetailsHustling copyWith({
    int? totalAudienceGathered,
    int? biggestMoneyWon,
    int? shillMoneyCollected,
    int? pickpocketMoneyCollected,
  }) {
    return UserCrimeDetailsHustling(
      totalAudienceGathered: totalAudienceGathered ?? this.totalAudienceGathered,
      biggestMoneyWon: biggestMoneyWon ?? this.biggestMoneyWon,
      shillMoneyCollected: shillMoneyCollected ?? this.shillMoneyCollected,
      pickpocketMoneyCollected: pickpocketMoneyCollected ?? this.pickpocketMoneyCollected,
    );
  }

  UserCrimeDetailsHustling copyWithWrapped({
    Wrapped<int>? totalAudienceGathered,
    Wrapped<int>? biggestMoneyWon,
    Wrapped<int>? shillMoneyCollected,
    Wrapped<int>? pickpocketMoneyCollected,
  }) {
    return UserCrimeDetailsHustling(
      totalAudienceGathered: (totalAudienceGathered != null ? totalAudienceGathered.value : this.totalAudienceGathered),
      biggestMoneyWon: (biggestMoneyWon != null ? biggestMoneyWon.value : this.biggestMoneyWon),
      shillMoneyCollected: (shillMoneyCollected != null ? shillMoneyCollected.value : this.shillMoneyCollected),
      pickpocketMoneyCollected:
          (pickpocketMoneyCollected != null ? pickpocketMoneyCollected.value : this.pickpocketMoneyCollected),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserCrimeDetailsCracking {
  const UserCrimeDetailsCracking({
    required this.bruteForceCycles,
    required this.encryptionLayersBroken,
    required this.highestMips,
    required this.charsGuessed,
    required this.charsGuessedTotal,
  });

  factory UserCrimeDetailsCracking.fromJson(Map<String, dynamic> json) => _$UserCrimeDetailsCrackingFromJson(json);

  static const toJsonFactory = _$UserCrimeDetailsCrackingToJson;
  Map<String, dynamic> toJson() => _$UserCrimeDetailsCrackingToJson(this);

  @JsonKey(name: 'brute_force_cycles')
  final int bruteForceCycles;
  @JsonKey(name: 'encryption_layers_broken')
  final int encryptionLayersBroken;
  @JsonKey(name: 'highest_mips')
  final int highestMips;
  @JsonKey(name: 'chars_guessed')
  final int charsGuessed;
  @JsonKey(name: 'chars_guessed_total')
  final int charsGuessedTotal;
  static const fromJsonFactory = _$UserCrimeDetailsCrackingFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserCrimeDetailsCracking &&
            (identical(other.bruteForceCycles, bruteForceCycles) ||
                const DeepCollectionEquality().equals(
                  other.bruteForceCycles,
                  bruteForceCycles,
                )) &&
            (identical(other.encryptionLayersBroken, encryptionLayersBroken) ||
                const DeepCollectionEquality().equals(
                  other.encryptionLayersBroken,
                  encryptionLayersBroken,
                )) &&
            (identical(other.highestMips, highestMips) ||
                const DeepCollectionEquality().equals(
                  other.highestMips,
                  highestMips,
                )) &&
            (identical(other.charsGuessed, charsGuessed) ||
                const DeepCollectionEquality().equals(
                  other.charsGuessed,
                  charsGuessed,
                )) &&
            (identical(other.charsGuessedTotal, charsGuessedTotal) ||
                const DeepCollectionEquality().equals(
                  other.charsGuessedTotal,
                  charsGuessedTotal,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(bruteForceCycles) ^
      const DeepCollectionEquality().hash(encryptionLayersBroken) ^
      const DeepCollectionEquality().hash(highestMips) ^
      const DeepCollectionEquality().hash(charsGuessed) ^
      const DeepCollectionEquality().hash(charsGuessedTotal) ^
      runtimeType.hashCode;
}

extension $UserCrimeDetailsCrackingExtension on UserCrimeDetailsCracking {
  UserCrimeDetailsCracking copyWith({
    int? bruteForceCycles,
    int? encryptionLayersBroken,
    int? highestMips,
    int? charsGuessed,
    int? charsGuessedTotal,
  }) {
    return UserCrimeDetailsCracking(
      bruteForceCycles: bruteForceCycles ?? this.bruteForceCycles,
      encryptionLayersBroken: encryptionLayersBroken ?? this.encryptionLayersBroken,
      highestMips: highestMips ?? this.highestMips,
      charsGuessed: charsGuessed ?? this.charsGuessed,
      charsGuessedTotal: charsGuessedTotal ?? this.charsGuessedTotal,
    );
  }

  UserCrimeDetailsCracking copyWithWrapped({
    Wrapped<int>? bruteForceCycles,
    Wrapped<int>? encryptionLayersBroken,
    Wrapped<int>? highestMips,
    Wrapped<int>? charsGuessed,
    Wrapped<int>? charsGuessedTotal,
  }) {
    return UserCrimeDetailsCracking(
      bruteForceCycles: (bruteForceCycles != null ? bruteForceCycles.value : this.bruteForceCycles),
      encryptionLayersBroken:
          (encryptionLayersBroken != null ? encryptionLayersBroken.value : this.encryptionLayersBroken),
      highestMips: (highestMips != null ? highestMips.value : this.highestMips),
      charsGuessed: (charsGuessed != null ? charsGuessed.value : this.charsGuessed),
      charsGuessedTotal: (charsGuessedTotal != null ? charsGuessedTotal.value : this.charsGuessedTotal),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserCrimeDetailsScamming {
  const UserCrimeDetailsScamming({
    required this.mostResponses,
    required this.zones,
    required this.concerns,
    required this.payouts,
    required this.emails,
  });

  factory UserCrimeDetailsScamming.fromJson(Map<String, dynamic> json) => _$UserCrimeDetailsScammingFromJson(json);

  static const toJsonFactory = _$UserCrimeDetailsScammingToJson;
  Map<String, dynamic> toJson() => _$UserCrimeDetailsScammingToJson(this);

  @JsonKey(name: 'most_responses')
  final int mostResponses;
  @JsonKey(name: 'zones')
  final UserCrimeDetailsScamming$Zones zones;
  @JsonKey(name: 'concerns')
  final UserCrimeDetailsScamming$Concerns concerns;
  @JsonKey(name: 'payouts')
  final UserCrimeDetailsScamming$Payouts payouts;
  @JsonKey(name: 'emails')
  final UserCrimeDetailsScamming$Emails emails;
  static const fromJsonFactory = _$UserCrimeDetailsScammingFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserCrimeDetailsScamming &&
            (identical(other.mostResponses, mostResponses) ||
                const DeepCollectionEquality().equals(
                  other.mostResponses,
                  mostResponses,
                )) &&
            (identical(other.zones, zones) || const DeepCollectionEquality().equals(other.zones, zones)) &&
            (identical(other.concerns, concerns) ||
                const DeepCollectionEquality().equals(
                  other.concerns,
                  concerns,
                )) &&
            (identical(other.payouts, payouts) ||
                const DeepCollectionEquality().equals(
                  other.payouts,
                  payouts,
                )) &&
            (identical(other.emails, emails) || const DeepCollectionEquality().equals(other.emails, emails)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(mostResponses) ^
      const DeepCollectionEquality().hash(zones) ^
      const DeepCollectionEquality().hash(concerns) ^
      const DeepCollectionEquality().hash(payouts) ^
      const DeepCollectionEquality().hash(emails) ^
      runtimeType.hashCode;
}

extension $UserCrimeDetailsScammingExtension on UserCrimeDetailsScamming {
  UserCrimeDetailsScamming copyWith({
    int? mostResponses,
    UserCrimeDetailsScamming$Zones? zones,
    UserCrimeDetailsScamming$Concerns? concerns,
    UserCrimeDetailsScamming$Payouts? payouts,
    UserCrimeDetailsScamming$Emails? emails,
  }) {
    return UserCrimeDetailsScamming(
      mostResponses: mostResponses ?? this.mostResponses,
      zones: zones ?? this.zones,
      concerns: concerns ?? this.concerns,
      payouts: payouts ?? this.payouts,
      emails: emails ?? this.emails,
    );
  }

  UserCrimeDetailsScamming copyWithWrapped({
    Wrapped<int>? mostResponses,
    Wrapped<UserCrimeDetailsScamming$Zones>? zones,
    Wrapped<UserCrimeDetailsScamming$Concerns>? concerns,
    Wrapped<UserCrimeDetailsScamming$Payouts>? payouts,
    Wrapped<UserCrimeDetailsScamming$Emails>? emails,
  }) {
    return UserCrimeDetailsScamming(
      mostResponses: (mostResponses != null ? mostResponses.value : this.mostResponses),
      zones: (zones != null ? zones.value : this.zones),
      concerns: (concerns != null ? concerns.value : this.concerns),
      payouts: (payouts != null ? payouts.value : this.payouts),
      emails: (emails != null ? emails.value : this.emails),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserSubcrime {
  const UserSubcrime({
    required this.id,
    required this.total,
    required this.success,
    required this.fail,
  });

  factory UserSubcrime.fromJson(Map<String, dynamic> json) => _$UserSubcrimeFromJson(json);

  static const toJsonFactory = _$UserSubcrimeToJson;
  Map<String, dynamic> toJson() => _$UserSubcrimeToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'total')
  final int total;
  @JsonKey(name: 'success')
  final int success;
  @JsonKey(name: 'fail')
  final int fail;
  static const fromJsonFactory = _$UserSubcrimeFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserSubcrime &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.total, total) || const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.success, success) ||
                const DeepCollectionEquality().equals(
                  other.success,
                  success,
                )) &&
            (identical(other.fail, fail) || const DeepCollectionEquality().equals(other.fail, fail)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(success) ^
      const DeepCollectionEquality().hash(fail) ^
      runtimeType.hashCode;
}

extension $UserSubcrimeExtension on UserSubcrime {
  UserSubcrime copyWith({int? id, int? total, int? success, int? fail}) {
    return UserSubcrime(
      id: id ?? this.id,
      total: total ?? this.total,
      success: success ?? this.success,
      fail: fail ?? this.fail,
    );
  }

  UserSubcrime copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<int>? total,
    Wrapped<int>? success,
    Wrapped<int>? fail,
  }) {
    return UserSubcrime(
      id: (id != null ? id.value : this.id),
      total: (total != null ? total.value : this.total),
      success: (success != null ? success.value : this.success),
      fail: (fail != null ? fail.value : this.fail),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserCrimeRewardAmmo {
  const UserCrimeRewardAmmo({required this.standard, required this.special});

  factory UserCrimeRewardAmmo.fromJson(Map<String, dynamic> json) => _$UserCrimeRewardAmmoFromJson(json);

  static const toJsonFactory = _$UserCrimeRewardAmmoToJson;
  Map<String, dynamic> toJson() => _$UserCrimeRewardAmmoToJson(this);

  @JsonKey(name: 'standard')
  final int standard;
  @JsonKey(name: 'special')
  final int special;
  static const fromJsonFactory = _$UserCrimeRewardAmmoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserCrimeRewardAmmo &&
            (identical(other.standard, standard) ||
                const DeepCollectionEquality().equals(
                  other.standard,
                  standard,
                )) &&
            (identical(other.special, special) || const DeepCollectionEquality().equals(other.special, special)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(standard) ^
      const DeepCollectionEquality().hash(special) ^
      runtimeType.hashCode;
}

extension $UserCrimeRewardAmmoExtension on UserCrimeRewardAmmo {
  UserCrimeRewardAmmo copyWith({int? standard, int? special}) {
    return UserCrimeRewardAmmo(
      standard: standard ?? this.standard,
      special: special ?? this.special,
    );
  }

  UserCrimeRewardAmmo copyWithWrapped({
    Wrapped<int>? standard,
    Wrapped<int>? special,
  }) {
    return UserCrimeRewardAmmo(
      standard: (standard != null ? standard.value : this.standard),
      special: (special != null ? special.value : this.special),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserCrimeRewardItem {
  const UserCrimeRewardItem({required this.id, required this.amount});

  factory UserCrimeRewardItem.fromJson(Map<String, dynamic> json) => _$UserCrimeRewardItemFromJson(json);

  static const toJsonFactory = _$UserCrimeRewardItemToJson;
  Map<String, dynamic> toJson() => _$UserCrimeRewardItemToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'amount')
  final int amount;
  static const fromJsonFactory = _$UserCrimeRewardItemFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserCrimeRewardItem &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.amount, amount) || const DeepCollectionEquality().equals(other.amount, amount)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^ const DeepCollectionEquality().hash(amount) ^ runtimeType.hashCode;
}

extension $UserCrimeRewardItemExtension on UserCrimeRewardItem {
  UserCrimeRewardItem copyWith({int? id, int? amount}) {
    return UserCrimeRewardItem(
      id: id ?? this.id,
      amount: amount ?? this.amount,
    );
  }

  UserCrimeRewardItem copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<int>? amount,
  }) {
    return UserCrimeRewardItem(
      id: (id != null ? id.value : this.id),
      amount: (amount != null ? amount.value : this.amount),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserCrimeRewards {
  const UserCrimeRewards({
    required this.money,
    required this.ammo,
    required this.items,
  });

  factory UserCrimeRewards.fromJson(Map<String, dynamic> json) => _$UserCrimeRewardsFromJson(json);

  static const toJsonFactory = _$UserCrimeRewardsToJson;
  Map<String, dynamic> toJson() => _$UserCrimeRewardsToJson(this);

  @JsonKey(name: 'money')
  final int money;
  @JsonKey(name: 'ammo')
  final UserCrimeRewardAmmo ammo;
  @JsonKey(name: 'items', defaultValue: <UserCrimeRewardItem>[])
  final List<UserCrimeRewardItem> items;
  static const fromJsonFactory = _$UserCrimeRewardsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserCrimeRewards &&
            (identical(other.money, money) || const DeepCollectionEquality().equals(other.money, money)) &&
            (identical(other.ammo, ammo) || const DeepCollectionEquality().equals(other.ammo, ammo)) &&
            (identical(other.items, items) || const DeepCollectionEquality().equals(other.items, items)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(money) ^
      const DeepCollectionEquality().hash(ammo) ^
      const DeepCollectionEquality().hash(items) ^
      runtimeType.hashCode;
}

extension $UserCrimeRewardsExtension on UserCrimeRewards {
  UserCrimeRewards copyWith({
    int? money,
    UserCrimeRewardAmmo? ammo,
    List<UserCrimeRewardItem>? items,
  }) {
    return UserCrimeRewards(
      money: money ?? this.money,
      ammo: ammo ?? this.ammo,
      items: items ?? this.items,
    );
  }

  UserCrimeRewards copyWithWrapped({
    Wrapped<int>? money,
    Wrapped<UserCrimeRewardAmmo>? ammo,
    Wrapped<List<UserCrimeRewardItem>>? items,
  }) {
    return UserCrimeRewards(
      money: (money != null ? money.value : this.money),
      ammo: (ammo != null ? ammo.value : this.ammo),
      items: (items != null ? items.value : this.items),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserCrimeAttempts {
  const UserCrimeAttempts({
    required this.total,
    required this.success,
    required this.fail,
    required this.criticalFail,
    required this.subcrimes,
  });

  factory UserCrimeAttempts.fromJson(Map<String, dynamic> json) => _$UserCrimeAttemptsFromJson(json);

  static const toJsonFactory = _$UserCrimeAttemptsToJson;
  Map<String, dynamic> toJson() => _$UserCrimeAttemptsToJson(this);

  @JsonKey(name: 'total')
  final int total;
  @JsonKey(name: 'success')
  final int success;
  @JsonKey(name: 'fail')
  final int fail;
  @JsonKey(name: 'critical_fail')
  final int criticalFail;
  @JsonKey(name: 'subcrimes', defaultValue: <UserSubcrime>[])
  final List<UserSubcrime> subcrimes;
  static const fromJsonFactory = _$UserCrimeAttemptsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserCrimeAttempts &&
            (identical(other.total, total) || const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.success, success) ||
                const DeepCollectionEquality().equals(
                  other.success,
                  success,
                )) &&
            (identical(other.fail, fail) || const DeepCollectionEquality().equals(other.fail, fail)) &&
            (identical(other.criticalFail, criticalFail) ||
                const DeepCollectionEquality().equals(
                  other.criticalFail,
                  criticalFail,
                )) &&
            (identical(other.subcrimes, subcrimes) ||
                const DeepCollectionEquality().equals(
                  other.subcrimes,
                  subcrimes,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(success) ^
      const DeepCollectionEquality().hash(fail) ^
      const DeepCollectionEquality().hash(criticalFail) ^
      const DeepCollectionEquality().hash(subcrimes) ^
      runtimeType.hashCode;
}

extension $UserCrimeAttemptsExtension on UserCrimeAttempts {
  UserCrimeAttempts copyWith({
    int? total,
    int? success,
    int? fail,
    int? criticalFail,
    List<UserSubcrime>? subcrimes,
  }) {
    return UserCrimeAttempts(
      total: total ?? this.total,
      success: success ?? this.success,
      fail: fail ?? this.fail,
      criticalFail: criticalFail ?? this.criticalFail,
      subcrimes: subcrimes ?? this.subcrimes,
    );
  }

  UserCrimeAttempts copyWithWrapped({
    Wrapped<int>? total,
    Wrapped<int>? success,
    Wrapped<int>? fail,
    Wrapped<int>? criticalFail,
    Wrapped<List<UserSubcrime>>? subcrimes,
  }) {
    return UserCrimeAttempts(
      total: (total != null ? total.value : this.total),
      success: (success != null ? success.value : this.success),
      fail: (fail != null ? fail.value : this.fail),
      criticalFail: (criticalFail != null ? criticalFail.value : this.criticalFail),
      subcrimes: (subcrimes != null ? subcrimes.value : this.subcrimes),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserCrimeUniquesRewardMoney {
  const UserCrimeUniquesRewardMoney({required this.min, required this.max});

  factory UserCrimeUniquesRewardMoney.fromJson(Map<String, dynamic> json) =>
      _$UserCrimeUniquesRewardMoneyFromJson(json);

  static const toJsonFactory = _$UserCrimeUniquesRewardMoneyToJson;
  Map<String, dynamic> toJson() => _$UserCrimeUniquesRewardMoneyToJson(this);

  @JsonKey(name: 'min')
  final int min;
  @JsonKey(name: 'max')
  final int max;
  static const fromJsonFactory = _$UserCrimeUniquesRewardMoneyFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserCrimeUniquesRewardMoney &&
            (identical(other.min, min) || const DeepCollectionEquality().equals(other.min, min)) &&
            (identical(other.max, max) || const DeepCollectionEquality().equals(other.max, max)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(min) ^ const DeepCollectionEquality().hash(max) ^ runtimeType.hashCode;
}

extension $UserCrimeUniquesRewardMoneyExtension on UserCrimeUniquesRewardMoney {
  UserCrimeUniquesRewardMoney copyWith({int? min, int? max}) {
    return UserCrimeUniquesRewardMoney(
      min: min ?? this.min,
      max: max ?? this.max,
    );
  }

  UserCrimeUniquesRewardMoney copyWithWrapped({
    Wrapped<int>? min,
    Wrapped<int>? max,
  }) {
    return UserCrimeUniquesRewardMoney(
      min: (min != null ? min.value : this.min),
      max: (max != null ? max.value : this.max),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserCrimeUniquesRewardAmmo {
  const UserCrimeUniquesRewardAmmo({required this.amount, required this.type});

  factory UserCrimeUniquesRewardAmmo.fromJson(Map<String, dynamic> json) => _$UserCrimeUniquesRewardAmmoFromJson(json);

  static const toJsonFactory = _$UserCrimeUniquesRewardAmmoToJson;
  Map<String, dynamic> toJson() => _$UserCrimeUniquesRewardAmmoToJson(this);

  @JsonKey(name: 'amount')
  final int amount;
  @JsonKey(
    name: 'type',
    toJson: userCrimeUniquesRewardAmmoEnumToJson,
    fromJson: userCrimeUniquesRewardAmmoEnumFromJson,
  )
  final enums.UserCrimeUniquesRewardAmmoEnum type;
  static const fromJsonFactory = _$UserCrimeUniquesRewardAmmoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserCrimeUniquesRewardAmmo &&
            (identical(other.amount, amount) || const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.type, type) || const DeepCollectionEquality().equals(other.type, type)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(amount) ^ const DeepCollectionEquality().hash(type) ^ runtimeType.hashCode;
}

extension $UserCrimeUniquesRewardAmmoExtension on UserCrimeUniquesRewardAmmo {
  UserCrimeUniquesRewardAmmo copyWith({
    int? amount,
    enums.UserCrimeUniquesRewardAmmoEnum? type,
  }) {
    return UserCrimeUniquesRewardAmmo(
      amount: amount ?? this.amount,
      type: type ?? this.type,
    );
  }

  UserCrimeUniquesRewardAmmo copyWithWrapped({
    Wrapped<int>? amount,
    Wrapped<enums.UserCrimeUniquesRewardAmmoEnum>? type,
  }) {
    return UserCrimeUniquesRewardAmmo(
      amount: (amount != null ? amount.value : this.amount),
      type: (type != null ? type.value : this.type),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserCrimeUniquesReward {
  const UserCrimeUniquesReward({
    required this.items,
    required this.money,
    required this.ammo,
  });

  factory UserCrimeUniquesReward.fromJson(Map<String, dynamic> json) => _$UserCrimeUniquesRewardFromJson(json);

  static const toJsonFactory = _$UserCrimeUniquesRewardToJson;
  Map<String, dynamic> toJson() => _$UserCrimeUniquesRewardToJson(this);

  @JsonKey(name: 'items', defaultValue: <UserCrimeRewardItem>[])
  final List<UserCrimeRewardItem> items;
  @JsonKey(name: 'money')
  final dynamic money;
  @JsonKey(name: 'ammo')
  final dynamic ammo;
  static const fromJsonFactory = _$UserCrimeUniquesRewardFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserCrimeUniquesReward &&
            (identical(other.items, items) || const DeepCollectionEquality().equals(other.items, items)) &&
            (identical(other.money, money) || const DeepCollectionEquality().equals(other.money, money)) &&
            (identical(other.ammo, ammo) || const DeepCollectionEquality().equals(other.ammo, ammo)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(items) ^
      const DeepCollectionEquality().hash(money) ^
      const DeepCollectionEquality().hash(ammo) ^
      runtimeType.hashCode;
}

extension $UserCrimeUniquesRewardExtension on UserCrimeUniquesReward {
  UserCrimeUniquesReward copyWith({
    List<UserCrimeRewardItem>? items,
    dynamic money,
    dynamic ammo,
  }) {
    return UserCrimeUniquesReward(
      items: items ?? this.items,
      money: money ?? this.money,
      ammo: ammo ?? this.ammo,
    );
  }

  UserCrimeUniquesReward copyWithWrapped({
    Wrapped<List<UserCrimeRewardItem>>? items,
    Wrapped<dynamic>? money,
    Wrapped<dynamic>? ammo,
  }) {
    return UserCrimeUniquesReward(
      items: (items != null ? items.value : this.items),
      money: (money != null ? money.value : this.money),
      ammo: (ammo != null ? ammo.value : this.ammo),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserCrimeUniques {
  const UserCrimeUniques({required this.id, required this.rewards});

  factory UserCrimeUniques.fromJson(Map<String, dynamic> json) => _$UserCrimeUniquesFromJson(json);

  static const toJsonFactory = _$UserCrimeUniquesToJson;
  Map<String, dynamic> toJson() => _$UserCrimeUniquesToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'rewards')
  final UserCrimeUniquesReward rewards;
  static const fromJsonFactory = _$UserCrimeUniquesFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserCrimeUniques &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.rewards, rewards) || const DeepCollectionEquality().equals(other.rewards, rewards)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^ const DeepCollectionEquality().hash(rewards) ^ runtimeType.hashCode;
}

extension $UserCrimeUniquesExtension on UserCrimeUniques {
  UserCrimeUniques copyWith({int? id, UserCrimeUniquesReward? rewards}) {
    return UserCrimeUniques(
      id: id ?? this.id,
      rewards: rewards ?? this.rewards,
    );
  }

  UserCrimeUniques copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<UserCrimeUniquesReward>? rewards,
  }) {
    return UserCrimeUniques(
      id: (id != null ? id.value : this.id),
      rewards: (rewards != null ? rewards.value : this.rewards),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserCrimesResponse {
  const UserCrimesResponse({required this.crimes});

  factory UserCrimesResponse.fromJson(Map<String, dynamic> json) => _$UserCrimesResponseFromJson(json);

  static const toJsonFactory = _$UserCrimesResponseToJson;
  Map<String, dynamic> toJson() => _$UserCrimesResponseToJson(this);

  @JsonKey(name: 'crimes')
  final UserCrime crimes;
  static const fromJsonFactory = _$UserCrimesResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserCrimesResponse &&
            (identical(other.crimes, crimes) || const DeepCollectionEquality().equals(other.crimes, crimes)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(crimes) ^ runtimeType.hashCode;
}

extension $UserCrimesResponseExtension on UserCrimesResponse {
  UserCrimesResponse copyWith({UserCrime? crimes}) {
    return UserCrimesResponse(crimes: crimes ?? this.crimes);
  }

  UserCrimesResponse copyWithWrapped({Wrapped<UserCrime>? crimes}) {
    return UserCrimesResponse(
      crimes: (crimes != null ? crimes.value : this.crimes),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserCrime {
  const UserCrime({
    required this.nerveSpent,
    required this.skill,
    required this.progressionBonus,
    required this.rewards,
    required this.attempts,
    required this.uniques,
    required this.miscellaneous,
  });

  factory UserCrime.fromJson(Map<String, dynamic> json) => _$UserCrimeFromJson(json);

  static const toJsonFactory = _$UserCrimeToJson;
  Map<String, dynamic> toJson() => _$UserCrimeToJson(this);

  @JsonKey(name: 'nerve_spent')
  final int nerveSpent;
  @JsonKey(name: 'skill')
  final int skill;
  @JsonKey(name: 'progression_bonus')
  final int progressionBonus;
  @JsonKey(name: 'rewards')
  final UserCrimeRewards rewards;
  @JsonKey(name: 'attempts')
  final UserCrimeAttempts attempts;
  @JsonKey(name: 'uniques', defaultValue: <UserCrimeUniques>[])
  final List<UserCrimeUniques> uniques;
  @JsonKey(name: 'miscellaneous')
  final dynamic miscellaneous;
  static const fromJsonFactory = _$UserCrimeFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserCrime &&
            (identical(other.nerveSpent, nerveSpent) ||
                const DeepCollectionEquality().equals(
                  other.nerveSpent,
                  nerveSpent,
                )) &&
            (identical(other.skill, skill) || const DeepCollectionEquality().equals(other.skill, skill)) &&
            (identical(other.progressionBonus, progressionBonus) ||
                const DeepCollectionEquality().equals(
                  other.progressionBonus,
                  progressionBonus,
                )) &&
            (identical(other.rewards, rewards) ||
                const DeepCollectionEquality().equals(
                  other.rewards,
                  rewards,
                )) &&
            (identical(other.attempts, attempts) ||
                const DeepCollectionEquality().equals(
                  other.attempts,
                  attempts,
                )) &&
            (identical(other.uniques, uniques) ||
                const DeepCollectionEquality().equals(
                  other.uniques,
                  uniques,
                )) &&
            (identical(other.miscellaneous, miscellaneous) ||
                const DeepCollectionEquality().equals(
                  other.miscellaneous,
                  miscellaneous,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(nerveSpent) ^
      const DeepCollectionEquality().hash(skill) ^
      const DeepCollectionEquality().hash(progressionBonus) ^
      const DeepCollectionEquality().hash(rewards) ^
      const DeepCollectionEquality().hash(attempts) ^
      const DeepCollectionEquality().hash(uniques) ^
      const DeepCollectionEquality().hash(miscellaneous) ^
      runtimeType.hashCode;
}

extension $UserCrimeExtension on UserCrime {
  UserCrime copyWith({
    int? nerveSpent,
    int? skill,
    int? progressionBonus,
    UserCrimeRewards? rewards,
    UserCrimeAttempts? attempts,
    List<UserCrimeUniques>? uniques,
    dynamic miscellaneous,
  }) {
    return UserCrime(
      nerveSpent: nerveSpent ?? this.nerveSpent,
      skill: skill ?? this.skill,
      progressionBonus: progressionBonus ?? this.progressionBonus,
      rewards: rewards ?? this.rewards,
      attempts: attempts ?? this.attempts,
      uniques: uniques ?? this.uniques,
      miscellaneous: miscellaneous ?? this.miscellaneous,
    );
  }

  UserCrime copyWithWrapped({
    Wrapped<int>? nerveSpent,
    Wrapped<int>? skill,
    Wrapped<int>? progressionBonus,
    Wrapped<UserCrimeRewards>? rewards,
    Wrapped<UserCrimeAttempts>? attempts,
    Wrapped<List<UserCrimeUniques>>? uniques,
    Wrapped<dynamic>? miscellaneous,
  }) {
    return UserCrime(
      nerveSpent: (nerveSpent != null ? nerveSpent.value : this.nerveSpent),
      skill: (skill != null ? skill.value : this.skill),
      progressionBonus: (progressionBonus != null ? progressionBonus.value : this.progressionBonus),
      rewards: (rewards != null ? rewards.value : this.rewards),
      attempts: (attempts != null ? attempts.value : this.attempts),
      uniques: (uniques != null ? uniques.value : this.uniques),
      miscellaneous: (miscellaneous != null ? miscellaneous.value : this.miscellaneous),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserRacesResponse {
  const UserRacesResponse({required this.races, required this.metadata});

  factory UserRacesResponse.fromJson(Map<String, dynamic> json) => _$UserRacesResponseFromJson(json);

  static const toJsonFactory = _$UserRacesResponseToJson;
  Map<String, dynamic> toJson() => _$UserRacesResponseToJson(this);

  @JsonKey(name: 'races', defaultValue: <RacingRaceDetails>[])
  final List<RacingRaceDetails> races;
  @JsonKey(name: '_metadata')
  final RequestMetadataWithLinks metadata;
  static const fromJsonFactory = _$UserRacesResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserRacesResponse &&
            (identical(other.races, races) || const DeepCollectionEquality().equals(other.races, races)) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality().equals(
                  other.metadata,
                  metadata,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(races) ^ const DeepCollectionEquality().hash(metadata) ^ runtimeType.hashCode;
}

extension $UserRacesResponseExtension on UserRacesResponse {
  UserRacesResponse copyWith({
    List<RacingRaceDetails>? races,
    RequestMetadataWithLinks? metadata,
  }) {
    return UserRacesResponse(
      races: races ?? this.races,
      metadata: metadata ?? this.metadata,
    );
  }

  UserRacesResponse copyWithWrapped({
    Wrapped<List<RacingRaceDetails>>? races,
    Wrapped<RequestMetadataWithLinks>? metadata,
  }) {
    return UserRacesResponse(
      races: (races != null ? races.value : this.races),
      metadata: (metadata != null ? metadata.value : this.metadata),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserRaceCarDetails {
  const UserRaceCarDetails({
    required this.id,
    required this.name,
    required this.worth,
    required this.pointsSpent,
    required this.racesEntered,
    required this.racesWon,
    required this.isRemoved,
    required this.parts,
    required this.carItemId,
    required this.carItemName,
    required this.topSpeed,
    required this.acceleration,
    required this.braking,
    required this.dirt,
    required this.handling,
    required this.safety,
    required this.tarmac,
    required this.$class,
  });

  factory UserRaceCarDetails.fromJson(Map<String, dynamic> json) => _$UserRaceCarDetailsFromJson(json);

  static const toJsonFactory = _$UserRaceCarDetailsToJson;
  Map<String, dynamic> toJson() => _$UserRaceCarDetailsToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'name')
  final dynamic name;
  @JsonKey(name: 'worth')
  final int worth;
  @JsonKey(name: 'points_spent')
  final int pointsSpent;
  @JsonKey(name: 'races_entered')
  final int racesEntered;
  @JsonKey(name: 'races_won')
  final int racesWon;
  @JsonKey(name: 'is_removed')
  final bool isRemoved;
  @JsonKey(name: 'parts', defaultValue: <int>[])
  final List<int> parts;
  @JsonKey(name: 'car_item_id')
  final int carItemId;
  @JsonKey(name: 'car_item_name')
  final String carItemName;
  @JsonKey(name: 'top_speed')
  final int topSpeed;
  @JsonKey(name: 'acceleration')
  final int acceleration;
  @JsonKey(name: 'braking')
  final int braking;
  @JsonKey(name: 'dirt')
  final int dirt;
  @JsonKey(name: 'handling')
  final int handling;
  @JsonKey(name: 'safety')
  final int safety;
  @JsonKey(name: 'tarmac')
  final int tarmac;
  @JsonKey(
    name: 'class',
    toJson: raceClassEnumToJson,
    fromJson: raceClassEnumFromJson,
  )
  final enums.RaceClassEnum $class;
  static const fromJsonFactory = _$UserRaceCarDetailsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserRaceCarDetails &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.worth, worth) || const DeepCollectionEquality().equals(other.worth, worth)) &&
            (identical(other.pointsSpent, pointsSpent) ||
                const DeepCollectionEquality().equals(
                  other.pointsSpent,
                  pointsSpent,
                )) &&
            (identical(other.racesEntered, racesEntered) ||
                const DeepCollectionEquality().equals(
                  other.racesEntered,
                  racesEntered,
                )) &&
            (identical(other.racesWon, racesWon) ||
                const DeepCollectionEquality().equals(
                  other.racesWon,
                  racesWon,
                )) &&
            (identical(other.isRemoved, isRemoved) ||
                const DeepCollectionEquality().equals(
                  other.isRemoved,
                  isRemoved,
                )) &&
            (identical(other.parts, parts) || const DeepCollectionEquality().equals(other.parts, parts)) &&
            (identical(other.carItemId, carItemId) ||
                const DeepCollectionEquality().equals(
                  other.carItemId,
                  carItemId,
                )) &&
            (identical(other.carItemName, carItemName) ||
                const DeepCollectionEquality().equals(
                  other.carItemName,
                  carItemName,
                )) &&
            (identical(other.topSpeed, topSpeed) ||
                const DeepCollectionEquality().equals(
                  other.topSpeed,
                  topSpeed,
                )) &&
            (identical(other.acceleration, acceleration) ||
                const DeepCollectionEquality().equals(
                  other.acceleration,
                  acceleration,
                )) &&
            (identical(other.braking, braking) ||
                const DeepCollectionEquality().equals(
                  other.braking,
                  braking,
                )) &&
            (identical(other.dirt, dirt) || const DeepCollectionEquality().equals(other.dirt, dirt)) &&
            (identical(other.handling, handling) ||
                const DeepCollectionEquality().equals(
                  other.handling,
                  handling,
                )) &&
            (identical(other.safety, safety) || const DeepCollectionEquality().equals(other.safety, safety)) &&
            (identical(other.tarmac, tarmac) || const DeepCollectionEquality().equals(other.tarmac, tarmac)) &&
            (identical(other.$class, $class) || const DeepCollectionEquality().equals(other.$class, $class)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(worth) ^
      const DeepCollectionEquality().hash(pointsSpent) ^
      const DeepCollectionEquality().hash(racesEntered) ^
      const DeepCollectionEquality().hash(racesWon) ^
      const DeepCollectionEquality().hash(isRemoved) ^
      const DeepCollectionEquality().hash(parts) ^
      const DeepCollectionEquality().hash(carItemId) ^
      const DeepCollectionEquality().hash(carItemName) ^
      const DeepCollectionEquality().hash(topSpeed) ^
      const DeepCollectionEquality().hash(acceleration) ^
      const DeepCollectionEquality().hash(braking) ^
      const DeepCollectionEquality().hash(dirt) ^
      const DeepCollectionEquality().hash(handling) ^
      const DeepCollectionEquality().hash(safety) ^
      const DeepCollectionEquality().hash(tarmac) ^
      const DeepCollectionEquality().hash($class) ^
      runtimeType.hashCode;
}

extension $UserRaceCarDetailsExtension on UserRaceCarDetails {
  UserRaceCarDetails copyWith({
    int? id,
    dynamic name,
    int? worth,
    int? pointsSpent,
    int? racesEntered,
    int? racesWon,
    bool? isRemoved,
    List<int>? parts,
    int? carItemId,
    String? carItemName,
    int? topSpeed,
    int? acceleration,
    int? braking,
    int? dirt,
    int? handling,
    int? safety,
    int? tarmac,
    enums.RaceClassEnum? $class,
  }) {
    return UserRaceCarDetails(
      id: id ?? this.id,
      name: name ?? this.name,
      worth: worth ?? this.worth,
      pointsSpent: pointsSpent ?? this.pointsSpent,
      racesEntered: racesEntered ?? this.racesEntered,
      racesWon: racesWon ?? this.racesWon,
      isRemoved: isRemoved ?? this.isRemoved,
      parts: parts ?? this.parts,
      carItemId: carItemId ?? this.carItemId,
      carItemName: carItemName ?? this.carItemName,
      topSpeed: topSpeed ?? this.topSpeed,
      acceleration: acceleration ?? this.acceleration,
      braking: braking ?? this.braking,
      dirt: dirt ?? this.dirt,
      handling: handling ?? this.handling,
      safety: safety ?? this.safety,
      tarmac: tarmac ?? this.tarmac,
      $class: $class ?? this.$class,
    );
  }

  UserRaceCarDetails copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<dynamic>? name,
    Wrapped<int>? worth,
    Wrapped<int>? pointsSpent,
    Wrapped<int>? racesEntered,
    Wrapped<int>? racesWon,
    Wrapped<bool>? isRemoved,
    Wrapped<List<int>>? parts,
    Wrapped<int>? carItemId,
    Wrapped<String>? carItemName,
    Wrapped<int>? topSpeed,
    Wrapped<int>? acceleration,
    Wrapped<int>? braking,
    Wrapped<int>? dirt,
    Wrapped<int>? handling,
    Wrapped<int>? safety,
    Wrapped<int>? tarmac,
    Wrapped<enums.RaceClassEnum>? $class,
  }) {
    return UserRaceCarDetails(
      id: (id != null ? id.value : this.id),
      name: (name != null ? name.value : this.name),
      worth: (worth != null ? worth.value : this.worth),
      pointsSpent: (pointsSpent != null ? pointsSpent.value : this.pointsSpent),
      racesEntered: (racesEntered != null ? racesEntered.value : this.racesEntered),
      racesWon: (racesWon != null ? racesWon.value : this.racesWon),
      isRemoved: (isRemoved != null ? isRemoved.value : this.isRemoved),
      parts: (parts != null ? parts.value : this.parts),
      carItemId: (carItemId != null ? carItemId.value : this.carItemId),
      carItemName: (carItemName != null ? carItemName.value : this.carItemName),
      topSpeed: (topSpeed != null ? topSpeed.value : this.topSpeed),
      acceleration: (acceleration != null ? acceleration.value : this.acceleration),
      braking: (braking != null ? braking.value : this.braking),
      dirt: (dirt != null ? dirt.value : this.dirt),
      handling: (handling != null ? handling.value : this.handling),
      safety: (safety != null ? safety.value : this.safety),
      tarmac: (tarmac != null ? tarmac.value : this.tarmac),
      $class: ($class != null ? $class.value : this.$class),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserEnlistedCarsResponse {
  const UserEnlistedCarsResponse({required this.enlistedcars});

  factory UserEnlistedCarsResponse.fromJson(Map<String, dynamic> json) => _$UserEnlistedCarsResponseFromJson(json);

  static const toJsonFactory = _$UserEnlistedCarsResponseToJson;
  Map<String, dynamic> toJson() => _$UserEnlistedCarsResponseToJson(this);

  @JsonKey(name: 'enlistedcars', defaultValue: <UserRaceCarDetails>[])
  final List<UserRaceCarDetails> enlistedcars;
  static const fromJsonFactory = _$UserEnlistedCarsResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserEnlistedCarsResponse &&
            (identical(other.enlistedcars, enlistedcars) ||
                const DeepCollectionEquality().equals(
                  other.enlistedcars,
                  enlistedcars,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(enlistedcars) ^ runtimeType.hashCode;
}

extension $UserEnlistedCarsResponseExtension on UserEnlistedCarsResponse {
  UserEnlistedCarsResponse copyWith({List<UserRaceCarDetails>? enlistedcars}) {
    return UserEnlistedCarsResponse(
      enlistedcars: enlistedcars ?? this.enlistedcars,
    );
  }

  UserEnlistedCarsResponse copyWithWrapped({
    Wrapped<List<UserRaceCarDetails>>? enlistedcars,
  }) {
    return UserEnlistedCarsResponse(
      enlistedcars: (enlistedcars != null ? enlistedcars.value : this.enlistedcars),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserForumPostsResponse {
  const UserForumPostsResponse({
    required this.forumPosts,
    required this.metadata,
  });

  factory UserForumPostsResponse.fromJson(Map<String, dynamic> json) => _$UserForumPostsResponseFromJson(json);

  static const toJsonFactory = _$UserForumPostsResponseToJson;
  Map<String, dynamic> toJson() => _$UserForumPostsResponseToJson(this);

  @JsonKey(name: 'forumPosts', defaultValue: <ForumPost>[])
  final List<ForumPost> forumPosts;
  @JsonKey(name: '_metadata')
  final RequestMetadataWithLinks metadata;
  static const fromJsonFactory = _$UserForumPostsResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserForumPostsResponse &&
            (identical(other.forumPosts, forumPosts) ||
                const DeepCollectionEquality().equals(
                  other.forumPosts,
                  forumPosts,
                )) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality().equals(
                  other.metadata,
                  metadata,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(forumPosts) ^
      const DeepCollectionEquality().hash(metadata) ^
      runtimeType.hashCode;
}

extension $UserForumPostsResponseExtension on UserForumPostsResponse {
  UserForumPostsResponse copyWith({
    List<ForumPost>? forumPosts,
    RequestMetadataWithLinks? metadata,
  }) {
    return UserForumPostsResponse(
      forumPosts: forumPosts ?? this.forumPosts,
      metadata: metadata ?? this.metadata,
    );
  }

  UserForumPostsResponse copyWithWrapped({
    Wrapped<List<ForumPost>>? forumPosts,
    Wrapped<RequestMetadataWithLinks>? metadata,
  }) {
    return UserForumPostsResponse(
      forumPosts: (forumPosts != null ? forumPosts.value : this.forumPosts),
      metadata: (metadata != null ? metadata.value : this.metadata),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserForumThreadsResponse {
  const UserForumThreadsResponse({
    required this.forumThreads,
    required this.metadata,
  });

  factory UserForumThreadsResponse.fromJson(Map<String, dynamic> json) => _$UserForumThreadsResponseFromJson(json);

  static const toJsonFactory = _$UserForumThreadsResponseToJson;
  Map<String, dynamic> toJson() => _$UserForumThreadsResponseToJson(this);

  @JsonKey(name: 'forumThreads', defaultValue: <ForumThreadUserExtended>[])
  final List<ForumThreadUserExtended> forumThreads;
  @JsonKey(name: '_metadata')
  final RequestMetadataWithLinks metadata;
  static const fromJsonFactory = _$UserForumThreadsResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserForumThreadsResponse &&
            (identical(other.forumThreads, forumThreads) ||
                const DeepCollectionEquality().equals(
                  other.forumThreads,
                  forumThreads,
                )) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality().equals(
                  other.metadata,
                  metadata,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(forumThreads) ^
      const DeepCollectionEquality().hash(metadata) ^
      runtimeType.hashCode;
}

extension $UserForumThreadsResponseExtension on UserForumThreadsResponse {
  UserForumThreadsResponse copyWith({
    List<ForumThreadUserExtended>? forumThreads,
    RequestMetadataWithLinks? metadata,
  }) {
    return UserForumThreadsResponse(
      forumThreads: forumThreads ?? this.forumThreads,
      metadata: metadata ?? this.metadata,
    );
  }

  UserForumThreadsResponse copyWithWrapped({
    Wrapped<List<ForumThreadUserExtended>>? forumThreads,
    Wrapped<RequestMetadataWithLinks>? metadata,
  }) {
    return UserForumThreadsResponse(
      forumThreads: (forumThreads != null ? forumThreads.value : this.forumThreads),
      metadata: (metadata != null ? metadata.value : this.metadata),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserForumSubscribedThreadsResponse {
  const UserForumSubscribedThreadsResponse({this.forumSubscribedThreads});

  factory UserForumSubscribedThreadsResponse.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$UserForumSubscribedThreadsResponseFromJson(json);

  static const toJsonFactory = _$UserForumSubscribedThreadsResponseToJson;
  Map<String, dynamic> toJson() => _$UserForumSubscribedThreadsResponseToJson(this);

  @JsonKey(
    name: 'forumSubscribedThreads',
    defaultValue: <ForumSubscribedThread>[],
  )
  final List<ForumSubscribedThread>? forumSubscribedThreads;
  static const fromJsonFactory = _$UserForumSubscribedThreadsResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserForumSubscribedThreadsResponse &&
            (identical(other.forumSubscribedThreads, forumSubscribedThreads) ||
                const DeepCollectionEquality().equals(
                  other.forumSubscribedThreads,
                  forumSubscribedThreads,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(forumSubscribedThreads) ^ runtimeType.hashCode;
}

extension $UserForumSubscribedThreadsResponseExtension on UserForumSubscribedThreadsResponse {
  UserForumSubscribedThreadsResponse copyWith({
    List<ForumSubscribedThread>? forumSubscribedThreads,
  }) {
    return UserForumSubscribedThreadsResponse(
      forumSubscribedThreads: forumSubscribedThreads ?? this.forumSubscribedThreads,
    );
  }

  UserForumSubscribedThreadsResponse copyWithWrapped({
    Wrapped<List<ForumSubscribedThread>?>? forumSubscribedThreads,
  }) {
    return UserForumSubscribedThreadsResponse(
      forumSubscribedThreads:
          (forumSubscribedThreads != null ? forumSubscribedThreads.value : this.forumSubscribedThreads),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserForumFeedResponse {
  const UserForumFeedResponse({required this.forumFeed});

  factory UserForumFeedResponse.fromJson(Map<String, dynamic> json) => _$UserForumFeedResponseFromJson(json);

  static const toJsonFactory = _$UserForumFeedResponseToJson;
  Map<String, dynamic> toJson() => _$UserForumFeedResponseToJson(this);

  @JsonKey(name: 'forumFeed', defaultValue: <ForumFeed>[])
  final List<ForumFeed> forumFeed;
  static const fromJsonFactory = _$UserForumFeedResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserForumFeedResponse &&
            (identical(other.forumFeed, forumFeed) ||
                const DeepCollectionEquality().equals(
                  other.forumFeed,
                  forumFeed,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(forumFeed) ^ runtimeType.hashCode;
}

extension $UserForumFeedResponseExtension on UserForumFeedResponse {
  UserForumFeedResponse copyWith({List<ForumFeed>? forumFeed}) {
    return UserForumFeedResponse(forumFeed: forumFeed ?? this.forumFeed);
  }

  UserForumFeedResponse copyWithWrapped({Wrapped<List<ForumFeed>>? forumFeed}) {
    return UserForumFeedResponse(
      forumFeed: (forumFeed != null ? forumFeed.value : this.forumFeed),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserForumFriendsResponse {
  const UserForumFriendsResponse({required this.forumFriends});

  factory UserForumFriendsResponse.fromJson(Map<String, dynamic> json) => _$UserForumFriendsResponseFromJson(json);

  static const toJsonFactory = _$UserForumFriendsResponseToJson;
  Map<String, dynamic> toJson() => _$UserForumFriendsResponseToJson(this);

  @JsonKey(name: 'forumFriends', defaultValue: <ForumFeed>[])
  final List<ForumFeed> forumFriends;
  static const fromJsonFactory = _$UserForumFriendsResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserForumFriendsResponse &&
            (identical(other.forumFriends, forumFriends) ||
                const DeepCollectionEquality().equals(
                  other.forumFriends,
                  forumFriends,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(forumFriends) ^ runtimeType.hashCode;
}

extension $UserForumFriendsResponseExtension on UserForumFriendsResponse {
  UserForumFriendsResponse copyWith({List<ForumFeed>? forumFriends}) {
    return UserForumFriendsResponse(
      forumFriends: forumFriends ?? this.forumFriends,
    );
  }

  UserForumFriendsResponse copyWithWrapped({
    Wrapped<List<ForumFeed>>? forumFriends,
  }) {
    return UserForumFriendsResponse(
      forumFriends: (forumFriends != null ? forumFriends.value : this.forumFriends),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class HofValue {
  const HofValue({required this.$value, required this.rank});

  factory HofValue.fromJson(Map<String, dynamic> json) => _$HofValueFromJson(json);

  static const toJsonFactory = _$HofValueToJson;
  Map<String, dynamic> toJson() => _$HofValueToJson(this);

  @JsonKey(name: 'value')
  final int $value;
  @JsonKey(name: 'rank')
  final int rank;
  static const fromJsonFactory = _$HofValueFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is HofValue &&
            (identical(other.$value, $value) || const DeepCollectionEquality().equals(other.$value, $value)) &&
            (identical(other.rank, rank) || const DeepCollectionEquality().equals(other.rank, rank)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash($value) ^ const DeepCollectionEquality().hash(rank) ^ runtimeType.hashCode;
}

extension $HofValueExtension on HofValue {
  HofValue copyWith({int? $value, int? rank}) {
    return HofValue($value: $value ?? this.$value, rank: rank ?? this.rank);
  }

  HofValue copyWithWrapped({Wrapped<int>? $value, Wrapped<int>? rank}) {
    return HofValue(
      $value: ($value != null ? $value.value : this.$value),
      rank: (rank != null ? rank.value : this.rank),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class HofValueFloat {
  const HofValueFloat({required this.$value, required this.rank});

  factory HofValueFloat.fromJson(Map<String, dynamic> json) => _$HofValueFloatFromJson(json);

  static const toJsonFactory = _$HofValueFloatToJson;
  Map<String, dynamic> toJson() => _$HofValueFloatToJson(this);

  @JsonKey(name: 'value')
  final double $value;
  @JsonKey(name: 'rank')
  final int rank;
  static const fromJsonFactory = _$HofValueFloatFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is HofValueFloat &&
            (identical(other.$value, $value) || const DeepCollectionEquality().equals(other.$value, $value)) &&
            (identical(other.rank, rank) || const DeepCollectionEquality().equals(other.rank, rank)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash($value) ^ const DeepCollectionEquality().hash(rank) ^ runtimeType.hashCode;
}

extension $HofValueFloatExtension on HofValueFloat {
  HofValueFloat copyWith({double? $value, int? rank}) {
    return HofValueFloat(
      $value: $value ?? this.$value,
      rank: rank ?? this.rank,
    );
  }

  HofValueFloat copyWithWrapped({Wrapped<double>? $value, Wrapped<int>? rank}) {
    return HofValueFloat(
      $value: ($value != null ? $value.value : this.$value),
      rank: (rank != null ? rank.value : this.rank),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class HofValueString {
  const HofValueString({required this.$value, required this.rank});

  factory HofValueString.fromJson(Map<String, dynamic> json) => _$HofValueStringFromJson(json);

  static const toJsonFactory = _$HofValueStringToJson;
  Map<String, dynamic> toJson() => _$HofValueStringToJson(this);

  @JsonKey(name: 'value')
  final String $value;
  @JsonKey(name: 'rank')
  final dynamic rank;
  static const fromJsonFactory = _$HofValueStringFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is HofValueString &&
            (identical(other.$value, $value) || const DeepCollectionEquality().equals(other.$value, $value)) &&
            (identical(other.rank, rank) || const DeepCollectionEquality().equals(other.rank, rank)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash($value) ^ const DeepCollectionEquality().hash(rank) ^ runtimeType.hashCode;
}

extension $HofValueStringExtension on HofValueString {
  HofValueString copyWith({String? $value, dynamic rank}) {
    return HofValueString(
      $value: $value ?? this.$value,
      rank: rank ?? this.rank,
    );
  }

  HofValueString copyWithWrapped({
    Wrapped<String>? $value,
    Wrapped<dynamic>? rank,
  }) {
    return HofValueString(
      $value: ($value != null ? $value.value : this.$value),
      rank: (rank != null ? rank.value : this.rank),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserHofStats {
  const UserHofStats({
    required this.attacks,
    required this.busts,
    required this.defends,
    required this.networth,
    required this.offences,
    required this.revives,
    required this.level,
    required this.rank,
    required this.awards,
    required this.racingSkill,
    required this.racingPoints,
    required this.racingWins,
    required this.travelTime,
    required this.workingStats,
    required this.battleStats,
  });

  factory UserHofStats.fromJson(Map<String, dynamic> json) => _$UserHofStatsFromJson(json);

  static const toJsonFactory = _$UserHofStatsToJson;
  Map<String, dynamic> toJson() => _$UserHofStatsToJson(this);

  @JsonKey(name: 'attacks')
  final HofValue attacks;
  @JsonKey(name: 'busts')
  final HofValue busts;
  @JsonKey(name: 'defends')
  final HofValue defends;
  @JsonKey(name: 'networth')
  final HofValue networth;
  @JsonKey(name: 'offences')
  final HofValue offences;
  @JsonKey(name: 'revives')
  final HofValue revives;
  @JsonKey(name: 'level')
  final HofValue level;
  @JsonKey(name: 'rank')
  final HofValue rank;
  @JsonKey(name: 'awards')
  final HofValue awards;
  @JsonKey(name: 'racing_skill')
  final HofValueFloat racingSkill;
  @JsonKey(name: 'racing_points')
  final HofValue racingPoints;
  @JsonKey(name: 'racing_wins')
  final HofValue racingWins;
  @JsonKey(name: 'travel_time')
  final HofValue travelTime;
  @JsonKey(name: 'working_stats')
  final HofValue workingStats;
  @JsonKey(name: 'battle_stats')
  final dynamic battleStats;
  static const fromJsonFactory = _$UserHofStatsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserHofStats &&
            (identical(other.attacks, attacks) ||
                const DeepCollectionEquality().equals(
                  other.attacks,
                  attacks,
                )) &&
            (identical(other.busts, busts) || const DeepCollectionEquality().equals(other.busts, busts)) &&
            (identical(other.defends, defends) ||
                const DeepCollectionEquality().equals(
                  other.defends,
                  defends,
                )) &&
            (identical(other.networth, networth) ||
                const DeepCollectionEquality().equals(
                  other.networth,
                  networth,
                )) &&
            (identical(other.offences, offences) ||
                const DeepCollectionEquality().equals(
                  other.offences,
                  offences,
                )) &&
            (identical(other.revives, revives) ||
                const DeepCollectionEquality().equals(
                  other.revives,
                  revives,
                )) &&
            (identical(other.level, level) || const DeepCollectionEquality().equals(other.level, level)) &&
            (identical(other.rank, rank) || const DeepCollectionEquality().equals(other.rank, rank)) &&
            (identical(other.awards, awards) || const DeepCollectionEquality().equals(other.awards, awards)) &&
            (identical(other.racingSkill, racingSkill) ||
                const DeepCollectionEquality().equals(
                  other.racingSkill,
                  racingSkill,
                )) &&
            (identical(other.racingPoints, racingPoints) ||
                const DeepCollectionEquality().equals(
                  other.racingPoints,
                  racingPoints,
                )) &&
            (identical(other.racingWins, racingWins) ||
                const DeepCollectionEquality().equals(
                  other.racingWins,
                  racingWins,
                )) &&
            (identical(other.travelTime, travelTime) ||
                const DeepCollectionEquality().equals(
                  other.travelTime,
                  travelTime,
                )) &&
            (identical(other.workingStats, workingStats) ||
                const DeepCollectionEquality().equals(
                  other.workingStats,
                  workingStats,
                )) &&
            (identical(other.battleStats, battleStats) ||
                const DeepCollectionEquality().equals(
                  other.battleStats,
                  battleStats,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(attacks) ^
      const DeepCollectionEquality().hash(busts) ^
      const DeepCollectionEquality().hash(defends) ^
      const DeepCollectionEquality().hash(networth) ^
      const DeepCollectionEquality().hash(offences) ^
      const DeepCollectionEquality().hash(revives) ^
      const DeepCollectionEquality().hash(level) ^
      const DeepCollectionEquality().hash(rank) ^
      const DeepCollectionEquality().hash(awards) ^
      const DeepCollectionEquality().hash(racingSkill) ^
      const DeepCollectionEquality().hash(racingPoints) ^
      const DeepCollectionEquality().hash(racingWins) ^
      const DeepCollectionEquality().hash(travelTime) ^
      const DeepCollectionEquality().hash(workingStats) ^
      const DeepCollectionEquality().hash(battleStats) ^
      runtimeType.hashCode;
}

extension $UserHofStatsExtension on UserHofStats {
  UserHofStats copyWith({
    HofValue? attacks,
    HofValue? busts,
    HofValue? defends,
    HofValue? networth,
    HofValue? offences,
    HofValue? revives,
    HofValue? level,
    HofValue? rank,
    HofValue? awards,
    HofValueFloat? racingSkill,
    HofValue? racingPoints,
    HofValue? racingWins,
    HofValue? travelTime,
    HofValue? workingStats,
    dynamic battleStats,
  }) {
    return UserHofStats(
      attacks: attacks ?? this.attacks,
      busts: busts ?? this.busts,
      defends: defends ?? this.defends,
      networth: networth ?? this.networth,
      offences: offences ?? this.offences,
      revives: revives ?? this.revives,
      level: level ?? this.level,
      rank: rank ?? this.rank,
      awards: awards ?? this.awards,
      racingSkill: racingSkill ?? this.racingSkill,
      racingPoints: racingPoints ?? this.racingPoints,
      racingWins: racingWins ?? this.racingWins,
      travelTime: travelTime ?? this.travelTime,
      workingStats: workingStats ?? this.workingStats,
      battleStats: battleStats ?? this.battleStats,
    );
  }

  UserHofStats copyWithWrapped({
    Wrapped<HofValue>? attacks,
    Wrapped<HofValue>? busts,
    Wrapped<HofValue>? defends,
    Wrapped<HofValue>? networth,
    Wrapped<HofValue>? offences,
    Wrapped<HofValue>? revives,
    Wrapped<HofValue>? level,
    Wrapped<HofValue>? rank,
    Wrapped<HofValue>? awards,
    Wrapped<HofValueFloat>? racingSkill,
    Wrapped<HofValue>? racingPoints,
    Wrapped<HofValue>? racingWins,
    Wrapped<HofValue>? travelTime,
    Wrapped<HofValue>? workingStats,
    Wrapped<dynamic>? battleStats,
  }) {
    return UserHofStats(
      attacks: (attacks != null ? attacks.value : this.attacks),
      busts: (busts != null ? busts.value : this.busts),
      defends: (defends != null ? defends.value : this.defends),
      networth: (networth != null ? networth.value : this.networth),
      offences: (offences != null ? offences.value : this.offences),
      revives: (revives != null ? revives.value : this.revives),
      level: (level != null ? level.value : this.level),
      rank: (rank != null ? rank.value : this.rank),
      awards: (awards != null ? awards.value : this.awards),
      racingSkill: (racingSkill != null ? racingSkill.value : this.racingSkill),
      racingPoints: (racingPoints != null ? racingPoints.value : this.racingPoints),
      racingWins: (racingWins != null ? racingWins.value : this.racingWins),
      travelTime: (travelTime != null ? travelTime.value : this.travelTime),
      workingStats: (workingStats != null ? workingStats.value : this.workingStats),
      battleStats: (battleStats != null ? battleStats.value : this.battleStats),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserHofResponse {
  const UserHofResponse({required this.hof});

  factory UserHofResponse.fromJson(Map<String, dynamic> json) => _$UserHofResponseFromJson(json);

  static const toJsonFactory = _$UserHofResponseToJson;
  Map<String, dynamic> toJson() => _$UserHofResponseToJson(this);

  @JsonKey(name: 'hof')
  final UserHofStats hof;
  static const fromJsonFactory = _$UserHofResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserHofResponse &&
            (identical(other.hof, hof) || const DeepCollectionEquality().equals(other.hof, hof)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(hof) ^ runtimeType.hashCode;
}

extension $UserHofResponseExtension on UserHofResponse {
  UserHofResponse copyWith({UserHofStats? hof}) {
    return UserHofResponse(hof: hof ?? this.hof);
  }

  UserHofResponse copyWithWrapped({Wrapped<UserHofStats>? hof}) {
    return UserHofResponse(hof: (hof != null ? hof.value : this.hof));
  }
}

@JsonSerializable(explicitToJson: true)
class UserCalendar {
  const UserCalendar({required this.startTime});

  factory UserCalendar.fromJson(Map<String, dynamic> json) => _$UserCalendarFromJson(json);

  static const toJsonFactory = _$UserCalendarToJson;
  Map<String, dynamic> toJson() => _$UserCalendarToJson(this);

  @JsonKey(name: 'start_time')
  final String startTime;
  static const fromJsonFactory = _$UserCalendarFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserCalendar &&
            (identical(other.startTime, startTime) ||
                const DeepCollectionEquality().equals(
                  other.startTime,
                  startTime,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(startTime) ^ runtimeType.hashCode;
}

extension $UserCalendarExtension on UserCalendar {
  UserCalendar copyWith({String? startTime}) {
    return UserCalendar(startTime: startTime ?? this.startTime);
  }

  UserCalendar copyWithWrapped({Wrapped<String>? startTime}) {
    return UserCalendar(
      startTime: (startTime != null ? startTime.value : this.startTime),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserCalendarResponse {
  const UserCalendarResponse({required this.calendar});

  factory UserCalendarResponse.fromJson(Map<String, dynamic> json) => _$UserCalendarResponseFromJson(json);

  static const toJsonFactory = _$UserCalendarResponseToJson;
  Map<String, dynamic> toJson() => _$UserCalendarResponseToJson(this);

  @JsonKey(name: 'calendar')
  final UserCalendar calendar;
  static const fromJsonFactory = _$UserCalendarResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserCalendarResponse &&
            (identical(other.calendar, calendar) ||
                const DeepCollectionEquality().equals(
                  other.calendar,
                  calendar,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(calendar) ^ runtimeType.hashCode;
}

extension $UserCalendarResponseExtension on UserCalendarResponse {
  UserCalendarResponse copyWith({UserCalendar? calendar}) {
    return UserCalendarResponse(calendar: calendar ?? this.calendar);
  }

  UserCalendarResponse copyWithWrapped({Wrapped<UserCalendar>? calendar}) {
    return UserCalendarResponse(
      calendar: (calendar != null ? calendar.value : this.calendar),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserBountiesResponse {
  const UserBountiesResponse({required this.bounties});

  factory UserBountiesResponse.fromJson(Map<String, dynamic> json) => _$UserBountiesResponseFromJson(json);

  static const toJsonFactory = _$UserBountiesResponseToJson;
  Map<String, dynamic> toJson() => _$UserBountiesResponseToJson(this);

  @JsonKey(name: 'bounties', defaultValue: <Bounty>[])
  final List<Bounty> bounties;
  static const fromJsonFactory = _$UserBountiesResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserBountiesResponse &&
            (identical(other.bounties, bounties) ||
                const DeepCollectionEquality().equals(
                  other.bounties,
                  bounties,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(bounties) ^ runtimeType.hashCode;
}

extension $UserBountiesResponseExtension on UserBountiesResponse {
  UserBountiesResponse copyWith({List<Bounty>? bounties}) {
    return UserBountiesResponse(bounties: bounties ?? this.bounties);
  }

  UserBountiesResponse copyWithWrapped({Wrapped<List<Bounty>>? bounties}) {
    return UserBountiesResponse(
      bounties: (bounties != null ? bounties.value : this.bounties),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserJobRanks {
  const UserJobRanks({
    required this.army,
    required this.grocer,
    required this.casino,
    required this.medical,
    required this.law,
    required this.education,
  });

  factory UserJobRanks.fromJson(Map<String, dynamic> json) => _$UserJobRanksFromJson(json);

  static const toJsonFactory = _$UserJobRanksToJson;
  Map<String, dynamic> toJson() => _$UserJobRanksToJson(this);

  @JsonKey(
    name: 'army',
    toJson: jobPositionArmyEnumToJson,
    fromJson: jobPositionArmyEnumFromJson,
  )
  final enums.JobPositionArmyEnum army;
  @JsonKey(
    name: 'grocer',
    toJson: jobPositionGrocerEnumToJson,
    fromJson: jobPositionGrocerEnumFromJson,
  )
  final enums.JobPositionGrocerEnum grocer;
  @JsonKey(
    name: 'casino',
    toJson: jobPositionCasinoEnumToJson,
    fromJson: jobPositionCasinoEnumFromJson,
  )
  final enums.JobPositionCasinoEnum casino;
  @JsonKey(
    name: 'medical',
    toJson: jobPositionMedicalEnumToJson,
    fromJson: jobPositionMedicalEnumFromJson,
  )
  final enums.JobPositionMedicalEnum medical;
  @JsonKey(
    name: 'law',
    toJson: jobPositionLawEnumToJson,
    fromJson: jobPositionLawEnumFromJson,
  )
  final enums.JobPositionLawEnum law;
  @JsonKey(
    name: 'education',
    toJson: jobPositionEducationEnumToJson,
    fromJson: jobPositionEducationEnumFromJson,
  )
  final enums.JobPositionEducationEnum education;
  static const fromJsonFactory = _$UserJobRanksFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserJobRanks &&
            (identical(other.army, army) || const DeepCollectionEquality().equals(other.army, army)) &&
            (identical(other.grocer, grocer) || const DeepCollectionEquality().equals(other.grocer, grocer)) &&
            (identical(other.casino, casino) || const DeepCollectionEquality().equals(other.casino, casino)) &&
            (identical(other.medical, medical) ||
                const DeepCollectionEquality().equals(
                  other.medical,
                  medical,
                )) &&
            (identical(other.law, law) || const DeepCollectionEquality().equals(other.law, law)) &&
            (identical(other.education, education) ||
                const DeepCollectionEquality().equals(
                  other.education,
                  education,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(army) ^
      const DeepCollectionEquality().hash(grocer) ^
      const DeepCollectionEquality().hash(casino) ^
      const DeepCollectionEquality().hash(medical) ^
      const DeepCollectionEquality().hash(law) ^
      const DeepCollectionEquality().hash(education) ^
      runtimeType.hashCode;
}

extension $UserJobRanksExtension on UserJobRanks {
  UserJobRanks copyWith({
    enums.JobPositionArmyEnum? army,
    enums.JobPositionGrocerEnum? grocer,
    enums.JobPositionCasinoEnum? casino,
    enums.JobPositionMedicalEnum? medical,
    enums.JobPositionLawEnum? law,
    enums.JobPositionEducationEnum? education,
  }) {
    return UserJobRanks(
      army: army ?? this.army,
      grocer: grocer ?? this.grocer,
      casino: casino ?? this.casino,
      medical: medical ?? this.medical,
      law: law ?? this.law,
      education: education ?? this.education,
    );
  }

  UserJobRanks copyWithWrapped({
    Wrapped<enums.JobPositionArmyEnum>? army,
    Wrapped<enums.JobPositionGrocerEnum>? grocer,
    Wrapped<enums.JobPositionCasinoEnum>? casino,
    Wrapped<enums.JobPositionMedicalEnum>? medical,
    Wrapped<enums.JobPositionLawEnum>? law,
    Wrapped<enums.JobPositionEducationEnum>? education,
  }) {
    return UserJobRanks(
      army: (army != null ? army.value : this.army),
      grocer: (grocer != null ? grocer.value : this.grocer),
      casino: (casino != null ? casino.value : this.casino),
      medical: (medical != null ? medical.value : this.medical),
      law: (law != null ? law.value : this.law),
      education: (education != null ? education.value : this.education),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserJobRanksResponse {
  const UserJobRanksResponse({required this.jobranks});

  factory UserJobRanksResponse.fromJson(Map<String, dynamic> json) => _$UserJobRanksResponseFromJson(json);

  static const toJsonFactory = _$UserJobRanksResponseToJson;
  Map<String, dynamic> toJson() => _$UserJobRanksResponseToJson(this);

  @JsonKey(name: 'jobranks')
  final UserJobRanks jobranks;
  static const fromJsonFactory = _$UserJobRanksResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserJobRanksResponse &&
            (identical(other.jobranks, jobranks) ||
                const DeepCollectionEquality().equals(
                  other.jobranks,
                  jobranks,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(jobranks) ^ runtimeType.hashCode;
}

extension $UserJobRanksResponseExtension on UserJobRanksResponse {
  UserJobRanksResponse copyWith({UserJobRanks? jobranks}) {
    return UserJobRanksResponse(jobranks: jobranks ?? this.jobranks);
  }

  UserJobRanksResponse copyWithWrapped({Wrapped<UserJobRanks>? jobranks}) {
    return UserJobRanksResponse(
      jobranks: (jobranks != null ? jobranks.value : this.jobranks),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserItemMarkeListingItemDetails {
  const UserItemMarkeListingItemDetails({
    required this.id,
    required this.name,
    required this.type,
    required this.rarity,
    required this.uid,
    required this.stats,
    required this.bonuses,
  });

  factory UserItemMarkeListingItemDetails.fromJson(Map<String, dynamic> json) =>
      _$UserItemMarkeListingItemDetailsFromJson(json);

  static const toJsonFactory = _$UserItemMarkeListingItemDetailsToJson;
  Map<String, dynamic> toJson() => _$UserItemMarkeListingItemDetailsToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'type')
  final String type;
  @JsonKey(name: 'rarity')
  final dynamic rarity;
  @JsonKey(name: 'uid')
  final dynamic uid;
  @JsonKey(name: 'stats')
  final dynamic stats;
  @JsonKey(name: 'bonuses', defaultValue: <ItemMarketListingItemBonus>[])
  final List<ItemMarketListingItemBonus> bonuses;
  static const fromJsonFactory = _$UserItemMarkeListingItemDetailsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserItemMarkeListingItemDetails &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.type, type) || const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.rarity, rarity) || const DeepCollectionEquality().equals(other.rarity, rarity)) &&
            (identical(other.uid, uid) || const DeepCollectionEquality().equals(other.uid, uid)) &&
            (identical(other.stats, stats) || const DeepCollectionEquality().equals(other.stats, stats)) &&
            (identical(other.bonuses, bonuses) || const DeepCollectionEquality().equals(other.bonuses, bonuses)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(rarity) ^
      const DeepCollectionEquality().hash(uid) ^
      const DeepCollectionEquality().hash(stats) ^
      const DeepCollectionEquality().hash(bonuses) ^
      runtimeType.hashCode;
}

extension $UserItemMarkeListingItemDetailsExtension on UserItemMarkeListingItemDetails {
  UserItemMarkeListingItemDetails copyWith({
    int? id,
    String? name,
    String? type,
    dynamic rarity,
    dynamic uid,
    dynamic stats,
    List<ItemMarketListingItemBonus>? bonuses,
  }) {
    return UserItemMarkeListingItemDetails(
      id: id ?? this.id,
      name: name ?? this.name,
      type: type ?? this.type,
      rarity: rarity ?? this.rarity,
      uid: uid ?? this.uid,
      stats: stats ?? this.stats,
      bonuses: bonuses ?? this.bonuses,
    );
  }

  UserItemMarkeListingItemDetails copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<String>? name,
    Wrapped<String>? type,
    Wrapped<dynamic>? rarity,
    Wrapped<dynamic>? uid,
    Wrapped<dynamic>? stats,
    Wrapped<List<ItemMarketListingItemBonus>>? bonuses,
  }) {
    return UserItemMarkeListingItemDetails(
      id: (id != null ? id.value : this.id),
      name: (name != null ? name.value : this.name),
      type: (type != null ? type.value : this.type),
      rarity: (rarity != null ? rarity.value : this.rarity),
      uid: (uid != null ? uid.value : this.uid),
      stats: (stats != null ? stats.value : this.stats),
      bonuses: (bonuses != null ? bonuses.value : this.bonuses),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserItemMarketListing {
  const UserItemMarketListing({
    required this.id,
    required this.price,
    required this.averagePrice,
    required this.amount,
    required this.isAnonymous,
    required this.available,
    required this.item,
  });

  factory UserItemMarketListing.fromJson(Map<String, dynamic> json) => _$UserItemMarketListingFromJson(json);

  static const toJsonFactory = _$UserItemMarketListingToJson;
  Map<String, dynamic> toJson() => _$UserItemMarketListingToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'price')
  final int price;
  @JsonKey(name: 'average_price')
  final int averagePrice;
  @JsonKey(name: 'amount')
  final int amount;
  @JsonKey(name: 'is_anonymous')
  final bool isAnonymous;
  @JsonKey(name: 'available')
  final int available;
  @JsonKey(name: 'item')
  final UserItemMarkeListingItemDetails item;
  static const fromJsonFactory = _$UserItemMarketListingFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserItemMarketListing &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.price, price) || const DeepCollectionEquality().equals(other.price, price)) &&
            (identical(other.averagePrice, averagePrice) ||
                const DeepCollectionEquality().equals(
                  other.averagePrice,
                  averagePrice,
                )) &&
            (identical(other.amount, amount) || const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.isAnonymous, isAnonymous) ||
                const DeepCollectionEquality().equals(
                  other.isAnonymous,
                  isAnonymous,
                )) &&
            (identical(other.available, available) ||
                const DeepCollectionEquality().equals(
                  other.available,
                  available,
                )) &&
            (identical(other.item, item) || const DeepCollectionEquality().equals(other.item, item)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(price) ^
      const DeepCollectionEquality().hash(averagePrice) ^
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(isAnonymous) ^
      const DeepCollectionEquality().hash(available) ^
      const DeepCollectionEquality().hash(item) ^
      runtimeType.hashCode;
}

extension $UserItemMarketListingExtension on UserItemMarketListing {
  UserItemMarketListing copyWith({
    int? id,
    int? price,
    int? averagePrice,
    int? amount,
    bool? isAnonymous,
    int? available,
    UserItemMarkeListingItemDetails? item,
  }) {
    return UserItemMarketListing(
      id: id ?? this.id,
      price: price ?? this.price,
      averagePrice: averagePrice ?? this.averagePrice,
      amount: amount ?? this.amount,
      isAnonymous: isAnonymous ?? this.isAnonymous,
      available: available ?? this.available,
      item: item ?? this.item,
    );
  }

  UserItemMarketListing copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<int>? price,
    Wrapped<int>? averagePrice,
    Wrapped<int>? amount,
    Wrapped<bool>? isAnonymous,
    Wrapped<int>? available,
    Wrapped<UserItemMarkeListingItemDetails>? item,
  }) {
    return UserItemMarketListing(
      id: (id != null ? id.value : this.id),
      price: (price != null ? price.value : this.price),
      averagePrice: (averagePrice != null ? averagePrice.value : this.averagePrice),
      amount: (amount != null ? amount.value : this.amount),
      isAnonymous: (isAnonymous != null ? isAnonymous.value : this.isAnonymous),
      available: (available != null ? available.value : this.available),
      item: (item != null ? item.value : this.item),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserItemMarketResponse {
  const UserItemMarketResponse({
    required this.itemmarket,
    required this.metadata,
  });

  factory UserItemMarketResponse.fromJson(Map<String, dynamic> json) => _$UserItemMarketResponseFromJson(json);

  static const toJsonFactory = _$UserItemMarketResponseToJson;
  Map<String, dynamic> toJson() => _$UserItemMarketResponseToJson(this);

  @JsonKey(name: 'itemmarket', defaultValue: <UserItemMarketListing>[])
  final List<UserItemMarketListing> itemmarket;
  @JsonKey(name: '_metadata')
  final RequestMetadataWithLinks metadata;
  static const fromJsonFactory = _$UserItemMarketResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserItemMarketResponse &&
            (identical(other.itemmarket, itemmarket) ||
                const DeepCollectionEquality().equals(
                  other.itemmarket,
                  itemmarket,
                )) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality().equals(
                  other.metadata,
                  metadata,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(itemmarket) ^
      const DeepCollectionEquality().hash(metadata) ^
      runtimeType.hashCode;
}

extension $UserItemMarketResponseExtension on UserItemMarketResponse {
  UserItemMarketResponse copyWith({
    List<UserItemMarketListing>? itemmarket,
    RequestMetadataWithLinks? metadata,
  }) {
    return UserItemMarketResponse(
      itemmarket: itemmarket ?? this.itemmarket,
      metadata: metadata ?? this.metadata,
    );
  }

  UserItemMarketResponse copyWithWrapped({
    Wrapped<List<UserItemMarketListing>>? itemmarket,
    Wrapped<RequestMetadataWithLinks>? metadata,
  }) {
    return UserItemMarketResponse(
      itemmarket: (itemmarket != null ? itemmarket.value : this.itemmarket),
      metadata: (metadata != null ? metadata.value : this.metadata),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserFactionBalance {
  const UserFactionBalance({required this.money, required this.points});

  factory UserFactionBalance.fromJson(Map<String, dynamic> json) => _$UserFactionBalanceFromJson(json);

  static const toJsonFactory = _$UserFactionBalanceToJson;
  Map<String, dynamic> toJson() => _$UserFactionBalanceToJson(this);

  @JsonKey(name: 'money')
  final int money;
  @JsonKey(name: 'points')
  final int points;
  static const fromJsonFactory = _$UserFactionBalanceFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserFactionBalance &&
            (identical(other.money, money) || const DeepCollectionEquality().equals(other.money, money)) &&
            (identical(other.points, points) || const DeepCollectionEquality().equals(other.points, points)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(money) ^ const DeepCollectionEquality().hash(points) ^ runtimeType.hashCode;
}

extension $UserFactionBalanceExtension on UserFactionBalance {
  UserFactionBalance copyWith({int? money, int? points}) {
    return UserFactionBalance(
      money: money ?? this.money,
      points: points ?? this.points,
    );
  }

  UserFactionBalance copyWithWrapped({
    Wrapped<int>? money,
    Wrapped<int>? points,
  }) {
    return UserFactionBalance(
      money: (money != null ? money.value : this.money),
      points: (points != null ? points.value : this.points),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserFactionBalanceResponse {
  const UserFactionBalanceResponse({required this.factionBalance});

  factory UserFactionBalanceResponse.fromJson(Map<String, dynamic> json) => _$UserFactionBalanceResponseFromJson(json);

  static const toJsonFactory = _$UserFactionBalanceResponseToJson;
  Map<String, dynamic> toJson() => _$UserFactionBalanceResponseToJson(this);

  @JsonKey(name: 'factionBalance')
  final dynamic factionBalance;
  static const fromJsonFactory = _$UserFactionBalanceResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserFactionBalanceResponse &&
            (identical(other.factionBalance, factionBalance) ||
                const DeepCollectionEquality().equals(
                  other.factionBalance,
                  factionBalance,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(factionBalance) ^ runtimeType.hashCode;
}

extension $UserFactionBalanceResponseExtension on UserFactionBalanceResponse {
  UserFactionBalanceResponse copyWith({dynamic factionBalance}) {
    return UserFactionBalanceResponse(
      factionBalance: factionBalance ?? this.factionBalance,
    );
  }

  UserFactionBalanceResponse copyWithWrapped({
    Wrapped<dynamic>? factionBalance,
  }) {
    return UserFactionBalanceResponse(
      factionBalance: (factionBalance != null ? factionBalance.value : this.factionBalance),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserOrganizedCrimeResponse {
  const UserOrganizedCrimeResponse({required this.organizedCrime});

  factory UserOrganizedCrimeResponse.fromJson(Map<String, dynamic> json) => _$UserOrganizedCrimeResponseFromJson(json);

  static const toJsonFactory = _$UserOrganizedCrimeResponseToJson;
  Map<String, dynamic> toJson() => _$UserOrganizedCrimeResponseToJson(this);

  @JsonKey(name: 'organizedCrime')
  final dynamic organizedCrime;
  static const fromJsonFactory = _$UserOrganizedCrimeResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserOrganizedCrimeResponse &&
            (identical(other.organizedCrime, organizedCrime) ||
                const DeepCollectionEquality().equals(
                  other.organizedCrime,
                  organizedCrime,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(organizedCrime) ^ runtimeType.hashCode;
}

extension $UserOrganizedCrimeResponseExtension on UserOrganizedCrimeResponse {
  UserOrganizedCrimeResponse copyWith({dynamic organizedCrime}) {
    return UserOrganizedCrimeResponse(
      organizedCrime: organizedCrime ?? this.organizedCrime,
    );
  }

  UserOrganizedCrimeResponse copyWithWrapped({
    Wrapped<dynamic>? organizedCrime,
  }) {
    return UserOrganizedCrimeResponse(
      organizedCrime: (organizedCrime != null ? organizedCrime.value : this.organizedCrime),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserList {
  const UserList({
    required this.id,
    required this.name,
    required this.level,
    required this.factionId,
    required this.lastAction,
    required this.status,
  });

  factory UserList.fromJson(Map<String, dynamic> json) => _$UserListFromJson(json);

  static const toJsonFactory = _$UserListToJson;
  Map<String, dynamic> toJson() => _$UserListToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'level')
  final int level;
  @JsonKey(name: 'faction_id')
  final dynamic factionId;
  @JsonKey(name: 'last_action')
  final UserLastAction lastAction;
  @JsonKey(name: 'status')
  final UserStatus status;
  static const fromJsonFactory = _$UserListFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserList &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.level, level) || const DeepCollectionEquality().equals(other.level, level)) &&
            (identical(other.factionId, factionId) ||
                const DeepCollectionEquality().equals(
                  other.factionId,
                  factionId,
                )) &&
            (identical(other.lastAction, lastAction) ||
                const DeepCollectionEquality().equals(
                  other.lastAction,
                  lastAction,
                )) &&
            (identical(other.status, status) || const DeepCollectionEquality().equals(other.status, status)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(level) ^
      const DeepCollectionEquality().hash(factionId) ^
      const DeepCollectionEquality().hash(lastAction) ^
      const DeepCollectionEquality().hash(status) ^
      runtimeType.hashCode;
}

extension $UserListExtension on UserList {
  UserList copyWith({
    int? id,
    String? name,
    int? level,
    dynamic factionId,
    UserLastAction? lastAction,
    UserStatus? status,
  }) {
    return UserList(
      id: id ?? this.id,
      name: name ?? this.name,
      level: level ?? this.level,
      factionId: factionId ?? this.factionId,
      lastAction: lastAction ?? this.lastAction,
      status: status ?? this.status,
    );
  }

  UserList copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<String>? name,
    Wrapped<int>? level,
    Wrapped<dynamic>? factionId,
    Wrapped<UserLastAction>? lastAction,
    Wrapped<UserStatus>? status,
  }) {
    return UserList(
      id: (id != null ? id.value : this.id),
      name: (name != null ? name.value : this.name),
      level: (level != null ? level.value : this.level),
      factionId: (factionId != null ? factionId.value : this.factionId),
      lastAction: (lastAction != null ? lastAction.value : this.lastAction),
      status: (status != null ? status.value : this.status),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserListResponse {
  const UserListResponse({required this.list, required this.metadata});

  factory UserListResponse.fromJson(Map<String, dynamic> json) => _$UserListResponseFromJson(json);

  static const toJsonFactory = _$UserListResponseToJson;
  Map<String, dynamic> toJson() => _$UserListResponseToJson(this);

  @JsonKey(name: 'list', defaultValue: <UserList>[])
  final List<UserList> list;
  @JsonKey(name: '_metadata')
  final RequestMetadataWithLinks metadata;
  static const fromJsonFactory = _$UserListResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserListResponse &&
            (identical(other.list, list) || const DeepCollectionEquality().equals(other.list, list)) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality().equals(
                  other.metadata,
                  metadata,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(list) ^ const DeepCollectionEquality().hash(metadata) ^ runtimeType.hashCode;
}

extension $UserListResponseExtension on UserListResponse {
  UserListResponse copyWith({
    List<UserList>? list,
    RequestMetadataWithLinks? metadata,
  }) {
    return UserListResponse(
      list: list ?? this.list,
      metadata: metadata ?? this.metadata,
    );
  }

  UserListResponse copyWithWrapped({
    Wrapped<List<UserList>>? list,
    Wrapped<RequestMetadataWithLinks>? metadata,
  }) {
    return UserListResponse(
      list: (list != null ? list.value : this.list),
      metadata: (metadata != null ? metadata.value : this.metadata),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserSelectionName {
  const UserSelectionName();

  factory UserSelectionName.fromJson(Map<String, dynamic> json) => _$UserSelectionNameFromJson(json);

  static const toJsonFactory = _$UserSelectionNameToJson;
  Map<String, dynamic> toJson() => _$UserSelectionNameToJson(this);

  static const fromJsonFactory = _$UserSelectionNameFromJson;

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => runtimeType.hashCode;
}

@JsonSerializable(explicitToJson: true)
class UserLookupResponse {
  const UserLookupResponse({required this.selections});

  factory UserLookupResponse.fromJson(Map<String, dynamic> json) => _$UserLookupResponseFromJson(json);

  static const toJsonFactory = _$UserLookupResponseToJson;
  Map<String, dynamic> toJson() => _$UserLookupResponseToJson(this);

  @JsonKey(name: 'selections', defaultValue: <UserSelectionName>[])
  final List<UserSelectionName> selections;
  static const fromJsonFactory = _$UserLookupResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserLookupResponse &&
            (identical(other.selections, selections) ||
                const DeepCollectionEquality().equals(
                  other.selections,
                  selections,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(selections) ^ runtimeType.hashCode;
}

extension $UserLookupResponseExtension on UserLookupResponse {
  UserLookupResponse copyWith({List<UserSelectionName>? selections}) {
    return UserLookupResponse(selections: selections ?? this.selections);
  }

  UserLookupResponse copyWithWrapped({
    Wrapped<List<UserSelectionName>>? selections,
  }) {
    return UserLookupResponse(
      selections: (selections != null ? selections.value : this.selections),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsOther {
  const PersonalStatsOther({required this.other});

  factory PersonalStatsOther.fromJson(Map<String, dynamic> json) => _$PersonalStatsOtherFromJson(json);

  static const toJsonFactory = _$PersonalStatsOtherToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsOtherToJson(this);

  @JsonKey(name: 'other')
  final PersonalStatsOther$Other other;
  static const fromJsonFactory = _$PersonalStatsOtherFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsOther &&
            (identical(other.other, other) || const DeepCollectionEquality().equals(other.other, other)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(other) ^ runtimeType.hashCode;
}

extension $PersonalStatsOtherExtension on PersonalStatsOther {
  PersonalStatsOther copyWith({PersonalStatsOther$Other? other}) {
    return PersonalStatsOther(other: other ?? this.other);
  }

  PersonalStatsOther copyWithWrapped({
    Wrapped<PersonalStatsOther$Other>? other,
  }) {
    return PersonalStatsOther(
      other: (other != null ? other.value : this.other),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsOtherPopular {
  const PersonalStatsOtherPopular({required this.other});

  factory PersonalStatsOtherPopular.fromJson(Map<String, dynamic> json) => _$PersonalStatsOtherPopularFromJson(json);

  static const toJsonFactory = _$PersonalStatsOtherPopularToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsOtherPopularToJson(this);

  @JsonKey(name: 'other')
  final PersonalStatsOtherPopular$Other other;
  static const fromJsonFactory = _$PersonalStatsOtherPopularFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsOtherPopular &&
            (identical(other.other, other) || const DeepCollectionEquality().equals(other.other, other)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(other) ^ runtimeType.hashCode;
}

extension $PersonalStatsOtherPopularExtension on PersonalStatsOtherPopular {
  PersonalStatsOtherPopular copyWith({PersonalStatsOtherPopular$Other? other}) {
    return PersonalStatsOtherPopular(other: other ?? this.other);
  }

  PersonalStatsOtherPopular copyWithWrapped({
    Wrapped<PersonalStatsOtherPopular$Other>? other,
  }) {
    return PersonalStatsOtherPopular(
      other: (other != null ? other.value : this.other),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsNetworthExtended {
  const PersonalStatsNetworthExtended({required this.networth});

  factory PersonalStatsNetworthExtended.fromJson(Map<String, dynamic> json) =>
      _$PersonalStatsNetworthExtendedFromJson(json);

  static const toJsonFactory = _$PersonalStatsNetworthExtendedToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsNetworthExtendedToJson(this);

  @JsonKey(name: 'networth')
  final PersonalStatsNetworthExtended$Networth networth;
  static const fromJsonFactory = _$PersonalStatsNetworthExtendedFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsNetworthExtended &&
            (identical(other.networth, networth) ||
                const DeepCollectionEquality().equals(
                  other.networth,
                  networth,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(networth) ^ runtimeType.hashCode;
}

extension $PersonalStatsNetworthExtendedExtension on PersonalStatsNetworthExtended {
  PersonalStatsNetworthExtended copyWith({
    PersonalStatsNetworthExtended$Networth? networth,
  }) {
    return PersonalStatsNetworthExtended(networth: networth ?? this.networth);
  }

  PersonalStatsNetworthExtended copyWithWrapped({
    Wrapped<PersonalStatsNetworthExtended$Networth>? networth,
  }) {
    return PersonalStatsNetworthExtended(
      networth: (networth != null ? networth.value : this.networth),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsNetworthPublic {
  const PersonalStatsNetworthPublic({required this.networth});

  factory PersonalStatsNetworthPublic.fromJson(Map<String, dynamic> json) =>
      _$PersonalStatsNetworthPublicFromJson(json);

  static const toJsonFactory = _$PersonalStatsNetworthPublicToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsNetworthPublicToJson(this);

  @JsonKey(name: 'networth')
  final PersonalStatsNetworthPublic$Networth networth;
  static const fromJsonFactory = _$PersonalStatsNetworthPublicFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsNetworthPublic &&
            (identical(other.networth, networth) ||
                const DeepCollectionEquality().equals(
                  other.networth,
                  networth,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(networth) ^ runtimeType.hashCode;
}

extension $PersonalStatsNetworthPublicExtension on PersonalStatsNetworthPublic {
  PersonalStatsNetworthPublic copyWith({
    PersonalStatsNetworthPublic$Networth? networth,
  }) {
    return PersonalStatsNetworthPublic(networth: networth ?? this.networth);
  }

  PersonalStatsNetworthPublic copyWithWrapped({
    Wrapped<PersonalStatsNetworthPublic$Networth>? networth,
  }) {
    return PersonalStatsNetworthPublic(
      networth: (networth != null ? networth.value : this.networth),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsRacing {
  const PersonalStatsRacing({required this.racing});

  factory PersonalStatsRacing.fromJson(Map<String, dynamic> json) => _$PersonalStatsRacingFromJson(json);

  static const toJsonFactory = _$PersonalStatsRacingToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsRacingToJson(this);

  @JsonKey(name: 'racing')
  final PersonalStatsRacing$Racing racing;
  static const fromJsonFactory = _$PersonalStatsRacingFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsRacing &&
            (identical(other.racing, racing) || const DeepCollectionEquality().equals(other.racing, racing)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(racing) ^ runtimeType.hashCode;
}

extension $PersonalStatsRacingExtension on PersonalStatsRacing {
  PersonalStatsRacing copyWith({PersonalStatsRacing$Racing? racing}) {
    return PersonalStatsRacing(racing: racing ?? this.racing);
  }

  PersonalStatsRacing copyWithWrapped({
    Wrapped<PersonalStatsRacing$Racing>? racing,
  }) {
    return PersonalStatsRacing(
      racing: (racing != null ? racing.value : this.racing),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsMissions {
  const PersonalStatsMissions({required this.missions});

  factory PersonalStatsMissions.fromJson(Map<String, dynamic> json) => _$PersonalStatsMissionsFromJson(json);

  static const toJsonFactory = _$PersonalStatsMissionsToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsMissionsToJson(this);

  @JsonKey(name: 'missions')
  final PersonalStatsMissions$Missions missions;
  static const fromJsonFactory = _$PersonalStatsMissionsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsMissions &&
            (identical(other.missions, missions) ||
                const DeepCollectionEquality().equals(
                  other.missions,
                  missions,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(missions) ^ runtimeType.hashCode;
}

extension $PersonalStatsMissionsExtension on PersonalStatsMissions {
  PersonalStatsMissions copyWith({PersonalStatsMissions$Missions? missions}) {
    return PersonalStatsMissions(missions: missions ?? this.missions);
  }

  PersonalStatsMissions copyWithWrapped({
    Wrapped<PersonalStatsMissions$Missions>? missions,
  }) {
    return PersonalStatsMissions(
      missions: (missions != null ? missions.value : this.missions),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsDrugs {
  const PersonalStatsDrugs({required this.drugs});

  factory PersonalStatsDrugs.fromJson(Map<String, dynamic> json) => _$PersonalStatsDrugsFromJson(json);

  static const toJsonFactory = _$PersonalStatsDrugsToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsDrugsToJson(this);

  @JsonKey(name: 'drugs')
  final PersonalStatsDrugs$Drugs drugs;
  static const fromJsonFactory = _$PersonalStatsDrugsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsDrugs &&
            (identical(other.drugs, drugs) || const DeepCollectionEquality().equals(other.drugs, drugs)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(drugs) ^ runtimeType.hashCode;
}

extension $PersonalStatsDrugsExtension on PersonalStatsDrugs {
  PersonalStatsDrugs copyWith({PersonalStatsDrugs$Drugs? drugs}) {
    return PersonalStatsDrugs(drugs: drugs ?? this.drugs);
  }

  PersonalStatsDrugs copyWithWrapped({
    Wrapped<PersonalStatsDrugs$Drugs>? drugs,
  }) {
    return PersonalStatsDrugs(
      drugs: (drugs != null ? drugs.value : this.drugs),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsTravel {
  const PersonalStatsTravel({required this.travel});

  factory PersonalStatsTravel.fromJson(Map<String, dynamic> json) => _$PersonalStatsTravelFromJson(json);

  static const toJsonFactory = _$PersonalStatsTravelToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsTravelToJson(this);

  @JsonKey(name: 'travel')
  final PersonalStatsTravel$Travel travel;
  static const fromJsonFactory = _$PersonalStatsTravelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsTravel &&
            (identical(other.travel, travel) || const DeepCollectionEquality().equals(other.travel, travel)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(travel) ^ runtimeType.hashCode;
}

extension $PersonalStatsTravelExtension on PersonalStatsTravel {
  PersonalStatsTravel copyWith({PersonalStatsTravel$Travel? travel}) {
    return PersonalStatsTravel(travel: travel ?? this.travel);
  }

  PersonalStatsTravel copyWithWrapped({
    Wrapped<PersonalStatsTravel$Travel>? travel,
  }) {
    return PersonalStatsTravel(
      travel: (travel != null ? travel.value : this.travel),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsTravelPopular {
  const PersonalStatsTravelPopular({required this.travel});

  factory PersonalStatsTravelPopular.fromJson(Map<String, dynamic> json) => _$PersonalStatsTravelPopularFromJson(json);

  static const toJsonFactory = _$PersonalStatsTravelPopularToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsTravelPopularToJson(this);

  @JsonKey(name: 'travel')
  final PersonalStatsTravelPopular$Travel travel;
  static const fromJsonFactory = _$PersonalStatsTravelPopularFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsTravelPopular &&
            (identical(other.travel, travel) || const DeepCollectionEquality().equals(other.travel, travel)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(travel) ^ runtimeType.hashCode;
}

extension $PersonalStatsTravelPopularExtension on PersonalStatsTravelPopular {
  PersonalStatsTravelPopular copyWith({
    PersonalStatsTravelPopular$Travel? travel,
  }) {
    return PersonalStatsTravelPopular(travel: travel ?? this.travel);
  }

  PersonalStatsTravelPopular copyWithWrapped({
    Wrapped<PersonalStatsTravelPopular$Travel>? travel,
  }) {
    return PersonalStatsTravelPopular(
      travel: (travel != null ? travel.value : this.travel),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsItems {
  const PersonalStatsItems({required this.items});

  factory PersonalStatsItems.fromJson(Map<String, dynamic> json) => _$PersonalStatsItemsFromJson(json);

  static const toJsonFactory = _$PersonalStatsItemsToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsItemsToJson(this);

  @JsonKey(name: 'items')
  final PersonalStatsItems$Items items;
  static const fromJsonFactory = _$PersonalStatsItemsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsItems &&
            (identical(other.items, items) || const DeepCollectionEquality().equals(other.items, items)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(items) ^ runtimeType.hashCode;
}

extension $PersonalStatsItemsExtension on PersonalStatsItems {
  PersonalStatsItems copyWith({PersonalStatsItems$Items? items}) {
    return PersonalStatsItems(items: items ?? this.items);
  }

  PersonalStatsItems copyWithWrapped({
    Wrapped<PersonalStatsItems$Items>? items,
  }) {
    return PersonalStatsItems(
      items: (items != null ? items.value : this.items),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsItemsPopular {
  const PersonalStatsItemsPopular({required this.items});

  factory PersonalStatsItemsPopular.fromJson(Map<String, dynamic> json) => _$PersonalStatsItemsPopularFromJson(json);

  static const toJsonFactory = _$PersonalStatsItemsPopularToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsItemsPopularToJson(this);

  @JsonKey(name: 'items')
  final PersonalStatsItemsPopular$Items items;
  static const fromJsonFactory = _$PersonalStatsItemsPopularFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsItemsPopular &&
            (identical(other.items, items) || const DeepCollectionEquality().equals(other.items, items)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(items) ^ runtimeType.hashCode;
}

extension $PersonalStatsItemsPopularExtension on PersonalStatsItemsPopular {
  PersonalStatsItemsPopular copyWith({PersonalStatsItemsPopular$Items? items}) {
    return PersonalStatsItemsPopular(items: items ?? this.items);
  }

  PersonalStatsItemsPopular copyWithWrapped({
    Wrapped<PersonalStatsItemsPopular$Items>? items,
  }) {
    return PersonalStatsItemsPopular(
      items: (items != null ? items.value : this.items),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsInvestments {
  const PersonalStatsInvestments({required this.investments});

  factory PersonalStatsInvestments.fromJson(Map<String, dynamic> json) => _$PersonalStatsInvestmentsFromJson(json);

  static const toJsonFactory = _$PersonalStatsInvestmentsToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsInvestmentsToJson(this);

  @JsonKey(name: 'investments')
  final PersonalStatsInvestments$Investments investments;
  static const fromJsonFactory = _$PersonalStatsInvestmentsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsInvestments &&
            (identical(other.investments, investments) ||
                const DeepCollectionEquality().equals(
                  other.investments,
                  investments,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(investments) ^ runtimeType.hashCode;
}

extension $PersonalStatsInvestmentsExtension on PersonalStatsInvestments {
  PersonalStatsInvestments copyWith({
    PersonalStatsInvestments$Investments? investments,
  }) {
    return PersonalStatsInvestments(
      investments: investments ?? this.investments,
    );
  }

  PersonalStatsInvestments copyWithWrapped({
    Wrapped<PersonalStatsInvestments$Investments>? investments,
  }) {
    return PersonalStatsInvestments(
      investments: (investments != null ? investments.value : this.investments),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsBounties {
  const PersonalStatsBounties({required this.bounties});

  factory PersonalStatsBounties.fromJson(Map<String, dynamic> json) => _$PersonalStatsBountiesFromJson(json);

  static const toJsonFactory = _$PersonalStatsBountiesToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsBountiesToJson(this);

  @JsonKey(name: 'bounties')
  final PersonalStatsBounties$Bounties bounties;
  static const fromJsonFactory = _$PersonalStatsBountiesFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsBounties &&
            (identical(other.bounties, bounties) ||
                const DeepCollectionEquality().equals(
                  other.bounties,
                  bounties,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(bounties) ^ runtimeType.hashCode;
}

extension $PersonalStatsBountiesExtension on PersonalStatsBounties {
  PersonalStatsBounties copyWith({PersonalStatsBounties$Bounties? bounties}) {
    return PersonalStatsBounties(bounties: bounties ?? this.bounties);
  }

  PersonalStatsBounties copyWithWrapped({
    Wrapped<PersonalStatsBounties$Bounties>? bounties,
  }) {
    return PersonalStatsBounties(
      bounties: (bounties != null ? bounties.value : this.bounties),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsCrimesV2 {
  const PersonalStatsCrimesV2({
    required this.offenses,
    required this.skills,
    required this.version,
  });

  factory PersonalStatsCrimesV2.fromJson(Map<String, dynamic> json) => _$PersonalStatsCrimesV2FromJson(json);

  static const toJsonFactory = _$PersonalStatsCrimesV2ToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsCrimesV2ToJson(this);

  @JsonKey(name: 'offenses')
  final PersonalStatsCrimesV2$Offenses offenses;
  @JsonKey(name: 'skills')
  final PersonalStatsCrimesV2$Skills skills;
  @JsonKey(name: 'version')
  final String version;
  static const fromJsonFactory = _$PersonalStatsCrimesV2FromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsCrimesV2 &&
            (identical(other.offenses, offenses) ||
                const DeepCollectionEquality().equals(
                  other.offenses,
                  offenses,
                )) &&
            (identical(other.skills, skills) || const DeepCollectionEquality().equals(other.skills, skills)) &&
            (identical(other.version, version) || const DeepCollectionEquality().equals(other.version, version)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(offenses) ^
      const DeepCollectionEquality().hash(skills) ^
      const DeepCollectionEquality().hash(version) ^
      runtimeType.hashCode;
}

extension $PersonalStatsCrimesV2Extension on PersonalStatsCrimesV2 {
  PersonalStatsCrimesV2 copyWith({
    PersonalStatsCrimesV2$Offenses? offenses,
    PersonalStatsCrimesV2$Skills? skills,
    String? version,
  }) {
    return PersonalStatsCrimesV2(
      offenses: offenses ?? this.offenses,
      skills: skills ?? this.skills,
      version: version ?? this.version,
    );
  }

  PersonalStatsCrimesV2 copyWithWrapped({
    Wrapped<PersonalStatsCrimesV2$Offenses>? offenses,
    Wrapped<PersonalStatsCrimesV2$Skills>? skills,
    Wrapped<String>? version,
  }) {
    return PersonalStatsCrimesV2(
      offenses: (offenses != null ? offenses.value : this.offenses),
      skills: (skills != null ? skills.value : this.skills),
      version: (version != null ? version.value : this.version),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsCrimesV1 {
  const PersonalStatsCrimesV1({
    required this.total,
    required this.sellIllegalGoods,
    required this.theft,
    required this.autoTheft,
    required this.drugDeals,
    required this.computer,
    required this.fraud,
    required this.murder,
    required this.other,
    required this.organizedCrimes,
    required this.version,
  });

  factory PersonalStatsCrimesV1.fromJson(Map<String, dynamic> json) => _$PersonalStatsCrimesV1FromJson(json);

  static const toJsonFactory = _$PersonalStatsCrimesV1ToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsCrimesV1ToJson(this);

  @JsonKey(name: 'total')
  final int total;
  @JsonKey(name: 'sell_illegal_goods')
  final int sellIllegalGoods;
  @JsonKey(name: 'theft')
  final int theft;
  @JsonKey(name: 'auto_theft')
  final int autoTheft;
  @JsonKey(name: 'drug_deals')
  final int drugDeals;
  @JsonKey(name: 'computer')
  final int computer;
  @JsonKey(name: 'fraud')
  final int fraud;
  @JsonKey(name: 'murder')
  final int murder;
  @JsonKey(name: 'other')
  final int other;
  @JsonKey(name: 'organized_crimes')
  final int organizedCrimes;
  @JsonKey(name: 'version')
  final String version;
  static const fromJsonFactory = _$PersonalStatsCrimesV1FromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsCrimesV1 &&
            (identical(other.total, total) || const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.sellIllegalGoods, sellIllegalGoods) ||
                const DeepCollectionEquality().equals(
                  other.sellIllegalGoods,
                  sellIllegalGoods,
                )) &&
            (identical(other.theft, theft) || const DeepCollectionEquality().equals(other.theft, theft)) &&
            (identical(other.autoTheft, autoTheft) ||
                const DeepCollectionEquality().equals(
                  other.autoTheft,
                  autoTheft,
                )) &&
            (identical(other.drugDeals, drugDeals) ||
                const DeepCollectionEquality().equals(
                  other.drugDeals,
                  drugDeals,
                )) &&
            (identical(other.computer, computer) ||
                const DeepCollectionEquality().equals(
                  other.computer,
                  computer,
                )) &&
            (identical(other.fraud, fraud) || const DeepCollectionEquality().equals(other.fraud, fraud)) &&
            (identical(other.murder, murder) || const DeepCollectionEquality().equals(other.murder, murder)) &&
            (identical(other.other, other) || const DeepCollectionEquality().equals(other.other, other)) &&
            (identical(other.organizedCrimes, organizedCrimes) ||
                const DeepCollectionEquality().equals(
                  other.organizedCrimes,
                  organizedCrimes,
                )) &&
            (identical(other.version, version) || const DeepCollectionEquality().equals(other.version, version)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(sellIllegalGoods) ^
      const DeepCollectionEquality().hash(theft) ^
      const DeepCollectionEquality().hash(autoTheft) ^
      const DeepCollectionEquality().hash(drugDeals) ^
      const DeepCollectionEquality().hash(computer) ^
      const DeepCollectionEquality().hash(fraud) ^
      const DeepCollectionEquality().hash(murder) ^
      const DeepCollectionEquality().hash(other) ^
      const DeepCollectionEquality().hash(organizedCrimes) ^
      const DeepCollectionEquality().hash(version) ^
      runtimeType.hashCode;
}

extension $PersonalStatsCrimesV1Extension on PersonalStatsCrimesV1 {
  PersonalStatsCrimesV1 copyWith({
    int? total,
    int? sellIllegalGoods,
    int? theft,
    int? autoTheft,
    int? drugDeals,
    int? computer,
    int? fraud,
    int? murder,
    int? other,
    int? organizedCrimes,
    String? version,
  }) {
    return PersonalStatsCrimesV1(
      total: total ?? this.total,
      sellIllegalGoods: sellIllegalGoods ?? this.sellIllegalGoods,
      theft: theft ?? this.theft,
      autoTheft: autoTheft ?? this.autoTheft,
      drugDeals: drugDeals ?? this.drugDeals,
      computer: computer ?? this.computer,
      fraud: fraud ?? this.fraud,
      murder: murder ?? this.murder,
      other: other ?? this.other,
      organizedCrimes: organizedCrimes ?? this.organizedCrimes,
      version: version ?? this.version,
    );
  }

  PersonalStatsCrimesV1 copyWithWrapped({
    Wrapped<int>? total,
    Wrapped<int>? sellIllegalGoods,
    Wrapped<int>? theft,
    Wrapped<int>? autoTheft,
    Wrapped<int>? drugDeals,
    Wrapped<int>? computer,
    Wrapped<int>? fraud,
    Wrapped<int>? murder,
    Wrapped<int>? other,
    Wrapped<int>? organizedCrimes,
    Wrapped<String>? version,
  }) {
    return PersonalStatsCrimesV1(
      total: (total != null ? total.value : this.total),
      sellIllegalGoods: (sellIllegalGoods != null ? sellIllegalGoods.value : this.sellIllegalGoods),
      theft: (theft != null ? theft.value : this.theft),
      autoTheft: (autoTheft != null ? autoTheft.value : this.autoTheft),
      drugDeals: (drugDeals != null ? drugDeals.value : this.drugDeals),
      computer: (computer != null ? computer.value : this.computer),
      fraud: (fraud != null ? fraud.value : this.fraud),
      murder: (murder != null ? murder.value : this.murder),
      other: (other != null ? other.value : this.other),
      organizedCrimes: (organizedCrimes != null ? organizedCrimes.value : this.organizedCrimes),
      version: (version != null ? version.value : this.version),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsCrimesPopular {
  const PersonalStatsCrimesPopular({required this.crimes});

  factory PersonalStatsCrimesPopular.fromJson(Map<String, dynamic> json) => _$PersonalStatsCrimesPopularFromJson(json);

  static const toJsonFactory = _$PersonalStatsCrimesPopularToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsCrimesPopularToJson(this);

  @JsonKey(name: 'crimes')
  final PersonalStatsCrimesPopular$Crimes crimes;
  static const fromJsonFactory = _$PersonalStatsCrimesPopularFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsCrimesPopular &&
            (identical(other.crimes, crimes) || const DeepCollectionEquality().equals(other.crimes, crimes)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(crimes) ^ runtimeType.hashCode;
}

extension $PersonalStatsCrimesPopularExtension on PersonalStatsCrimesPopular {
  PersonalStatsCrimesPopular copyWith({
    PersonalStatsCrimesPopular$Crimes? crimes,
  }) {
    return PersonalStatsCrimesPopular(crimes: crimes ?? this.crimes);
  }

  PersonalStatsCrimesPopular copyWithWrapped({
    Wrapped<PersonalStatsCrimesPopular$Crimes>? crimes,
  }) {
    return PersonalStatsCrimesPopular(
      crimes: (crimes != null ? crimes.value : this.crimes),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsCommunication {
  const PersonalStatsCommunication({required this.communication});

  factory PersonalStatsCommunication.fromJson(Map<String, dynamic> json) => _$PersonalStatsCommunicationFromJson(json);

  static const toJsonFactory = _$PersonalStatsCommunicationToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsCommunicationToJson(this);

  @JsonKey(name: 'communication')
  final PersonalStatsCommunication$Communication communication;
  static const fromJsonFactory = _$PersonalStatsCommunicationFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsCommunication &&
            (identical(other.communication, communication) ||
                const DeepCollectionEquality().equals(
                  other.communication,
                  communication,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(communication) ^ runtimeType.hashCode;
}

extension $PersonalStatsCommunicationExtension on PersonalStatsCommunication {
  PersonalStatsCommunication copyWith({
    PersonalStatsCommunication$Communication? communication,
  }) {
    return PersonalStatsCommunication(
      communication: communication ?? this.communication,
    );
  }

  PersonalStatsCommunication copyWithWrapped({
    Wrapped<PersonalStatsCommunication$Communication>? communication,
  }) {
    return PersonalStatsCommunication(
      communication: (communication != null ? communication.value : this.communication),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsFinishingHits {
  const PersonalStatsFinishingHits({required this.finishingHits});

  factory PersonalStatsFinishingHits.fromJson(Map<String, dynamic> json) => _$PersonalStatsFinishingHitsFromJson(json);

  static const toJsonFactory = _$PersonalStatsFinishingHitsToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsFinishingHitsToJson(this);

  @JsonKey(name: 'finishing_hits')
  final PersonalStatsFinishingHits$FinishingHits finishingHits;
  static const fromJsonFactory = _$PersonalStatsFinishingHitsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsFinishingHits &&
            (identical(other.finishingHits, finishingHits) ||
                const DeepCollectionEquality().equals(
                  other.finishingHits,
                  finishingHits,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(finishingHits) ^ runtimeType.hashCode;
}

extension $PersonalStatsFinishingHitsExtension on PersonalStatsFinishingHits {
  PersonalStatsFinishingHits copyWith({
    PersonalStatsFinishingHits$FinishingHits? finishingHits,
  }) {
    return PersonalStatsFinishingHits(
      finishingHits: finishingHits ?? this.finishingHits,
    );
  }

  PersonalStatsFinishingHits copyWithWrapped({
    Wrapped<PersonalStatsFinishingHits$FinishingHits>? finishingHits,
  }) {
    return PersonalStatsFinishingHits(
      finishingHits: (finishingHits != null ? finishingHits.value : this.finishingHits),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsHospital {
  const PersonalStatsHospital({required this.hospital});

  factory PersonalStatsHospital.fromJson(Map<String, dynamic> json) => _$PersonalStatsHospitalFromJson(json);

  static const toJsonFactory = _$PersonalStatsHospitalToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsHospitalToJson(this);

  @JsonKey(name: 'hospital')
  final PersonalStatsHospital$Hospital hospital;
  static const fromJsonFactory = _$PersonalStatsHospitalFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsHospital &&
            (identical(other.hospital, hospital) ||
                const DeepCollectionEquality().equals(
                  other.hospital,
                  hospital,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(hospital) ^ runtimeType.hashCode;
}

extension $PersonalStatsHospitalExtension on PersonalStatsHospital {
  PersonalStatsHospital copyWith({PersonalStatsHospital$Hospital? hospital}) {
    return PersonalStatsHospital(hospital: hospital ?? this.hospital);
  }

  PersonalStatsHospital copyWithWrapped({
    Wrapped<PersonalStatsHospital$Hospital>? hospital,
  }) {
    return PersonalStatsHospital(
      hospital: (hospital != null ? hospital.value : this.hospital),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsHospitalPopular {
  const PersonalStatsHospitalPopular({required this.hospital});

  factory PersonalStatsHospitalPopular.fromJson(Map<String, dynamic> json) =>
      _$PersonalStatsHospitalPopularFromJson(json);

  static const toJsonFactory = _$PersonalStatsHospitalPopularToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsHospitalPopularToJson(this);

  @JsonKey(name: 'hospital')
  final PersonalStatsHospitalPopular$Hospital hospital;
  static const fromJsonFactory = _$PersonalStatsHospitalPopularFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsHospitalPopular &&
            (identical(other.hospital, hospital) ||
                const DeepCollectionEquality().equals(
                  other.hospital,
                  hospital,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(hospital) ^ runtimeType.hashCode;
}

extension $PersonalStatsHospitalPopularExtension on PersonalStatsHospitalPopular {
  PersonalStatsHospitalPopular copyWith({
    PersonalStatsHospitalPopular$Hospital? hospital,
  }) {
    return PersonalStatsHospitalPopular(hospital: hospital ?? this.hospital);
  }

  PersonalStatsHospitalPopular copyWithWrapped({
    Wrapped<PersonalStatsHospitalPopular$Hospital>? hospital,
  }) {
    return PersonalStatsHospitalPopular(
      hospital: (hospital != null ? hospital.value : this.hospital),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsJail {
  const PersonalStatsJail({required this.jail});

  factory PersonalStatsJail.fromJson(Map<String, dynamic> json) => _$PersonalStatsJailFromJson(json);

  static const toJsonFactory = _$PersonalStatsJailToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsJailToJson(this);

  @JsonKey(name: 'jail')
  final PersonalStatsJail$Jail jail;
  static const fromJsonFactory = _$PersonalStatsJailFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsJail &&
            (identical(other.jail, jail) || const DeepCollectionEquality().equals(other.jail, jail)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(jail) ^ runtimeType.hashCode;
}

extension $PersonalStatsJailExtension on PersonalStatsJail {
  PersonalStatsJail copyWith({PersonalStatsJail$Jail? jail}) {
    return PersonalStatsJail(jail: jail ?? this.jail);
  }

  PersonalStatsJail copyWithWrapped({Wrapped<PersonalStatsJail$Jail>? jail}) {
    return PersonalStatsJail(jail: (jail != null ? jail.value : this.jail));
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsTrading {
  const PersonalStatsTrading({required this.trading});

  factory PersonalStatsTrading.fromJson(Map<String, dynamic> json) => _$PersonalStatsTradingFromJson(json);

  static const toJsonFactory = _$PersonalStatsTradingToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsTradingToJson(this);

  @JsonKey(name: 'trading')
  final PersonalStatsTrading$Trading trading;
  static const fromJsonFactory = _$PersonalStatsTradingFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsTrading &&
            (identical(other.trading, trading) || const DeepCollectionEquality().equals(other.trading, trading)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(trading) ^ runtimeType.hashCode;
}

extension $PersonalStatsTradingExtension on PersonalStatsTrading {
  PersonalStatsTrading copyWith({PersonalStatsTrading$Trading? trading}) {
    return PersonalStatsTrading(trading: trading ?? this.trading);
  }

  PersonalStatsTrading copyWithWrapped({
    Wrapped<PersonalStatsTrading$Trading>? trading,
  }) {
    return PersonalStatsTrading(
      trading: (trading != null ? trading.value : this.trading),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsJobsPublic {
  const PersonalStatsJobsPublic({required this.jobs});

  factory PersonalStatsJobsPublic.fromJson(Map<String, dynamic> json) => _$PersonalStatsJobsPublicFromJson(json);

  static const toJsonFactory = _$PersonalStatsJobsPublicToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsJobsPublicToJson(this);

  @JsonKey(name: 'jobs')
  final PersonalStatsJobsPublic$Jobs jobs;
  static const fromJsonFactory = _$PersonalStatsJobsPublicFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsJobsPublic &&
            (identical(other.jobs, jobs) || const DeepCollectionEquality().equals(other.jobs, jobs)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(jobs) ^ runtimeType.hashCode;
}

extension $PersonalStatsJobsPublicExtension on PersonalStatsJobsPublic {
  PersonalStatsJobsPublic copyWith({PersonalStatsJobsPublic$Jobs? jobs}) {
    return PersonalStatsJobsPublic(jobs: jobs ?? this.jobs);
  }

  PersonalStatsJobsPublic copyWithWrapped({
    Wrapped<PersonalStatsJobsPublic$Jobs>? jobs,
  }) {
    return PersonalStatsJobsPublic(
      jobs: (jobs != null ? jobs.value : this.jobs),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsJobsExtended {
  const PersonalStatsJobsExtended({required this.jobs});

  factory PersonalStatsJobsExtended.fromJson(Map<String, dynamic> json) => _$PersonalStatsJobsExtendedFromJson(json);

  static const toJsonFactory = _$PersonalStatsJobsExtendedToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsJobsExtendedToJson(this);

  @JsonKey(name: 'jobs')
  final PersonalStatsJobsExtended$Jobs jobs;
  static const fromJsonFactory = _$PersonalStatsJobsExtendedFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsJobsExtended &&
            (identical(other.jobs, jobs) || const DeepCollectionEquality().equals(other.jobs, jobs)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(jobs) ^ runtimeType.hashCode;
}

extension $PersonalStatsJobsExtendedExtension on PersonalStatsJobsExtended {
  PersonalStatsJobsExtended copyWith({PersonalStatsJobsExtended$Jobs? jobs}) {
    return PersonalStatsJobsExtended(jobs: jobs ?? this.jobs);
  }

  PersonalStatsJobsExtended copyWithWrapped({
    Wrapped<PersonalStatsJobsExtended$Jobs>? jobs,
  }) {
    return PersonalStatsJobsExtended(
      jobs: (jobs != null ? jobs.value : this.jobs),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsBattleStats {
  const PersonalStatsBattleStats({required this.battleStats});

  factory PersonalStatsBattleStats.fromJson(Map<String, dynamic> json) => _$PersonalStatsBattleStatsFromJson(json);

  static const toJsonFactory = _$PersonalStatsBattleStatsToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsBattleStatsToJson(this);

  @JsonKey(name: 'battle_stats')
  final PersonalStatsBattleStats$BattleStats battleStats;
  static const fromJsonFactory = _$PersonalStatsBattleStatsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsBattleStats &&
            (identical(other.battleStats, battleStats) ||
                const DeepCollectionEquality().equals(
                  other.battleStats,
                  battleStats,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(battleStats) ^ runtimeType.hashCode;
}

extension $PersonalStatsBattleStatsExtension on PersonalStatsBattleStats {
  PersonalStatsBattleStats copyWith({
    PersonalStatsBattleStats$BattleStats? battleStats,
  }) {
    return PersonalStatsBattleStats(
      battleStats: battleStats ?? this.battleStats,
    );
  }

  PersonalStatsBattleStats copyWithWrapped({
    Wrapped<PersonalStatsBattleStats$BattleStats>? battleStats,
  }) {
    return PersonalStatsBattleStats(
      battleStats: (battleStats != null ? battleStats.value : this.battleStats),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsAttackingPublic {
  const PersonalStatsAttackingPublic({required this.attacking});

  factory PersonalStatsAttackingPublic.fromJson(Map<String, dynamic> json) =>
      _$PersonalStatsAttackingPublicFromJson(json);

  static const toJsonFactory = _$PersonalStatsAttackingPublicToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsAttackingPublicToJson(this);

  @JsonKey(name: 'attacking')
  final PersonalStatsAttackingPublic$Attacking attacking;
  static const fromJsonFactory = _$PersonalStatsAttackingPublicFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsAttackingPublic &&
            (identical(other.attacking, attacking) ||
                const DeepCollectionEquality().equals(
                  other.attacking,
                  attacking,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(attacking) ^ runtimeType.hashCode;
}

extension $PersonalStatsAttackingPublicExtension on PersonalStatsAttackingPublic {
  PersonalStatsAttackingPublic copyWith({
    PersonalStatsAttackingPublic$Attacking? attacking,
  }) {
    return PersonalStatsAttackingPublic(attacking: attacking ?? this.attacking);
  }

  PersonalStatsAttackingPublic copyWithWrapped({
    Wrapped<PersonalStatsAttackingPublic$Attacking>? attacking,
  }) {
    return PersonalStatsAttackingPublic(
      attacking: (attacking != null ? attacking.value : this.attacking),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsAttackingExtended {
  const PersonalStatsAttackingExtended({required this.attacking});

  factory PersonalStatsAttackingExtended.fromJson(Map<String, dynamic> json) =>
      _$PersonalStatsAttackingExtendedFromJson(json);

  static const toJsonFactory = _$PersonalStatsAttackingExtendedToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsAttackingExtendedToJson(this);

  @JsonKey(name: 'attacking')
  final PersonalStatsAttackingExtended$Attacking attacking;
  static const fromJsonFactory = _$PersonalStatsAttackingExtendedFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsAttackingExtended &&
            (identical(other.attacking, attacking) ||
                const DeepCollectionEquality().equals(
                  other.attacking,
                  attacking,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(attacking) ^ runtimeType.hashCode;
}

extension $PersonalStatsAttackingExtendedExtension on PersonalStatsAttackingExtended {
  PersonalStatsAttackingExtended copyWith({
    PersonalStatsAttackingExtended$Attacking? attacking,
  }) {
    return PersonalStatsAttackingExtended(
      attacking: attacking ?? this.attacking,
    );
  }

  PersonalStatsAttackingExtended copyWithWrapped({
    Wrapped<PersonalStatsAttackingExtended$Attacking>? attacking,
  }) {
    return PersonalStatsAttackingExtended(
      attacking: (attacking != null ? attacking.value : this.attacking),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsAttackingPopular {
  const PersonalStatsAttackingPopular({required this.attacking});

  factory PersonalStatsAttackingPopular.fromJson(Map<String, dynamic> json) =>
      _$PersonalStatsAttackingPopularFromJson(json);

  static const toJsonFactory = _$PersonalStatsAttackingPopularToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsAttackingPopularToJson(this);

  @JsonKey(name: 'attacking')
  final PersonalStatsAttackingPopular$Attacking attacking;
  static const fromJsonFactory = _$PersonalStatsAttackingPopularFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsAttackingPopular &&
            (identical(other.attacking, attacking) ||
                const DeepCollectionEquality().equals(
                  other.attacking,
                  attacking,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(attacking) ^ runtimeType.hashCode;
}

extension $PersonalStatsAttackingPopularExtension on PersonalStatsAttackingPopular {
  PersonalStatsAttackingPopular copyWith({
    PersonalStatsAttackingPopular$Attacking? attacking,
  }) {
    return PersonalStatsAttackingPopular(
      attacking: attacking ?? this.attacking,
    );
  }

  PersonalStatsAttackingPopular copyWithWrapped({
    Wrapped<PersonalStatsAttackingPopular$Attacking>? attacking,
  }) {
    return PersonalStatsAttackingPopular(
      attacking: (attacking != null ? attacking.value : this.attacking),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsHistoricStat {
  const PersonalStatsHistoricStat({
    required this.name,
    required this.$value,
    required this.timestamp,
  });

  factory PersonalStatsHistoricStat.fromJson(Map<String, dynamic> json) => _$PersonalStatsHistoricStatFromJson(json);

  static const toJsonFactory = _$PersonalStatsHistoricStatToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsHistoricStatToJson(this);

  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'value')
  final int $value;
  @JsonKey(name: 'timestamp')
  final int timestamp;
  static const fromJsonFactory = _$PersonalStatsHistoricStatFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsHistoricStat &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.$value, $value) || const DeepCollectionEquality().equals(other.$value, $value)) &&
            (identical(other.timestamp, timestamp) ||
                const DeepCollectionEquality().equals(
                  other.timestamp,
                  timestamp,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash($value) ^
      const DeepCollectionEquality().hash(timestamp) ^
      runtimeType.hashCode;
}

extension $PersonalStatsHistoricStatExtension on PersonalStatsHistoricStat {
  PersonalStatsHistoricStat copyWith({
    String? name,
    int? $value,
    int? timestamp,
  }) {
    return PersonalStatsHistoricStat(
      name: name ?? this.name,
      $value: $value ?? this.$value,
      timestamp: timestamp ?? this.timestamp,
    );
  }

  PersonalStatsHistoricStat copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<int>? $value,
    Wrapped<int>? timestamp,
  }) {
    return PersonalStatsHistoricStat(
      name: (name != null ? name.value : this.name),
      $value: ($value != null ? $value.value : this.$value),
      timestamp: (timestamp != null ? timestamp.value : this.timestamp),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserPersonalStatsHistoric {
  const UserPersonalStatsHistoric({required this.personalstats});

  factory UserPersonalStatsHistoric.fromJson(Map<String, dynamic> json) => _$UserPersonalStatsHistoricFromJson(json);

  static const toJsonFactory = _$UserPersonalStatsHistoricToJson;
  Map<String, dynamic> toJson() => _$UserPersonalStatsHistoricToJson(this);

  @JsonKey(name: 'personalstats', defaultValue: <PersonalStatsHistoricStat>[])
  final List<PersonalStatsHistoricStat> personalstats;
  static const fromJsonFactory = _$UserPersonalStatsHistoricFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserPersonalStatsHistoric &&
            (identical(other.personalstats, personalstats) ||
                const DeepCollectionEquality().equals(
                  other.personalstats,
                  personalstats,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(personalstats) ^ runtimeType.hashCode;
}

extension $UserPersonalStatsHistoricExtension on UserPersonalStatsHistoric {
  UserPersonalStatsHistoric copyWith({
    List<PersonalStatsHistoricStat>? personalstats,
  }) {
    return UserPersonalStatsHistoric(
      personalstats: personalstats ?? this.personalstats,
    );
  }

  UserPersonalStatsHistoric copyWithWrapped({
    Wrapped<List<PersonalStatsHistoricStat>>? personalstats,
  }) {
    return UserPersonalStatsHistoric(
      personalstats: (personalstats != null ? personalstats.value : this.personalstats),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsCrimes {
  const PersonalStatsCrimes({required this.crimes});

  factory PersonalStatsCrimes.fromJson(Map<String, dynamic> json) => _$PersonalStatsCrimesFromJson(json);

  static const toJsonFactory = _$PersonalStatsCrimesToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsCrimesToJson(this);

  @JsonKey(name: 'crimes')
  final dynamic crimes;
  static const fromJsonFactory = _$PersonalStatsCrimesFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsCrimes &&
            (identical(other.crimes, crimes) || const DeepCollectionEquality().equals(other.crimes, crimes)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(crimes) ^ runtimeType.hashCode;
}

extension $PersonalStatsCrimesExtension on PersonalStatsCrimes {
  PersonalStatsCrimes copyWith({dynamic crimes}) {
    return PersonalStatsCrimes(crimes: crimes ?? this.crimes);
  }

  PersonalStatsCrimes copyWithWrapped({Wrapped<dynamic>? crimes}) {
    return PersonalStatsCrimes(
      crimes: (crimes != null ? crimes.value : this.crimes),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserPersonalStatsPopular {
  const UserPersonalStatsPopular({required this.personalstats});

  factory UserPersonalStatsPopular.fromJson(Map<String, dynamic> json) => _$UserPersonalStatsPopularFromJson(json);

  static const toJsonFactory = _$UserPersonalStatsPopularToJson;
  Map<String, dynamic> toJson() => _$UserPersonalStatsPopularToJson(this);

  @JsonKey(name: 'personalstats')
  final dynamic personalstats;
  static const fromJsonFactory = _$UserPersonalStatsPopularFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserPersonalStatsPopular &&
            (identical(other.personalstats, personalstats) ||
                const DeepCollectionEquality().equals(
                  other.personalstats,
                  personalstats,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(personalstats) ^ runtimeType.hashCode;
}

extension $UserPersonalStatsPopularExtension on UserPersonalStatsPopular {
  UserPersonalStatsPopular copyWith({dynamic personalstats}) {
    return UserPersonalStatsPopular(
      personalstats: personalstats ?? this.personalstats,
    );
  }

  UserPersonalStatsPopular copyWithWrapped({Wrapped<dynamic>? personalstats}) {
    return UserPersonalStatsPopular(
      personalstats: (personalstats != null ? personalstats.value : this.personalstats),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserPersonalStatsCategory {
  const UserPersonalStatsCategory({required this.personalstats});

  factory UserPersonalStatsCategory.fromJson(Map<String, dynamic> json) => _$UserPersonalStatsCategoryFromJson(json);

  static const toJsonFactory = _$UserPersonalStatsCategoryToJson;
  Map<String, dynamic> toJson() => _$UserPersonalStatsCategoryToJson(this);

  @JsonKey(name: 'personalstats')
  final dynamic personalstats;
  static const fromJsonFactory = _$UserPersonalStatsCategoryFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserPersonalStatsCategory &&
            (identical(other.personalstats, personalstats) ||
                const DeepCollectionEquality().equals(
                  other.personalstats,
                  personalstats,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(personalstats) ^ runtimeType.hashCode;
}

extension $UserPersonalStatsCategoryExtension on UserPersonalStatsCategory {
  UserPersonalStatsCategory copyWith({dynamic personalstats}) {
    return UserPersonalStatsCategory(
      personalstats: personalstats ?? this.personalstats,
    );
  }

  UserPersonalStatsCategory copyWithWrapped({Wrapped<dynamic>? personalstats}) {
    return UserPersonalStatsCategory(
      personalstats: (personalstats != null ? personalstats.value : this.personalstats),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserPersonalStatsFull {
  const UserPersonalStatsFull({required this.personalstats});

  factory UserPersonalStatsFull.fromJson(Map<String, dynamic> json) => _$UserPersonalStatsFullFromJson(json);

  static const toJsonFactory = _$UserPersonalStatsFullToJson;
  Map<String, dynamic> toJson() => _$UserPersonalStatsFullToJson(this);

  @JsonKey(name: 'personalstats')
  final dynamic personalstats;
  static const fromJsonFactory = _$UserPersonalStatsFullFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserPersonalStatsFull &&
            (identical(other.personalstats, personalstats) ||
                const DeepCollectionEquality().equals(
                  other.personalstats,
                  personalstats,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(personalstats) ^ runtimeType.hashCode;
}

extension $UserPersonalStatsFullExtension on UserPersonalStatsFull {
  UserPersonalStatsFull copyWith({dynamic personalstats}) {
    return UserPersonalStatsFull(
      personalstats: personalstats ?? this.personalstats,
    );
  }

  UserPersonalStatsFull copyWithWrapped({Wrapped<dynamic>? personalstats}) {
    return UserPersonalStatsFull(
      personalstats: (personalstats != null ? personalstats.value : this.personalstats),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserPersonalStatsFullPublic {
  const UserPersonalStatsFullPublic({required this.personalstats});

  factory UserPersonalStatsFullPublic.fromJson(Map<String, dynamic> json) =>
      _$UserPersonalStatsFullPublicFromJson(json);

  static const toJsonFactory = _$UserPersonalStatsFullPublicToJson;
  Map<String, dynamic> toJson() => _$UserPersonalStatsFullPublicToJson(this);

  @JsonKey(name: 'personalstats')
  final dynamic personalstats;
  static const fromJsonFactory = _$UserPersonalStatsFullPublicFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserPersonalStatsFullPublic &&
            (identical(other.personalstats, personalstats) ||
                const DeepCollectionEquality().equals(
                  other.personalstats,
                  personalstats,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(personalstats) ^ runtimeType.hashCode;
}

extension $UserPersonalStatsFullPublicExtension on UserPersonalStatsFullPublic {
  UserPersonalStatsFullPublic copyWith({dynamic personalstats}) {
    return UserPersonalStatsFullPublic(
      personalstats: personalstats ?? this.personalstats,
    );
  }

  UserPersonalStatsFullPublic copyWithWrapped({
    Wrapped<dynamic>? personalstats,
  }) {
    return UserPersonalStatsFullPublic(
      personalstats: (personalstats != null ? personalstats.value : this.personalstats),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserPersonalStatsResponse {
  const UserPersonalStatsResponse();

  factory UserPersonalStatsResponse.fromJson(Map<String, dynamic> json) => _$UserPersonalStatsResponseFromJson(json);

  static const toJsonFactory = _$UserPersonalStatsResponseToJson;
  Map<String, dynamic> toJson() => _$UserPersonalStatsResponseToJson(this);

  static const fromJsonFactory = _$UserPersonalStatsResponseFromJson;

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => runtimeType.hashCode;
}

@JsonSerializable(explicitToJson: true)
class FactionRaidReport {
  const FactionRaidReport({
    required this.id,
    required this.start,
    required this.end,
    required this.aggressor,
    required this.defender,
  });

  factory FactionRaidReport.fromJson(Map<String, dynamic> json) => _$FactionRaidReportFromJson(json);

  static const toJsonFactory = _$FactionRaidReportToJson;
  Map<String, dynamic> toJson() => _$FactionRaidReportToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'start')
  final int start;
  @JsonKey(name: 'end')
  final int end;
  @JsonKey(name: 'aggressor')
  final FactionRaidReportFaction aggressor;
  @JsonKey(name: 'defender')
  final FactionRaidReportFaction defender;
  static const fromJsonFactory = _$FactionRaidReportFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionRaidReport &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.start, start) || const DeepCollectionEquality().equals(other.start, start)) &&
            (identical(other.end, end) || const DeepCollectionEquality().equals(other.end, end)) &&
            (identical(other.aggressor, aggressor) ||
                const DeepCollectionEquality().equals(
                  other.aggressor,
                  aggressor,
                )) &&
            (identical(other.defender, defender) ||
                const DeepCollectionEquality().equals(
                  other.defender,
                  defender,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(start) ^
      const DeepCollectionEquality().hash(end) ^
      const DeepCollectionEquality().hash(aggressor) ^
      const DeepCollectionEquality().hash(defender) ^
      runtimeType.hashCode;
}

extension $FactionRaidReportExtension on FactionRaidReport {
  FactionRaidReport copyWith({
    int? id,
    int? start,
    int? end,
    FactionRaidReportFaction? aggressor,
    FactionRaidReportFaction? defender,
  }) {
    return FactionRaidReport(
      id: id ?? this.id,
      start: start ?? this.start,
      end: end ?? this.end,
      aggressor: aggressor ?? this.aggressor,
      defender: defender ?? this.defender,
    );
  }

  FactionRaidReport copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<int>? start,
    Wrapped<int>? end,
    Wrapped<FactionRaidReportFaction>? aggressor,
    Wrapped<FactionRaidReportFaction>? defender,
  }) {
    return FactionRaidReport(
      id: (id != null ? id.value : this.id),
      start: (start != null ? start.value : this.start),
      end: (end != null ? end.value : this.end),
      aggressor: (aggressor != null ? aggressor.value : this.aggressor),
      defender: (defender != null ? defender.value : this.defender),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionRaidReportFaction {
  const FactionRaidReportFaction({
    required this.id,
    required this.name,
    required this.score,
    required this.attackers,
    required this.nonAttackers,
  });

  factory FactionRaidReportFaction.fromJson(Map<String, dynamic> json) => _$FactionRaidReportFactionFromJson(json);

  static const toJsonFactory = _$FactionRaidReportFactionToJson;
  Map<String, dynamic> toJson() => _$FactionRaidReportFactionToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'score')
  final double score;
  @JsonKey(name: 'attackers', defaultValue: <FactionRaidReportAttacker>[])
  final List<FactionRaidReportAttacker> attackers;
  @JsonKey(name: 'non_attackers', defaultValue: <FactionRaidReportUser>[])
  final List<FactionRaidReportUser> nonAttackers;
  static const fromJsonFactory = _$FactionRaidReportFactionFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionRaidReportFaction &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.score, score) || const DeepCollectionEquality().equals(other.score, score)) &&
            (identical(other.attackers, attackers) ||
                const DeepCollectionEquality().equals(
                  other.attackers,
                  attackers,
                )) &&
            (identical(other.nonAttackers, nonAttackers) ||
                const DeepCollectionEquality().equals(
                  other.nonAttackers,
                  nonAttackers,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(score) ^
      const DeepCollectionEquality().hash(attackers) ^
      const DeepCollectionEquality().hash(nonAttackers) ^
      runtimeType.hashCode;
}

extension $FactionRaidReportFactionExtension on FactionRaidReportFaction {
  FactionRaidReportFaction copyWith({
    int? id,
    String? name,
    double? score,
    List<FactionRaidReportAttacker>? attackers,
    List<FactionRaidReportUser>? nonAttackers,
  }) {
    return FactionRaidReportFaction(
      id: id ?? this.id,
      name: name ?? this.name,
      score: score ?? this.score,
      attackers: attackers ?? this.attackers,
      nonAttackers: nonAttackers ?? this.nonAttackers,
    );
  }

  FactionRaidReportFaction copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<String>? name,
    Wrapped<double>? score,
    Wrapped<List<FactionRaidReportAttacker>>? attackers,
    Wrapped<List<FactionRaidReportUser>>? nonAttackers,
  }) {
    return FactionRaidReportFaction(
      id: (id != null ? id.value : this.id),
      name: (name != null ? name.value : this.name),
      score: (score != null ? score.value : this.score),
      attackers: (attackers != null ? attackers.value : this.attackers),
      nonAttackers: (nonAttackers != null ? nonAttackers.value : this.nonAttackers),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionRaidReportAttacker {
  const FactionRaidReportAttacker({
    required this.user,
    required this.attacks,
    required this.damage,
  });

  factory FactionRaidReportAttacker.fromJson(Map<String, dynamic> json) => _$FactionRaidReportAttackerFromJson(json);

  static const toJsonFactory = _$FactionRaidReportAttackerToJson;
  Map<String, dynamic> toJson() => _$FactionRaidReportAttackerToJson(this);

  @JsonKey(name: 'user')
  final FactionRaidReportUser user;
  @JsonKey(name: 'attacks')
  final int attacks;
  @JsonKey(name: 'damage')
  final double damage;
  static const fromJsonFactory = _$FactionRaidReportAttackerFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionRaidReportAttacker &&
            (identical(other.user, user) || const DeepCollectionEquality().equals(other.user, user)) &&
            (identical(other.attacks, attacks) ||
                const DeepCollectionEquality().equals(
                  other.attacks,
                  attacks,
                )) &&
            (identical(other.damage, damage) || const DeepCollectionEquality().equals(other.damage, damage)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(user) ^
      const DeepCollectionEquality().hash(attacks) ^
      const DeepCollectionEquality().hash(damage) ^
      runtimeType.hashCode;
}

extension $FactionRaidReportAttackerExtension on FactionRaidReportAttacker {
  FactionRaidReportAttacker copyWith({
    FactionRaidReportUser? user,
    int? attacks,
    double? damage,
  }) {
    return FactionRaidReportAttacker(
      user: user ?? this.user,
      attacks: attacks ?? this.attacks,
      damage: damage ?? this.damage,
    );
  }

  FactionRaidReportAttacker copyWithWrapped({
    Wrapped<FactionRaidReportUser>? user,
    Wrapped<int>? attacks,
    Wrapped<double>? damage,
  }) {
    return FactionRaidReportAttacker(
      user: (user != null ? user.value : this.user),
      attacks: (attacks != null ? attacks.value : this.attacks),
      damage: (damage != null ? damage.value : this.damage),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionRaidReportUser {
  const FactionRaidReportUser({required this.id, required this.name});

  factory FactionRaidReportUser.fromJson(Map<String, dynamic> json) => _$FactionRaidReportUserFromJson(json);

  static const toJsonFactory = _$FactionRaidReportUserToJson;
  Map<String, dynamic> toJson() => _$FactionRaidReportUserToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'name')
  final String name;
  static const fromJsonFactory = _$FactionRaidReportUserFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionRaidReportUser &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^ const DeepCollectionEquality().hash(name) ^ runtimeType.hashCode;
}

extension $FactionRaidReportUserExtension on FactionRaidReportUser {
  FactionRaidReportUser copyWith({int? id, String? name}) {
    return FactionRaidReportUser(id: id ?? this.id, name: name ?? this.name);
  }

  FactionRaidReportUser copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<String>? name,
  }) {
    return FactionRaidReportUser(
      id: (id != null ? id.value : this.id),
      name: (name != null ? name.value : this.name),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionRaidWarReportResponse {
  const FactionRaidWarReportResponse({required this.raidreport});

  factory FactionRaidWarReportResponse.fromJson(Map<String, dynamic> json) =>
      _$FactionRaidWarReportResponseFromJson(json);

  static const toJsonFactory = _$FactionRaidWarReportResponseToJson;
  Map<String, dynamic> toJson() => _$FactionRaidWarReportResponseToJson(this);

  @JsonKey(name: 'raidreport', defaultValue: <FactionRaidReport>[])
  final List<FactionRaidReport> raidreport;
  static const fromJsonFactory = _$FactionRaidWarReportResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionRaidWarReportResponse &&
            (identical(other.raidreport, raidreport) ||
                const DeepCollectionEquality().equals(
                  other.raidreport,
                  raidreport,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(raidreport) ^ runtimeType.hashCode;
}

extension $FactionRaidWarReportResponseExtension on FactionRaidWarReportResponse {
  FactionRaidWarReportResponse copyWith({List<FactionRaidReport>? raidreport}) {
    return FactionRaidWarReportResponse(
      raidreport: raidreport ?? this.raidreport,
    );
  }

  FactionRaidWarReportResponse copyWithWrapped({
    Wrapped<List<FactionRaidReport>>? raidreport,
  }) {
    return FactionRaidWarReportResponse(
      raidreport: (raidreport != null ? raidreport.value : this.raidreport),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionWarfareDirtyBomb {
  const FactionWarfareDirtyBomb({
    required this.id,
    required this.plantedAt,
    required this.detonatedAt,
    required this.faction,
    required this.user,
  });

  factory FactionWarfareDirtyBomb.fromJson(Map<String, dynamic> json) => _$FactionWarfareDirtyBombFromJson(json);

  static const toJsonFactory = _$FactionWarfareDirtyBombToJson;
  Map<String, dynamic> toJson() => _$FactionWarfareDirtyBombToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'planted_at')
  final int plantedAt;
  @JsonKey(name: 'detonated_at')
  final int detonatedAt;
  @JsonKey(name: 'faction')
  final FactionWarfareDirtyBombTargetFaction faction;
  @JsonKey(name: 'user')
  final dynamic user;
  static const fromJsonFactory = _$FactionWarfareDirtyBombFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionWarfareDirtyBomb &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.plantedAt, plantedAt) ||
                const DeepCollectionEquality().equals(
                  other.plantedAt,
                  plantedAt,
                )) &&
            (identical(other.detonatedAt, detonatedAt) ||
                const DeepCollectionEquality().equals(
                  other.detonatedAt,
                  detonatedAt,
                )) &&
            (identical(other.faction, faction) ||
                const DeepCollectionEquality().equals(
                  other.faction,
                  faction,
                )) &&
            (identical(other.user, user) || const DeepCollectionEquality().equals(other.user, user)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(plantedAt) ^
      const DeepCollectionEquality().hash(detonatedAt) ^
      const DeepCollectionEquality().hash(faction) ^
      const DeepCollectionEquality().hash(user) ^
      runtimeType.hashCode;
}

extension $FactionWarfareDirtyBombExtension on FactionWarfareDirtyBomb {
  FactionWarfareDirtyBomb copyWith({
    int? id,
    int? plantedAt,
    int? detonatedAt,
    FactionWarfareDirtyBombTargetFaction? faction,
    dynamic user,
  }) {
    return FactionWarfareDirtyBomb(
      id: id ?? this.id,
      plantedAt: plantedAt ?? this.plantedAt,
      detonatedAt: detonatedAt ?? this.detonatedAt,
      faction: faction ?? this.faction,
      user: user ?? this.user,
    );
  }

  FactionWarfareDirtyBomb copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<int>? plantedAt,
    Wrapped<int>? detonatedAt,
    Wrapped<FactionWarfareDirtyBombTargetFaction>? faction,
    Wrapped<dynamic>? user,
  }) {
    return FactionWarfareDirtyBomb(
      id: (id != null ? id.value : this.id),
      plantedAt: (plantedAt != null ? plantedAt.value : this.plantedAt),
      detonatedAt: (detonatedAt != null ? detonatedAt.value : this.detonatedAt),
      faction: (faction != null ? faction.value : this.faction),
      user: (user != null ? user.value : this.user),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionWarfareDirtyBombTargetFaction {
  const FactionWarfareDirtyBombTargetFaction({
    required this.id,
    required this.name,
    required this.respectLost,
  });

  factory FactionWarfareDirtyBombTargetFaction.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$FactionWarfareDirtyBombTargetFactionFromJson(json);

  static const toJsonFactory = _$FactionWarfareDirtyBombTargetFactionToJson;
  Map<String, dynamic> toJson() => _$FactionWarfareDirtyBombTargetFactionToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'respect_lost')
  final int respectLost;
  static const fromJsonFactory = _$FactionWarfareDirtyBombTargetFactionFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionWarfareDirtyBombTargetFaction &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.respectLost, respectLost) ||
                const DeepCollectionEquality().equals(
                  other.respectLost,
                  respectLost,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(respectLost) ^
      runtimeType.hashCode;
}

extension $FactionWarfareDirtyBombTargetFactionExtension on FactionWarfareDirtyBombTargetFaction {
  FactionWarfareDirtyBombTargetFaction copyWith({
    int? id,
    String? name,
    int? respectLost,
  }) {
    return FactionWarfareDirtyBombTargetFaction(
      id: id ?? this.id,
      name: name ?? this.name,
      respectLost: respectLost ?? this.respectLost,
    );
  }

  FactionWarfareDirtyBombTargetFaction copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<String>? name,
    Wrapped<int>? respectLost,
  }) {
    return FactionWarfareDirtyBombTargetFaction(
      id: (id != null ? id.value : this.id),
      name: (name != null ? name.value : this.name),
      respectLost: (respectLost != null ? respectLost.value : this.respectLost),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionWarfareDirtyBombPlanter {
  const FactionWarfareDirtyBombPlanter({required this.id, required this.name});

  factory FactionWarfareDirtyBombPlanter.fromJson(Map<String, dynamic> json) =>
      _$FactionWarfareDirtyBombPlanterFromJson(json);

  static const toJsonFactory = _$FactionWarfareDirtyBombPlanterToJson;
  Map<String, dynamic> toJson() => _$FactionWarfareDirtyBombPlanterToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'name')
  final String name;
  static const fromJsonFactory = _$FactionWarfareDirtyBombPlanterFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionWarfareDirtyBombPlanter &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^ const DeepCollectionEquality().hash(name) ^ runtimeType.hashCode;
}

extension $FactionWarfareDirtyBombPlanterExtension on FactionWarfareDirtyBombPlanter {
  FactionWarfareDirtyBombPlanter copyWith({int? id, String? name}) {
    return FactionWarfareDirtyBombPlanter(
      id: id ?? this.id,
      name: name ?? this.name,
    );
  }

  FactionWarfareDirtyBombPlanter copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<String>? name,
  }) {
    return FactionWarfareDirtyBombPlanter(
      id: (id != null ? id.value : this.id),
      name: (name != null ? name.value : this.name),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionRaidWarfare {
  const FactionRaidWarfare({
    required this.id,
    required this.start,
    required this.end,
    required this.aggressor,
    required this.defender,
  });

  factory FactionRaidWarfare.fromJson(Map<String, dynamic> json) => _$FactionRaidWarfareFromJson(json);

  static const toJsonFactory = _$FactionRaidWarfareToJson;
  Map<String, dynamic> toJson() => _$FactionRaidWarfareToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'start')
  final int start;
  @JsonKey(name: 'end')
  final dynamic end;
  @JsonKey(name: 'aggressor')
  final FactionRaidWarfareFaction aggressor;
  @JsonKey(name: 'defender')
  final FactionRaidWarfareFaction defender;
  static const fromJsonFactory = _$FactionRaidWarfareFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionRaidWarfare &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.start, start) || const DeepCollectionEquality().equals(other.start, start)) &&
            (identical(other.end, end) || const DeepCollectionEquality().equals(other.end, end)) &&
            (identical(other.aggressor, aggressor) ||
                const DeepCollectionEquality().equals(
                  other.aggressor,
                  aggressor,
                )) &&
            (identical(other.defender, defender) ||
                const DeepCollectionEquality().equals(
                  other.defender,
                  defender,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(start) ^
      const DeepCollectionEquality().hash(end) ^
      const DeepCollectionEquality().hash(aggressor) ^
      const DeepCollectionEquality().hash(defender) ^
      runtimeType.hashCode;
}

extension $FactionRaidWarfareExtension on FactionRaidWarfare {
  FactionRaidWarfare copyWith({
    int? id,
    int? start,
    dynamic end,
    FactionRaidWarfareFaction? aggressor,
    FactionRaidWarfareFaction? defender,
  }) {
    return FactionRaidWarfare(
      id: id ?? this.id,
      start: start ?? this.start,
      end: end ?? this.end,
      aggressor: aggressor ?? this.aggressor,
      defender: defender ?? this.defender,
    );
  }

  FactionRaidWarfare copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<int>? start,
    Wrapped<dynamic>? end,
    Wrapped<FactionRaidWarfareFaction>? aggressor,
    Wrapped<FactionRaidWarfareFaction>? defender,
  }) {
    return FactionRaidWarfare(
      id: (id != null ? id.value : this.id),
      start: (start != null ? start.value : this.start),
      end: (end != null ? end.value : this.end),
      aggressor: (aggressor != null ? aggressor.value : this.aggressor),
      defender: (defender != null ? defender.value : this.defender),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionRaidWarfareFaction {
  const FactionRaidWarfareFaction({
    required this.id,
    required this.name,
    required this.score,
    this.chain,
  });

  factory FactionRaidWarfareFaction.fromJson(Map<String, dynamic> json) => _$FactionRaidWarfareFactionFromJson(json);

  static const toJsonFactory = _$FactionRaidWarfareFactionToJson;
  Map<String, dynamic> toJson() => _$FactionRaidWarfareFactionToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'score')
  final double score;
  @JsonKey(name: 'chain')
  final int? chain;
  static const fromJsonFactory = _$FactionRaidWarfareFactionFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionRaidWarfareFaction &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.score, score) || const DeepCollectionEquality().equals(other.score, score)) &&
            (identical(other.chain, chain) || const DeepCollectionEquality().equals(other.chain, chain)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(score) ^
      const DeepCollectionEquality().hash(chain) ^
      runtimeType.hashCode;
}

extension $FactionRaidWarfareFactionExtension on FactionRaidWarfareFaction {
  FactionRaidWarfareFaction copyWith({
    int? id,
    String? name,
    double? score,
    int? chain,
  }) {
    return FactionRaidWarfareFaction(
      id: id ?? this.id,
      name: name ?? this.name,
      score: score ?? this.score,
      chain: chain ?? this.chain,
    );
  }

  FactionRaidWarfareFaction copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<String>? name,
    Wrapped<double>? score,
    Wrapped<int?>? chain,
  }) {
    return FactionRaidWarfareFaction(
      id: (id != null ? id.value : this.id),
      name: (name != null ? name.value : this.name),
      score: (score != null ? score.value : this.score),
      chain: (chain != null ? chain.value : this.chain),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionTerritoryWarfare {
  const FactionTerritoryWarfare({
    required this.id,
    required this.territory,
    required this.start,
    required this.end,
    required this.target,
    required this.aggressor,
    required this.defender,
    required this.result,
  });

  factory FactionTerritoryWarfare.fromJson(Map<String, dynamic> json) => _$FactionTerritoryWarfareFromJson(json);

  static const toJsonFactory = _$FactionTerritoryWarfareToJson;
  Map<String, dynamic> toJson() => _$FactionTerritoryWarfareToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(
    name: 'territory',
    toJson: factionTerritoryEnumToJson,
    fromJson: factionTerritoryEnumFromJson,
  )
  final enums.FactionTerritoryEnum territory;
  @JsonKey(name: 'start')
  final int start;
  @JsonKey(name: 'end')
  final int end;
  @JsonKey(name: 'target')
  final int target;
  @JsonKey(name: 'aggressor')
  final FactionTerritoryWarFaction aggressor;
  @JsonKey(name: 'defender')
  final FactionTerritoryWarFaction defender;
  @JsonKey(name: 'result')
  final String result;
  static const fromJsonFactory = _$FactionTerritoryWarfareFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionTerritoryWarfare &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.territory, territory) ||
                const DeepCollectionEquality().equals(
                  other.territory,
                  territory,
                )) &&
            (identical(other.start, start) || const DeepCollectionEquality().equals(other.start, start)) &&
            (identical(other.end, end) || const DeepCollectionEquality().equals(other.end, end)) &&
            (identical(other.target, target) || const DeepCollectionEquality().equals(other.target, target)) &&
            (identical(other.aggressor, aggressor) ||
                const DeepCollectionEquality().equals(
                  other.aggressor,
                  aggressor,
                )) &&
            (identical(other.defender, defender) ||
                const DeepCollectionEquality().equals(
                  other.defender,
                  defender,
                )) &&
            (identical(other.result, result) || const DeepCollectionEquality().equals(other.result, result)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(territory) ^
      const DeepCollectionEquality().hash(start) ^
      const DeepCollectionEquality().hash(end) ^
      const DeepCollectionEquality().hash(target) ^
      const DeepCollectionEquality().hash(aggressor) ^
      const DeepCollectionEquality().hash(defender) ^
      const DeepCollectionEquality().hash(result) ^
      runtimeType.hashCode;
}

extension $FactionTerritoryWarfareExtension on FactionTerritoryWarfare {
  FactionTerritoryWarfare copyWith({
    int? id,
    enums.FactionTerritoryEnum? territory,
    int? start,
    int? end,
    int? target,
    FactionTerritoryWarFaction? aggressor,
    FactionTerritoryWarFaction? defender,
    String? result,
  }) {
    return FactionTerritoryWarfare(
      id: id ?? this.id,
      territory: territory ?? this.territory,
      start: start ?? this.start,
      end: end ?? this.end,
      target: target ?? this.target,
      aggressor: aggressor ?? this.aggressor,
      defender: defender ?? this.defender,
      result: result ?? this.result,
    );
  }

  FactionTerritoryWarfare copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<enums.FactionTerritoryEnum>? territory,
    Wrapped<int>? start,
    Wrapped<int>? end,
    Wrapped<int>? target,
    Wrapped<FactionTerritoryWarFaction>? aggressor,
    Wrapped<FactionTerritoryWarFaction>? defender,
    Wrapped<String>? result,
  }) {
    return FactionTerritoryWarfare(
      id: (id != null ? id.value : this.id),
      territory: (territory != null ? territory.value : this.territory),
      start: (start != null ? start.value : this.start),
      end: (end != null ? end.value : this.end),
      target: (target != null ? target.value : this.target),
      aggressor: (aggressor != null ? aggressor.value : this.aggressor),
      defender: (defender != null ? defender.value : this.defender),
      result: (result != null ? result.value : this.result),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionTerritoryWarFactionWallPlayers {
  const FactionTerritoryWarFactionWallPlayers({
    required this.id,
    required this.name,
  });

  factory FactionTerritoryWarFactionWallPlayers.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$FactionTerritoryWarFactionWallPlayersFromJson(json);

  static const toJsonFactory = _$FactionTerritoryWarFactionWallPlayersToJson;
  Map<String, dynamic> toJson() => _$FactionTerritoryWarFactionWallPlayersToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'name')
  final String name;
  static const fromJsonFactory = _$FactionTerritoryWarFactionWallPlayersFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionTerritoryWarFactionWallPlayers &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^ const DeepCollectionEquality().hash(name) ^ runtimeType.hashCode;
}

extension $FactionTerritoryWarFactionWallPlayersExtension on FactionTerritoryWarFactionWallPlayers {
  FactionTerritoryWarFactionWallPlayers copyWith({int? id, String? name}) {
    return FactionTerritoryWarFactionWallPlayers(
      id: id ?? this.id,
      name: name ?? this.name,
    );
  }

  FactionTerritoryWarFactionWallPlayers copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<String>? name,
  }) {
    return FactionTerritoryWarFactionWallPlayers(
      id: (id != null ? id.value : this.id),
      name: (name != null ? name.value : this.name),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionTerritoryWarFaction {
  const FactionTerritoryWarFaction({
    required this.id,
    required this.name,
    required this.score,
    this.chain,
    this.playersOnWall,
  });

  factory FactionTerritoryWarFaction.fromJson(Map<String, dynamic> json) => _$FactionTerritoryWarFactionFromJson(json);

  static const toJsonFactory = _$FactionTerritoryWarFactionToJson;
  Map<String, dynamic> toJson() => _$FactionTerritoryWarFactionToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'score')
  final int score;
  @JsonKey(name: 'chain')
  final int? chain;
  @JsonKey(
    name: 'players_on_wall',
    defaultValue: <FactionTerritoryWarFactionWallPlayers>[],
  )
  final List<FactionTerritoryWarFactionWallPlayers>? playersOnWall;
  static const fromJsonFactory = _$FactionTerritoryWarFactionFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionTerritoryWarFaction &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.score, score) || const DeepCollectionEquality().equals(other.score, score)) &&
            (identical(other.chain, chain) || const DeepCollectionEquality().equals(other.chain, chain)) &&
            (identical(other.playersOnWall, playersOnWall) ||
                const DeepCollectionEquality().equals(
                  other.playersOnWall,
                  playersOnWall,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(score) ^
      const DeepCollectionEquality().hash(chain) ^
      const DeepCollectionEquality().hash(playersOnWall) ^
      runtimeType.hashCode;
}

extension $FactionTerritoryWarFactionExtension on FactionTerritoryWarFaction {
  FactionTerritoryWarFaction copyWith({
    int? id,
    String? name,
    int? score,
    int? chain,
    List<FactionTerritoryWarFactionWallPlayers>? playersOnWall,
  }) {
    return FactionTerritoryWarFaction(
      id: id ?? this.id,
      name: name ?? this.name,
      score: score ?? this.score,
      chain: chain ?? this.chain,
      playersOnWall: playersOnWall ?? this.playersOnWall,
    );
  }

  FactionTerritoryWarFaction copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<String>? name,
    Wrapped<int>? score,
    Wrapped<int?>? chain,
    Wrapped<List<FactionTerritoryWarFactionWallPlayers>?>? playersOnWall,
  }) {
    return FactionTerritoryWarFaction(
      id: (id != null ? id.value : this.id),
      name: (name != null ? name.value : this.name),
      score: (score != null ? score.value : this.score),
      chain: (chain != null ? chain.value : this.chain),
      playersOnWall: (playersOnWall != null ? playersOnWall.value : this.playersOnWall),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionTerritoryWarFinishedFaction {
  const FactionTerritoryWarFinishedFaction({
    required this.id,
    required this.name,
    required this.score,
    required this.isAggressor,
  });

  factory FactionTerritoryWarFinishedFaction.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$FactionTerritoryWarFinishedFactionFromJson(json);

  static const toJsonFactory = _$FactionTerritoryWarFinishedFactionToJson;
  Map<String, dynamic> toJson() => _$FactionTerritoryWarFinishedFactionToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'score')
  final int score;
  @JsonKey(name: 'is_aggressor')
  final bool isAggressor;
  static const fromJsonFactory = _$FactionTerritoryWarFinishedFactionFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionTerritoryWarFinishedFaction &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.score, score) || const DeepCollectionEquality().equals(other.score, score)) &&
            (identical(other.isAggressor, isAggressor) ||
                const DeepCollectionEquality().equals(
                  other.isAggressor,
                  isAggressor,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(score) ^
      const DeepCollectionEquality().hash(isAggressor) ^
      runtimeType.hashCode;
}

extension $FactionTerritoryWarFinishedFactionExtension on FactionTerritoryWarFinishedFaction {
  FactionTerritoryWarFinishedFaction copyWith({
    int? id,
    String? name,
    int? score,
    bool? isAggressor,
  }) {
    return FactionTerritoryWarFinishedFaction(
      id: id ?? this.id,
      name: name ?? this.name,
      score: score ?? this.score,
      isAggressor: isAggressor ?? this.isAggressor,
    );
  }

  FactionTerritoryWarFinishedFaction copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<String>? name,
    Wrapped<int>? score,
    Wrapped<bool>? isAggressor,
  }) {
    return FactionTerritoryWarFinishedFaction(
      id: (id != null ? id.value : this.id),
      name: (name != null ? name.value : this.name),
      score: (score != null ? score.value : this.score),
      isAggressor: (isAggressor != null ? isAggressor.value : this.isAggressor),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionSearchLeader {
  const FactionSearchLeader({required this.id, required this.name});

  factory FactionSearchLeader.fromJson(Map<String, dynamic> json) => _$FactionSearchLeaderFromJson(json);

  static const toJsonFactory = _$FactionSearchLeaderToJson;
  Map<String, dynamic> toJson() => _$FactionSearchLeaderToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'name')
  final String name;
  static const fromJsonFactory = _$FactionSearchLeaderFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionSearchLeader &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^ const DeepCollectionEquality().hash(name) ^ runtimeType.hashCode;
}

extension $FactionSearchLeaderExtension on FactionSearchLeader {
  FactionSearchLeader copyWith({int? id, String? name}) {
    return FactionSearchLeader(id: id ?? this.id, name: name ?? this.name);
  }

  FactionSearchLeader copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<String>? name,
  }) {
    return FactionSearchLeader(
      id: (id != null ? id.value : this.id),
      name: (name != null ? name.value : this.name),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionSearch {
  const FactionSearch({
    required this.id,
    required this.name,
    required this.respect,
    required this.members,
    required this.leader,
    required this.coLeader,
    required this.image,
    required this.tagImage,
    required this.tag,
    required this.isDestroyed,
    required this.isRecruiting,
  });

  factory FactionSearch.fromJson(Map<String, dynamic> json) => _$FactionSearchFromJson(json);

  static const toJsonFactory = _$FactionSearchToJson;
  Map<String, dynamic> toJson() => _$FactionSearchToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'respect')
  final int respect;
  @JsonKey(name: 'members')
  final int members;
  @JsonKey(name: 'leader')
  final FactionSearchLeader leader;
  @JsonKey(name: 'co_leader')
  final dynamic coLeader;
  @JsonKey(name: 'image')
  final dynamic image;
  @JsonKey(name: 'tag_image')
  final dynamic tagImage;
  @JsonKey(name: 'tag')
  final dynamic tag;
  @JsonKey(name: 'is_destroyed')
  final bool isDestroyed;
  @JsonKey(name: 'is_recruiting')
  final bool isRecruiting;
  static const fromJsonFactory = _$FactionSearchFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionSearch &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.respect, respect) ||
                const DeepCollectionEquality().equals(
                  other.respect,
                  respect,
                )) &&
            (identical(other.members, members) ||
                const DeepCollectionEquality().equals(
                  other.members,
                  members,
                )) &&
            (identical(other.leader, leader) || const DeepCollectionEquality().equals(other.leader, leader)) &&
            (identical(other.coLeader, coLeader) ||
                const DeepCollectionEquality().equals(
                  other.coLeader,
                  coLeader,
                )) &&
            (identical(other.image, image) || const DeepCollectionEquality().equals(other.image, image)) &&
            (identical(other.tagImage, tagImage) ||
                const DeepCollectionEquality().equals(
                  other.tagImage,
                  tagImage,
                )) &&
            (identical(other.tag, tag) || const DeepCollectionEquality().equals(other.tag, tag)) &&
            (identical(other.isDestroyed, isDestroyed) ||
                const DeepCollectionEquality().equals(
                  other.isDestroyed,
                  isDestroyed,
                )) &&
            (identical(other.isRecruiting, isRecruiting) ||
                const DeepCollectionEquality().equals(
                  other.isRecruiting,
                  isRecruiting,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(respect) ^
      const DeepCollectionEquality().hash(members) ^
      const DeepCollectionEquality().hash(leader) ^
      const DeepCollectionEquality().hash(coLeader) ^
      const DeepCollectionEquality().hash(image) ^
      const DeepCollectionEquality().hash(tagImage) ^
      const DeepCollectionEquality().hash(tag) ^
      const DeepCollectionEquality().hash(isDestroyed) ^
      const DeepCollectionEquality().hash(isRecruiting) ^
      runtimeType.hashCode;
}

extension $FactionSearchExtension on FactionSearch {
  FactionSearch copyWith({
    int? id,
    String? name,
    int? respect,
    int? members,
    FactionSearchLeader? leader,
    dynamic coLeader,
    dynamic image,
    dynamic tagImage,
    dynamic tag,
    bool? isDestroyed,
    bool? isRecruiting,
  }) {
    return FactionSearch(
      id: id ?? this.id,
      name: name ?? this.name,
      respect: respect ?? this.respect,
      members: members ?? this.members,
      leader: leader ?? this.leader,
      coLeader: coLeader ?? this.coLeader,
      image: image ?? this.image,
      tagImage: tagImage ?? this.tagImage,
      tag: tag ?? this.tag,
      isDestroyed: isDestroyed ?? this.isDestroyed,
      isRecruiting: isRecruiting ?? this.isRecruiting,
    );
  }

  FactionSearch copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<String>? name,
    Wrapped<int>? respect,
    Wrapped<int>? members,
    Wrapped<FactionSearchLeader>? leader,
    Wrapped<dynamic>? coLeader,
    Wrapped<dynamic>? image,
    Wrapped<dynamic>? tagImage,
    Wrapped<dynamic>? tag,
    Wrapped<bool>? isDestroyed,
    Wrapped<bool>? isRecruiting,
  }) {
    return FactionSearch(
      id: (id != null ? id.value : this.id),
      name: (name != null ? name.value : this.name),
      respect: (respect != null ? respect.value : this.respect),
      members: (members != null ? members.value : this.members),
      leader: (leader != null ? leader.value : this.leader),
      coLeader: (coLeader != null ? coLeader.value : this.coLeader),
      image: (image != null ? image.value : this.image),
      tagImage: (tagImage != null ? tagImage.value : this.tagImage),
      tag: (tag != null ? tag.value : this.tag),
      isDestroyed: (isDestroyed != null ? isDestroyed.value : this.isDestroyed),
      isRecruiting: (isRecruiting != null ? isRecruiting.value : this.isRecruiting),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionSearchResponse {
  const FactionSearchResponse({required this.search, required this.metadata});

  factory FactionSearchResponse.fromJson(Map<String, dynamic> json) => _$FactionSearchResponseFromJson(json);

  static const toJsonFactory = _$FactionSearchResponseToJson;
  Map<String, dynamic> toJson() => _$FactionSearchResponseToJson(this);

  @JsonKey(name: 'search', defaultValue: <FactionSearch>[])
  final List<FactionSearch> search;
  @JsonKey(name: '_metadata')
  final RequestMetadataWithLinks metadata;
  static const fromJsonFactory = _$FactionSearchResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionSearchResponse &&
            (identical(other.search, search) || const DeepCollectionEquality().equals(other.search, search)) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality().equals(
                  other.metadata,
                  metadata,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(search) ^
      const DeepCollectionEquality().hash(metadata) ^
      runtimeType.hashCode;
}

extension $FactionSearchResponseExtension on FactionSearchResponse {
  FactionSearchResponse copyWith({
    List<FactionSearch>? search,
    RequestMetadataWithLinks? metadata,
  }) {
    return FactionSearchResponse(
      search: search ?? this.search,
      metadata: metadata ?? this.metadata,
    );
  }

  FactionSearchResponse copyWithWrapped({
    Wrapped<List<FactionSearch>>? search,
    Wrapped<RequestMetadataWithLinks>? metadata,
  }) {
    return FactionSearchResponse(
      search: (search != null ? search.value : this.search),
      metadata: (metadata != null ? metadata.value : this.metadata),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionTerritoryWarFinished {
  const FactionTerritoryWarFinished({
    required this.id,
    required this.territory,
    required this.start,
    required this.end,
    required this.target,
    required this.result,
    required this.factions,
  });

  factory FactionTerritoryWarFinished.fromJson(Map<String, dynamic> json) =>
      _$FactionTerritoryWarFinishedFromJson(json);

  static const toJsonFactory = _$FactionTerritoryWarFinishedToJson;
  Map<String, dynamic> toJson() => _$FactionTerritoryWarFinishedToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(
    name: 'territory',
    toJson: factionTerritoryEnumToJson,
    fromJson: factionTerritoryEnumFromJson,
  )
  final enums.FactionTerritoryEnum territory;
  @JsonKey(name: 'start')
  final int start;
  @JsonKey(name: 'end')
  final int end;
  @JsonKey(name: 'target')
  final int target;
  @JsonKey(
    name: 'result',
    toJson: factionTerritoryWarResultEnumToJson,
    fromJson: factionTerritoryWarResultEnumFromJson,
  )
  final enums.FactionTerritoryWarResultEnum result;
  @JsonKey(
    name: 'factions',
    defaultValue: <FactionTerritoryWarFinishedFaction>[],
  )
  final List<FactionTerritoryWarFinishedFaction> factions;
  static const fromJsonFactory = _$FactionTerritoryWarFinishedFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionTerritoryWarFinished &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.territory, territory) ||
                const DeepCollectionEquality().equals(
                  other.territory,
                  territory,
                )) &&
            (identical(other.start, start) || const DeepCollectionEquality().equals(other.start, start)) &&
            (identical(other.end, end) || const DeepCollectionEquality().equals(other.end, end)) &&
            (identical(other.target, target) || const DeepCollectionEquality().equals(other.target, target)) &&
            (identical(other.result, result) || const DeepCollectionEquality().equals(other.result, result)) &&
            (identical(other.factions, factions) ||
                const DeepCollectionEquality().equals(
                  other.factions,
                  factions,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(territory) ^
      const DeepCollectionEquality().hash(start) ^
      const DeepCollectionEquality().hash(end) ^
      const DeepCollectionEquality().hash(target) ^
      const DeepCollectionEquality().hash(result) ^
      const DeepCollectionEquality().hash(factions) ^
      runtimeType.hashCode;
}

extension $FactionTerritoryWarFinishedExtension on FactionTerritoryWarFinished {
  FactionTerritoryWarFinished copyWith({
    int? id,
    enums.FactionTerritoryEnum? territory,
    int? start,
    int? end,
    int? target,
    enums.FactionTerritoryWarResultEnum? result,
    List<FactionTerritoryWarFinishedFaction>? factions,
  }) {
    return FactionTerritoryWarFinished(
      id: id ?? this.id,
      territory: territory ?? this.territory,
      start: start ?? this.start,
      end: end ?? this.end,
      target: target ?? this.target,
      result: result ?? this.result,
      factions: factions ?? this.factions,
    );
  }

  FactionTerritoryWarFinished copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<enums.FactionTerritoryEnum>? territory,
    Wrapped<int>? start,
    Wrapped<int>? end,
    Wrapped<int>? target,
    Wrapped<enums.FactionTerritoryWarResultEnum>? result,
    Wrapped<List<FactionTerritoryWarFinishedFaction>>? factions,
  }) {
    return FactionTerritoryWarFinished(
      id: (id != null ? id.value : this.id),
      territory: (territory != null ? territory.value : this.territory),
      start: (start != null ? start.value : this.start),
      end: (end != null ? end.value : this.end),
      target: (target != null ? target.value : this.target),
      result: (result != null ? result.value : this.result),
      factions: (factions != null ? factions.value : this.factions),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionTerritoryWarOngoingFaction {
  const FactionTerritoryWarOngoingFaction({
    required this.id,
    required this.name,
    required this.score,
    required this.isAggressor,
    required this.chain,
    required this.playerIds,
  });

  factory FactionTerritoryWarOngoingFaction.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$FactionTerritoryWarOngoingFactionFromJson(json);

  static const toJsonFactory = _$FactionTerritoryWarOngoingFactionToJson;
  Map<String, dynamic> toJson() => _$FactionTerritoryWarOngoingFactionToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'score')
  final int score;
  @JsonKey(name: 'is_aggressor')
  final bool isAggressor;
  @JsonKey(name: 'chain')
  final int chain;
  @JsonKey(name: 'playerIds', defaultValue: <int>[])
  final List<int> playerIds;
  static const fromJsonFactory = _$FactionTerritoryWarOngoingFactionFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionTerritoryWarOngoingFaction &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.score, score) || const DeepCollectionEquality().equals(other.score, score)) &&
            (identical(other.isAggressor, isAggressor) ||
                const DeepCollectionEquality().equals(
                  other.isAggressor,
                  isAggressor,
                )) &&
            (identical(other.chain, chain) || const DeepCollectionEquality().equals(other.chain, chain)) &&
            (identical(other.playerIds, playerIds) ||
                const DeepCollectionEquality().equals(
                  other.playerIds,
                  playerIds,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(score) ^
      const DeepCollectionEquality().hash(isAggressor) ^
      const DeepCollectionEquality().hash(chain) ^
      const DeepCollectionEquality().hash(playerIds) ^
      runtimeType.hashCode;
}

extension $FactionTerritoryWarOngoingFactionExtension on FactionTerritoryWarOngoingFaction {
  FactionTerritoryWarOngoingFaction copyWith({
    int? id,
    String? name,
    int? score,
    bool? isAggressor,
    int? chain,
    List<int>? playerIds,
  }) {
    return FactionTerritoryWarOngoingFaction(
      id: id ?? this.id,
      name: name ?? this.name,
      score: score ?? this.score,
      isAggressor: isAggressor ?? this.isAggressor,
      chain: chain ?? this.chain,
      playerIds: playerIds ?? this.playerIds,
    );
  }

  FactionTerritoryWarOngoingFaction copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<String>? name,
    Wrapped<int>? score,
    Wrapped<bool>? isAggressor,
    Wrapped<int>? chain,
    Wrapped<List<int>>? playerIds,
  }) {
    return FactionTerritoryWarOngoingFaction(
      id: (id != null ? id.value : this.id),
      name: (name != null ? name.value : this.name),
      score: (score != null ? score.value : this.score),
      isAggressor: (isAggressor != null ? isAggressor.value : this.isAggressor),
      chain: (chain != null ? chain.value : this.chain),
      playerIds: (playerIds != null ? playerIds.value : this.playerIds),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionTerritoryWarOngoing {
  const FactionTerritoryWarOngoing({
    required this.id,
    required this.territory,
    required this.start,
    required this.end,
    required this.target,
    required this.factions,
  });

  factory FactionTerritoryWarOngoing.fromJson(Map<String, dynamic> json) => _$FactionTerritoryWarOngoingFromJson(json);

  static const toJsonFactory = _$FactionTerritoryWarOngoingToJson;
  Map<String, dynamic> toJson() => _$FactionTerritoryWarOngoingToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(
    name: 'territory',
    toJson: factionTerritoryEnumToJson,
    fromJson: factionTerritoryEnumFromJson,
  )
  final enums.FactionTerritoryEnum territory;
  @JsonKey(name: 'start')
  final int start;
  @JsonKey(name: 'end')
  final int end;
  @JsonKey(name: 'target')
  final int target;
  @JsonKey(
    name: 'factions',
    defaultValue: <FactionTerritoryWarOngoingFaction>[],
  )
  final List<FactionTerritoryWarOngoingFaction> factions;
  static const fromJsonFactory = _$FactionTerritoryWarOngoingFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionTerritoryWarOngoing &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.territory, territory) ||
                const DeepCollectionEquality().equals(
                  other.territory,
                  territory,
                )) &&
            (identical(other.start, start) || const DeepCollectionEquality().equals(other.start, start)) &&
            (identical(other.end, end) || const DeepCollectionEquality().equals(other.end, end)) &&
            (identical(other.target, target) || const DeepCollectionEquality().equals(other.target, target)) &&
            (identical(other.factions, factions) ||
                const DeepCollectionEquality().equals(
                  other.factions,
                  factions,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(territory) ^
      const DeepCollectionEquality().hash(start) ^
      const DeepCollectionEquality().hash(end) ^
      const DeepCollectionEquality().hash(target) ^
      const DeepCollectionEquality().hash(factions) ^
      runtimeType.hashCode;
}

extension $FactionTerritoryWarOngoingExtension on FactionTerritoryWarOngoing {
  FactionTerritoryWarOngoing copyWith({
    int? id,
    enums.FactionTerritoryEnum? territory,
    int? start,
    int? end,
    int? target,
    List<FactionTerritoryWarOngoingFaction>? factions,
  }) {
    return FactionTerritoryWarOngoing(
      id: id ?? this.id,
      territory: territory ?? this.territory,
      start: start ?? this.start,
      end: end ?? this.end,
      target: target ?? this.target,
      factions: factions ?? this.factions,
    );
  }

  FactionTerritoryWarOngoing copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<enums.FactionTerritoryEnum>? territory,
    Wrapped<int>? start,
    Wrapped<int>? end,
    Wrapped<int>? target,
    Wrapped<List<FactionTerritoryWarOngoingFaction>>? factions,
  }) {
    return FactionTerritoryWarOngoing(
      id: (id != null ? id.value : this.id),
      territory: (territory != null ? territory.value : this.territory),
      start: (start != null ? start.value : this.start),
      end: (end != null ? end.value : this.end),
      target: (target != null ? target.value : this.target),
      factions: (factions != null ? factions.value : this.factions),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionTerritoryWarsResponse {
  const FactionTerritoryWarsResponse({required this.territorywars});

  factory FactionTerritoryWarsResponse.fromJson(Map<String, dynamic> json) =>
      _$FactionTerritoryWarsResponseFromJson(json);

  static const toJsonFactory = _$FactionTerritoryWarsResponseToJson;
  Map<String, dynamic> toJson() => _$FactionTerritoryWarsResponseToJson(this);

  @JsonKey(name: 'territorywars')
  final dynamic territorywars;
  static const fromJsonFactory = _$FactionTerritoryWarsResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionTerritoryWarsResponse &&
            (identical(other.territorywars, territorywars) ||
                const DeepCollectionEquality().equals(
                  other.territorywars,
                  territorywars,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(territorywars) ^ runtimeType.hashCode;
}

extension $FactionTerritoryWarsResponseExtension on FactionTerritoryWarsResponse {
  FactionTerritoryWarsResponse copyWith({dynamic territorywars}) {
    return FactionTerritoryWarsResponse(
      territorywars: territorywars ?? this.territorywars,
    );
  }

  FactionTerritoryWarsResponse copyWithWrapped({
    Wrapped<dynamic>? territorywars,
  }) {
    return FactionTerritoryWarsResponse(
      territorywars: (territorywars != null ? territorywars.value : this.territorywars),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionTerritoryWarsHistoryResponse {
  const FactionTerritoryWarsHistoryResponse({required this.territorywars});

  factory FactionTerritoryWarsHistoryResponse.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$FactionTerritoryWarsHistoryResponseFromJson(json);

  static const toJsonFactory = _$FactionTerritoryWarsHistoryResponseToJson;
  Map<String, dynamic> toJson() => _$FactionTerritoryWarsHistoryResponseToJson(this);

  @JsonKey(name: 'territorywars', defaultValue: <FactionTerritoryWarFinished>[])
  final List<FactionTerritoryWarFinished> territorywars;
  static const fromJsonFactory = _$FactionTerritoryWarsHistoryResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionTerritoryWarsHistoryResponse &&
            (identical(other.territorywars, territorywars) ||
                const DeepCollectionEquality().equals(
                  other.territorywars,
                  territorywars,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(territorywars) ^ runtimeType.hashCode;
}

extension $FactionTerritoryWarsHistoryResponseExtension on FactionTerritoryWarsHistoryResponse {
  FactionTerritoryWarsHistoryResponse copyWith({
    List<FactionTerritoryWarFinished>? territorywars,
  }) {
    return FactionTerritoryWarsHistoryResponse(
      territorywars: territorywars ?? this.territorywars,
    );
  }

  FactionTerritoryWarsHistoryResponse copyWithWrapped({
    Wrapped<List<FactionTerritoryWarFinished>>? territorywars,
  }) {
    return FactionTerritoryWarsHistoryResponse(
      territorywars: (territorywars != null ? territorywars.value : this.territorywars),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionTerritoryWarReportMembers {
  const FactionTerritoryWarReportMembers({
    required this.id,
    required this.username,
    required this.level,
    required this.score,
    required this.joins,
    required this.clears,
  });

  factory FactionTerritoryWarReportMembers.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$FactionTerritoryWarReportMembersFromJson(json);

  static const toJsonFactory = _$FactionTerritoryWarReportMembersToJson;
  Map<String, dynamic> toJson() => _$FactionTerritoryWarReportMembersToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'username')
  final String username;
  @JsonKey(name: 'level')
  final int level;
  @JsonKey(name: 'score')
  final int score;
  @JsonKey(name: 'joins')
  final int joins;
  @JsonKey(name: 'clears')
  final int clears;
  static const fromJsonFactory = _$FactionTerritoryWarReportMembersFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionTerritoryWarReportMembers &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.username, username) ||
                const DeepCollectionEquality().equals(
                  other.username,
                  username,
                )) &&
            (identical(other.level, level) || const DeepCollectionEquality().equals(other.level, level)) &&
            (identical(other.score, score) || const DeepCollectionEquality().equals(other.score, score)) &&
            (identical(other.joins, joins) || const DeepCollectionEquality().equals(other.joins, joins)) &&
            (identical(other.clears, clears) || const DeepCollectionEquality().equals(other.clears, clears)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(username) ^
      const DeepCollectionEquality().hash(level) ^
      const DeepCollectionEquality().hash(score) ^
      const DeepCollectionEquality().hash(joins) ^
      const DeepCollectionEquality().hash(clears) ^
      runtimeType.hashCode;
}

extension $FactionTerritoryWarReportMembersExtension on FactionTerritoryWarReportMembers {
  FactionTerritoryWarReportMembers copyWith({
    int? id,
    String? username,
    int? level,
    int? score,
    int? joins,
    int? clears,
  }) {
    return FactionTerritoryWarReportMembers(
      id: id ?? this.id,
      username: username ?? this.username,
      level: level ?? this.level,
      score: score ?? this.score,
      joins: joins ?? this.joins,
      clears: clears ?? this.clears,
    );
  }

  FactionTerritoryWarReportMembers copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<String>? username,
    Wrapped<int>? level,
    Wrapped<int>? score,
    Wrapped<int>? joins,
    Wrapped<int>? clears,
  }) {
    return FactionTerritoryWarReportMembers(
      id: (id != null ? id.value : this.id),
      username: (username != null ? username.value : this.username),
      level: (level != null ? level.value : this.level),
      score: (score != null ? score.value : this.score),
      joins: (joins != null ? joins.value : this.joins),
      clears: (clears != null ? clears.value : this.clears),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionTerritoryWarReportFaction {
  const FactionTerritoryWarReportFaction({
    required this.id,
    required this.name,
    required this.score,
    required this.joins,
    required this.clears,
    required this.isAggressor,
    required this.members,
  });

  factory FactionTerritoryWarReportFaction.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$FactionTerritoryWarReportFactionFromJson(json);

  static const toJsonFactory = _$FactionTerritoryWarReportFactionToJson;
  Map<String, dynamic> toJson() => _$FactionTerritoryWarReportFactionToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'score')
  final int score;
  @JsonKey(name: 'joins')
  final int joins;
  @JsonKey(name: 'clears')
  final int clears;
  @JsonKey(name: 'is_aggressor')
  final bool isAggressor;
  @JsonKey(name: 'members', defaultValue: <FactionTerritoryWarReportMembers>[])
  final List<FactionTerritoryWarReportMembers> members;
  static const fromJsonFactory = _$FactionTerritoryWarReportFactionFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionTerritoryWarReportFaction &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.score, score) || const DeepCollectionEquality().equals(other.score, score)) &&
            (identical(other.joins, joins) || const DeepCollectionEquality().equals(other.joins, joins)) &&
            (identical(other.clears, clears) || const DeepCollectionEquality().equals(other.clears, clears)) &&
            (identical(other.isAggressor, isAggressor) ||
                const DeepCollectionEquality().equals(
                  other.isAggressor,
                  isAggressor,
                )) &&
            (identical(other.members, members) || const DeepCollectionEquality().equals(other.members, members)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(score) ^
      const DeepCollectionEquality().hash(joins) ^
      const DeepCollectionEquality().hash(clears) ^
      const DeepCollectionEquality().hash(isAggressor) ^
      const DeepCollectionEquality().hash(members) ^
      runtimeType.hashCode;
}

extension $FactionTerritoryWarReportFactionExtension on FactionTerritoryWarReportFaction {
  FactionTerritoryWarReportFaction copyWith({
    int? id,
    String? name,
    int? score,
    int? joins,
    int? clears,
    bool? isAggressor,
    List<FactionTerritoryWarReportMembers>? members,
  }) {
    return FactionTerritoryWarReportFaction(
      id: id ?? this.id,
      name: name ?? this.name,
      score: score ?? this.score,
      joins: joins ?? this.joins,
      clears: clears ?? this.clears,
      isAggressor: isAggressor ?? this.isAggressor,
      members: members ?? this.members,
    );
  }

  FactionTerritoryWarReportFaction copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<String>? name,
    Wrapped<int>? score,
    Wrapped<int>? joins,
    Wrapped<int>? clears,
    Wrapped<bool>? isAggressor,
    Wrapped<List<FactionTerritoryWarReportMembers>>? members,
  }) {
    return FactionTerritoryWarReportFaction(
      id: (id != null ? id.value : this.id),
      name: (name != null ? name.value : this.name),
      score: (score != null ? score.value : this.score),
      joins: (joins != null ? joins.value : this.joins),
      clears: (clears != null ? clears.value : this.clears),
      isAggressor: (isAggressor != null ? isAggressor.value : this.isAggressor),
      members: (members != null ? members.value : this.members),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionTerritoryWarReport {
  const FactionTerritoryWarReport({
    required this.id,
    required this.territory,
    required this.startedAt,
    required this.endedAt,
    required this.winner,
    required this.result,
    required this.factions,
  });

  factory FactionTerritoryWarReport.fromJson(Map<String, dynamic> json) => _$FactionTerritoryWarReportFromJson(json);

  static const toJsonFactory = _$FactionTerritoryWarReportToJson;
  Map<String, dynamic> toJson() => _$FactionTerritoryWarReportToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(
    name: 'territory',
    toJson: factionTerritoryEnumToJson,
    fromJson: factionTerritoryEnumFromJson,
  )
  final enums.FactionTerritoryEnum territory;
  @JsonKey(name: 'started_at')
  final int startedAt;
  @JsonKey(name: 'ended_at')
  final int endedAt;
  @JsonKey(name: 'winner')
  final int winner;
  @JsonKey(name: 'result')
  final String result;
  @JsonKey(name: 'factions', defaultValue: <FactionTerritoryWarReportFaction>[])
  final List<FactionTerritoryWarReportFaction> factions;
  static const fromJsonFactory = _$FactionTerritoryWarReportFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionTerritoryWarReport &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.territory, territory) ||
                const DeepCollectionEquality().equals(
                  other.territory,
                  territory,
                )) &&
            (identical(other.startedAt, startedAt) ||
                const DeepCollectionEquality().equals(
                  other.startedAt,
                  startedAt,
                )) &&
            (identical(other.endedAt, endedAt) ||
                const DeepCollectionEquality().equals(
                  other.endedAt,
                  endedAt,
                )) &&
            (identical(other.winner, winner) || const DeepCollectionEquality().equals(other.winner, winner)) &&
            (identical(other.result, result) || const DeepCollectionEquality().equals(other.result, result)) &&
            (identical(other.factions, factions) ||
                const DeepCollectionEquality().equals(
                  other.factions,
                  factions,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(territory) ^
      const DeepCollectionEquality().hash(startedAt) ^
      const DeepCollectionEquality().hash(endedAt) ^
      const DeepCollectionEquality().hash(winner) ^
      const DeepCollectionEquality().hash(result) ^
      const DeepCollectionEquality().hash(factions) ^
      runtimeType.hashCode;
}

extension $FactionTerritoryWarReportExtension on FactionTerritoryWarReport {
  FactionTerritoryWarReport copyWith({
    int? id,
    enums.FactionTerritoryEnum? territory,
    int? startedAt,
    int? endedAt,
    int? winner,
    String? result,
    List<FactionTerritoryWarReportFaction>? factions,
  }) {
    return FactionTerritoryWarReport(
      id: id ?? this.id,
      territory: territory ?? this.territory,
      startedAt: startedAt ?? this.startedAt,
      endedAt: endedAt ?? this.endedAt,
      winner: winner ?? this.winner,
      result: result ?? this.result,
      factions: factions ?? this.factions,
    );
  }

  FactionTerritoryWarReport copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<enums.FactionTerritoryEnum>? territory,
    Wrapped<int>? startedAt,
    Wrapped<int>? endedAt,
    Wrapped<int>? winner,
    Wrapped<String>? result,
    Wrapped<List<FactionTerritoryWarReportFaction>>? factions,
  }) {
    return FactionTerritoryWarReport(
      id: (id != null ? id.value : this.id),
      territory: (territory != null ? territory.value : this.territory),
      startedAt: (startedAt != null ? startedAt.value : this.startedAt),
      endedAt: (endedAt != null ? endedAt.value : this.endedAt),
      winner: (winner != null ? winner.value : this.winner),
      result: (result != null ? result.value : this.result),
      factions: (factions != null ? factions.value : this.factions),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionTerritoryWarReportResponse {
  const FactionTerritoryWarReportResponse({required this.territorywarreport});

  factory FactionTerritoryWarReportResponse.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$FactionTerritoryWarReportResponseFromJson(json);

  static const toJsonFactory = _$FactionTerritoryWarReportResponseToJson;
  Map<String, dynamic> toJson() => _$FactionTerritoryWarReportResponseToJson(this);

  @JsonKey(
    name: 'territorywarreport',
    defaultValue: <FactionTerritoryWarReport>[],
  )
  final List<FactionTerritoryWarReport> territorywarreport;
  static const fromJsonFactory = _$FactionTerritoryWarReportResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionTerritoryWarReportResponse &&
            (identical(other.territorywarreport, territorywarreport) ||
                const DeepCollectionEquality().equals(
                  other.territorywarreport,
                  territorywarreport,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(territorywarreport) ^ runtimeType.hashCode;
}

extension $FactionTerritoryWarReportResponseExtension on FactionTerritoryWarReportResponse {
  FactionTerritoryWarReportResponse copyWith({
    List<FactionTerritoryWarReport>? territorywarreport,
  }) {
    return FactionTerritoryWarReportResponse(
      territorywarreport: territorywarreport ?? this.territorywarreport,
    );
  }

  FactionTerritoryWarReportResponse copyWithWrapped({
    Wrapped<List<FactionTerritoryWarReport>>? territorywarreport,
  }) {
    return FactionTerritoryWarReportResponse(
      territorywarreport: (territorywarreport != null ? territorywarreport.value : this.territorywarreport),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionTerritoryOwnership {
  const FactionTerritoryOwnership({
    required this.id,
    required this.ownedBy,
    required this.acquiredAt,
  });

  factory FactionTerritoryOwnership.fromJson(Map<String, dynamic> json) => _$FactionTerritoryOwnershipFromJson(json);

  static const toJsonFactory = _$FactionTerritoryOwnershipToJson;
  Map<String, dynamic> toJson() => _$FactionTerritoryOwnershipToJson(this);

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'owned_by')
  final dynamic ownedBy;
  @JsonKey(name: 'acquired_at')
  final dynamic acquiredAt;
  static const fromJsonFactory = _$FactionTerritoryOwnershipFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionTerritoryOwnership &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.ownedBy, ownedBy) ||
                const DeepCollectionEquality().equals(
                  other.ownedBy,
                  ownedBy,
                )) &&
            (identical(other.acquiredAt, acquiredAt) ||
                const DeepCollectionEquality().equals(
                  other.acquiredAt,
                  acquiredAt,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(ownedBy) ^
      const DeepCollectionEquality().hash(acquiredAt) ^
      runtimeType.hashCode;
}

extension $FactionTerritoryOwnershipExtension on FactionTerritoryOwnership {
  FactionTerritoryOwnership copyWith({
    String? id,
    dynamic ownedBy,
    dynamic acquiredAt,
  }) {
    return FactionTerritoryOwnership(
      id: id ?? this.id,
      ownedBy: ownedBy ?? this.ownedBy,
      acquiredAt: acquiredAt ?? this.acquiredAt,
    );
  }

  FactionTerritoryOwnership copyWithWrapped({
    Wrapped<String>? id,
    Wrapped<dynamic>? ownedBy,
    Wrapped<dynamic>? acquiredAt,
  }) {
    return FactionTerritoryOwnership(
      id: (id != null ? id.value : this.id),
      ownedBy: (ownedBy != null ? ownedBy.value : this.ownedBy),
      acquiredAt: (acquiredAt != null ? acquiredAt.value : this.acquiredAt),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionTerritoriesOwnershipResponse {
  const FactionTerritoriesOwnershipResponse({required this.territoryOwnership});

  factory FactionTerritoriesOwnershipResponse.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$FactionTerritoriesOwnershipResponseFromJson(json);

  static const toJsonFactory = _$FactionTerritoriesOwnershipResponseToJson;
  Map<String, dynamic> toJson() => _$FactionTerritoriesOwnershipResponseToJson(this);

  @JsonKey(
    name: 'territoryOwnership',
    defaultValue: <FactionTerritoryOwnership>[],
  )
  final List<FactionTerritoryOwnership> territoryOwnership;
  static const fromJsonFactory = _$FactionTerritoriesOwnershipResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionTerritoriesOwnershipResponse &&
            (identical(other.territoryOwnership, territoryOwnership) ||
                const DeepCollectionEquality().equals(
                  other.territoryOwnership,
                  territoryOwnership,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(territoryOwnership) ^ runtimeType.hashCode;
}

extension $FactionTerritoriesOwnershipResponseExtension on FactionTerritoriesOwnershipResponse {
  FactionTerritoriesOwnershipResponse copyWith({
    List<FactionTerritoryOwnership>? territoryOwnership,
  }) {
    return FactionTerritoriesOwnershipResponse(
      territoryOwnership: territoryOwnership ?? this.territoryOwnership,
    );
  }

  FactionTerritoriesOwnershipResponse copyWithWrapped({
    Wrapped<List<FactionTerritoryOwnership>>? territoryOwnership,
  }) {
    return FactionTerritoriesOwnershipResponse(
      territoryOwnership: (territoryOwnership != null ? territoryOwnership.value : this.territoryOwnership),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TornRacketReward {
  const TornRacketReward({
    required this.type,
    required this.quantity,
    required this.id,
  });

  factory TornRacketReward.fromJson(Map<String, dynamic> json) => _$TornRacketRewardFromJson(json);

  static const toJsonFactory = _$TornRacketRewardToJson;
  Map<String, dynamic> toJson() => _$TornRacketRewardToJson(this);

  @JsonKey(
    name: 'type',
    toJson: tornRacketTypeToJson,
    fromJson: tornRacketTypeFromJson,
  )
  final enums.TornRacketType type;
  @JsonKey(name: 'quantity')
  final int quantity;
  @JsonKey(name: 'id')
  final dynamic id;
  static const fromJsonFactory = _$TornRacketRewardFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TornRacketReward &&
            (identical(other.type, type) || const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.quantity, quantity) ||
                const DeepCollectionEquality().equals(
                  other.quantity,
                  quantity,
                )) &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(quantity) ^
      const DeepCollectionEquality().hash(id) ^
      runtimeType.hashCode;
}

extension $TornRacketRewardExtension on TornRacketReward {
  TornRacketReward copyWith({
    enums.TornRacketType? type,
    int? quantity,
    dynamic id,
  }) {
    return TornRacketReward(
      type: type ?? this.type,
      quantity: quantity ?? this.quantity,
      id: id ?? this.id,
    );
  }

  TornRacketReward copyWithWrapped({
    Wrapped<enums.TornRacketType>? type,
    Wrapped<int>? quantity,
    Wrapped<dynamic>? id,
  }) {
    return TornRacketReward(
      type: (type != null ? type.value : this.type),
      quantity: (quantity != null ? quantity.value : this.quantity),
      id: (id != null ? id.value : this.id),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TornRacket {
  const TornRacket({
    required this.name,
    required this.level,
    required this.description,
    required this.reward,
    required this.createdAt,
    required this.changedAt,
  });

  factory TornRacket.fromJson(Map<String, dynamic> json) => _$TornRacketFromJson(json);

  static const toJsonFactory = _$TornRacketToJson;
  Map<String, dynamic> toJson() => _$TornRacketToJson(this);

  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'level')
  final int level;
  @JsonKey(name: 'description')
  final String description;
  @JsonKey(name: 'reward')
  final TornRacketReward reward;
  @JsonKey(name: 'created_at')
  final int createdAt;
  @JsonKey(name: 'changed_at')
  final int changedAt;
  static const fromJsonFactory = _$TornRacketFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TornRacket &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.level, level) || const DeepCollectionEquality().equals(other.level, level)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.reward, reward) || const DeepCollectionEquality().equals(other.reward, reward)) &&
            (identical(other.createdAt, createdAt) ||
                const DeepCollectionEquality().equals(
                  other.createdAt,
                  createdAt,
                )) &&
            (identical(other.changedAt, changedAt) ||
                const DeepCollectionEquality().equals(
                  other.changedAt,
                  changedAt,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(level) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(reward) ^
      const DeepCollectionEquality().hash(createdAt) ^
      const DeepCollectionEquality().hash(changedAt) ^
      runtimeType.hashCode;
}

extension $TornRacketExtension on TornRacket {
  TornRacket copyWith({
    String? name,
    int? level,
    String? description,
    TornRacketReward? reward,
    int? createdAt,
    int? changedAt,
  }) {
    return TornRacket(
      name: name ?? this.name,
      level: level ?? this.level,
      description: description ?? this.description,
      reward: reward ?? this.reward,
      createdAt: createdAt ?? this.createdAt,
      changedAt: changedAt ?? this.changedAt,
    );
  }

  TornRacket copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<int>? level,
    Wrapped<String>? description,
    Wrapped<TornRacketReward>? reward,
    Wrapped<int>? createdAt,
    Wrapped<int>? changedAt,
  }) {
    return TornRacket(
      name: (name != null ? name.value : this.name),
      level: (level != null ? level.value : this.level),
      description: (description != null ? description.value : this.description),
      reward: (reward != null ? reward.value : this.reward),
      createdAt: (createdAt != null ? createdAt.value : this.createdAt),
      changedAt: (changedAt != null ? changedAt.value : this.changedAt),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionRacketsResponse {
  const FactionRacketsResponse({required this.rackets});

  factory FactionRacketsResponse.fromJson(Map<String, dynamic> json) => _$FactionRacketsResponseFromJson(json);

  static const toJsonFactory = _$FactionRacketsResponseToJson;
  Map<String, dynamic> toJson() => _$FactionRacketsResponseToJson(this);

  @JsonKey(name: 'rackets', defaultValue: <TornRacket>[])
  final List<TornRacket> rackets;
  static const fromJsonFactory = _$FactionRacketsResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionRacketsResponse &&
            (identical(other.rackets, rackets) || const DeepCollectionEquality().equals(other.rackets, rackets)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(rackets) ^ runtimeType.hashCode;
}

extension $FactionRacketsResponseExtension on FactionRacketsResponse {
  FactionRacketsResponse copyWith({List<TornRacket>? rackets}) {
    return FactionRacketsResponse(rackets: rackets ?? this.rackets);
  }

  FactionRacketsResponse copyWithWrapped({Wrapped<List<TornRacket>>? rackets}) {
    return FactionRacketsResponse(
      rackets: (rackets != null ? rackets.value : this.rackets),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionTerritory {
  const FactionTerritory({
    required this.id,
    required this.acquiredAt,
    required this.sector,
    required this.size,
    required this.density,
    required this.slots,
    required this.respect,
    required this.coordinates,
    required this.racket,
  });

  factory FactionTerritory.fromJson(Map<String, dynamic> json) => _$FactionTerritoryFromJson(json);

  static const toJsonFactory = _$FactionTerritoryToJson;
  Map<String, dynamic> toJson() => _$FactionTerritoryToJson(this);

  @JsonKey(
    name: 'id',
    toJson: factionTerritoryEnumToJson,
    fromJson: factionTerritoryEnumFromJson,
  )
  final enums.FactionTerritoryEnum id;
  @JsonKey(name: 'acquired_at')
  final int acquiredAt;
  @JsonKey(name: 'sector')
  final int sector;
  @JsonKey(name: 'size')
  final int size;
  @JsonKey(name: 'density')
  final int density;
  @JsonKey(name: 'slots')
  final int slots;
  @JsonKey(name: 'respect')
  final int respect;
  @JsonKey(name: 'coordinates')
  final TornTerritoryCoordinates coordinates;
  @JsonKey(name: 'racket')
  final dynamic racket;
  static const fromJsonFactory = _$FactionTerritoryFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionTerritory &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.acquiredAt, acquiredAt) ||
                const DeepCollectionEquality().equals(
                  other.acquiredAt,
                  acquiredAt,
                )) &&
            (identical(other.sector, sector) || const DeepCollectionEquality().equals(other.sector, sector)) &&
            (identical(other.size, size) || const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.density, density) ||
                const DeepCollectionEquality().equals(
                  other.density,
                  density,
                )) &&
            (identical(other.slots, slots) || const DeepCollectionEquality().equals(other.slots, slots)) &&
            (identical(other.respect, respect) ||
                const DeepCollectionEquality().equals(
                  other.respect,
                  respect,
                )) &&
            (identical(other.coordinates, coordinates) ||
                const DeepCollectionEquality().equals(
                  other.coordinates,
                  coordinates,
                )) &&
            (identical(other.racket, racket) || const DeepCollectionEquality().equals(other.racket, racket)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(acquiredAt) ^
      const DeepCollectionEquality().hash(sector) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(density) ^
      const DeepCollectionEquality().hash(slots) ^
      const DeepCollectionEquality().hash(respect) ^
      const DeepCollectionEquality().hash(coordinates) ^
      const DeepCollectionEquality().hash(racket) ^
      runtimeType.hashCode;
}

extension $FactionTerritoryExtension on FactionTerritory {
  FactionTerritory copyWith({
    enums.FactionTerritoryEnum? id,
    int? acquiredAt,
    int? sector,
    int? size,
    int? density,
    int? slots,
    int? respect,
    TornTerritoryCoordinates? coordinates,
    dynamic racket,
  }) {
    return FactionTerritory(
      id: id ?? this.id,
      acquiredAt: acquiredAt ?? this.acquiredAt,
      sector: sector ?? this.sector,
      size: size ?? this.size,
      density: density ?? this.density,
      slots: slots ?? this.slots,
      respect: respect ?? this.respect,
      coordinates: coordinates ?? this.coordinates,
      racket: racket ?? this.racket,
    );
  }

  FactionTerritory copyWithWrapped({
    Wrapped<enums.FactionTerritoryEnum>? id,
    Wrapped<int>? acquiredAt,
    Wrapped<int>? sector,
    Wrapped<int>? size,
    Wrapped<int>? density,
    Wrapped<int>? slots,
    Wrapped<int>? respect,
    Wrapped<TornTerritoryCoordinates>? coordinates,
    Wrapped<dynamic>? racket,
  }) {
    return FactionTerritory(
      id: (id != null ? id.value : this.id),
      acquiredAt: (acquiredAt != null ? acquiredAt.value : this.acquiredAt),
      sector: (sector != null ? sector.value : this.sector),
      size: (size != null ? size.value : this.size),
      density: (density != null ? density.value : this.density),
      slots: (slots != null ? slots.value : this.slots),
      respect: (respect != null ? respect.value : this.respect),
      coordinates: (coordinates != null ? coordinates.value : this.coordinates),
      racket: (racket != null ? racket.value : this.racket),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionTerritoriesResponse {
  const FactionTerritoriesResponse({required this.territory});

  factory FactionTerritoriesResponse.fromJson(Map<String, dynamic> json) => _$FactionTerritoriesResponseFromJson(json);

  static const toJsonFactory = _$FactionTerritoriesResponseToJson;
  Map<String, dynamic> toJson() => _$FactionTerritoriesResponseToJson(this);

  @JsonKey(name: 'territory', defaultValue: <FactionTerritory>[])
  final List<FactionTerritory> territory;
  static const fromJsonFactory = _$FactionTerritoriesResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionTerritoriesResponse &&
            (identical(other.territory, territory) ||
                const DeepCollectionEquality().equals(
                  other.territory,
                  territory,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(territory) ^ runtimeType.hashCode;
}

extension $FactionTerritoriesResponseExtension on FactionTerritoriesResponse {
  FactionTerritoriesResponse copyWith({List<FactionTerritory>? territory}) {
    return FactionTerritoriesResponse(territory: territory ?? this.territory);
  }

  FactionTerritoriesResponse copyWithWrapped({
    Wrapped<List<FactionTerritory>>? territory,
  }) {
    return FactionTerritoriesResponse(
      territory: (territory != null ? territory.value : this.territory),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionPosition {
  const FactionPosition({
    required this.name,
    required this.isDefault,
    required this.abilities,
  });

  factory FactionPosition.fromJson(Map<String, dynamic> json) => _$FactionPositionFromJson(json);

  static const toJsonFactory = _$FactionPositionToJson;
  Map<String, dynamic> toJson() => _$FactionPositionToJson(this);

  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'is_default')
  final bool isDefault;
  @JsonKey(
    name: 'abilities',
    toJson: factionPositionAbilityEnumListToJson,
    fromJson: factionPositionAbilityEnumListFromJson,
  )
  final List<enums.FactionPositionAbilityEnum> abilities;
  static const fromJsonFactory = _$FactionPositionFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionPosition &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.isDefault, isDefault) ||
                const DeepCollectionEquality().equals(
                  other.isDefault,
                  isDefault,
                )) &&
            (identical(other.abilities, abilities) ||
                const DeepCollectionEquality().equals(
                  other.abilities,
                  abilities,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(isDefault) ^
      const DeepCollectionEquality().hash(abilities) ^
      runtimeType.hashCode;
}

extension $FactionPositionExtension on FactionPosition {
  FactionPosition copyWith({
    String? name,
    bool? isDefault,
    List<enums.FactionPositionAbilityEnum>? abilities,
  }) {
    return FactionPosition(
      name: name ?? this.name,
      isDefault: isDefault ?? this.isDefault,
      abilities: abilities ?? this.abilities,
    );
  }

  FactionPosition copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<bool>? isDefault,
    Wrapped<List<enums.FactionPositionAbilityEnum>>? abilities,
  }) {
    return FactionPosition(
      name: (name != null ? name.value : this.name),
      isDefault: (isDefault != null ? isDefault.value : this.isDefault),
      abilities: (abilities != null ? abilities.value : this.abilities),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionPositionsResponse {
  const FactionPositionsResponse({required this.positions});

  factory FactionPositionsResponse.fromJson(Map<String, dynamic> json) => _$FactionPositionsResponseFromJson(json);

  static const toJsonFactory = _$FactionPositionsResponseToJson;
  Map<String, dynamic> toJson() => _$FactionPositionsResponseToJson(this);

  @JsonKey(name: 'positions', defaultValue: <FactionPosition>[])
  final List<FactionPosition> positions;
  static const fromJsonFactory = _$FactionPositionsResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionPositionsResponse &&
            (identical(other.positions, positions) ||
                const DeepCollectionEquality().equals(
                  other.positions,
                  positions,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(positions) ^ runtimeType.hashCode;
}

extension $FactionPositionsResponseExtension on FactionPositionsResponse {
  FactionPositionsResponse copyWith({List<FactionPosition>? positions}) {
    return FactionPositionsResponse(positions: positions ?? this.positions);
  }

  FactionPositionsResponse copyWithWrapped({
    Wrapped<List<FactionPosition>>? positions,
  }) {
    return FactionPositionsResponse(
      positions: (positions != null ? positions.value : this.positions),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionUpgradeDetails {
  const FactionUpgradeDetails({
    required this.id,
    required this.name,
    required this.ability,
    required this.level,
    required this.cost,
    this.unlockedAt,
  });

  factory FactionUpgradeDetails.fromJson(Map<String, dynamic> json) => _$FactionUpgradeDetailsFromJson(json);

  static const toJsonFactory = _$FactionUpgradeDetailsToJson;
  Map<String, dynamic> toJson() => _$FactionUpgradeDetailsToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'ability')
  final String ability;
  @JsonKey(name: 'level')
  final int level;
  @JsonKey(name: 'cost')
  final int cost;
  @JsonKey(name: 'unlocked_at')
  final int? unlockedAt;
  static const fromJsonFactory = _$FactionUpgradeDetailsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionUpgradeDetails &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.ability, ability) ||
                const DeepCollectionEquality().equals(
                  other.ability,
                  ability,
                )) &&
            (identical(other.level, level) || const DeepCollectionEquality().equals(other.level, level)) &&
            (identical(other.cost, cost) || const DeepCollectionEquality().equals(other.cost, cost)) &&
            (identical(other.unlockedAt, unlockedAt) ||
                const DeepCollectionEquality().equals(
                  other.unlockedAt,
                  unlockedAt,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(ability) ^
      const DeepCollectionEquality().hash(level) ^
      const DeepCollectionEquality().hash(cost) ^
      const DeepCollectionEquality().hash(unlockedAt) ^
      runtimeType.hashCode;
}

extension $FactionUpgradeDetailsExtension on FactionUpgradeDetails {
  FactionUpgradeDetails copyWith({
    int? id,
    String? name,
    String? ability,
    int? level,
    int? cost,
    int? unlockedAt,
  }) {
    return FactionUpgradeDetails(
      id: id ?? this.id,
      name: name ?? this.name,
      ability: ability ?? this.ability,
      level: level ?? this.level,
      cost: cost ?? this.cost,
      unlockedAt: unlockedAt ?? this.unlockedAt,
    );
  }

  FactionUpgradeDetails copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<String>? name,
    Wrapped<String>? ability,
    Wrapped<int>? level,
    Wrapped<int>? cost,
    Wrapped<int?>? unlockedAt,
  }) {
    return FactionUpgradeDetails(
      id: (id != null ? id.value : this.id),
      name: (name != null ? name.value : this.name),
      ability: (ability != null ? ability.value : this.ability),
      level: (level != null ? level.value : this.level),
      cost: (cost != null ? cost.value : this.cost),
      unlockedAt: (unlockedAt != null ? unlockedAt.value : this.unlockedAt),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionBranchDetails {
  const FactionBranchDetails({
    required this.name,
    required this.order,
    required this.multiplier,
    required this.upgrades,
  });

  factory FactionBranchDetails.fromJson(Map<String, dynamic> json) => _$FactionBranchDetailsFromJson(json);

  static const toJsonFactory = _$FactionBranchDetailsToJson;
  Map<String, dynamic> toJson() => _$FactionBranchDetailsToJson(this);

  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'order')
  final int order;
  @JsonKey(name: 'multiplier')
  final int multiplier;
  @JsonKey(name: 'upgrades', defaultValue: <FactionUpgradeDetails>[])
  final List<FactionUpgradeDetails> upgrades;
  static const fromJsonFactory = _$FactionBranchDetailsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionBranchDetails &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.order, order) || const DeepCollectionEquality().equals(other.order, order)) &&
            (identical(other.multiplier, multiplier) ||
                const DeepCollectionEquality().equals(
                  other.multiplier,
                  multiplier,
                )) &&
            (identical(other.upgrades, upgrades) ||
                const DeepCollectionEquality().equals(
                  other.upgrades,
                  upgrades,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(order) ^
      const DeepCollectionEquality().hash(multiplier) ^
      const DeepCollectionEquality().hash(upgrades) ^
      runtimeType.hashCode;
}

extension $FactionBranchDetailsExtension on FactionBranchDetails {
  FactionBranchDetails copyWith({
    String? name,
    int? order,
    int? multiplier,
    List<FactionUpgradeDetails>? upgrades,
  }) {
    return FactionBranchDetails(
      name: name ?? this.name,
      order: order ?? this.order,
      multiplier: multiplier ?? this.multiplier,
      upgrades: upgrades ?? this.upgrades,
    );
  }

  FactionBranchDetails copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<int>? order,
    Wrapped<int>? multiplier,
    Wrapped<List<FactionUpgradeDetails>>? upgrades,
  }) {
    return FactionBranchDetails(
      name: (name != null ? name.value : this.name),
      order: (order != null ? order.value : this.order),
      multiplier: (multiplier != null ? multiplier.value : this.multiplier),
      upgrades: (upgrades != null ? upgrades.value : this.upgrades),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionUpgrades {
  const FactionUpgrades({
    required this.core,
    required this.peace,
    required this.war,
  });

  factory FactionUpgrades.fromJson(Map<String, dynamic> json) => _$FactionUpgradesFromJson(json);

  static const toJsonFactory = _$FactionUpgradesToJson;
  Map<String, dynamic> toJson() => _$FactionUpgradesToJson(this);

  @JsonKey(name: 'core')
  final FactionUpgrades$Core core;
  @JsonKey(name: 'peace', defaultValue: <FactionBranchDetails>[])
  final List<FactionBranchDetails> peace;
  @JsonKey(name: 'war', defaultValue: <FactionBranchDetails>[])
  final List<FactionBranchDetails> war;
  static const fromJsonFactory = _$FactionUpgradesFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionUpgrades &&
            (identical(other.core, core) || const DeepCollectionEquality().equals(other.core, core)) &&
            (identical(other.peace, peace) || const DeepCollectionEquality().equals(other.peace, peace)) &&
            (identical(other.war, war) || const DeepCollectionEquality().equals(other.war, war)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(core) ^
      const DeepCollectionEquality().hash(peace) ^
      const DeepCollectionEquality().hash(war) ^
      runtimeType.hashCode;
}

extension $FactionUpgradesExtension on FactionUpgrades {
  FactionUpgrades copyWith({
    FactionUpgrades$Core? core,
    List<FactionBranchDetails>? peace,
    List<FactionBranchDetails>? war,
  }) {
    return FactionUpgrades(
      core: core ?? this.core,
      peace: peace ?? this.peace,
      war: war ?? this.war,
    );
  }

  FactionUpgrades copyWithWrapped({
    Wrapped<FactionUpgrades$Core>? core,
    Wrapped<List<FactionBranchDetails>>? peace,
    Wrapped<List<FactionBranchDetails>>? war,
  }) {
    return FactionUpgrades(
      core: (core != null ? core.value : this.core),
      peace: (peace != null ? peace.value : this.peace),
      war: (war != null ? war.value : this.war),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionUpgradesResponse {
  const FactionUpgradesResponse({required this.upgrades, required this.state});

  factory FactionUpgradesResponse.fromJson(Map<String, dynamic> json) => _$FactionUpgradesResponseFromJson(json);

  static const toJsonFactory = _$FactionUpgradesResponseToJson;
  Map<String, dynamic> toJson() => _$FactionUpgradesResponseToJson(this);

  @JsonKey(name: 'upgrades')
  final FactionUpgrades upgrades;
  @JsonKey(
    name: 'state',
    toJson: factionBranchStateEnumToJson,
    fromJson: factionBranchStateEnumFromJson,
  )
  final enums.FactionBranchStateEnum state;
  static const fromJsonFactory = _$FactionUpgradesResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionUpgradesResponse &&
            (identical(other.upgrades, upgrades) ||
                const DeepCollectionEquality().equals(
                  other.upgrades,
                  upgrades,
                )) &&
            (identical(other.state, state) || const DeepCollectionEquality().equals(other.state, state)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(upgrades) ^ const DeepCollectionEquality().hash(state) ^ runtimeType.hashCode;
}

extension $FactionUpgradesResponseExtension on FactionUpgradesResponse {
  FactionUpgradesResponse copyWith({
    FactionUpgrades? upgrades,
    enums.FactionBranchStateEnum? state,
  }) {
    return FactionUpgradesResponse(
      upgrades: upgrades ?? this.upgrades,
      state: state ?? this.state,
    );
  }

  FactionUpgradesResponse copyWithWrapped({
    Wrapped<FactionUpgrades>? upgrades,
    Wrapped<enums.FactionBranchStateEnum>? state,
  }) {
    return FactionUpgradesResponse(
      upgrades: (upgrades != null ? upgrades.value : this.upgrades),
      state: (state != null ? state.value : this.state),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionStat {
  const FactionStat({required this.name, required this.$value});

  factory FactionStat.fromJson(Map<String, dynamic> json) => _$FactionStatFromJson(json);

  static const toJsonFactory = _$FactionStatToJson;
  Map<String, dynamic> toJson() => _$FactionStatToJson(this);

  @JsonKey(
    name: 'name',
    toJson: factionStatEnumToJson,
    fromJson: factionStatEnumFromJson,
  )
  final enums.FactionStatEnum name;
  @JsonKey(name: 'value')
  final int $value;
  static const fromJsonFactory = _$FactionStatFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionStat &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.$value, $value) || const DeepCollectionEquality().equals(other.$value, $value)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^ const DeepCollectionEquality().hash($value) ^ runtimeType.hashCode;
}

extension $FactionStatExtension on FactionStat {
  FactionStat copyWith({enums.FactionStatEnum? name, int? $value}) {
    return FactionStat(name: name ?? this.name, $value: $value ?? this.$value);
  }

  FactionStat copyWithWrapped({
    Wrapped<enums.FactionStatEnum>? name,
    Wrapped<int>? $value,
  }) {
    return FactionStat(
      name: (name != null ? name.value : this.name),
      $value: ($value != null ? $value.value : this.$value),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionStatsResponse {
  const FactionStatsResponse({required this.stats});

  factory FactionStatsResponse.fromJson(Map<String, dynamic> json) => _$FactionStatsResponseFromJson(json);

  static const toJsonFactory = _$FactionStatsResponseToJson;
  Map<String, dynamic> toJson() => _$FactionStatsResponseToJson(this);

  @JsonKey(name: 'stats', defaultValue: <FactionStat>[])
  final List<FactionStat> stats;
  static const fromJsonFactory = _$FactionStatsResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionStatsResponse &&
            (identical(other.stats, stats) || const DeepCollectionEquality().equals(other.stats, stats)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(stats) ^ runtimeType.hashCode;
}

extension $FactionStatsResponseExtension on FactionStatsResponse {
  FactionStatsResponse copyWith({List<FactionStat>? stats}) {
    return FactionStatsResponse(stats: stats ?? this.stats);
  }

  FactionStatsResponse copyWithWrapped({Wrapped<List<FactionStat>>? stats}) {
    return FactionStatsResponse(
      stats: (stats != null ? stats.value : this.stats),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionContributor {
  const FactionContributor({
    required this.id,
    required this.username,
    required this.$value,
    required this.inFaction,
  });

  factory FactionContributor.fromJson(Map<String, dynamic> json) => _$FactionContributorFromJson(json);

  static const toJsonFactory = _$FactionContributorToJson;
  Map<String, dynamic> toJson() => _$FactionContributorToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'username')
  final String username;
  @JsonKey(name: 'value')
  final int $value;
  @JsonKey(name: 'in_faction')
  final bool inFaction;
  static const fromJsonFactory = _$FactionContributorFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionContributor &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.username, username) ||
                const DeepCollectionEquality().equals(
                  other.username,
                  username,
                )) &&
            (identical(other.$value, $value) || const DeepCollectionEquality().equals(other.$value, $value)) &&
            (identical(other.inFaction, inFaction) ||
                const DeepCollectionEquality().equals(
                  other.inFaction,
                  inFaction,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(username) ^
      const DeepCollectionEquality().hash($value) ^
      const DeepCollectionEquality().hash(inFaction) ^
      runtimeType.hashCode;
}

extension $FactionContributorExtension on FactionContributor {
  FactionContributor copyWith({
    int? id,
    String? username,
    int? $value,
    bool? inFaction,
  }) {
    return FactionContributor(
      id: id ?? this.id,
      username: username ?? this.username,
      $value: $value ?? this.$value,
      inFaction: inFaction ?? this.inFaction,
    );
  }

  FactionContributor copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<String>? username,
    Wrapped<int>? $value,
    Wrapped<bool>? inFaction,
  }) {
    return FactionContributor(
      id: (id != null ? id.value : this.id),
      username: (username != null ? username.value : this.username),
      $value: ($value != null ? $value.value : this.$value),
      inFaction: (inFaction != null ? inFaction.value : this.inFaction),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionContributorsResponse {
  const FactionContributorsResponse({required this.contributors});

  factory FactionContributorsResponse.fromJson(Map<String, dynamic> json) =>
      _$FactionContributorsResponseFromJson(json);

  static const toJsonFactory = _$FactionContributorsResponseToJson;
  Map<String, dynamic> toJson() => _$FactionContributorsResponseToJson(this);

  @JsonKey(name: 'contributors', defaultValue: <FactionContributor>[])
  final List<FactionContributor> contributors;
  static const fromJsonFactory = _$FactionContributorsResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionContributorsResponse &&
            (identical(other.contributors, contributors) ||
                const DeepCollectionEquality().equals(
                  other.contributors,
                  contributors,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(contributors) ^ runtimeType.hashCode;
}

extension $FactionContributorsResponseExtension on FactionContributorsResponse {
  FactionContributorsResponse copyWith({
    List<FactionContributor>? contributors,
  }) {
    return FactionContributorsResponse(
      contributors: contributors ?? this.contributors,
    );
  }

  FactionContributorsResponse copyWithWrapped({
    Wrapped<List<FactionContributor>>? contributors,
  }) {
    return FactionContributorsResponse(
      contributors: (contributors != null ? contributors.value : this.contributors),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionHofStats {
  const FactionHofStats({
    required this.rank,
    required this.respect,
    required this.chain,
  });

  factory FactionHofStats.fromJson(Map<String, dynamic> json) => _$FactionHofStatsFromJson(json);

  static const toJsonFactory = _$FactionHofStatsToJson;
  Map<String, dynamic> toJson() => _$FactionHofStatsToJson(this);

  @JsonKey(name: 'rank')
  final HofValueString rank;
  @JsonKey(name: 'respect')
  final HofValue respect;
  @JsonKey(name: 'chain')
  final HofValue chain;
  static const fromJsonFactory = _$FactionHofStatsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionHofStats &&
            (identical(other.rank, rank) || const DeepCollectionEquality().equals(other.rank, rank)) &&
            (identical(other.respect, respect) ||
                const DeepCollectionEquality().equals(
                  other.respect,
                  respect,
                )) &&
            (identical(other.chain, chain) || const DeepCollectionEquality().equals(other.chain, chain)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(rank) ^
      const DeepCollectionEquality().hash(respect) ^
      const DeepCollectionEquality().hash(chain) ^
      runtimeType.hashCode;
}

extension $FactionHofStatsExtension on FactionHofStats {
  FactionHofStats copyWith({
    HofValueString? rank,
    HofValue? respect,
    HofValue? chain,
  }) {
    return FactionHofStats(
      rank: rank ?? this.rank,
      respect: respect ?? this.respect,
      chain: chain ?? this.chain,
    );
  }

  FactionHofStats copyWithWrapped({
    Wrapped<HofValueString>? rank,
    Wrapped<HofValue>? respect,
    Wrapped<HofValue>? chain,
  }) {
    return FactionHofStats(
      rank: (rank != null ? rank.value : this.rank),
      respect: (respect != null ? respect.value : this.respect),
      chain: (chain != null ? chain.value : this.chain),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionHofResponse {
  const FactionHofResponse({required this.hof});

  factory FactionHofResponse.fromJson(Map<String, dynamic> json) => _$FactionHofResponseFromJson(json);

  static const toJsonFactory = _$FactionHofResponseToJson;
  Map<String, dynamic> toJson() => _$FactionHofResponseToJson(this);

  @JsonKey(name: 'hof')
  final FactionHofStats hof;
  static const fromJsonFactory = _$FactionHofResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionHofResponse &&
            (identical(other.hof, hof) || const DeepCollectionEquality().equals(other.hof, hof)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(hof) ^ runtimeType.hashCode;
}

extension $FactionHofResponseExtension on FactionHofResponse {
  FactionHofResponse copyWith({FactionHofStats? hof}) {
    return FactionHofResponse(hof: hof ?? this.hof);
  }

  FactionHofResponse copyWithWrapped({Wrapped<FactionHofStats>? hof}) {
    return FactionHofResponse(hof: (hof != null ? hof.value : this.hof));
  }
}

@JsonSerializable(explicitToJson: true)
class FactionMember {
  const FactionMember({
    required this.id,
    required this.name,
    required this.position,
    required this.level,
    required this.daysInFaction,
    required this.isRevivable,
    required this.isOnWall,
    required this.isInOc,
    required this.hasEarlyDischarge,
    required this.lastAction,
    required this.status,
    required this.reviveSetting,
  });

  factory FactionMember.fromJson(Map<String, dynamic> json) => _$FactionMemberFromJson(json);

  static const toJsonFactory = _$FactionMemberToJson;
  Map<String, dynamic> toJson() => _$FactionMemberToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'position')
  final String position;
  @JsonKey(name: 'level')
  final int level;
  @JsonKey(name: 'days_in_faction')
  final int daysInFaction;
  @JsonKey(name: 'is_revivable')
  final bool isRevivable;
  @JsonKey(name: 'is_on_wall')
  final bool isOnWall;
  @JsonKey(name: 'is_in_oc')
  final bool isInOc;
  @JsonKey(name: 'has_early_discharge')
  final bool hasEarlyDischarge;
  @JsonKey(name: 'last_action')
  final UserLastAction lastAction;
  @JsonKey(name: 'status')
  final UserStatus status;
  @JsonKey(
    name: 'revive_setting',
    toJson: reviveSettingToJson,
    fromJson: reviveSettingFromJson,
  )
  final enums.ReviveSetting reviveSetting;
  static const fromJsonFactory = _$FactionMemberFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionMember &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.position, position) ||
                const DeepCollectionEquality().equals(
                  other.position,
                  position,
                )) &&
            (identical(other.level, level) || const DeepCollectionEquality().equals(other.level, level)) &&
            (identical(other.daysInFaction, daysInFaction) ||
                const DeepCollectionEquality().equals(
                  other.daysInFaction,
                  daysInFaction,
                )) &&
            (identical(other.isRevivable, isRevivable) ||
                const DeepCollectionEquality().equals(
                  other.isRevivable,
                  isRevivable,
                )) &&
            (identical(other.isOnWall, isOnWall) ||
                const DeepCollectionEquality().equals(
                  other.isOnWall,
                  isOnWall,
                )) &&
            (identical(other.isInOc, isInOc) || const DeepCollectionEquality().equals(other.isInOc, isInOc)) &&
            (identical(other.hasEarlyDischarge, hasEarlyDischarge) ||
                const DeepCollectionEquality().equals(
                  other.hasEarlyDischarge,
                  hasEarlyDischarge,
                )) &&
            (identical(other.lastAction, lastAction) ||
                const DeepCollectionEquality().equals(
                  other.lastAction,
                  lastAction,
                )) &&
            (identical(other.status, status) || const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.reviveSetting, reviveSetting) ||
                const DeepCollectionEquality().equals(
                  other.reviveSetting,
                  reviveSetting,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(position) ^
      const DeepCollectionEquality().hash(level) ^
      const DeepCollectionEquality().hash(daysInFaction) ^
      const DeepCollectionEquality().hash(isRevivable) ^
      const DeepCollectionEquality().hash(isOnWall) ^
      const DeepCollectionEquality().hash(isInOc) ^
      const DeepCollectionEquality().hash(hasEarlyDischarge) ^
      const DeepCollectionEquality().hash(lastAction) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(reviveSetting) ^
      runtimeType.hashCode;
}

extension $FactionMemberExtension on FactionMember {
  FactionMember copyWith({
    int? id,
    String? name,
    String? position,
    int? level,
    int? daysInFaction,
    bool? isRevivable,
    bool? isOnWall,
    bool? isInOc,
    bool? hasEarlyDischarge,
    UserLastAction? lastAction,
    UserStatus? status,
    enums.ReviveSetting? reviveSetting,
  }) {
    return FactionMember(
      id: id ?? this.id,
      name: name ?? this.name,
      position: position ?? this.position,
      level: level ?? this.level,
      daysInFaction: daysInFaction ?? this.daysInFaction,
      isRevivable: isRevivable ?? this.isRevivable,
      isOnWall: isOnWall ?? this.isOnWall,
      isInOc: isInOc ?? this.isInOc,
      hasEarlyDischarge: hasEarlyDischarge ?? this.hasEarlyDischarge,
      lastAction: lastAction ?? this.lastAction,
      status: status ?? this.status,
      reviveSetting: reviveSetting ?? this.reviveSetting,
    );
  }

  FactionMember copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<String>? name,
    Wrapped<String>? position,
    Wrapped<int>? level,
    Wrapped<int>? daysInFaction,
    Wrapped<bool>? isRevivable,
    Wrapped<bool>? isOnWall,
    Wrapped<bool>? isInOc,
    Wrapped<bool>? hasEarlyDischarge,
    Wrapped<UserLastAction>? lastAction,
    Wrapped<UserStatus>? status,
    Wrapped<enums.ReviveSetting>? reviveSetting,
  }) {
    return FactionMember(
      id: (id != null ? id.value : this.id),
      name: (name != null ? name.value : this.name),
      position: (position != null ? position.value : this.position),
      level: (level != null ? level.value : this.level),
      daysInFaction: (daysInFaction != null ? daysInFaction.value : this.daysInFaction),
      isRevivable: (isRevivable != null ? isRevivable.value : this.isRevivable),
      isOnWall: (isOnWall != null ? isOnWall.value : this.isOnWall),
      isInOc: (isInOc != null ? isInOc.value : this.isInOc),
      hasEarlyDischarge: (hasEarlyDischarge != null ? hasEarlyDischarge.value : this.hasEarlyDischarge),
      lastAction: (lastAction != null ? lastAction.value : this.lastAction),
      status: (status != null ? status.value : this.status),
      reviveSetting: (reviveSetting != null ? reviveSetting.value : this.reviveSetting),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserLastAction {
  const UserLastAction({
    required this.status,
    required this.timestamp,
    required this.relative,
  });

  factory UserLastAction.fromJson(Map<String, dynamic> json) => _$UserLastActionFromJson(json);

  static const toJsonFactory = _$UserLastActionToJson;
  Map<String, dynamic> toJson() => _$UserLastActionToJson(this);

  @JsonKey(name: 'status')
  final String status;
  @JsonKey(name: 'timestamp')
  final int timestamp;
  @JsonKey(name: 'relative')
  final String relative;
  static const fromJsonFactory = _$UserLastActionFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserLastAction &&
            (identical(other.status, status) || const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.timestamp, timestamp) ||
                const DeepCollectionEquality().equals(
                  other.timestamp,
                  timestamp,
                )) &&
            (identical(other.relative, relative) ||
                const DeepCollectionEquality().equals(
                  other.relative,
                  relative,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(timestamp) ^
      const DeepCollectionEquality().hash(relative) ^
      runtimeType.hashCode;
}

extension $UserLastActionExtension on UserLastAction {
  UserLastAction copyWith({String? status, int? timestamp, String? relative}) {
    return UserLastAction(
      status: status ?? this.status,
      timestamp: timestamp ?? this.timestamp,
      relative: relative ?? this.relative,
    );
  }

  UserLastAction copyWithWrapped({
    Wrapped<String>? status,
    Wrapped<int>? timestamp,
    Wrapped<String>? relative,
  }) {
    return UserLastAction(
      status: (status != null ? status.value : this.status),
      timestamp: (timestamp != null ? timestamp.value : this.timestamp),
      relative: (relative != null ? relative.value : this.relative),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserStatus {
  const UserStatus({
    required this.description,
    required this.details,
    required this.state,
    required this.until,
  });

  factory UserStatus.fromJson(Map<String, dynamic> json) => _$UserStatusFromJson(json);

  static const toJsonFactory = _$UserStatusToJson;
  Map<String, dynamic> toJson() => _$UserStatusToJson(this);

  @JsonKey(name: 'description')
  final String description;
  @JsonKey(name: 'details')
  final dynamic details;
  @JsonKey(name: 'state')
  final String state;
  @JsonKey(name: 'until')
  final dynamic until;
  static const fromJsonFactory = _$UserStatusFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserStatus &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.details, details) ||
                const DeepCollectionEquality().equals(
                  other.details,
                  details,
                )) &&
            (identical(other.state, state) || const DeepCollectionEquality().equals(other.state, state)) &&
            (identical(other.until, until) || const DeepCollectionEquality().equals(other.until, until)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(details) ^
      const DeepCollectionEquality().hash(state) ^
      const DeepCollectionEquality().hash(until) ^
      runtimeType.hashCode;
}

extension $UserStatusExtension on UserStatus {
  UserStatus copyWith({
    String? description,
    dynamic details,
    String? state,
    dynamic until,
  }) {
    return UserStatus(
      description: description ?? this.description,
      details: details ?? this.details,
      state: state ?? this.state,
      until: until ?? this.until,
    );
  }

  UserStatus copyWithWrapped({
    Wrapped<String>? description,
    Wrapped<dynamic>? details,
    Wrapped<String>? state,
    Wrapped<dynamic>? until,
  }) {
    return UserStatus(
      description: (description != null ? description.value : this.description),
      details: (details != null ? details.value : this.details),
      state: (state != null ? state.value : this.state),
      until: (until != null ? until.value : this.until),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionMembersResponse {
  const FactionMembersResponse({required this.members});

  factory FactionMembersResponse.fromJson(Map<String, dynamic> json) => _$FactionMembersResponseFromJson(json);

  static const toJsonFactory = _$FactionMembersResponseToJson;
  Map<String, dynamic> toJson() => _$FactionMembersResponseToJson(this);

  @JsonKey(name: 'members', defaultValue: <FactionMember>[])
  final List<FactionMember> members;
  static const fromJsonFactory = _$FactionMembersResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionMembersResponse &&
            (identical(other.members, members) || const DeepCollectionEquality().equals(other.members, members)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(members) ^ runtimeType.hashCode;
}

extension $FactionMembersResponseExtension on FactionMembersResponse {
  FactionMembersResponse copyWith({List<FactionMember>? members}) {
    return FactionMembersResponse(members: members ?? this.members);
  }

  FactionMembersResponse copyWithWrapped({
    Wrapped<List<FactionMember>>? members,
  }) {
    return FactionMembersResponse(
      members: (members != null ? members.value : this.members),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionRank {
  const FactionRank({
    required this.level,
    required this.name,
    required this.division,
    required this.position,
    required this.wins,
  });

  factory FactionRank.fromJson(Map<String, dynamic> json) => _$FactionRankFromJson(json);

  static const toJsonFactory = _$FactionRankToJson;
  Map<String, dynamic> toJson() => _$FactionRankToJson(this);

  @JsonKey(name: 'level')
  final int level;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'division')
  final int division;
  @JsonKey(name: 'position')
  final int position;
  @JsonKey(name: 'wins')
  final int wins;
  static const fromJsonFactory = _$FactionRankFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionRank &&
            (identical(other.level, level) || const DeepCollectionEquality().equals(other.level, level)) &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.division, division) ||
                const DeepCollectionEquality().equals(
                  other.division,
                  division,
                )) &&
            (identical(other.position, position) ||
                const DeepCollectionEquality().equals(
                  other.position,
                  position,
                )) &&
            (identical(other.wins, wins) || const DeepCollectionEquality().equals(other.wins, wins)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(level) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(division) ^
      const DeepCollectionEquality().hash(position) ^
      const DeepCollectionEquality().hash(wins) ^
      runtimeType.hashCode;
}

extension $FactionRankExtension on FactionRank {
  FactionRank copyWith({
    int? level,
    String? name,
    int? division,
    int? position,
    int? wins,
  }) {
    return FactionRank(
      level: level ?? this.level,
      name: name ?? this.name,
      division: division ?? this.division,
      position: position ?? this.position,
      wins: wins ?? this.wins,
    );
  }

  FactionRank copyWithWrapped({
    Wrapped<int>? level,
    Wrapped<String>? name,
    Wrapped<int>? division,
    Wrapped<int>? position,
    Wrapped<int>? wins,
  }) {
    return FactionRank(
      level: (level != null ? level.value : this.level),
      name: (name != null ? name.value : this.name),
      division: (division != null ? division.value : this.division),
      position: (position != null ? position.value : this.position),
      wins: (wins != null ? wins.value : this.wins),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionBasic {
  const FactionBasic({
    required this.id,
    required this.name,
    required this.tag,
    required this.tagImage,
    required this.leaderId,
    required this.coLeaderId,
    required this.respect,
    required this.daysOld,
    required this.capacity,
    required this.members,
    required this.isEnlisted,
    required this.rank,
    required this.bestChain,
  });

  factory FactionBasic.fromJson(Map<String, dynamic> json) => _$FactionBasicFromJson(json);

  static const toJsonFactory = _$FactionBasicToJson;
  Map<String, dynamic> toJson() => _$FactionBasicToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'tag')
  final String tag;
  @JsonKey(name: 'tag_image')
  final String tagImage;
  @JsonKey(name: 'leader_id')
  final int leaderId;
  @JsonKey(name: 'co_leader_id')
  final int coLeaderId;
  @JsonKey(name: 'respect')
  final int respect;
  @JsonKey(name: 'days_old')
  final int daysOld;
  @JsonKey(name: 'capacity')
  final int capacity;
  @JsonKey(name: 'members')
  final int members;
  @JsonKey(name: 'is_enlisted')
  final dynamic isEnlisted;
  @JsonKey(name: 'rank')
  final FactionRank rank;
  @JsonKey(name: 'best_chain')
  final int bestChain;
  static const fromJsonFactory = _$FactionBasicFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionBasic &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.tag, tag) || const DeepCollectionEquality().equals(other.tag, tag)) &&
            (identical(other.tagImage, tagImage) ||
                const DeepCollectionEquality().equals(
                  other.tagImage,
                  tagImage,
                )) &&
            (identical(other.leaderId, leaderId) ||
                const DeepCollectionEquality().equals(
                  other.leaderId,
                  leaderId,
                )) &&
            (identical(other.coLeaderId, coLeaderId) ||
                const DeepCollectionEquality().equals(
                  other.coLeaderId,
                  coLeaderId,
                )) &&
            (identical(other.respect, respect) ||
                const DeepCollectionEquality().equals(
                  other.respect,
                  respect,
                )) &&
            (identical(other.daysOld, daysOld) ||
                const DeepCollectionEquality().equals(
                  other.daysOld,
                  daysOld,
                )) &&
            (identical(other.capacity, capacity) ||
                const DeepCollectionEquality().equals(
                  other.capacity,
                  capacity,
                )) &&
            (identical(other.members, members) ||
                const DeepCollectionEquality().equals(
                  other.members,
                  members,
                )) &&
            (identical(other.isEnlisted, isEnlisted) ||
                const DeepCollectionEquality().equals(
                  other.isEnlisted,
                  isEnlisted,
                )) &&
            (identical(other.rank, rank) || const DeepCollectionEquality().equals(other.rank, rank)) &&
            (identical(other.bestChain, bestChain) ||
                const DeepCollectionEquality().equals(
                  other.bestChain,
                  bestChain,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(tag) ^
      const DeepCollectionEquality().hash(tagImage) ^
      const DeepCollectionEquality().hash(leaderId) ^
      const DeepCollectionEquality().hash(coLeaderId) ^
      const DeepCollectionEquality().hash(respect) ^
      const DeepCollectionEquality().hash(daysOld) ^
      const DeepCollectionEquality().hash(capacity) ^
      const DeepCollectionEquality().hash(members) ^
      const DeepCollectionEquality().hash(isEnlisted) ^
      const DeepCollectionEquality().hash(rank) ^
      const DeepCollectionEquality().hash(bestChain) ^
      runtimeType.hashCode;
}

extension $FactionBasicExtension on FactionBasic {
  FactionBasic copyWith({
    int? id,
    String? name,
    String? tag,
    String? tagImage,
    int? leaderId,
    int? coLeaderId,
    int? respect,
    int? daysOld,
    int? capacity,
    int? members,
    dynamic isEnlisted,
    FactionRank? rank,
    int? bestChain,
  }) {
    return FactionBasic(
      id: id ?? this.id,
      name: name ?? this.name,
      tag: tag ?? this.tag,
      tagImage: tagImage ?? this.tagImage,
      leaderId: leaderId ?? this.leaderId,
      coLeaderId: coLeaderId ?? this.coLeaderId,
      respect: respect ?? this.respect,
      daysOld: daysOld ?? this.daysOld,
      capacity: capacity ?? this.capacity,
      members: members ?? this.members,
      isEnlisted: isEnlisted ?? this.isEnlisted,
      rank: rank ?? this.rank,
      bestChain: bestChain ?? this.bestChain,
    );
  }

  FactionBasic copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<String>? name,
    Wrapped<String>? tag,
    Wrapped<String>? tagImage,
    Wrapped<int>? leaderId,
    Wrapped<int>? coLeaderId,
    Wrapped<int>? respect,
    Wrapped<int>? daysOld,
    Wrapped<int>? capacity,
    Wrapped<int>? members,
    Wrapped<dynamic>? isEnlisted,
    Wrapped<FactionRank>? rank,
    Wrapped<int>? bestChain,
  }) {
    return FactionBasic(
      id: (id != null ? id.value : this.id),
      name: (name != null ? name.value : this.name),
      tag: (tag != null ? tag.value : this.tag),
      tagImage: (tagImage != null ? tagImage.value : this.tagImage),
      leaderId: (leaderId != null ? leaderId.value : this.leaderId),
      coLeaderId: (coLeaderId != null ? coLeaderId.value : this.coLeaderId),
      respect: (respect != null ? respect.value : this.respect),
      daysOld: (daysOld != null ? daysOld.value : this.daysOld),
      capacity: (capacity != null ? capacity.value : this.capacity),
      members: (members != null ? members.value : this.members),
      isEnlisted: (isEnlisted != null ? isEnlisted.value : this.isEnlisted),
      rank: (rank != null ? rank.value : this.rank),
      bestChain: (bestChain != null ? bestChain.value : this.bestChain),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionBasicResponse {
  const FactionBasicResponse({required this.basic});

  factory FactionBasicResponse.fromJson(Map<String, dynamic> json) => _$FactionBasicResponseFromJson(json);

  static const toJsonFactory = _$FactionBasicResponseToJson;
  Map<String, dynamic> toJson() => _$FactionBasicResponseToJson(this);

  @JsonKey(name: 'basic')
  final FactionBasic basic;
  static const fromJsonFactory = _$FactionBasicResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionBasicResponse &&
            (identical(other.basic, basic) || const DeepCollectionEquality().equals(other.basic, basic)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(basic) ^ runtimeType.hashCode;
}

extension $FactionBasicResponseExtension on FactionBasicResponse {
  FactionBasicResponse copyWith({FactionBasic? basic}) {
    return FactionBasicResponse(basic: basic ?? this.basic);
  }

  FactionBasicResponse copyWithWrapped({Wrapped<FactionBasic>? basic}) {
    return FactionBasicResponse(
      basic: (basic != null ? basic.value : this.basic),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionPact {
  const FactionPact({
    required this.factionId,
    required this.factionName,
    required this.until,
  });

  factory FactionPact.fromJson(Map<String, dynamic> json) => _$FactionPactFromJson(json);

  static const toJsonFactory = _$FactionPactToJson;
  Map<String, dynamic> toJson() => _$FactionPactToJson(this);

  @JsonKey(name: 'faction_id')
  final int factionId;
  @JsonKey(name: 'faction_name')
  final String factionName;
  @JsonKey(name: 'until')
  final String until;
  static const fromJsonFactory = _$FactionPactFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionPact &&
            (identical(other.factionId, factionId) ||
                const DeepCollectionEquality().equals(
                  other.factionId,
                  factionId,
                )) &&
            (identical(other.factionName, factionName) ||
                const DeepCollectionEquality().equals(
                  other.factionName,
                  factionName,
                )) &&
            (identical(other.until, until) || const DeepCollectionEquality().equals(other.until, until)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(factionId) ^
      const DeepCollectionEquality().hash(factionName) ^
      const DeepCollectionEquality().hash(until) ^
      runtimeType.hashCode;
}

extension $FactionPactExtension on FactionPact {
  FactionPact copyWith({int? factionId, String? factionName, String? until}) {
    return FactionPact(
      factionId: factionId ?? this.factionId,
      factionName: factionName ?? this.factionName,
      until: until ?? this.until,
    );
  }

  FactionPact copyWithWrapped({
    Wrapped<int>? factionId,
    Wrapped<String>? factionName,
    Wrapped<String>? until,
  }) {
    return FactionPact(
      factionId: (factionId != null ? factionId.value : this.factionId),
      factionName: (factionName != null ? factionName.value : this.factionName),
      until: (until != null ? until.value : this.until),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionRankedWarParticipant {
  const FactionRankedWarParticipant({
    required this.id,
    required this.name,
    required this.score,
    required this.chain,
  });

  factory FactionRankedWarParticipant.fromJson(Map<String, dynamic> json) =>
      _$FactionRankedWarParticipantFromJson(json);

  static const toJsonFactory = _$FactionRankedWarParticipantToJson;
  Map<String, dynamic> toJson() => _$FactionRankedWarParticipantToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'score')
  final int score;
  @JsonKey(name: 'chain')
  final int chain;
  static const fromJsonFactory = _$FactionRankedWarParticipantFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionRankedWarParticipant &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.score, score) || const DeepCollectionEquality().equals(other.score, score)) &&
            (identical(other.chain, chain) || const DeepCollectionEquality().equals(other.chain, chain)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(score) ^
      const DeepCollectionEquality().hash(chain) ^
      runtimeType.hashCode;
}

extension $FactionRankedWarParticipantExtension on FactionRankedWarParticipant {
  FactionRankedWarParticipant copyWith({
    int? id,
    String? name,
    int? score,
    int? chain,
  }) {
    return FactionRankedWarParticipant(
      id: id ?? this.id,
      name: name ?? this.name,
      score: score ?? this.score,
      chain: chain ?? this.chain,
    );
  }

  FactionRankedWarParticipant copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<String>? name,
    Wrapped<int>? score,
    Wrapped<int>? chain,
  }) {
    return FactionRankedWarParticipant(
      id: (id != null ? id.value : this.id),
      name: (name != null ? name.value : this.name),
      score: (score != null ? score.value : this.score),
      chain: (chain != null ? chain.value : this.chain),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionRankedWar {
  const FactionRankedWar({
    required this.warId,
    required this.start,
    required this.end,
    required this.target,
    required this.winner,
    required this.factions,
  });

  factory FactionRankedWar.fromJson(Map<String, dynamic> json) => _$FactionRankedWarFromJson(json);

  static const toJsonFactory = _$FactionRankedWarToJson;
  Map<String, dynamic> toJson() => _$FactionRankedWarToJson(this);

  @JsonKey(name: 'war_id')
  final int warId;
  @JsonKey(name: 'start')
  final int start;
  @JsonKey(name: 'end')
  final dynamic end;
  @JsonKey(name: 'target')
  final int target;
  @JsonKey(name: 'winner')
  final dynamic winner;
  @JsonKey(name: 'factions', defaultValue: <FactionRankedWarParticipant>[])
  final List<FactionRankedWarParticipant> factions;
  static const fromJsonFactory = _$FactionRankedWarFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionRankedWar &&
            (identical(other.warId, warId) || const DeepCollectionEquality().equals(other.warId, warId)) &&
            (identical(other.start, start) || const DeepCollectionEquality().equals(other.start, start)) &&
            (identical(other.end, end) || const DeepCollectionEquality().equals(other.end, end)) &&
            (identical(other.target, target) || const DeepCollectionEquality().equals(other.target, target)) &&
            (identical(other.winner, winner) || const DeepCollectionEquality().equals(other.winner, winner)) &&
            (identical(other.factions, factions) ||
                const DeepCollectionEquality().equals(
                  other.factions,
                  factions,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(warId) ^
      const DeepCollectionEquality().hash(start) ^
      const DeepCollectionEquality().hash(end) ^
      const DeepCollectionEquality().hash(target) ^
      const DeepCollectionEquality().hash(winner) ^
      const DeepCollectionEquality().hash(factions) ^
      runtimeType.hashCode;
}

extension $FactionRankedWarExtension on FactionRankedWar {
  FactionRankedWar copyWith({
    int? warId,
    int? start,
    dynamic end,
    int? target,
    dynamic winner,
    List<FactionRankedWarParticipant>? factions,
  }) {
    return FactionRankedWar(
      warId: warId ?? this.warId,
      start: start ?? this.start,
      end: end ?? this.end,
      target: target ?? this.target,
      winner: winner ?? this.winner,
      factions: factions ?? this.factions,
    );
  }

  FactionRankedWar copyWithWrapped({
    Wrapped<int>? warId,
    Wrapped<int>? start,
    Wrapped<dynamic>? end,
    Wrapped<int>? target,
    Wrapped<dynamic>? winner,
    Wrapped<List<FactionRankedWarParticipant>>? factions,
  }) {
    return FactionRankedWar(
      warId: (warId != null ? warId.value : this.warId),
      start: (start != null ? start.value : this.start),
      end: (end != null ? end.value : this.end),
      target: (target != null ? target.value : this.target),
      winner: (winner != null ? winner.value : this.winner),
      factions: (factions != null ? factions.value : this.factions),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionRaidWarParticipant {
  const FactionRaidWarParticipant({
    required this.id,
    required this.name,
    required this.score,
    required this.chain,
    required this.isAggressor,
  });

  factory FactionRaidWarParticipant.fromJson(Map<String, dynamic> json) => _$FactionRaidWarParticipantFromJson(json);

  static const toJsonFactory = _$FactionRaidWarParticipantToJson;
  Map<String, dynamic> toJson() => _$FactionRaidWarParticipantToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'score')
  final int score;
  @JsonKey(name: 'chain')
  final int chain;
  @JsonKey(name: 'is_aggressor')
  final bool isAggressor;
  static const fromJsonFactory = _$FactionRaidWarParticipantFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionRaidWarParticipant &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.score, score) || const DeepCollectionEquality().equals(other.score, score)) &&
            (identical(other.chain, chain) || const DeepCollectionEquality().equals(other.chain, chain)) &&
            (identical(other.isAggressor, isAggressor) ||
                const DeepCollectionEquality().equals(
                  other.isAggressor,
                  isAggressor,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(score) ^
      const DeepCollectionEquality().hash(chain) ^
      const DeepCollectionEquality().hash(isAggressor) ^
      runtimeType.hashCode;
}

extension $FactionRaidWarParticipantExtension on FactionRaidWarParticipant {
  FactionRaidWarParticipant copyWith({
    int? id,
    String? name,
    int? score,
    int? chain,
    bool? isAggressor,
  }) {
    return FactionRaidWarParticipant(
      id: id ?? this.id,
      name: name ?? this.name,
      score: score ?? this.score,
      chain: chain ?? this.chain,
      isAggressor: isAggressor ?? this.isAggressor,
    );
  }

  FactionRaidWarParticipant copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<String>? name,
    Wrapped<int>? score,
    Wrapped<int>? chain,
    Wrapped<bool>? isAggressor,
  }) {
    return FactionRaidWarParticipant(
      id: (id != null ? id.value : this.id),
      name: (name != null ? name.value : this.name),
      score: (score != null ? score.value : this.score),
      chain: (chain != null ? chain.value : this.chain),
      isAggressor: (isAggressor != null ? isAggressor.value : this.isAggressor),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionRaidWar {
  const FactionRaidWar({
    required this.warId,
    required this.start,
    required this.end,
    required this.factions,
  });

  factory FactionRaidWar.fromJson(Map<String, dynamic> json) => _$FactionRaidWarFromJson(json);

  static const toJsonFactory = _$FactionRaidWarToJson;
  Map<String, dynamic> toJson() => _$FactionRaidWarToJson(this);

  @JsonKey(name: 'war_id')
  final int warId;
  @JsonKey(name: 'start')
  final int start;
  @JsonKey(name: 'end')
  final dynamic end;
  @JsonKey(name: 'factions', defaultValue: <FactionRaidWarParticipant>[])
  final List<FactionRaidWarParticipant> factions;
  static const fromJsonFactory = _$FactionRaidWarFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionRaidWar &&
            (identical(other.warId, warId) || const DeepCollectionEquality().equals(other.warId, warId)) &&
            (identical(other.start, start) || const DeepCollectionEquality().equals(other.start, start)) &&
            (identical(other.end, end) || const DeepCollectionEquality().equals(other.end, end)) &&
            (identical(other.factions, factions) ||
                const DeepCollectionEquality().equals(
                  other.factions,
                  factions,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(warId) ^
      const DeepCollectionEquality().hash(start) ^
      const DeepCollectionEquality().hash(end) ^
      const DeepCollectionEquality().hash(factions) ^
      runtimeType.hashCode;
}

extension $FactionRaidWarExtension on FactionRaidWar {
  FactionRaidWar copyWith({
    int? warId,
    int? start,
    dynamic end,
    List<FactionRaidWarParticipant>? factions,
  }) {
    return FactionRaidWar(
      warId: warId ?? this.warId,
      start: start ?? this.start,
      end: end ?? this.end,
      factions: factions ?? this.factions,
    );
  }

  FactionRaidWar copyWithWrapped({
    Wrapped<int>? warId,
    Wrapped<int>? start,
    Wrapped<dynamic>? end,
    Wrapped<List<FactionRaidWarParticipant>>? factions,
  }) {
    return FactionRaidWar(
      warId: (warId != null ? warId.value : this.warId),
      start: (start != null ? start.value : this.start),
      end: (end != null ? end.value : this.end),
      factions: (factions != null ? factions.value : this.factions),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionTerritoryWarParticipant {
  const FactionTerritoryWarParticipant({
    required this.id,
    required this.name,
    required this.score,
    required this.chain,
    required this.isAggressor,
    required this.playerIds,
  });

  factory FactionTerritoryWarParticipant.fromJson(Map<String, dynamic> json) =>
      _$FactionTerritoryWarParticipantFromJson(json);

  static const toJsonFactory = _$FactionTerritoryWarParticipantToJson;
  Map<String, dynamic> toJson() => _$FactionTerritoryWarParticipantToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'score')
  final int score;
  @JsonKey(name: 'chain')
  final int chain;
  @JsonKey(name: 'is_aggressor')
  final bool isAggressor;
  @JsonKey(name: 'playerIds', defaultValue: <int>[])
  final List<int> playerIds;
  static const fromJsonFactory = _$FactionTerritoryWarParticipantFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionTerritoryWarParticipant &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.score, score) || const DeepCollectionEquality().equals(other.score, score)) &&
            (identical(other.chain, chain) || const DeepCollectionEquality().equals(other.chain, chain)) &&
            (identical(other.isAggressor, isAggressor) ||
                const DeepCollectionEquality().equals(
                  other.isAggressor,
                  isAggressor,
                )) &&
            (identical(other.playerIds, playerIds) ||
                const DeepCollectionEquality().equals(
                  other.playerIds,
                  playerIds,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(score) ^
      const DeepCollectionEquality().hash(chain) ^
      const DeepCollectionEquality().hash(isAggressor) ^
      const DeepCollectionEquality().hash(playerIds) ^
      runtimeType.hashCode;
}

extension $FactionTerritoryWarParticipantExtension on FactionTerritoryWarParticipant {
  FactionTerritoryWarParticipant copyWith({
    int? id,
    String? name,
    int? score,
    int? chain,
    bool? isAggressor,
    List<int>? playerIds,
  }) {
    return FactionTerritoryWarParticipant(
      id: id ?? this.id,
      name: name ?? this.name,
      score: score ?? this.score,
      chain: chain ?? this.chain,
      isAggressor: isAggressor ?? this.isAggressor,
      playerIds: playerIds ?? this.playerIds,
    );
  }

  FactionTerritoryWarParticipant copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<String>? name,
    Wrapped<int>? score,
    Wrapped<int>? chain,
    Wrapped<bool>? isAggressor,
    Wrapped<List<int>>? playerIds,
  }) {
    return FactionTerritoryWarParticipant(
      id: (id != null ? id.value : this.id),
      name: (name != null ? name.value : this.name),
      score: (score != null ? score.value : this.score),
      chain: (chain != null ? chain.value : this.chain),
      isAggressor: (isAggressor != null ? isAggressor.value : this.isAggressor),
      playerIds: (playerIds != null ? playerIds.value : this.playerIds),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionTerritoryWar {
  const FactionTerritoryWar({
    required this.warId,
    required this.territory,
    required this.start,
    required this.end,
    required this.target,
    this.winner,
    required this.factions,
  });

  factory FactionTerritoryWar.fromJson(Map<String, dynamic> json) => _$FactionTerritoryWarFromJson(json);

  static const toJsonFactory = _$FactionTerritoryWarToJson;
  Map<String, dynamic> toJson() => _$FactionTerritoryWarToJson(this);

  @JsonKey(name: 'war_id')
  final int warId;
  @JsonKey(name: 'territory')
  final String territory;
  @JsonKey(name: 'start')
  final int start;
  @JsonKey(name: 'end')
  final dynamic end;
  @JsonKey(name: 'target')
  final int target;
  @JsonKey(name: 'winner')
  final dynamic winner;
  @JsonKey(name: 'factions', defaultValue: <FactionTerritoryWarParticipant>[])
  final List<FactionTerritoryWarParticipant> factions;
  static const fromJsonFactory = _$FactionTerritoryWarFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionTerritoryWar &&
            (identical(other.warId, warId) || const DeepCollectionEquality().equals(other.warId, warId)) &&
            (identical(other.territory, territory) ||
                const DeepCollectionEquality().equals(
                  other.territory,
                  territory,
                )) &&
            (identical(other.start, start) || const DeepCollectionEquality().equals(other.start, start)) &&
            (identical(other.end, end) || const DeepCollectionEquality().equals(other.end, end)) &&
            (identical(other.target, target) || const DeepCollectionEquality().equals(other.target, target)) &&
            (identical(other.winner, winner) || const DeepCollectionEquality().equals(other.winner, winner)) &&
            (identical(other.factions, factions) ||
                const DeepCollectionEquality().equals(
                  other.factions,
                  factions,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(warId) ^
      const DeepCollectionEquality().hash(territory) ^
      const DeepCollectionEquality().hash(start) ^
      const DeepCollectionEquality().hash(end) ^
      const DeepCollectionEquality().hash(target) ^
      const DeepCollectionEquality().hash(winner) ^
      const DeepCollectionEquality().hash(factions) ^
      runtimeType.hashCode;
}

extension $FactionTerritoryWarExtension on FactionTerritoryWar {
  FactionTerritoryWar copyWith({
    int? warId,
    String? territory,
    int? start,
    dynamic end,
    int? target,
    dynamic winner,
    List<FactionTerritoryWarParticipant>? factions,
  }) {
    return FactionTerritoryWar(
      warId: warId ?? this.warId,
      territory: territory ?? this.territory,
      start: start ?? this.start,
      end: end ?? this.end,
      target: target ?? this.target,
      winner: winner ?? this.winner,
      factions: factions ?? this.factions,
    );
  }

  FactionTerritoryWar copyWithWrapped({
    Wrapped<int>? warId,
    Wrapped<String>? territory,
    Wrapped<int>? start,
    Wrapped<dynamic>? end,
    Wrapped<int>? target,
    Wrapped<dynamic>? winner,
    Wrapped<List<FactionTerritoryWarParticipant>>? factions,
  }) {
    return FactionTerritoryWar(
      warId: (warId != null ? warId.value : this.warId),
      territory: (territory != null ? territory.value : this.territory),
      start: (start != null ? start.value : this.start),
      end: (end != null ? end.value : this.end),
      target: (target != null ? target.value : this.target),
      winner: (winner != null ? winner.value : this.winner),
      factions: (factions != null ? factions.value : this.factions),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionWars {
  const FactionWars({
    required this.ranked,
    required this.raids,
    required this.territory,
  });

  factory FactionWars.fromJson(Map<String, dynamic> json) => _$FactionWarsFromJson(json);

  static const toJsonFactory = _$FactionWarsToJson;
  Map<String, dynamic> toJson() => _$FactionWarsToJson(this);

  @JsonKey(name: 'ranked')
  final dynamic ranked;
  @JsonKey(name: 'raids', defaultValue: <FactionRaidWar>[])
  final List<FactionRaidWar> raids;
  @JsonKey(name: 'territory', defaultValue: <FactionTerritoryWar>[])
  final List<FactionTerritoryWar> territory;
  static const fromJsonFactory = _$FactionWarsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionWars &&
            (identical(other.ranked, ranked) || const DeepCollectionEquality().equals(other.ranked, ranked)) &&
            (identical(other.raids, raids) || const DeepCollectionEquality().equals(other.raids, raids)) &&
            (identical(other.territory, territory) ||
                const DeepCollectionEquality().equals(
                  other.territory,
                  territory,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ranked) ^
      const DeepCollectionEquality().hash(raids) ^
      const DeepCollectionEquality().hash(territory) ^
      runtimeType.hashCode;
}

extension $FactionWarsExtension on FactionWars {
  FactionWars copyWith({
    dynamic ranked,
    List<FactionRaidWar>? raids,
    List<FactionTerritoryWar>? territory,
  }) {
    return FactionWars(
      ranked: ranked ?? this.ranked,
      raids: raids ?? this.raids,
      territory: territory ?? this.territory,
    );
  }

  FactionWars copyWithWrapped({
    Wrapped<dynamic>? ranked,
    Wrapped<List<FactionRaidWar>>? raids,
    Wrapped<List<FactionTerritoryWar>>? territory,
  }) {
    return FactionWars(
      ranked: (ranked != null ? ranked.value : this.ranked),
      raids: (raids != null ? raids.value : this.raids),
      territory: (territory != null ? territory.value : this.territory),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionWarsResponse {
  const FactionWarsResponse({required this.pacts, required this.wars});

  factory FactionWarsResponse.fromJson(Map<String, dynamic> json) => _$FactionWarsResponseFromJson(json);

  static const toJsonFactory = _$FactionWarsResponseToJson;
  Map<String, dynamic> toJson() => _$FactionWarsResponseToJson(this);

  @JsonKey(name: 'pacts', defaultValue: <FactionPact>[])
  final List<FactionPact> pacts;
  @JsonKey(name: 'wars')
  final FactionWars wars;
  static const fromJsonFactory = _$FactionWarsResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionWarsResponse &&
            (identical(other.pacts, pacts) || const DeepCollectionEquality().equals(other.pacts, pacts)) &&
            (identical(other.wars, wars) || const DeepCollectionEquality().equals(other.wars, wars)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(pacts) ^ const DeepCollectionEquality().hash(wars) ^ runtimeType.hashCode;
}

extension $FactionWarsResponseExtension on FactionWarsResponse {
  FactionWarsResponse copyWith({List<FactionPact>? pacts, FactionWars? wars}) {
    return FactionWarsResponse(
      pacts: pacts ?? this.pacts,
      wars: wars ?? this.wars,
    );
  }

  FactionWarsResponse copyWithWrapped({
    Wrapped<List<FactionPact>>? pacts,
    Wrapped<FactionWars>? wars,
  }) {
    return FactionWarsResponse(
      pacts: (pacts != null ? pacts.value : this.pacts),
      wars: (wars != null ? wars.value : this.wars),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionNews {
  const FactionNews({
    required this.id,
    required this.text,
    required this.timestamp,
  });

  factory FactionNews.fromJson(Map<String, dynamic> json) => _$FactionNewsFromJson(json);

  static const toJsonFactory = _$FactionNewsToJson;
  Map<String, dynamic> toJson() => _$FactionNewsToJson(this);

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'text')
  final String text;
  @JsonKey(name: 'timestamp')
  final int timestamp;
  static const fromJsonFactory = _$FactionNewsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionNews &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.text, text) || const DeepCollectionEquality().equals(other.text, text)) &&
            (identical(other.timestamp, timestamp) ||
                const DeepCollectionEquality().equals(
                  other.timestamp,
                  timestamp,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(text) ^
      const DeepCollectionEquality().hash(timestamp) ^
      runtimeType.hashCode;
}

extension $FactionNewsExtension on FactionNews {
  FactionNews copyWith({String? id, String? text, int? timestamp}) {
    return FactionNews(
      id: id ?? this.id,
      text: text ?? this.text,
      timestamp: timestamp ?? this.timestamp,
    );
  }

  FactionNews copyWithWrapped({
    Wrapped<String>? id,
    Wrapped<String>? text,
    Wrapped<int>? timestamp,
  }) {
    return FactionNews(
      id: (id != null ? id.value : this.id),
      text: (text != null ? text.value : this.text),
      timestamp: (timestamp != null ? timestamp.value : this.timestamp),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionNewsResponse {
  const FactionNewsResponse({required this.news, required this.metadata});

  factory FactionNewsResponse.fromJson(Map<String, dynamic> json) => _$FactionNewsResponseFromJson(json);

  static const toJsonFactory = _$FactionNewsResponseToJson;
  Map<String, dynamic> toJson() => _$FactionNewsResponseToJson(this);

  @JsonKey(name: 'news', defaultValue: <FactionNews>[])
  final List<FactionNews> news;
  @JsonKey(name: '_metadata')
  final RequestMetadataWithLinks metadata;
  static const fromJsonFactory = _$FactionNewsResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionNewsResponse &&
            (identical(other.news, news) || const DeepCollectionEquality().equals(other.news, news)) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality().equals(
                  other.metadata,
                  metadata,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(news) ^ const DeepCollectionEquality().hash(metadata) ^ runtimeType.hashCode;
}

extension $FactionNewsResponseExtension on FactionNewsResponse {
  FactionNewsResponse copyWith({
    List<FactionNews>? news,
    RequestMetadataWithLinks? metadata,
  }) {
    return FactionNewsResponse(
      news: news ?? this.news,
      metadata: metadata ?? this.metadata,
    );
  }

  FactionNewsResponse copyWithWrapped({
    Wrapped<List<FactionNews>>? news,
    Wrapped<RequestMetadataWithLinks>? metadata,
  }) {
    return FactionNewsResponse(
      news: (news != null ? news.value : this.news),
      metadata: (metadata != null ? metadata.value : this.metadata),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionRaidsResponse {
  const FactionRaidsResponse({required this.raids, required this.metadata});

  factory FactionRaidsResponse.fromJson(Map<String, dynamic> json) => _$FactionRaidsResponseFromJson(json);

  static const toJsonFactory = _$FactionRaidsResponseToJson;
  Map<String, dynamic> toJson() => _$FactionRaidsResponseToJson(this);

  @JsonKey(name: 'raids', defaultValue: <FactionRaidWarfare>[])
  final List<FactionRaidWarfare> raids;
  @JsonKey(name: '_metadata')
  final RequestMetadataWithLinks metadata;
  static const fromJsonFactory = _$FactionRaidsResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionRaidsResponse &&
            (identical(other.raids, raids) || const DeepCollectionEquality().equals(other.raids, raids)) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality().equals(
                  other.metadata,
                  metadata,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(raids) ^ const DeepCollectionEquality().hash(metadata) ^ runtimeType.hashCode;
}

extension $FactionRaidsResponseExtension on FactionRaidsResponse {
  FactionRaidsResponse copyWith({
    List<FactionRaidWarfare>? raids,
    RequestMetadataWithLinks? metadata,
  }) {
    return FactionRaidsResponse(
      raids: raids ?? this.raids,
      metadata: metadata ?? this.metadata,
    );
  }

  FactionRaidsResponse copyWithWrapped({
    Wrapped<List<FactionRaidWarfare>>? raids,
    Wrapped<RequestMetadataWithLinks>? metadata,
  }) {
    return FactionRaidsResponse(
      raids: (raids != null ? raids.value : this.raids),
      metadata: (metadata != null ? metadata.value : this.metadata),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionAttacksResponse {
  const FactionAttacksResponse({required this.attacks, required this.metadata});

  factory FactionAttacksResponse.fromJson(Map<String, dynamic> json) => _$FactionAttacksResponseFromJson(json);

  static const toJsonFactory = _$FactionAttacksResponseToJson;
  Map<String, dynamic> toJson() => _$FactionAttacksResponseToJson(this);

  @JsonKey(name: 'attacks', defaultValue: <Attack>[])
  final List<Attack> attacks;
  @JsonKey(name: '_metadata')
  final RequestMetadataWithLinks metadata;
  static const fromJsonFactory = _$FactionAttacksResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionAttacksResponse &&
            (identical(other.attacks, attacks) ||
                const DeepCollectionEquality().equals(
                  other.attacks,
                  attacks,
                )) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality().equals(
                  other.metadata,
                  metadata,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(attacks) ^
      const DeepCollectionEquality().hash(metadata) ^
      runtimeType.hashCode;
}

extension $FactionAttacksResponseExtension on FactionAttacksResponse {
  FactionAttacksResponse copyWith({
    List<Attack>? attacks,
    RequestMetadataWithLinks? metadata,
  }) {
    return FactionAttacksResponse(
      attacks: attacks ?? this.attacks,
      metadata: metadata ?? this.metadata,
    );
  }

  FactionAttacksResponse copyWithWrapped({
    Wrapped<List<Attack>>? attacks,
    Wrapped<RequestMetadataWithLinks>? metadata,
  }) {
    return FactionAttacksResponse(
      attacks: (attacks != null ? attacks.value : this.attacks),
      metadata: (metadata != null ? metadata.value : this.metadata),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionAttacksFullResponse {
  const FactionAttacksFullResponse({
    required this.attacks,
    required this.metadata,
  });

  factory FactionAttacksFullResponse.fromJson(Map<String, dynamic> json) => _$FactionAttacksFullResponseFromJson(json);

  static const toJsonFactory = _$FactionAttacksFullResponseToJson;
  Map<String, dynamic> toJson() => _$FactionAttacksFullResponseToJson(this);

  @JsonKey(name: 'attacks', defaultValue: <AttackSimplified>[])
  final List<AttackSimplified> attacks;
  @JsonKey(name: '_metadata')
  final RequestMetadataWithLinks metadata;
  static const fromJsonFactory = _$FactionAttacksFullResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionAttacksFullResponse &&
            (identical(other.attacks, attacks) ||
                const DeepCollectionEquality().equals(
                  other.attacks,
                  attacks,
                )) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality().equals(
                  other.metadata,
                  metadata,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(attacks) ^
      const DeepCollectionEquality().hash(metadata) ^
      runtimeType.hashCode;
}

extension $FactionAttacksFullResponseExtension on FactionAttacksFullResponse {
  FactionAttacksFullResponse copyWith({
    List<AttackSimplified>? attacks,
    RequestMetadataWithLinks? metadata,
  }) {
    return FactionAttacksFullResponse(
      attacks: attacks ?? this.attacks,
      metadata: metadata ?? this.metadata,
    );
  }

  FactionAttacksFullResponse copyWithWrapped({
    Wrapped<List<AttackSimplified>>? attacks,
    Wrapped<RequestMetadataWithLinks>? metadata,
  }) {
    return FactionAttacksFullResponse(
      attacks: (attacks != null ? attacks.value : this.attacks),
      metadata: (metadata != null ? metadata.value : this.metadata),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionApplication {
  const FactionApplication({
    required this.id,
    required this.user,
    required this.message,
    required this.validUntil,
    required this.status,
  });

  factory FactionApplication.fromJson(Map<String, dynamic> json) => _$FactionApplicationFromJson(json);

  static const toJsonFactory = _$FactionApplicationToJson;
  Map<String, dynamic> toJson() => _$FactionApplicationToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'user')
  final FactionApplication$User user;
  @JsonKey(name: 'message')
  final dynamic message;
  @JsonKey(name: 'valid_until')
  final int validUntil;
  @JsonKey(
    name: 'status',
    toJson: factionApplicationStatusEnumToJson,
    fromJson: factionApplicationStatusEnumFromJson,
  )
  final enums.FactionApplicationStatusEnum status;
  static const fromJsonFactory = _$FactionApplicationFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionApplication &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.user, user) || const DeepCollectionEquality().equals(other.user, user)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality().equals(
                  other.message,
                  message,
                )) &&
            (identical(other.validUntil, validUntil) ||
                const DeepCollectionEquality().equals(
                  other.validUntil,
                  validUntil,
                )) &&
            (identical(other.status, status) || const DeepCollectionEquality().equals(other.status, status)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(user) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(validUntil) ^
      const DeepCollectionEquality().hash(status) ^
      runtimeType.hashCode;
}

extension $FactionApplicationExtension on FactionApplication {
  FactionApplication copyWith({
    int? id,
    FactionApplication$User? user,
    dynamic message,
    int? validUntil,
    enums.FactionApplicationStatusEnum? status,
  }) {
    return FactionApplication(
      id: id ?? this.id,
      user: user ?? this.user,
      message: message ?? this.message,
      validUntil: validUntil ?? this.validUntil,
      status: status ?? this.status,
    );
  }

  FactionApplication copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<FactionApplication$User>? user,
    Wrapped<dynamic>? message,
    Wrapped<int>? validUntil,
    Wrapped<enums.FactionApplicationStatusEnum>? status,
  }) {
    return FactionApplication(
      id: (id != null ? id.value : this.id),
      user: (user != null ? user.value : this.user),
      message: (message != null ? message.value : this.message),
      validUntil: (validUntil != null ? validUntil.value : this.validUntil),
      status: (status != null ? status.value : this.status),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionApplicationsResponse {
  const FactionApplicationsResponse({required this.applications});

  factory FactionApplicationsResponse.fromJson(Map<String, dynamic> json) =>
      _$FactionApplicationsResponseFromJson(json);

  static const toJsonFactory = _$FactionApplicationsResponseToJson;
  Map<String, dynamic> toJson() => _$FactionApplicationsResponseToJson(this);

  @JsonKey(name: 'applications', defaultValue: <FactionApplication>[])
  final List<FactionApplication> applications;
  static const fromJsonFactory = _$FactionApplicationsResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionApplicationsResponse &&
            (identical(other.applications, applications) ||
                const DeepCollectionEquality().equals(
                  other.applications,
                  applications,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(applications) ^ runtimeType.hashCode;
}

extension $FactionApplicationsResponseExtension on FactionApplicationsResponse {
  FactionApplicationsResponse copyWith({
    List<FactionApplication>? applications,
  }) {
    return FactionApplicationsResponse(
      applications: applications ?? this.applications,
    );
  }

  FactionApplicationsResponse copyWithWrapped({
    Wrapped<List<FactionApplication>>? applications,
  }) {
    return FactionApplicationsResponse(
      applications: (applications != null ? applications.value : this.applications),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionOngoingChain {
  const FactionOngoingChain({
    required this.id,
    required this.current,
    required this.max,
    required this.timeout,
    required this.modifier,
    required this.cooldown,
    required this.start,
    required this.end,
  });

  factory FactionOngoingChain.fromJson(Map<String, dynamic> json) => _$FactionOngoingChainFromJson(json);

  static const toJsonFactory = _$FactionOngoingChainToJson;
  Map<String, dynamic> toJson() => _$FactionOngoingChainToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'current')
  final int current;
  @JsonKey(name: 'max')
  final int max;
  @JsonKey(name: 'timeout')
  final int timeout;
  @JsonKey(name: 'modifier')
  final double modifier;
  @JsonKey(name: 'cooldown')
  final int cooldown;
  @JsonKey(name: 'start')
  final int start;
  @JsonKey(name: 'end')
  final int end;
  static const fromJsonFactory = _$FactionOngoingChainFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionOngoingChain &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.current, current) ||
                const DeepCollectionEquality().equals(
                  other.current,
                  current,
                )) &&
            (identical(other.max, max) || const DeepCollectionEquality().equals(other.max, max)) &&
            (identical(other.timeout, timeout) ||
                const DeepCollectionEquality().equals(
                  other.timeout,
                  timeout,
                )) &&
            (identical(other.modifier, modifier) ||
                const DeepCollectionEquality().equals(
                  other.modifier,
                  modifier,
                )) &&
            (identical(other.cooldown, cooldown) ||
                const DeepCollectionEquality().equals(
                  other.cooldown,
                  cooldown,
                )) &&
            (identical(other.start, start) || const DeepCollectionEquality().equals(other.start, start)) &&
            (identical(other.end, end) || const DeepCollectionEquality().equals(other.end, end)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(current) ^
      const DeepCollectionEquality().hash(max) ^
      const DeepCollectionEquality().hash(timeout) ^
      const DeepCollectionEquality().hash(modifier) ^
      const DeepCollectionEquality().hash(cooldown) ^
      const DeepCollectionEquality().hash(start) ^
      const DeepCollectionEquality().hash(end) ^
      runtimeType.hashCode;
}

extension $FactionOngoingChainExtension on FactionOngoingChain {
  FactionOngoingChain copyWith({
    int? id,
    int? current,
    int? max,
    int? timeout,
    double? modifier,
    int? cooldown,
    int? start,
    int? end,
  }) {
    return FactionOngoingChain(
      id: id ?? this.id,
      current: current ?? this.current,
      max: max ?? this.max,
      timeout: timeout ?? this.timeout,
      modifier: modifier ?? this.modifier,
      cooldown: cooldown ?? this.cooldown,
      start: start ?? this.start,
      end: end ?? this.end,
    );
  }

  FactionOngoingChain copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<int>? current,
    Wrapped<int>? max,
    Wrapped<int>? timeout,
    Wrapped<double>? modifier,
    Wrapped<int>? cooldown,
    Wrapped<int>? start,
    Wrapped<int>? end,
  }) {
    return FactionOngoingChain(
      id: (id != null ? id.value : this.id),
      current: (current != null ? current.value : this.current),
      max: (max != null ? max.value : this.max),
      timeout: (timeout != null ? timeout.value : this.timeout),
      modifier: (modifier != null ? modifier.value : this.modifier),
      cooldown: (cooldown != null ? cooldown.value : this.cooldown),
      start: (start != null ? start.value : this.start),
      end: (end != null ? end.value : this.end),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionOngoingChainResponse {
  const FactionOngoingChainResponse({required this.chain});

  factory FactionOngoingChainResponse.fromJson(Map<String, dynamic> json) =>
      _$FactionOngoingChainResponseFromJson(json);

  static const toJsonFactory = _$FactionOngoingChainResponseToJson;
  Map<String, dynamic> toJson() => _$FactionOngoingChainResponseToJson(this);

  @JsonKey(name: 'chain')
  final FactionOngoingChain chain;
  static const fromJsonFactory = _$FactionOngoingChainResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionOngoingChainResponse &&
            (identical(other.chain, chain) || const DeepCollectionEquality().equals(other.chain, chain)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(chain) ^ runtimeType.hashCode;
}

extension $FactionOngoingChainResponseExtension on FactionOngoingChainResponse {
  FactionOngoingChainResponse copyWith({FactionOngoingChain? chain}) {
    return FactionOngoingChainResponse(chain: chain ?? this.chain);
  }

  FactionOngoingChainResponse copyWithWrapped({
    Wrapped<FactionOngoingChain>? chain,
  }) {
    return FactionOngoingChainResponse(
      chain: (chain != null ? chain.value : this.chain),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionChain {
  const FactionChain({
    required this.id,
    required this.chain,
    required this.respect,
    required this.start,
    required this.end,
  });

  factory FactionChain.fromJson(Map<String, dynamic> json) => _$FactionChainFromJson(json);

  static const toJsonFactory = _$FactionChainToJson;
  Map<String, dynamic> toJson() => _$FactionChainToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'chain')
  final int chain;
  @JsonKey(name: 'respect')
  final double respect;
  @JsonKey(name: 'start')
  final int start;
  @JsonKey(name: 'end')
  final int end;
  static const fromJsonFactory = _$FactionChainFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionChain &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.chain, chain) || const DeepCollectionEquality().equals(other.chain, chain)) &&
            (identical(other.respect, respect) ||
                const DeepCollectionEquality().equals(
                  other.respect,
                  respect,
                )) &&
            (identical(other.start, start) || const DeepCollectionEquality().equals(other.start, start)) &&
            (identical(other.end, end) || const DeepCollectionEquality().equals(other.end, end)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(chain) ^
      const DeepCollectionEquality().hash(respect) ^
      const DeepCollectionEquality().hash(start) ^
      const DeepCollectionEquality().hash(end) ^
      runtimeType.hashCode;
}

extension $FactionChainExtension on FactionChain {
  FactionChain copyWith({
    int? id,
    int? chain,
    double? respect,
    int? start,
    int? end,
  }) {
    return FactionChain(
      id: id ?? this.id,
      chain: chain ?? this.chain,
      respect: respect ?? this.respect,
      start: start ?? this.start,
      end: end ?? this.end,
    );
  }

  FactionChain copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<int>? chain,
    Wrapped<double>? respect,
    Wrapped<int>? start,
    Wrapped<int>? end,
  }) {
    return FactionChain(
      id: (id != null ? id.value : this.id),
      chain: (chain != null ? chain.value : this.chain),
      respect: (respect != null ? respect.value : this.respect),
      start: (start != null ? start.value : this.start),
      end: (end != null ? end.value : this.end),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionChainWarfare {
  const FactionChainWarfare({
    required this.faction,
    required this.id,
    required this.chain,
    required this.respect,
    required this.start,
    required this.end,
  });

  factory FactionChainWarfare.fromJson(Map<String, dynamic> json) => _$FactionChainWarfareFromJson(json);

  static const toJsonFactory = _$FactionChainWarfareToJson;
  Map<String, dynamic> toJson() => _$FactionChainWarfareToJson(this);

  @JsonKey(name: 'faction')
  final FactionChainWarfare$Faction faction;
  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'chain')
  final int chain;
  @JsonKey(name: 'respect')
  final double respect;
  @JsonKey(name: 'start')
  final int start;
  @JsonKey(name: 'end')
  final int end;
  static const fromJsonFactory = _$FactionChainWarfareFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionChainWarfare &&
            (identical(other.faction, faction) ||
                const DeepCollectionEquality().equals(
                  other.faction,
                  faction,
                )) &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.chain, chain) || const DeepCollectionEquality().equals(other.chain, chain)) &&
            (identical(other.respect, respect) ||
                const DeepCollectionEquality().equals(
                  other.respect,
                  respect,
                )) &&
            (identical(other.start, start) || const DeepCollectionEquality().equals(other.start, start)) &&
            (identical(other.end, end) || const DeepCollectionEquality().equals(other.end, end)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(faction) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(chain) ^
      const DeepCollectionEquality().hash(respect) ^
      const DeepCollectionEquality().hash(start) ^
      const DeepCollectionEquality().hash(end) ^
      runtimeType.hashCode;
}

extension $FactionChainWarfareExtension on FactionChainWarfare {
  FactionChainWarfare copyWith({
    FactionChainWarfare$Faction? faction,
    int? id,
    int? chain,
    double? respect,
    int? start,
    int? end,
  }) {
    return FactionChainWarfare(
      faction: faction ?? this.faction,
      id: id ?? this.id,
      chain: chain ?? this.chain,
      respect: respect ?? this.respect,
      start: start ?? this.start,
      end: end ?? this.end,
    );
  }

  FactionChainWarfare copyWithWrapped({
    Wrapped<FactionChainWarfare$Faction>? faction,
    Wrapped<int>? id,
    Wrapped<int>? chain,
    Wrapped<double>? respect,
    Wrapped<int>? start,
    Wrapped<int>? end,
  }) {
    return FactionChainWarfare(
      faction: (faction != null ? faction.value : this.faction),
      id: (id != null ? id.value : this.id),
      chain: (chain != null ? chain.value : this.chain),
      respect: (respect != null ? respect.value : this.respect),
      start: (start != null ? start.value : this.start),
      end: (end != null ? end.value : this.end),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionChainsResponse {
  const FactionChainsResponse({required this.chains, required this.metadata});

  factory FactionChainsResponse.fromJson(Map<String, dynamic> json) => _$FactionChainsResponseFromJson(json);

  static const toJsonFactory = _$FactionChainsResponseToJson;
  Map<String, dynamic> toJson() => _$FactionChainsResponseToJson(this);

  @JsonKey(name: 'chains', defaultValue: <FactionChain>[])
  final List<FactionChain> chains;
  @JsonKey(name: '_metadata')
  final RequestMetadataWithLinks metadata;
  static const fromJsonFactory = _$FactionChainsResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionChainsResponse &&
            (identical(other.chains, chains) || const DeepCollectionEquality().equals(other.chains, chains)) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality().equals(
                  other.metadata,
                  metadata,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(chains) ^
      const DeepCollectionEquality().hash(metadata) ^
      runtimeType.hashCode;
}

extension $FactionChainsResponseExtension on FactionChainsResponse {
  FactionChainsResponse copyWith({
    List<FactionChain>? chains,
    RequestMetadataWithLinks? metadata,
  }) {
    return FactionChainsResponse(
      chains: chains ?? this.chains,
      metadata: metadata ?? this.metadata,
    );
  }

  FactionChainsResponse copyWithWrapped({
    Wrapped<List<FactionChain>>? chains,
    Wrapped<RequestMetadataWithLinks>? metadata,
  }) {
    return FactionChainsResponse(
      chains: (chains != null ? chains.value : this.chains),
      metadata: (metadata != null ? metadata.value : this.metadata),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionChainReportResponse {
  const FactionChainReportResponse({required this.chainreport});

  factory FactionChainReportResponse.fromJson(Map<String, dynamic> json) => _$FactionChainReportResponseFromJson(json);

  static const toJsonFactory = _$FactionChainReportResponseToJson;
  Map<String, dynamic> toJson() => _$FactionChainReportResponseToJson(this);

  @JsonKey(name: 'chainreport')
  final FactionChainReport chainreport;
  static const fromJsonFactory = _$FactionChainReportResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionChainReportResponse &&
            (identical(other.chainreport, chainreport) ||
                const DeepCollectionEquality().equals(
                  other.chainreport,
                  chainreport,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(chainreport) ^ runtimeType.hashCode;
}

extension $FactionChainReportResponseExtension on FactionChainReportResponse {
  FactionChainReportResponse copyWith({FactionChainReport? chainreport}) {
    return FactionChainReportResponse(
      chainreport: chainreport ?? this.chainreport,
    );
  }

  FactionChainReportResponse copyWithWrapped({
    Wrapped<FactionChainReport>? chainreport,
  }) {
    return FactionChainReportResponse(
      chainreport: (chainreport != null ? chainreport.value : this.chainreport),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionChainReport {
  const FactionChainReport({
    required this.id,
    required this.factionId,
    required this.start,
    required this.end,
    required this.details,
    required this.bonuses,
    required this.attackers,
    required this.nonAttackers,
  });

  factory FactionChainReport.fromJson(Map<String, dynamic> json) => _$FactionChainReportFromJson(json);

  static const toJsonFactory = _$FactionChainReportToJson;
  Map<String, dynamic> toJson() => _$FactionChainReportToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'faction_id')
  final int factionId;
  @JsonKey(name: 'start')
  final int start;
  @JsonKey(name: 'end')
  final int end;
  @JsonKey(name: 'details')
  final FactionChainReportDetails details;
  @JsonKey(name: 'bonuses', defaultValue: <FactionChainReportBonus>[])
  final List<FactionChainReportBonus> bonuses;
  @JsonKey(name: 'attackers', defaultValue: <FactionChainReportAttacker>[])
  final List<FactionChainReportAttacker> attackers;
  @JsonKey(name: 'non_attackers', defaultValue: <int>[])
  final List<int> nonAttackers;
  static const fromJsonFactory = _$FactionChainReportFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionChainReport &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.factionId, factionId) ||
                const DeepCollectionEquality().equals(
                  other.factionId,
                  factionId,
                )) &&
            (identical(other.start, start) || const DeepCollectionEquality().equals(other.start, start)) &&
            (identical(other.end, end) || const DeepCollectionEquality().equals(other.end, end)) &&
            (identical(other.details, details) ||
                const DeepCollectionEquality().equals(
                  other.details,
                  details,
                )) &&
            (identical(other.bonuses, bonuses) ||
                const DeepCollectionEquality().equals(
                  other.bonuses,
                  bonuses,
                )) &&
            (identical(other.attackers, attackers) ||
                const DeepCollectionEquality().equals(
                  other.attackers,
                  attackers,
                )) &&
            (identical(other.nonAttackers, nonAttackers) ||
                const DeepCollectionEquality().equals(
                  other.nonAttackers,
                  nonAttackers,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(factionId) ^
      const DeepCollectionEquality().hash(start) ^
      const DeepCollectionEquality().hash(end) ^
      const DeepCollectionEquality().hash(details) ^
      const DeepCollectionEquality().hash(bonuses) ^
      const DeepCollectionEquality().hash(attackers) ^
      const DeepCollectionEquality().hash(nonAttackers) ^
      runtimeType.hashCode;
}

extension $FactionChainReportExtension on FactionChainReport {
  FactionChainReport copyWith({
    int? id,
    int? factionId,
    int? start,
    int? end,
    FactionChainReportDetails? details,
    List<FactionChainReportBonus>? bonuses,
    List<FactionChainReportAttacker>? attackers,
    List<int>? nonAttackers,
  }) {
    return FactionChainReport(
      id: id ?? this.id,
      factionId: factionId ?? this.factionId,
      start: start ?? this.start,
      end: end ?? this.end,
      details: details ?? this.details,
      bonuses: bonuses ?? this.bonuses,
      attackers: attackers ?? this.attackers,
      nonAttackers: nonAttackers ?? this.nonAttackers,
    );
  }

  FactionChainReport copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<int>? factionId,
    Wrapped<int>? start,
    Wrapped<int>? end,
    Wrapped<FactionChainReportDetails>? details,
    Wrapped<List<FactionChainReportBonus>>? bonuses,
    Wrapped<List<FactionChainReportAttacker>>? attackers,
    Wrapped<List<int>>? nonAttackers,
  }) {
    return FactionChainReport(
      id: (id != null ? id.value : this.id),
      factionId: (factionId != null ? factionId.value : this.factionId),
      start: (start != null ? start.value : this.start),
      end: (end != null ? end.value : this.end),
      details: (details != null ? details.value : this.details),
      bonuses: (bonuses != null ? bonuses.value : this.bonuses),
      attackers: (attackers != null ? attackers.value : this.attackers),
      nonAttackers: (nonAttackers != null ? nonAttackers.value : this.nonAttackers),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionChainReportDetails {
  const FactionChainReportDetails({
    required this.chain,
    required this.respect,
    required this.members,
    required this.targets,
    required this.war,
    required this.best,
    required this.leave,
    required this.mug,
    required this.hospitalize,
    required this.assists,
    required this.retaliations,
    required this.overseas,
    required this.draws,
    required this.escapes,
    required this.losses,
  });

  factory FactionChainReportDetails.fromJson(Map<String, dynamic> json) => _$FactionChainReportDetailsFromJson(json);

  static const toJsonFactory = _$FactionChainReportDetailsToJson;
  Map<String, dynamic> toJson() => _$FactionChainReportDetailsToJson(this);

  @JsonKey(name: 'chain')
  final int chain;
  @JsonKey(name: 'respect')
  final double respect;
  @JsonKey(name: 'members')
  final int members;
  @JsonKey(name: 'targets')
  final int targets;
  @JsonKey(name: 'war')
  final int war;
  @JsonKey(name: 'best')
  final double best;
  @JsonKey(name: 'leave')
  final int leave;
  @JsonKey(name: 'mug')
  final int mug;
  @JsonKey(name: 'hospitalize')
  final int hospitalize;
  @JsonKey(name: 'assists')
  final int assists;
  @JsonKey(name: 'retaliations')
  final int retaliations;
  @JsonKey(name: 'overseas')
  final int overseas;
  @JsonKey(name: 'draws')
  final int draws;
  @JsonKey(name: 'escapes')
  final int escapes;
  @JsonKey(name: 'losses')
  final int losses;
  static const fromJsonFactory = _$FactionChainReportDetailsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionChainReportDetails &&
            (identical(other.chain, chain) || const DeepCollectionEquality().equals(other.chain, chain)) &&
            (identical(other.respect, respect) ||
                const DeepCollectionEquality().equals(
                  other.respect,
                  respect,
                )) &&
            (identical(other.members, members) ||
                const DeepCollectionEquality().equals(
                  other.members,
                  members,
                )) &&
            (identical(other.targets, targets) ||
                const DeepCollectionEquality().equals(
                  other.targets,
                  targets,
                )) &&
            (identical(other.war, war) || const DeepCollectionEquality().equals(other.war, war)) &&
            (identical(other.best, best) || const DeepCollectionEquality().equals(other.best, best)) &&
            (identical(other.leave, leave) || const DeepCollectionEquality().equals(other.leave, leave)) &&
            (identical(other.mug, mug) || const DeepCollectionEquality().equals(other.mug, mug)) &&
            (identical(other.hospitalize, hospitalize) ||
                const DeepCollectionEquality().equals(
                  other.hospitalize,
                  hospitalize,
                )) &&
            (identical(other.assists, assists) ||
                const DeepCollectionEquality().equals(
                  other.assists,
                  assists,
                )) &&
            (identical(other.retaliations, retaliations) ||
                const DeepCollectionEquality().equals(
                  other.retaliations,
                  retaliations,
                )) &&
            (identical(other.overseas, overseas) ||
                const DeepCollectionEquality().equals(
                  other.overseas,
                  overseas,
                )) &&
            (identical(other.draws, draws) || const DeepCollectionEquality().equals(other.draws, draws)) &&
            (identical(other.escapes, escapes) ||
                const DeepCollectionEquality().equals(
                  other.escapes,
                  escapes,
                )) &&
            (identical(other.losses, losses) || const DeepCollectionEquality().equals(other.losses, losses)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(chain) ^
      const DeepCollectionEquality().hash(respect) ^
      const DeepCollectionEquality().hash(members) ^
      const DeepCollectionEquality().hash(targets) ^
      const DeepCollectionEquality().hash(war) ^
      const DeepCollectionEquality().hash(best) ^
      const DeepCollectionEquality().hash(leave) ^
      const DeepCollectionEquality().hash(mug) ^
      const DeepCollectionEquality().hash(hospitalize) ^
      const DeepCollectionEquality().hash(assists) ^
      const DeepCollectionEquality().hash(retaliations) ^
      const DeepCollectionEquality().hash(overseas) ^
      const DeepCollectionEquality().hash(draws) ^
      const DeepCollectionEquality().hash(escapes) ^
      const DeepCollectionEquality().hash(losses) ^
      runtimeType.hashCode;
}

extension $FactionChainReportDetailsExtension on FactionChainReportDetails {
  FactionChainReportDetails copyWith({
    int? chain,
    double? respect,
    int? members,
    int? targets,
    int? war,
    double? best,
    int? leave,
    int? mug,
    int? hospitalize,
    int? assists,
    int? retaliations,
    int? overseas,
    int? draws,
    int? escapes,
    int? losses,
  }) {
    return FactionChainReportDetails(
      chain: chain ?? this.chain,
      respect: respect ?? this.respect,
      members: members ?? this.members,
      targets: targets ?? this.targets,
      war: war ?? this.war,
      best: best ?? this.best,
      leave: leave ?? this.leave,
      mug: mug ?? this.mug,
      hospitalize: hospitalize ?? this.hospitalize,
      assists: assists ?? this.assists,
      retaliations: retaliations ?? this.retaliations,
      overseas: overseas ?? this.overseas,
      draws: draws ?? this.draws,
      escapes: escapes ?? this.escapes,
      losses: losses ?? this.losses,
    );
  }

  FactionChainReportDetails copyWithWrapped({
    Wrapped<int>? chain,
    Wrapped<double>? respect,
    Wrapped<int>? members,
    Wrapped<int>? targets,
    Wrapped<int>? war,
    Wrapped<double>? best,
    Wrapped<int>? leave,
    Wrapped<int>? mug,
    Wrapped<int>? hospitalize,
    Wrapped<int>? assists,
    Wrapped<int>? retaliations,
    Wrapped<int>? overseas,
    Wrapped<int>? draws,
    Wrapped<int>? escapes,
    Wrapped<int>? losses,
  }) {
    return FactionChainReportDetails(
      chain: (chain != null ? chain.value : this.chain),
      respect: (respect != null ? respect.value : this.respect),
      members: (members != null ? members.value : this.members),
      targets: (targets != null ? targets.value : this.targets),
      war: (war != null ? war.value : this.war),
      best: (best != null ? best.value : this.best),
      leave: (leave != null ? leave.value : this.leave),
      mug: (mug != null ? mug.value : this.mug),
      hospitalize: (hospitalize != null ? hospitalize.value : this.hospitalize),
      assists: (assists != null ? assists.value : this.assists),
      retaliations: (retaliations != null ? retaliations.value : this.retaliations),
      overseas: (overseas != null ? overseas.value : this.overseas),
      draws: (draws != null ? draws.value : this.draws),
      escapes: (escapes != null ? escapes.value : this.escapes),
      losses: (losses != null ? losses.value : this.losses),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionChainReportBonus {
  const FactionChainReportBonus({
    required this.attackerId,
    required this.defenderId,
    required this.chain,
    required this.respect,
  });

  factory FactionChainReportBonus.fromJson(Map<String, dynamic> json) => _$FactionChainReportBonusFromJson(json);

  static const toJsonFactory = _$FactionChainReportBonusToJson;
  Map<String, dynamic> toJson() => _$FactionChainReportBonusToJson(this);

  @JsonKey(name: 'attacker_id')
  final int attackerId;
  @JsonKey(name: 'defender_id')
  final int defenderId;
  @JsonKey(name: 'chain')
  final int chain;
  @JsonKey(name: 'respect')
  final int respect;
  static const fromJsonFactory = _$FactionChainReportBonusFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionChainReportBonus &&
            (identical(other.attackerId, attackerId) ||
                const DeepCollectionEquality().equals(
                  other.attackerId,
                  attackerId,
                )) &&
            (identical(other.defenderId, defenderId) ||
                const DeepCollectionEquality().equals(
                  other.defenderId,
                  defenderId,
                )) &&
            (identical(other.chain, chain) || const DeepCollectionEquality().equals(other.chain, chain)) &&
            (identical(other.respect, respect) || const DeepCollectionEquality().equals(other.respect, respect)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(attackerId) ^
      const DeepCollectionEquality().hash(defenderId) ^
      const DeepCollectionEquality().hash(chain) ^
      const DeepCollectionEquality().hash(respect) ^
      runtimeType.hashCode;
}

extension $FactionChainReportBonusExtension on FactionChainReportBonus {
  FactionChainReportBonus copyWith({
    int? attackerId,
    int? defenderId,
    int? chain,
    int? respect,
  }) {
    return FactionChainReportBonus(
      attackerId: attackerId ?? this.attackerId,
      defenderId: defenderId ?? this.defenderId,
      chain: chain ?? this.chain,
      respect: respect ?? this.respect,
    );
  }

  FactionChainReportBonus copyWithWrapped({
    Wrapped<int>? attackerId,
    Wrapped<int>? defenderId,
    Wrapped<int>? chain,
    Wrapped<int>? respect,
  }) {
    return FactionChainReportBonus(
      attackerId: (attackerId != null ? attackerId.value : this.attackerId),
      defenderId: (defenderId != null ? defenderId.value : this.defenderId),
      chain: (chain != null ? chain.value : this.chain),
      respect: (respect != null ? respect.value : this.respect),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionChainReportAttacker {
  const FactionChainReportAttacker({
    required this.id,
    required this.respect,
    required this.attacks,
  });

  factory FactionChainReportAttacker.fromJson(Map<String, dynamic> json) => _$FactionChainReportAttackerFromJson(json);

  static const toJsonFactory = _$FactionChainReportAttackerToJson;
  Map<String, dynamic> toJson() => _$FactionChainReportAttackerToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'respect')
  final FactionChainReportAttackerRespect respect;
  @JsonKey(name: 'attacks')
  final FactionChainReportAttackerAttacks attacks;
  static const fromJsonFactory = _$FactionChainReportAttackerFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionChainReportAttacker &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.respect, respect) ||
                const DeepCollectionEquality().equals(
                  other.respect,
                  respect,
                )) &&
            (identical(other.attacks, attacks) || const DeepCollectionEquality().equals(other.attacks, attacks)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(respect) ^
      const DeepCollectionEquality().hash(attacks) ^
      runtimeType.hashCode;
}

extension $FactionChainReportAttackerExtension on FactionChainReportAttacker {
  FactionChainReportAttacker copyWith({
    int? id,
    FactionChainReportAttackerRespect? respect,
    FactionChainReportAttackerAttacks? attacks,
  }) {
    return FactionChainReportAttacker(
      id: id ?? this.id,
      respect: respect ?? this.respect,
      attacks: attacks ?? this.attacks,
    );
  }

  FactionChainReportAttacker copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<FactionChainReportAttackerRespect>? respect,
    Wrapped<FactionChainReportAttackerAttacks>? attacks,
  }) {
    return FactionChainReportAttacker(
      id: (id != null ? id.value : this.id),
      respect: (respect != null ? respect.value : this.respect),
      attacks: (attacks != null ? attacks.value : this.attacks),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionChainReportAttackerRespect {
  const FactionChainReportAttackerRespect({
    required this.total,
    required this.average,
    required this.best,
  });

  factory FactionChainReportAttackerRespect.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$FactionChainReportAttackerRespectFromJson(json);

  static const toJsonFactory = _$FactionChainReportAttackerRespectToJson;
  Map<String, dynamic> toJson() => _$FactionChainReportAttackerRespectToJson(this);

  @JsonKey(name: 'total')
  final double total;
  @JsonKey(name: 'average')
  final double average;
  @JsonKey(name: 'best')
  final double best;
  static const fromJsonFactory = _$FactionChainReportAttackerRespectFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionChainReportAttackerRespect &&
            (identical(other.total, total) || const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.average, average) ||
                const DeepCollectionEquality().equals(
                  other.average,
                  average,
                )) &&
            (identical(other.best, best) || const DeepCollectionEquality().equals(other.best, best)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(average) ^
      const DeepCollectionEquality().hash(best) ^
      runtimeType.hashCode;
}

extension $FactionChainReportAttackerRespectExtension on FactionChainReportAttackerRespect {
  FactionChainReportAttackerRespect copyWith({
    double? total,
    double? average,
    double? best,
  }) {
    return FactionChainReportAttackerRespect(
      total: total ?? this.total,
      average: average ?? this.average,
      best: best ?? this.best,
    );
  }

  FactionChainReportAttackerRespect copyWithWrapped({
    Wrapped<double>? total,
    Wrapped<double>? average,
    Wrapped<double>? best,
  }) {
    return FactionChainReportAttackerRespect(
      total: (total != null ? total.value : this.total),
      average: (average != null ? average.value : this.average),
      best: (best != null ? best.value : this.best),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionChainReportAttackerAttacks {
  const FactionChainReportAttackerAttacks({
    required this.total,
    required this.leave,
    required this.mug,
    required this.hospitalize,
    required this.assists,
    required this.retaliations,
    required this.overseas,
    required this.draws,
    this.escapes,
    required this.losses,
    required this.war,
    required this.bonuses,
  });

  factory FactionChainReportAttackerAttacks.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$FactionChainReportAttackerAttacksFromJson(json);

  static const toJsonFactory = _$FactionChainReportAttackerAttacksToJson;
  Map<String, dynamic> toJson() => _$FactionChainReportAttackerAttacksToJson(this);

  @JsonKey(name: 'total')
  final int total;
  @JsonKey(name: 'leave')
  final int leave;
  @JsonKey(name: 'mug')
  final int mug;
  @JsonKey(name: 'hospitalize')
  final int hospitalize;
  @JsonKey(name: 'assists')
  final int assists;
  @JsonKey(name: 'retaliations')
  final int retaliations;
  @JsonKey(name: 'overseas')
  final int overseas;
  @JsonKey(name: 'draws')
  final int draws;
  @JsonKey(name: 'escapes')
  final int? escapes;
  @JsonKey(name: 'losses')
  final int losses;
  @JsonKey(name: 'war')
  final int war;
  @JsonKey(name: 'bonuses')
  final int bonuses;
  static const fromJsonFactory = _$FactionChainReportAttackerAttacksFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionChainReportAttackerAttacks &&
            (identical(other.total, total) || const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.leave, leave) || const DeepCollectionEquality().equals(other.leave, leave)) &&
            (identical(other.mug, mug) || const DeepCollectionEquality().equals(other.mug, mug)) &&
            (identical(other.hospitalize, hospitalize) ||
                const DeepCollectionEquality().equals(
                  other.hospitalize,
                  hospitalize,
                )) &&
            (identical(other.assists, assists) ||
                const DeepCollectionEquality().equals(
                  other.assists,
                  assists,
                )) &&
            (identical(other.retaliations, retaliations) ||
                const DeepCollectionEquality().equals(
                  other.retaliations,
                  retaliations,
                )) &&
            (identical(other.overseas, overseas) ||
                const DeepCollectionEquality().equals(
                  other.overseas,
                  overseas,
                )) &&
            (identical(other.draws, draws) || const DeepCollectionEquality().equals(other.draws, draws)) &&
            (identical(other.escapes, escapes) ||
                const DeepCollectionEquality().equals(
                  other.escapes,
                  escapes,
                )) &&
            (identical(other.losses, losses) || const DeepCollectionEquality().equals(other.losses, losses)) &&
            (identical(other.war, war) || const DeepCollectionEquality().equals(other.war, war)) &&
            (identical(other.bonuses, bonuses) || const DeepCollectionEquality().equals(other.bonuses, bonuses)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(leave) ^
      const DeepCollectionEquality().hash(mug) ^
      const DeepCollectionEquality().hash(hospitalize) ^
      const DeepCollectionEquality().hash(assists) ^
      const DeepCollectionEquality().hash(retaliations) ^
      const DeepCollectionEquality().hash(overseas) ^
      const DeepCollectionEquality().hash(draws) ^
      const DeepCollectionEquality().hash(escapes) ^
      const DeepCollectionEquality().hash(losses) ^
      const DeepCollectionEquality().hash(war) ^
      const DeepCollectionEquality().hash(bonuses) ^
      runtimeType.hashCode;
}

extension $FactionChainReportAttackerAttacksExtension on FactionChainReportAttackerAttacks {
  FactionChainReportAttackerAttacks copyWith({
    int? total,
    int? leave,
    int? mug,
    int? hospitalize,
    int? assists,
    int? retaliations,
    int? overseas,
    int? draws,
    int? escapes,
    int? losses,
    int? war,
    int? bonuses,
  }) {
    return FactionChainReportAttackerAttacks(
      total: total ?? this.total,
      leave: leave ?? this.leave,
      mug: mug ?? this.mug,
      hospitalize: hospitalize ?? this.hospitalize,
      assists: assists ?? this.assists,
      retaliations: retaliations ?? this.retaliations,
      overseas: overseas ?? this.overseas,
      draws: draws ?? this.draws,
      escapes: escapes ?? this.escapes,
      losses: losses ?? this.losses,
      war: war ?? this.war,
      bonuses: bonuses ?? this.bonuses,
    );
  }

  FactionChainReportAttackerAttacks copyWithWrapped({
    Wrapped<int>? total,
    Wrapped<int>? leave,
    Wrapped<int>? mug,
    Wrapped<int>? hospitalize,
    Wrapped<int>? assists,
    Wrapped<int>? retaliations,
    Wrapped<int>? overseas,
    Wrapped<int>? draws,
    Wrapped<int?>? escapes,
    Wrapped<int>? losses,
    Wrapped<int>? war,
    Wrapped<int>? bonuses,
  }) {
    return FactionChainReportAttackerAttacks(
      total: (total != null ? total.value : this.total),
      leave: (leave != null ? leave.value : this.leave),
      mug: (mug != null ? mug.value : this.mug),
      hospitalize: (hospitalize != null ? hospitalize.value : this.hospitalize),
      assists: (assists != null ? assists.value : this.assists),
      retaliations: (retaliations != null ? retaliations.value : this.retaliations),
      overseas: (overseas != null ? overseas.value : this.overseas),
      draws: (draws != null ? draws.value : this.draws),
      escapes: (escapes != null ? escapes.value : this.escapes),
      losses: (losses != null ? losses.value : this.losses),
      war: (war != null ? war.value : this.war),
      bonuses: (bonuses != null ? bonuses.value : this.bonuses),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionCrimeUser {
  const FactionCrimeUser({
    required this.id,
    required this.outcome,
    required this.joinedAt,
    required this.progress,
  });

  factory FactionCrimeUser.fromJson(Map<String, dynamic> json) => _$FactionCrimeUserFromJson(json);

  static const toJsonFactory = _$FactionCrimeUserToJson;
  Map<String, dynamic> toJson() => _$FactionCrimeUserToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'outcome')
  final dynamic outcome;
  @JsonKey(name: 'joined_at')
  final int joinedAt;
  @JsonKey(name: 'progress')
  final double progress;
  static const fromJsonFactory = _$FactionCrimeUserFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionCrimeUser &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.outcome, outcome) ||
                const DeepCollectionEquality().equals(
                  other.outcome,
                  outcome,
                )) &&
            (identical(other.joinedAt, joinedAt) ||
                const DeepCollectionEquality().equals(
                  other.joinedAt,
                  joinedAt,
                )) &&
            (identical(other.progress, progress) ||
                const DeepCollectionEquality().equals(
                  other.progress,
                  progress,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(outcome) ^
      const DeepCollectionEquality().hash(joinedAt) ^
      const DeepCollectionEquality().hash(progress) ^
      runtimeType.hashCode;
}

extension $FactionCrimeUserExtension on FactionCrimeUser {
  FactionCrimeUser copyWith({
    int? id,
    dynamic outcome,
    int? joinedAt,
    double? progress,
  }) {
    return FactionCrimeUser(
      id: id ?? this.id,
      outcome: outcome ?? this.outcome,
      joinedAt: joinedAt ?? this.joinedAt,
      progress: progress ?? this.progress,
    );
  }

  FactionCrimeUser copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<dynamic>? outcome,
    Wrapped<int>? joinedAt,
    Wrapped<double>? progress,
  }) {
    return FactionCrimeUser(
      id: (id != null ? id.value : this.id),
      outcome: (outcome != null ? outcome.value : this.outcome),
      joinedAt: (joinedAt != null ? joinedAt.value : this.joinedAt),
      progress: (progress != null ? progress.value : this.progress),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionCrimeRewardItem {
  const FactionCrimeRewardItem({required this.id, required this.quantity});

  factory FactionCrimeRewardItem.fromJson(Map<String, dynamic> json) => _$FactionCrimeRewardItemFromJson(json);

  static const toJsonFactory = _$FactionCrimeRewardItemToJson;
  Map<String, dynamic> toJson() => _$FactionCrimeRewardItemToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'quantity')
  final int quantity;
  static const fromJsonFactory = _$FactionCrimeRewardItemFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionCrimeRewardItem &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.quantity, quantity) ||
                const DeepCollectionEquality().equals(
                  other.quantity,
                  quantity,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^ const DeepCollectionEquality().hash(quantity) ^ runtimeType.hashCode;
}

extension $FactionCrimeRewardItemExtension on FactionCrimeRewardItem {
  FactionCrimeRewardItem copyWith({int? id, int? quantity}) {
    return FactionCrimeRewardItem(
      id: id ?? this.id,
      quantity: quantity ?? this.quantity,
    );
  }

  FactionCrimeRewardItem copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<int>? quantity,
  }) {
    return FactionCrimeRewardItem(
      id: (id != null ? id.value : this.id),
      quantity: (quantity != null ? quantity.value : this.quantity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionCrimeRewardPayout {
  const FactionCrimeRewardPayout({
    required this.type,
    required this.percentage,
    required this.paidBy,
    required this.paidAt,
  });

  factory FactionCrimeRewardPayout.fromJson(Map<String, dynamic> json) => _$FactionCrimeRewardPayoutFromJson(json);

  static const toJsonFactory = _$FactionCrimeRewardPayoutToJson;
  Map<String, dynamic> toJson() => _$FactionCrimeRewardPayoutToJson(this);

  @JsonKey(
    name: 'type',
    toJson: factionOrganizedCrimePayoutTypeToJson,
    fromJson: factionOrganizedCrimePayoutTypeFromJson,
  )
  final enums.FactionOrganizedCrimePayoutType type;
  @JsonKey(name: 'percentage')
  final int percentage;
  @JsonKey(name: 'paid_by')
  final int paidBy;
  @JsonKey(name: 'paid_at')
  final int paidAt;
  static const fromJsonFactory = _$FactionCrimeRewardPayoutFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionCrimeRewardPayout &&
            (identical(other.type, type) || const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.percentage, percentage) ||
                const DeepCollectionEquality().equals(
                  other.percentage,
                  percentage,
                )) &&
            (identical(other.paidBy, paidBy) || const DeepCollectionEquality().equals(other.paidBy, paidBy)) &&
            (identical(other.paidAt, paidAt) || const DeepCollectionEquality().equals(other.paidAt, paidAt)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(percentage) ^
      const DeepCollectionEquality().hash(paidBy) ^
      const DeepCollectionEquality().hash(paidAt) ^
      runtimeType.hashCode;
}

extension $FactionCrimeRewardPayoutExtension on FactionCrimeRewardPayout {
  FactionCrimeRewardPayout copyWith({
    enums.FactionOrganizedCrimePayoutType? type,
    int? percentage,
    int? paidBy,
    int? paidAt,
  }) {
    return FactionCrimeRewardPayout(
      type: type ?? this.type,
      percentage: percentage ?? this.percentage,
      paidBy: paidBy ?? this.paidBy,
      paidAt: paidAt ?? this.paidAt,
    );
  }

  FactionCrimeRewardPayout copyWithWrapped({
    Wrapped<enums.FactionOrganizedCrimePayoutType>? type,
    Wrapped<int>? percentage,
    Wrapped<int>? paidBy,
    Wrapped<int>? paidAt,
  }) {
    return FactionCrimeRewardPayout(
      type: (type != null ? type.value : this.type),
      percentage: (percentage != null ? percentage.value : this.percentage),
      paidBy: (paidBy != null ? paidBy.value : this.paidBy),
      paidAt: (paidAt != null ? paidAt.value : this.paidAt),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionCrimeReward {
  const FactionCrimeReward({
    required this.money,
    required this.items,
    required this.respect,
    required this.scope,
    required this.payout,
  });

  factory FactionCrimeReward.fromJson(Map<String, dynamic> json) => _$FactionCrimeRewardFromJson(json);

  static const toJsonFactory = _$FactionCrimeRewardToJson;
  Map<String, dynamic> toJson() => _$FactionCrimeRewardToJson(this);

  @JsonKey(name: 'money')
  final int money;
  @JsonKey(name: 'items', defaultValue: <FactionCrimeRewardItem>[])
  final List<FactionCrimeRewardItem> items;
  @JsonKey(name: 'respect')
  final int respect;
  @JsonKey(name: 'scope')
  final int scope;
  @JsonKey(name: 'payout')
  final dynamic payout;
  static const fromJsonFactory = _$FactionCrimeRewardFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionCrimeReward &&
            (identical(other.money, money) || const DeepCollectionEquality().equals(other.money, money)) &&
            (identical(other.items, items) || const DeepCollectionEquality().equals(other.items, items)) &&
            (identical(other.respect, respect) ||
                const DeepCollectionEquality().equals(
                  other.respect,
                  respect,
                )) &&
            (identical(other.scope, scope) || const DeepCollectionEquality().equals(other.scope, scope)) &&
            (identical(other.payout, payout) || const DeepCollectionEquality().equals(other.payout, payout)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(money) ^
      const DeepCollectionEquality().hash(items) ^
      const DeepCollectionEquality().hash(respect) ^
      const DeepCollectionEquality().hash(scope) ^
      const DeepCollectionEquality().hash(payout) ^
      runtimeType.hashCode;
}

extension $FactionCrimeRewardExtension on FactionCrimeReward {
  FactionCrimeReward copyWith({
    int? money,
    List<FactionCrimeRewardItem>? items,
    int? respect,
    int? scope,
    dynamic payout,
  }) {
    return FactionCrimeReward(
      money: money ?? this.money,
      items: items ?? this.items,
      respect: respect ?? this.respect,
      scope: scope ?? this.scope,
      payout: payout ?? this.payout,
    );
  }

  FactionCrimeReward copyWithWrapped({
    Wrapped<int>? money,
    Wrapped<List<FactionCrimeRewardItem>>? items,
    Wrapped<int>? respect,
    Wrapped<int>? scope,
    Wrapped<dynamic>? payout,
  }) {
    return FactionCrimeReward(
      money: (money != null ? money.value : this.money),
      items: (items != null ? items.value : this.items),
      respect: (respect != null ? respect.value : this.respect),
      scope: (scope != null ? scope.value : this.scope),
      payout: (payout != null ? payout.value : this.payout),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionCrimeSlot {
  const FactionCrimeSlot({
    required this.position,
    required this.itemRequirement,
    required this.user,
    required this.checkpointPassRate,
  });

  factory FactionCrimeSlot.fromJson(Map<String, dynamic> json) => _$FactionCrimeSlotFromJson(json);

  static const toJsonFactory = _$FactionCrimeSlotToJson;
  Map<String, dynamic> toJson() => _$FactionCrimeSlotToJson(this);

  @JsonKey(name: 'position')
  final String position;
  @JsonKey(name: 'item_requirement')
  final dynamic itemRequirement;
  @JsonKey(name: 'user')
  final dynamic user;
  @JsonKey(name: 'checkpoint_pass_rate')
  final int checkpointPassRate;
  static const fromJsonFactory = _$FactionCrimeSlotFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionCrimeSlot &&
            (identical(other.position, position) ||
                const DeepCollectionEquality().equals(
                  other.position,
                  position,
                )) &&
            (identical(other.itemRequirement, itemRequirement) ||
                const DeepCollectionEquality().equals(
                  other.itemRequirement,
                  itemRequirement,
                )) &&
            (identical(other.user, user) || const DeepCollectionEquality().equals(other.user, user)) &&
            (identical(other.checkpointPassRate, checkpointPassRate) ||
                const DeepCollectionEquality().equals(
                  other.checkpointPassRate,
                  checkpointPassRate,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(position) ^
      const DeepCollectionEquality().hash(itemRequirement) ^
      const DeepCollectionEquality().hash(user) ^
      const DeepCollectionEquality().hash(checkpointPassRate) ^
      runtimeType.hashCode;
}

extension $FactionCrimeSlotExtension on FactionCrimeSlot {
  FactionCrimeSlot copyWith({
    String? position,
    dynamic itemRequirement,
    dynamic user,
    int? checkpointPassRate,
  }) {
    return FactionCrimeSlot(
      position: position ?? this.position,
      itemRequirement: itemRequirement ?? this.itemRequirement,
      user: user ?? this.user,
      checkpointPassRate: checkpointPassRate ?? this.checkpointPassRate,
    );
  }

  FactionCrimeSlot copyWithWrapped({
    Wrapped<String>? position,
    Wrapped<dynamic>? itemRequirement,
    Wrapped<dynamic>? user,
    Wrapped<int>? checkpointPassRate,
  }) {
    return FactionCrimeSlot(
      position: (position != null ? position.value : this.position),
      itemRequirement: (itemRequirement != null ? itemRequirement.value : this.itemRequirement),
      user: (user != null ? user.value : this.user),
      checkpointPassRate: (checkpointPassRate != null ? checkpointPassRate.value : this.checkpointPassRate),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionCrime {
  const FactionCrime({
    required this.id,
    required this.previousCrimeId,
    required this.name,
    required this.difficulty,
    required this.status,
    required this.createdAt,
    required this.planningAt,
    required this.readyAt,
    required this.expiredAt,
    required this.executedAt,
    required this.slots,
    required this.rewards,
  });

  factory FactionCrime.fromJson(Map<String, dynamic> json) => _$FactionCrimeFromJson(json);

  static const toJsonFactory = _$FactionCrimeToJson;
  Map<String, dynamic> toJson() => _$FactionCrimeToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'previous_crime_id')
  final dynamic previousCrimeId;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'difficulty')
  final int difficulty;
  @JsonKey(
    name: 'status',
    toJson: factionCrimeStatusEnumToJson,
    fromJson: factionCrimeStatusEnumFromJson,
  )
  final enums.FactionCrimeStatusEnum status;
  @JsonKey(name: 'created_at')
  final int createdAt;
  @JsonKey(name: 'planning_at')
  final dynamic planningAt;
  @JsonKey(name: 'ready_at')
  final dynamic readyAt;
  @JsonKey(name: 'expired_at')
  final int expiredAt;
  @JsonKey(name: 'executed_at')
  final dynamic executedAt;
  @JsonKey(name: 'slots', defaultValue: <FactionCrimeSlot>[])
  final List<FactionCrimeSlot> slots;
  @JsonKey(name: 'rewards')
  final dynamic rewards;
  static const fromJsonFactory = _$FactionCrimeFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionCrime &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.previousCrimeId, previousCrimeId) ||
                const DeepCollectionEquality().equals(
                  other.previousCrimeId,
                  previousCrimeId,
                )) &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.difficulty, difficulty) ||
                const DeepCollectionEquality().equals(
                  other.difficulty,
                  difficulty,
                )) &&
            (identical(other.status, status) || const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.createdAt, createdAt) ||
                const DeepCollectionEquality().equals(
                  other.createdAt,
                  createdAt,
                )) &&
            (identical(other.planningAt, planningAt) ||
                const DeepCollectionEquality().equals(
                  other.planningAt,
                  planningAt,
                )) &&
            (identical(other.readyAt, readyAt) ||
                const DeepCollectionEquality().equals(
                  other.readyAt,
                  readyAt,
                )) &&
            (identical(other.expiredAt, expiredAt) ||
                const DeepCollectionEquality().equals(
                  other.expiredAt,
                  expiredAt,
                )) &&
            (identical(other.executedAt, executedAt) ||
                const DeepCollectionEquality().equals(
                  other.executedAt,
                  executedAt,
                )) &&
            (identical(other.slots, slots) || const DeepCollectionEquality().equals(other.slots, slots)) &&
            (identical(other.rewards, rewards) || const DeepCollectionEquality().equals(other.rewards, rewards)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(previousCrimeId) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(difficulty) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(createdAt) ^
      const DeepCollectionEquality().hash(planningAt) ^
      const DeepCollectionEquality().hash(readyAt) ^
      const DeepCollectionEquality().hash(expiredAt) ^
      const DeepCollectionEquality().hash(executedAt) ^
      const DeepCollectionEquality().hash(slots) ^
      const DeepCollectionEquality().hash(rewards) ^
      runtimeType.hashCode;
}

extension $FactionCrimeExtension on FactionCrime {
  FactionCrime copyWith({
    int? id,
    dynamic previousCrimeId,
    String? name,
    int? difficulty,
    enums.FactionCrimeStatusEnum? status,
    int? createdAt,
    dynamic planningAt,
    dynamic readyAt,
    int? expiredAt,
    dynamic executedAt,
    List<FactionCrimeSlot>? slots,
    dynamic rewards,
  }) {
    return FactionCrime(
      id: id ?? this.id,
      previousCrimeId: previousCrimeId ?? this.previousCrimeId,
      name: name ?? this.name,
      difficulty: difficulty ?? this.difficulty,
      status: status ?? this.status,
      createdAt: createdAt ?? this.createdAt,
      planningAt: planningAt ?? this.planningAt,
      readyAt: readyAt ?? this.readyAt,
      expiredAt: expiredAt ?? this.expiredAt,
      executedAt: executedAt ?? this.executedAt,
      slots: slots ?? this.slots,
      rewards: rewards ?? this.rewards,
    );
  }

  FactionCrime copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<dynamic>? previousCrimeId,
    Wrapped<String>? name,
    Wrapped<int>? difficulty,
    Wrapped<enums.FactionCrimeStatusEnum>? status,
    Wrapped<int>? createdAt,
    Wrapped<dynamic>? planningAt,
    Wrapped<dynamic>? readyAt,
    Wrapped<int>? expiredAt,
    Wrapped<dynamic>? executedAt,
    Wrapped<List<FactionCrimeSlot>>? slots,
    Wrapped<dynamic>? rewards,
  }) {
    return FactionCrime(
      id: (id != null ? id.value : this.id),
      previousCrimeId: (previousCrimeId != null ? previousCrimeId.value : this.previousCrimeId),
      name: (name != null ? name.value : this.name),
      difficulty: (difficulty != null ? difficulty.value : this.difficulty),
      status: (status != null ? status.value : this.status),
      createdAt: (createdAt != null ? createdAt.value : this.createdAt),
      planningAt: (planningAt != null ? planningAt.value : this.planningAt),
      readyAt: (readyAt != null ? readyAt.value : this.readyAt),
      expiredAt: (expiredAt != null ? expiredAt.value : this.expiredAt),
      executedAt: (executedAt != null ? executedAt.value : this.executedAt),
      slots: (slots != null ? slots.value : this.slots),
      rewards: (rewards != null ? rewards.value : this.rewards),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionCrimesResponse {
  const FactionCrimesResponse({required this.crimes, required this.metadata});

  factory FactionCrimesResponse.fromJson(Map<String, dynamic> json) => _$FactionCrimesResponseFromJson(json);

  static const toJsonFactory = _$FactionCrimesResponseToJson;
  Map<String, dynamic> toJson() => _$FactionCrimesResponseToJson(this);

  @JsonKey(name: 'crimes', defaultValue: <FactionCrime>[])
  final List<FactionCrime> crimes;
  @JsonKey(name: '_metadata')
  final RequestMetadataWithLinks metadata;
  static const fromJsonFactory = _$FactionCrimesResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionCrimesResponse &&
            (identical(other.crimes, crimes) || const DeepCollectionEquality().equals(other.crimes, crimes)) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality().equals(
                  other.metadata,
                  metadata,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(crimes) ^
      const DeepCollectionEquality().hash(metadata) ^
      runtimeType.hashCode;
}

extension $FactionCrimesResponseExtension on FactionCrimesResponse {
  FactionCrimesResponse copyWith({
    List<FactionCrime>? crimes,
    RequestMetadataWithLinks? metadata,
  }) {
    return FactionCrimesResponse(
      crimes: crimes ?? this.crimes,
      metadata: metadata ?? this.metadata,
    );
  }

  FactionCrimesResponse copyWithWrapped({
    Wrapped<List<FactionCrime>>? crimes,
    Wrapped<RequestMetadataWithLinks>? metadata,
  }) {
    return FactionCrimesResponse(
      crimes: (crimes != null ? crimes.value : this.crimes),
      metadata: (metadata != null ? metadata.value : this.metadata),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionCrimeResponse {
  const FactionCrimeResponse({required this.crime});

  factory FactionCrimeResponse.fromJson(Map<String, dynamic> json) => _$FactionCrimeResponseFromJson(json);

  static const toJsonFactory = _$FactionCrimeResponseToJson;
  Map<String, dynamic> toJson() => _$FactionCrimeResponseToJson(this);

  @JsonKey(name: 'crime')
  final FactionCrime crime;
  static const fromJsonFactory = _$FactionCrimeResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionCrimeResponse &&
            (identical(other.crime, crime) || const DeepCollectionEquality().equals(other.crime, crime)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(crime) ^ runtimeType.hashCode;
}

extension $FactionCrimeResponseExtension on FactionCrimeResponse {
  FactionCrimeResponse copyWith({FactionCrime? crime}) {
    return FactionCrimeResponse(crime: crime ?? this.crime);
  }

  FactionCrimeResponse copyWithWrapped({Wrapped<FactionCrime>? crime}) {
    return FactionCrimeResponse(
      crime: (crime != null ? crime.value : this.crime),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionBalance {
  const FactionBalance({required this.faction, required this.members});

  factory FactionBalance.fromJson(Map<String, dynamic> json) => _$FactionBalanceFromJson(json);

  static const toJsonFactory = _$FactionBalanceToJson;
  Map<String, dynamic> toJson() => _$FactionBalanceToJson(this);

  @JsonKey(name: 'faction')
  final FactionBalance$Faction faction;
  @JsonKey(name: 'members')
  final List<FactionBalance$Members$Item> members;
  static const fromJsonFactory = _$FactionBalanceFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionBalance &&
            (identical(other.faction, faction) ||
                const DeepCollectionEquality().equals(
                  other.faction,
                  faction,
                )) &&
            (identical(other.members, members) || const DeepCollectionEquality().equals(other.members, members)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(faction) ^
      const DeepCollectionEquality().hash(members) ^
      runtimeType.hashCode;
}

extension $FactionBalanceExtension on FactionBalance {
  FactionBalance copyWith({
    FactionBalance$Faction? faction,
    List<FactionBalance$Members$Item>? members,
  }) {
    return FactionBalance(
      faction: faction ?? this.faction,
      members: members ?? this.members,
    );
  }

  FactionBalance copyWithWrapped({
    Wrapped<FactionBalance$Faction>? faction,
    Wrapped<List<FactionBalance$Members$Item>>? members,
  }) {
    return FactionBalance(
      faction: (faction != null ? faction.value : this.faction),
      members: (members != null ? members.value : this.members),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionBalanceResponse {
  const FactionBalanceResponse({required this.balance});

  factory FactionBalanceResponse.fromJson(Map<String, dynamic> json) => _$FactionBalanceResponseFromJson(json);

  static const toJsonFactory = _$FactionBalanceResponseToJson;
  Map<String, dynamic> toJson() => _$FactionBalanceResponseToJson(this);

  @JsonKey(name: 'balance')
  final FactionBalance balance;
  static const fromJsonFactory = _$FactionBalanceResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionBalanceResponse &&
            (identical(other.balance, balance) || const DeepCollectionEquality().equals(other.balance, balance)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(balance) ^ runtimeType.hashCode;
}

extension $FactionBalanceResponseExtension on FactionBalanceResponse {
  FactionBalanceResponse copyWith({FactionBalance? balance}) {
    return FactionBalanceResponse(balance: balance ?? this.balance);
  }

  FactionBalanceResponse copyWithWrapped({Wrapped<FactionBalance>? balance}) {
    return FactionBalanceResponse(
      balance: (balance != null ? balance.value : this.balance),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionSelectionName {
  const FactionSelectionName();

  factory FactionSelectionName.fromJson(Map<String, dynamic> json) => _$FactionSelectionNameFromJson(json);

  static const toJsonFactory = _$FactionSelectionNameToJson;
  Map<String, dynamic> toJson() => _$FactionSelectionNameToJson(this);

  static const fromJsonFactory = _$FactionSelectionNameFromJson;

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => runtimeType.hashCode;
}

@JsonSerializable(explicitToJson: true)
class FactionLookupResponse {
  const FactionLookupResponse({required this.selections});

  factory FactionLookupResponse.fromJson(Map<String, dynamic> json) => _$FactionLookupResponseFromJson(json);

  static const toJsonFactory = _$FactionLookupResponseToJson;
  Map<String, dynamic> toJson() => _$FactionLookupResponseToJson(this);

  @JsonKey(name: 'selections', defaultValue: <FactionSelectionName>[])
  final List<FactionSelectionName> selections;
  static const fromJsonFactory = _$FactionLookupResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionLookupResponse &&
            (identical(other.selections, selections) ||
                const DeepCollectionEquality().equals(
                  other.selections,
                  selections,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(selections) ^ runtimeType.hashCode;
}

extension $FactionLookupResponseExtension on FactionLookupResponse {
  FactionLookupResponse copyWith({List<FactionSelectionName>? selections}) {
    return FactionLookupResponse(selections: selections ?? this.selections);
  }

  FactionLookupResponse copyWithWrapped({
    Wrapped<List<FactionSelectionName>>? selections,
  }) {
    return FactionLookupResponse(
      selections: (selections != null ? selections.value : this.selections),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionRankedWarDetails {
  const FactionRankedWarDetails({
    required this.id,
    required this.start,
    required this.end,
    required this.target,
    required this.winner,
    required this.factions,
  });

  factory FactionRankedWarDetails.fromJson(Map<String, dynamic> json) => _$FactionRankedWarDetailsFromJson(json);

  static const toJsonFactory = _$FactionRankedWarDetailsToJson;
  Map<String, dynamic> toJson() => _$FactionRankedWarDetailsToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'start')
  final int start;
  @JsonKey(name: 'end')
  final int end;
  @JsonKey(name: 'target')
  final int target;
  @JsonKey(name: 'winner')
  final dynamic winner;
  @JsonKey(name: 'factions')
  final List<FactionRankedWarDetails$Factions$Item> factions;
  static const fromJsonFactory = _$FactionRankedWarDetailsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionRankedWarDetails &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.start, start) || const DeepCollectionEquality().equals(other.start, start)) &&
            (identical(other.end, end) || const DeepCollectionEquality().equals(other.end, end)) &&
            (identical(other.target, target) || const DeepCollectionEquality().equals(other.target, target)) &&
            (identical(other.winner, winner) || const DeepCollectionEquality().equals(other.winner, winner)) &&
            (identical(other.factions, factions) ||
                const DeepCollectionEquality().equals(
                  other.factions,
                  factions,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(start) ^
      const DeepCollectionEquality().hash(end) ^
      const DeepCollectionEquality().hash(target) ^
      const DeepCollectionEquality().hash(winner) ^
      const DeepCollectionEquality().hash(factions) ^
      runtimeType.hashCode;
}

extension $FactionRankedWarDetailsExtension on FactionRankedWarDetails {
  FactionRankedWarDetails copyWith({
    int? id,
    int? start,
    int? end,
    int? target,
    dynamic winner,
    List<FactionRankedWarDetails$Factions$Item>? factions,
  }) {
    return FactionRankedWarDetails(
      id: id ?? this.id,
      start: start ?? this.start,
      end: end ?? this.end,
      target: target ?? this.target,
      winner: winner ?? this.winner,
      factions: factions ?? this.factions,
    );
  }

  FactionRankedWarDetails copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<int>? start,
    Wrapped<int>? end,
    Wrapped<int>? target,
    Wrapped<dynamic>? winner,
    Wrapped<List<FactionRankedWarDetails$Factions$Item>>? factions,
  }) {
    return FactionRankedWarDetails(
      id: (id != null ? id.value : this.id),
      start: (start != null ? start.value : this.start),
      end: (end != null ? end.value : this.end),
      target: (target != null ? target.value : this.target),
      winner: (winner != null ? winner.value : this.winner),
      factions: (factions != null ? factions.value : this.factions),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionRankedWarResponse {
  const FactionRankedWarResponse({
    required this.rankedwars,
    required this.metadata,
  });

  factory FactionRankedWarResponse.fromJson(Map<String, dynamic> json) => _$FactionRankedWarResponseFromJson(json);

  static const toJsonFactory = _$FactionRankedWarResponseToJson;
  Map<String, dynamic> toJson() => _$FactionRankedWarResponseToJson(this);

  @JsonKey(name: 'rankedwars', defaultValue: <FactionRankedWarDetails>[])
  final List<FactionRankedWarDetails> rankedwars;
  @JsonKey(name: '_metadata')
  final RequestMetadataWithLinks metadata;
  static const fromJsonFactory = _$FactionRankedWarResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionRankedWarResponse &&
            (identical(other.rankedwars, rankedwars) ||
                const DeepCollectionEquality().equals(
                  other.rankedwars,
                  rankedwars,
                )) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality().equals(
                  other.metadata,
                  metadata,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(rankedwars) ^
      const DeepCollectionEquality().hash(metadata) ^
      runtimeType.hashCode;
}

extension $FactionRankedWarResponseExtension on FactionRankedWarResponse {
  FactionRankedWarResponse copyWith({
    List<FactionRankedWarDetails>? rankedwars,
    RequestMetadataWithLinks? metadata,
  }) {
    return FactionRankedWarResponse(
      rankedwars: rankedwars ?? this.rankedwars,
      metadata: metadata ?? this.metadata,
    );
  }

  FactionRankedWarResponse copyWithWrapped({
    Wrapped<List<FactionRankedWarDetails>>? rankedwars,
    Wrapped<RequestMetadataWithLinks>? metadata,
  }) {
    return FactionRankedWarResponse(
      rankedwars: (rankedwars != null ? rankedwars.value : this.rankedwars),
      metadata: (metadata != null ? metadata.value : this.metadata),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionWarfareResponse {
  const FactionWarfareResponse({required this.warfare, required this.metadata});

  factory FactionWarfareResponse.fromJson(Map<String, dynamic> json) => _$FactionWarfareResponseFromJson(json);

  static const toJsonFactory = _$FactionWarfareResponseToJson;
  Map<String, dynamic> toJson() => _$FactionWarfareResponseToJson(this);

  @JsonKey(name: 'warfare')
  final dynamic warfare;
  @JsonKey(name: '_metadata')
  final RequestMetadataWithLinks metadata;
  static const fromJsonFactory = _$FactionWarfareResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionWarfareResponse &&
            (identical(other.warfare, warfare) ||
                const DeepCollectionEquality().equals(
                  other.warfare,
                  warfare,
                )) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality().equals(
                  other.metadata,
                  metadata,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(warfare) ^
      const DeepCollectionEquality().hash(metadata) ^
      runtimeType.hashCode;
}

extension $FactionWarfareResponseExtension on FactionWarfareResponse {
  FactionWarfareResponse copyWith({
    dynamic warfare,
    RequestMetadataWithLinks? metadata,
  }) {
    return FactionWarfareResponse(
      warfare: warfare ?? this.warfare,
      metadata: metadata ?? this.metadata,
    );
  }

  FactionWarfareResponse copyWithWrapped({
    Wrapped<dynamic>? warfare,
    Wrapped<RequestMetadataWithLinks>? metadata,
  }) {
    return FactionWarfareResponse(
      warfare: (warfare != null ? warfare.value : this.warfare),
      metadata: (metadata != null ? metadata.value : this.metadata),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionRankedWarReportResponse {
  const FactionRankedWarReportResponse({required this.rankedwarreport});

  factory FactionRankedWarReportResponse.fromJson(Map<String, dynamic> json) =>
      _$FactionRankedWarReportResponseFromJson(json);

  static const toJsonFactory = _$FactionRankedWarReportResponseToJson;
  Map<String, dynamic> toJson() => _$FactionRankedWarReportResponseToJson(this);

  @JsonKey(name: 'rankedwarreport')
  final FactionRankedWarReportResponse$Rankedwarreport rankedwarreport;
  static const fromJsonFactory = _$FactionRankedWarReportResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionRankedWarReportResponse &&
            (identical(other.rankedwarreport, rankedwarreport) ||
                const DeepCollectionEquality().equals(
                  other.rankedwarreport,
                  rankedwarreport,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(rankedwarreport) ^ runtimeType.hashCode;
}

extension $FactionRankedWarReportResponseExtension on FactionRankedWarReportResponse {
  FactionRankedWarReportResponse copyWith({
    FactionRankedWarReportResponse$Rankedwarreport? rankedwarreport,
  }) {
    return FactionRankedWarReportResponse(
      rankedwarreport: rankedwarreport ?? this.rankedwarreport,
    );
  }

  FactionRankedWarReportResponse copyWithWrapped({
    Wrapped<FactionRankedWarReportResponse$Rankedwarreport>? rankedwarreport,
  }) {
    return FactionRankedWarReportResponse(
      rankedwarreport: (rankedwarreport != null ? rankedwarreport.value : this.rankedwarreport),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ForumCategoriesResponse {
  const ForumCategoriesResponse({required this.categories});

  factory ForumCategoriesResponse.fromJson(Map<String, dynamic> json) => _$ForumCategoriesResponseFromJson(json);

  static const toJsonFactory = _$ForumCategoriesResponseToJson;
  Map<String, dynamic> toJson() => _$ForumCategoriesResponseToJson(this);

  @JsonKey(name: 'categories')
  final List<ForumCategoriesResponse$Categories$Item> categories;
  static const fromJsonFactory = _$ForumCategoriesResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ForumCategoriesResponse &&
            (identical(other.categories, categories) ||
                const DeepCollectionEquality().equals(
                  other.categories,
                  categories,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(categories) ^ runtimeType.hashCode;
}

extension $ForumCategoriesResponseExtension on ForumCategoriesResponse {
  ForumCategoriesResponse copyWith({
    List<ForumCategoriesResponse$Categories$Item>? categories,
  }) {
    return ForumCategoriesResponse(categories: categories ?? this.categories);
  }

  ForumCategoriesResponse copyWithWrapped({
    Wrapped<List<ForumCategoriesResponse$Categories$Item>>? categories,
  }) {
    return ForumCategoriesResponse(
      categories: (categories != null ? categories.value : this.categories),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ForumThreadAuthor {
  const ForumThreadAuthor({
    required this.id,
    required this.username,
    required this.karma,
  });

  factory ForumThreadAuthor.fromJson(Map<String, dynamic> json) => _$ForumThreadAuthorFromJson(json);

  static const toJsonFactory = _$ForumThreadAuthorToJson;
  Map<String, dynamic> toJson() => _$ForumThreadAuthorToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'username')
  final String username;
  @JsonKey(name: 'karma')
  final int karma;
  static const fromJsonFactory = _$ForumThreadAuthorFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ForumThreadAuthor &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.username, username) ||
                const DeepCollectionEquality().equals(
                  other.username,
                  username,
                )) &&
            (identical(other.karma, karma) || const DeepCollectionEquality().equals(other.karma, karma)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(username) ^
      const DeepCollectionEquality().hash(karma) ^
      runtimeType.hashCode;
}

extension $ForumThreadAuthorExtension on ForumThreadAuthor {
  ForumThreadAuthor copyWith({int? id, String? username, int? karma}) {
    return ForumThreadAuthor(
      id: id ?? this.id,
      username: username ?? this.username,
      karma: karma ?? this.karma,
    );
  }

  ForumThreadAuthor copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<String>? username,
    Wrapped<int>? karma,
  }) {
    return ForumThreadAuthor(
      id: (id != null ? id.value : this.id),
      username: (username != null ? username.value : this.username),
      karma: (karma != null ? karma.value : this.karma),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ForumPollVote {
  const ForumPollVote({required this.answer, required this.votes});

  factory ForumPollVote.fromJson(Map<String, dynamic> json) => _$ForumPollVoteFromJson(json);

  static const toJsonFactory = _$ForumPollVoteToJson;
  Map<String, dynamic> toJson() => _$ForumPollVoteToJson(this);

  @JsonKey(name: 'answer')
  final String answer;
  @JsonKey(name: 'votes')
  final int votes;
  static const fromJsonFactory = _$ForumPollVoteFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ForumPollVote &&
            (identical(other.answer, answer) || const DeepCollectionEquality().equals(other.answer, answer)) &&
            (identical(other.votes, votes) || const DeepCollectionEquality().equals(other.votes, votes)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(answer) ^ const DeepCollectionEquality().hash(votes) ^ runtimeType.hashCode;
}

extension $ForumPollVoteExtension on ForumPollVote {
  ForumPollVote copyWith({String? answer, int? votes}) {
    return ForumPollVote(
      answer: answer ?? this.answer,
      votes: votes ?? this.votes,
    );
  }

  ForumPollVote copyWithWrapped({
    Wrapped<String>? answer,
    Wrapped<int>? votes,
  }) {
    return ForumPollVote(
      answer: (answer != null ? answer.value : this.answer),
      votes: (votes != null ? votes.value : this.votes),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ForumPoll {
  const ForumPoll({
    required this.question,
    required this.answersCount,
    required this.answers,
  });

  factory ForumPoll.fromJson(Map<String, dynamic> json) => _$ForumPollFromJson(json);

  static const toJsonFactory = _$ForumPollToJson;
  Map<String, dynamic> toJson() => _$ForumPollToJson(this);

  @JsonKey(name: 'question')
  final String question;
  @JsonKey(name: 'answers_count')
  final int answersCount;
  @JsonKey(name: 'answers', defaultValue: <ForumPollVote>[])
  final List<ForumPollVote> answers;
  static const fromJsonFactory = _$ForumPollFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ForumPoll &&
            (identical(other.question, question) ||
                const DeepCollectionEquality().equals(
                  other.question,
                  question,
                )) &&
            (identical(other.answersCount, answersCount) ||
                const DeepCollectionEquality().equals(
                  other.answersCount,
                  answersCount,
                )) &&
            (identical(other.answers, answers) || const DeepCollectionEquality().equals(other.answers, answers)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(question) ^
      const DeepCollectionEquality().hash(answersCount) ^
      const DeepCollectionEquality().hash(answers) ^
      runtimeType.hashCode;
}

extension $ForumPollExtension on ForumPoll {
  ForumPoll copyWith({
    String? question,
    int? answersCount,
    List<ForumPollVote>? answers,
  }) {
    return ForumPoll(
      question: question ?? this.question,
      answersCount: answersCount ?? this.answersCount,
      answers: answers ?? this.answers,
    );
  }

  ForumPoll copyWithWrapped({
    Wrapped<String>? question,
    Wrapped<int>? answersCount,
    Wrapped<List<ForumPollVote>>? answers,
  }) {
    return ForumPoll(
      question: (question != null ? question.value : this.question),
      answersCount: (answersCount != null ? answersCount.value : this.answersCount),
      answers: (answers != null ? answers.value : this.answers),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ForumThreadBase {
  const ForumThreadBase({
    required this.id,
    required this.title,
    required this.forumId,
    required this.posts,
    required this.rating,
    required this.views,
    required this.author,
    required this.lastPoster,
    required this.firstPostTime,
    required this.lastPostTime,
    required this.hasPoll,
    required this.isLocked,
    required this.isSticky,
  });

  factory ForumThreadBase.fromJson(Map<String, dynamic> json) => _$ForumThreadBaseFromJson(json);

  static const toJsonFactory = _$ForumThreadBaseToJson;
  Map<String, dynamic> toJson() => _$ForumThreadBaseToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'title')
  final String title;
  @JsonKey(name: 'forum_id')
  final int forumId;
  @JsonKey(name: 'posts')
  final int posts;
  @JsonKey(name: 'rating')
  final int rating;
  @JsonKey(name: 'views')
  final int views;
  @JsonKey(name: 'author')
  final ForumThreadAuthor author;
  @JsonKey(name: 'last_poster')
  final dynamic lastPoster;
  @JsonKey(name: 'first_post_time')
  final int firstPostTime;
  @JsonKey(name: 'last_post_time')
  final dynamic lastPostTime;
  @JsonKey(name: 'has_poll')
  final bool hasPoll;
  @JsonKey(name: 'is_locked')
  final bool isLocked;
  @JsonKey(name: 'is_sticky')
  final bool isSticky;
  static const fromJsonFactory = _$ForumThreadBaseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ForumThreadBase &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.title, title) || const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.forumId, forumId) ||
                const DeepCollectionEquality().equals(
                  other.forumId,
                  forumId,
                )) &&
            (identical(other.posts, posts) || const DeepCollectionEquality().equals(other.posts, posts)) &&
            (identical(other.rating, rating) || const DeepCollectionEquality().equals(other.rating, rating)) &&
            (identical(other.views, views) || const DeepCollectionEquality().equals(other.views, views)) &&
            (identical(other.author, author) || const DeepCollectionEquality().equals(other.author, author)) &&
            (identical(other.lastPoster, lastPoster) ||
                const DeepCollectionEquality().equals(
                  other.lastPoster,
                  lastPoster,
                )) &&
            (identical(other.firstPostTime, firstPostTime) ||
                const DeepCollectionEquality().equals(
                  other.firstPostTime,
                  firstPostTime,
                )) &&
            (identical(other.lastPostTime, lastPostTime) ||
                const DeepCollectionEquality().equals(
                  other.lastPostTime,
                  lastPostTime,
                )) &&
            (identical(other.hasPoll, hasPoll) ||
                const DeepCollectionEquality().equals(
                  other.hasPoll,
                  hasPoll,
                )) &&
            (identical(other.isLocked, isLocked) ||
                const DeepCollectionEquality().equals(
                  other.isLocked,
                  isLocked,
                )) &&
            (identical(other.isSticky, isSticky) ||
                const DeepCollectionEquality().equals(
                  other.isSticky,
                  isSticky,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(forumId) ^
      const DeepCollectionEquality().hash(posts) ^
      const DeepCollectionEquality().hash(rating) ^
      const DeepCollectionEquality().hash(views) ^
      const DeepCollectionEquality().hash(author) ^
      const DeepCollectionEquality().hash(lastPoster) ^
      const DeepCollectionEquality().hash(firstPostTime) ^
      const DeepCollectionEquality().hash(lastPostTime) ^
      const DeepCollectionEquality().hash(hasPoll) ^
      const DeepCollectionEquality().hash(isLocked) ^
      const DeepCollectionEquality().hash(isSticky) ^
      runtimeType.hashCode;
}

extension $ForumThreadBaseExtension on ForumThreadBase {
  ForumThreadBase copyWith({
    int? id,
    String? title,
    int? forumId,
    int? posts,
    int? rating,
    int? views,
    ForumThreadAuthor? author,
    dynamic lastPoster,
    int? firstPostTime,
    dynamic lastPostTime,
    bool? hasPoll,
    bool? isLocked,
    bool? isSticky,
  }) {
    return ForumThreadBase(
      id: id ?? this.id,
      title: title ?? this.title,
      forumId: forumId ?? this.forumId,
      posts: posts ?? this.posts,
      rating: rating ?? this.rating,
      views: views ?? this.views,
      author: author ?? this.author,
      lastPoster: lastPoster ?? this.lastPoster,
      firstPostTime: firstPostTime ?? this.firstPostTime,
      lastPostTime: lastPostTime ?? this.lastPostTime,
      hasPoll: hasPoll ?? this.hasPoll,
      isLocked: isLocked ?? this.isLocked,
      isSticky: isSticky ?? this.isSticky,
    );
  }

  ForumThreadBase copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<String>? title,
    Wrapped<int>? forumId,
    Wrapped<int>? posts,
    Wrapped<int>? rating,
    Wrapped<int>? views,
    Wrapped<ForumThreadAuthor>? author,
    Wrapped<dynamic>? lastPoster,
    Wrapped<int>? firstPostTime,
    Wrapped<dynamic>? lastPostTime,
    Wrapped<bool>? hasPoll,
    Wrapped<bool>? isLocked,
    Wrapped<bool>? isSticky,
  }) {
    return ForumThreadBase(
      id: (id != null ? id.value : this.id),
      title: (title != null ? title.value : this.title),
      forumId: (forumId != null ? forumId.value : this.forumId),
      posts: (posts != null ? posts.value : this.posts),
      rating: (rating != null ? rating.value : this.rating),
      views: (views != null ? views.value : this.views),
      author: (author != null ? author.value : this.author),
      lastPoster: (lastPoster != null ? lastPoster.value : this.lastPoster),
      firstPostTime: (firstPostTime != null ? firstPostTime.value : this.firstPostTime),
      lastPostTime: (lastPostTime != null ? lastPostTime.value : this.lastPostTime),
      hasPoll: (hasPoll != null ? hasPoll.value : this.hasPoll),
      isLocked: (isLocked != null ? isLocked.value : this.isLocked),
      isSticky: (isSticky != null ? isSticky.value : this.isSticky),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ForumThreadExtended {
  const ForumThreadExtended({
    required this.content,
    required this.contentRaw,
    required this.poll,
    required this.id,
    required this.title,
    required this.forumId,
    required this.posts,
    required this.rating,
    required this.views,
    required this.author,
    required this.lastPoster,
    required this.firstPostTime,
    required this.lastPostTime,
    required this.hasPoll,
    required this.isLocked,
    required this.isSticky,
  });

  factory ForumThreadExtended.fromJson(Map<String, dynamic> json) => _$ForumThreadExtendedFromJson(json);

  static const toJsonFactory = _$ForumThreadExtendedToJson;
  Map<String, dynamic> toJson() => _$ForumThreadExtendedToJson(this);

  @JsonKey(name: 'content')
  final String content;
  @JsonKey(name: 'content_raw')
  final String contentRaw;
  @JsonKey(name: 'poll')
  final dynamic poll;
  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'title')
  final String title;
  @JsonKey(name: 'forum_id')
  final int forumId;
  @JsonKey(name: 'posts')
  final int posts;
  @JsonKey(name: 'rating')
  final int rating;
  @JsonKey(name: 'views')
  final int views;
  @JsonKey(name: 'author')
  final ForumThreadAuthor author;
  @JsonKey(name: 'last_poster')
  final dynamic lastPoster;
  @JsonKey(name: 'first_post_time')
  final int firstPostTime;
  @JsonKey(name: 'last_post_time')
  final dynamic lastPostTime;
  @JsonKey(name: 'has_poll')
  final bool hasPoll;
  @JsonKey(name: 'is_locked')
  final bool isLocked;
  @JsonKey(name: 'is_sticky')
  final bool isSticky;
  static const fromJsonFactory = _$ForumThreadExtendedFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ForumThreadExtended &&
            (identical(other.content, content) ||
                const DeepCollectionEquality().equals(
                  other.content,
                  content,
                )) &&
            (identical(other.contentRaw, contentRaw) ||
                const DeepCollectionEquality().equals(
                  other.contentRaw,
                  contentRaw,
                )) &&
            (identical(other.poll, poll) || const DeepCollectionEquality().equals(other.poll, poll)) &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.title, title) || const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.forumId, forumId) ||
                const DeepCollectionEquality().equals(
                  other.forumId,
                  forumId,
                )) &&
            (identical(other.posts, posts) || const DeepCollectionEquality().equals(other.posts, posts)) &&
            (identical(other.rating, rating) || const DeepCollectionEquality().equals(other.rating, rating)) &&
            (identical(other.views, views) || const DeepCollectionEquality().equals(other.views, views)) &&
            (identical(other.author, author) || const DeepCollectionEquality().equals(other.author, author)) &&
            (identical(other.lastPoster, lastPoster) ||
                const DeepCollectionEquality().equals(
                  other.lastPoster,
                  lastPoster,
                )) &&
            (identical(other.firstPostTime, firstPostTime) ||
                const DeepCollectionEquality().equals(
                  other.firstPostTime,
                  firstPostTime,
                )) &&
            (identical(other.lastPostTime, lastPostTime) ||
                const DeepCollectionEquality().equals(
                  other.lastPostTime,
                  lastPostTime,
                )) &&
            (identical(other.hasPoll, hasPoll) ||
                const DeepCollectionEquality().equals(
                  other.hasPoll,
                  hasPoll,
                )) &&
            (identical(other.isLocked, isLocked) ||
                const DeepCollectionEquality().equals(
                  other.isLocked,
                  isLocked,
                )) &&
            (identical(other.isSticky, isSticky) ||
                const DeepCollectionEquality().equals(
                  other.isSticky,
                  isSticky,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(content) ^
      const DeepCollectionEquality().hash(contentRaw) ^
      const DeepCollectionEquality().hash(poll) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(forumId) ^
      const DeepCollectionEquality().hash(posts) ^
      const DeepCollectionEquality().hash(rating) ^
      const DeepCollectionEquality().hash(views) ^
      const DeepCollectionEquality().hash(author) ^
      const DeepCollectionEquality().hash(lastPoster) ^
      const DeepCollectionEquality().hash(firstPostTime) ^
      const DeepCollectionEquality().hash(lastPostTime) ^
      const DeepCollectionEquality().hash(hasPoll) ^
      const DeepCollectionEquality().hash(isLocked) ^
      const DeepCollectionEquality().hash(isSticky) ^
      runtimeType.hashCode;
}

extension $ForumThreadExtendedExtension on ForumThreadExtended {
  ForumThreadExtended copyWith({
    String? content,
    String? contentRaw,
    dynamic poll,
    int? id,
    String? title,
    int? forumId,
    int? posts,
    int? rating,
    int? views,
    ForumThreadAuthor? author,
    dynamic lastPoster,
    int? firstPostTime,
    dynamic lastPostTime,
    bool? hasPoll,
    bool? isLocked,
    bool? isSticky,
  }) {
    return ForumThreadExtended(
      content: content ?? this.content,
      contentRaw: contentRaw ?? this.contentRaw,
      poll: poll ?? this.poll,
      id: id ?? this.id,
      title: title ?? this.title,
      forumId: forumId ?? this.forumId,
      posts: posts ?? this.posts,
      rating: rating ?? this.rating,
      views: views ?? this.views,
      author: author ?? this.author,
      lastPoster: lastPoster ?? this.lastPoster,
      firstPostTime: firstPostTime ?? this.firstPostTime,
      lastPostTime: lastPostTime ?? this.lastPostTime,
      hasPoll: hasPoll ?? this.hasPoll,
      isLocked: isLocked ?? this.isLocked,
      isSticky: isSticky ?? this.isSticky,
    );
  }

  ForumThreadExtended copyWithWrapped({
    Wrapped<String>? content,
    Wrapped<String>? contentRaw,
    Wrapped<dynamic>? poll,
    Wrapped<int>? id,
    Wrapped<String>? title,
    Wrapped<int>? forumId,
    Wrapped<int>? posts,
    Wrapped<int>? rating,
    Wrapped<int>? views,
    Wrapped<ForumThreadAuthor>? author,
    Wrapped<dynamic>? lastPoster,
    Wrapped<int>? firstPostTime,
    Wrapped<dynamic>? lastPostTime,
    Wrapped<bool>? hasPoll,
    Wrapped<bool>? isLocked,
    Wrapped<bool>? isSticky,
  }) {
    return ForumThreadExtended(
      content: (content != null ? content.value : this.content),
      contentRaw: (contentRaw != null ? contentRaw.value : this.contentRaw),
      poll: (poll != null ? poll.value : this.poll),
      id: (id != null ? id.value : this.id),
      title: (title != null ? title.value : this.title),
      forumId: (forumId != null ? forumId.value : this.forumId),
      posts: (posts != null ? posts.value : this.posts),
      rating: (rating != null ? rating.value : this.rating),
      views: (views != null ? views.value : this.views),
      author: (author != null ? author.value : this.author),
      lastPoster: (lastPoster != null ? lastPoster.value : this.lastPoster),
      firstPostTime: (firstPostTime != null ? firstPostTime.value : this.firstPostTime),
      lastPostTime: (lastPostTime != null ? lastPostTime.value : this.lastPostTime),
      hasPoll: (hasPoll != null ? hasPoll.value : this.hasPoll),
      isLocked: (isLocked != null ? isLocked.value : this.isLocked),
      isSticky: (isSticky != null ? isSticky.value : this.isSticky),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ForumPost {
  const ForumPost({
    required this.id,
    required this.threadId,
    required this.author,
    required this.isLegacy,
    required this.isTopic,
    required this.isEdited,
    required this.isPinned,
    required this.createdTime,
    required this.editedBy,
    required this.hasQuote,
    required this.quotedPostId,
    required this.content,
    required this.likes,
    required this.dislikes,
  });

  factory ForumPost.fromJson(Map<String, dynamic> json) => _$ForumPostFromJson(json);

  static const toJsonFactory = _$ForumPostToJson;
  Map<String, dynamic> toJson() => _$ForumPostToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'thread_id')
  final int threadId;
  @JsonKey(name: 'author')
  final ForumThreadAuthor author;
  @JsonKey(name: 'is_legacy')
  final bool isLegacy;
  @JsonKey(name: 'is_topic')
  final bool isTopic;
  @JsonKey(name: 'is_edited')
  final bool isEdited;
  @JsonKey(name: 'is_pinned')
  final bool isPinned;
  @JsonKey(name: 'created_time')
  final int createdTime;
  @JsonKey(name: 'edited_by')
  final dynamic editedBy;
  @JsonKey(name: 'has_quote')
  final bool hasQuote;
  @JsonKey(name: 'quoted_post_id')
  final dynamic quotedPostId;
  @JsonKey(name: 'content')
  final String content;
  @JsonKey(name: 'likes')
  final int likes;
  @JsonKey(name: 'dislikes')
  final int dislikes;
  static const fromJsonFactory = _$ForumPostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ForumPost &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.threadId, threadId) ||
                const DeepCollectionEquality().equals(
                  other.threadId,
                  threadId,
                )) &&
            (identical(other.author, author) || const DeepCollectionEquality().equals(other.author, author)) &&
            (identical(other.isLegacy, isLegacy) ||
                const DeepCollectionEquality().equals(
                  other.isLegacy,
                  isLegacy,
                )) &&
            (identical(other.isTopic, isTopic) ||
                const DeepCollectionEquality().equals(
                  other.isTopic,
                  isTopic,
                )) &&
            (identical(other.isEdited, isEdited) ||
                const DeepCollectionEquality().equals(
                  other.isEdited,
                  isEdited,
                )) &&
            (identical(other.isPinned, isPinned) ||
                const DeepCollectionEquality().equals(
                  other.isPinned,
                  isPinned,
                )) &&
            (identical(other.createdTime, createdTime) ||
                const DeepCollectionEquality().equals(
                  other.createdTime,
                  createdTime,
                )) &&
            (identical(other.editedBy, editedBy) ||
                const DeepCollectionEquality().equals(
                  other.editedBy,
                  editedBy,
                )) &&
            (identical(other.hasQuote, hasQuote) ||
                const DeepCollectionEquality().equals(
                  other.hasQuote,
                  hasQuote,
                )) &&
            (identical(other.quotedPostId, quotedPostId) ||
                const DeepCollectionEquality().equals(
                  other.quotedPostId,
                  quotedPostId,
                )) &&
            (identical(other.content, content) ||
                const DeepCollectionEquality().equals(
                  other.content,
                  content,
                )) &&
            (identical(other.likes, likes) || const DeepCollectionEquality().equals(other.likes, likes)) &&
            (identical(other.dislikes, dislikes) ||
                const DeepCollectionEquality().equals(
                  other.dislikes,
                  dislikes,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(threadId) ^
      const DeepCollectionEquality().hash(author) ^
      const DeepCollectionEquality().hash(isLegacy) ^
      const DeepCollectionEquality().hash(isTopic) ^
      const DeepCollectionEquality().hash(isEdited) ^
      const DeepCollectionEquality().hash(isPinned) ^
      const DeepCollectionEquality().hash(createdTime) ^
      const DeepCollectionEquality().hash(editedBy) ^
      const DeepCollectionEquality().hash(hasQuote) ^
      const DeepCollectionEquality().hash(quotedPostId) ^
      const DeepCollectionEquality().hash(content) ^
      const DeepCollectionEquality().hash(likes) ^
      const DeepCollectionEquality().hash(dislikes) ^
      runtimeType.hashCode;
}

extension $ForumPostExtension on ForumPost {
  ForumPost copyWith({
    int? id,
    int? threadId,
    ForumThreadAuthor? author,
    bool? isLegacy,
    bool? isTopic,
    bool? isEdited,
    bool? isPinned,
    int? createdTime,
    dynamic editedBy,
    bool? hasQuote,
    dynamic quotedPostId,
    String? content,
    int? likes,
    int? dislikes,
  }) {
    return ForumPost(
      id: id ?? this.id,
      threadId: threadId ?? this.threadId,
      author: author ?? this.author,
      isLegacy: isLegacy ?? this.isLegacy,
      isTopic: isTopic ?? this.isTopic,
      isEdited: isEdited ?? this.isEdited,
      isPinned: isPinned ?? this.isPinned,
      createdTime: createdTime ?? this.createdTime,
      editedBy: editedBy ?? this.editedBy,
      hasQuote: hasQuote ?? this.hasQuote,
      quotedPostId: quotedPostId ?? this.quotedPostId,
      content: content ?? this.content,
      likes: likes ?? this.likes,
      dislikes: dislikes ?? this.dislikes,
    );
  }

  ForumPost copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<int>? threadId,
    Wrapped<ForumThreadAuthor>? author,
    Wrapped<bool>? isLegacy,
    Wrapped<bool>? isTopic,
    Wrapped<bool>? isEdited,
    Wrapped<bool>? isPinned,
    Wrapped<int>? createdTime,
    Wrapped<dynamic>? editedBy,
    Wrapped<bool>? hasQuote,
    Wrapped<dynamic>? quotedPostId,
    Wrapped<String>? content,
    Wrapped<int>? likes,
    Wrapped<int>? dislikes,
  }) {
    return ForumPost(
      id: (id != null ? id.value : this.id),
      threadId: (threadId != null ? threadId.value : this.threadId),
      author: (author != null ? author.value : this.author),
      isLegacy: (isLegacy != null ? isLegacy.value : this.isLegacy),
      isTopic: (isTopic != null ? isTopic.value : this.isTopic),
      isEdited: (isEdited != null ? isEdited.value : this.isEdited),
      isPinned: (isPinned != null ? isPinned.value : this.isPinned),
      createdTime: (createdTime != null ? createdTime.value : this.createdTime),
      editedBy: (editedBy != null ? editedBy.value : this.editedBy),
      hasQuote: (hasQuote != null ? hasQuote.value : this.hasQuote),
      quotedPostId: (quotedPostId != null ? quotedPostId.value : this.quotedPostId),
      content: (content != null ? content.value : this.content),
      likes: (likes != null ? likes.value : this.likes),
      dislikes: (dislikes != null ? dislikes.value : this.dislikes),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ForumThreadUserExtended {
  const ForumThreadUserExtended({
    required this.newPosts,
    required this.id,
    required this.title,
    required this.forumId,
    required this.posts,
    required this.rating,
    required this.views,
    required this.author,
    required this.lastPoster,
    required this.firstPostTime,
    required this.lastPostTime,
    required this.hasPoll,
    required this.isLocked,
    required this.isSticky,
  });

  factory ForumThreadUserExtended.fromJson(Map<String, dynamic> json) => _$ForumThreadUserExtendedFromJson(json);

  static const toJsonFactory = _$ForumThreadUserExtendedToJson;
  Map<String, dynamic> toJson() => _$ForumThreadUserExtendedToJson(this);

  @JsonKey(name: 'new_posts')
  final dynamic newPosts;
  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'title')
  final String title;
  @JsonKey(name: 'forum_id')
  final int forumId;
  @JsonKey(name: 'posts')
  final int posts;
  @JsonKey(name: 'rating')
  final int rating;
  @JsonKey(name: 'views')
  final int views;
  @JsonKey(name: 'author')
  final ForumThreadAuthor author;
  @JsonKey(name: 'last_poster')
  final dynamic lastPoster;
  @JsonKey(name: 'first_post_time')
  final int firstPostTime;
  @JsonKey(name: 'last_post_time')
  final dynamic lastPostTime;
  @JsonKey(name: 'has_poll')
  final bool hasPoll;
  @JsonKey(name: 'is_locked')
  final bool isLocked;
  @JsonKey(name: 'is_sticky')
  final bool isSticky;
  static const fromJsonFactory = _$ForumThreadUserExtendedFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ForumThreadUserExtended &&
            (identical(other.newPosts, newPosts) ||
                const DeepCollectionEquality().equals(
                  other.newPosts,
                  newPosts,
                )) &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.title, title) || const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.forumId, forumId) ||
                const DeepCollectionEquality().equals(
                  other.forumId,
                  forumId,
                )) &&
            (identical(other.posts, posts) || const DeepCollectionEquality().equals(other.posts, posts)) &&
            (identical(other.rating, rating) || const DeepCollectionEquality().equals(other.rating, rating)) &&
            (identical(other.views, views) || const DeepCollectionEquality().equals(other.views, views)) &&
            (identical(other.author, author) || const DeepCollectionEquality().equals(other.author, author)) &&
            (identical(other.lastPoster, lastPoster) ||
                const DeepCollectionEquality().equals(
                  other.lastPoster,
                  lastPoster,
                )) &&
            (identical(other.firstPostTime, firstPostTime) ||
                const DeepCollectionEquality().equals(
                  other.firstPostTime,
                  firstPostTime,
                )) &&
            (identical(other.lastPostTime, lastPostTime) ||
                const DeepCollectionEquality().equals(
                  other.lastPostTime,
                  lastPostTime,
                )) &&
            (identical(other.hasPoll, hasPoll) ||
                const DeepCollectionEquality().equals(
                  other.hasPoll,
                  hasPoll,
                )) &&
            (identical(other.isLocked, isLocked) ||
                const DeepCollectionEquality().equals(
                  other.isLocked,
                  isLocked,
                )) &&
            (identical(other.isSticky, isSticky) ||
                const DeepCollectionEquality().equals(
                  other.isSticky,
                  isSticky,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(newPosts) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(forumId) ^
      const DeepCollectionEquality().hash(posts) ^
      const DeepCollectionEquality().hash(rating) ^
      const DeepCollectionEquality().hash(views) ^
      const DeepCollectionEquality().hash(author) ^
      const DeepCollectionEquality().hash(lastPoster) ^
      const DeepCollectionEquality().hash(firstPostTime) ^
      const DeepCollectionEquality().hash(lastPostTime) ^
      const DeepCollectionEquality().hash(hasPoll) ^
      const DeepCollectionEquality().hash(isLocked) ^
      const DeepCollectionEquality().hash(isSticky) ^
      runtimeType.hashCode;
}

extension $ForumThreadUserExtendedExtension on ForumThreadUserExtended {
  ForumThreadUserExtended copyWith({
    dynamic newPosts,
    int? id,
    String? title,
    int? forumId,
    int? posts,
    int? rating,
    int? views,
    ForumThreadAuthor? author,
    dynamic lastPoster,
    int? firstPostTime,
    dynamic lastPostTime,
    bool? hasPoll,
    bool? isLocked,
    bool? isSticky,
  }) {
    return ForumThreadUserExtended(
      newPosts: newPosts ?? this.newPosts,
      id: id ?? this.id,
      title: title ?? this.title,
      forumId: forumId ?? this.forumId,
      posts: posts ?? this.posts,
      rating: rating ?? this.rating,
      views: views ?? this.views,
      author: author ?? this.author,
      lastPoster: lastPoster ?? this.lastPoster,
      firstPostTime: firstPostTime ?? this.firstPostTime,
      lastPostTime: lastPostTime ?? this.lastPostTime,
      hasPoll: hasPoll ?? this.hasPoll,
      isLocked: isLocked ?? this.isLocked,
      isSticky: isSticky ?? this.isSticky,
    );
  }

  ForumThreadUserExtended copyWithWrapped({
    Wrapped<dynamic>? newPosts,
    Wrapped<int>? id,
    Wrapped<String>? title,
    Wrapped<int>? forumId,
    Wrapped<int>? posts,
    Wrapped<int>? rating,
    Wrapped<int>? views,
    Wrapped<ForumThreadAuthor>? author,
    Wrapped<dynamic>? lastPoster,
    Wrapped<int>? firstPostTime,
    Wrapped<dynamic>? lastPostTime,
    Wrapped<bool>? hasPoll,
    Wrapped<bool>? isLocked,
    Wrapped<bool>? isSticky,
  }) {
    return ForumThreadUserExtended(
      newPosts: (newPosts != null ? newPosts.value : this.newPosts),
      id: (id != null ? id.value : this.id),
      title: (title != null ? title.value : this.title),
      forumId: (forumId != null ? forumId.value : this.forumId),
      posts: (posts != null ? posts.value : this.posts),
      rating: (rating != null ? rating.value : this.rating),
      views: (views != null ? views.value : this.views),
      author: (author != null ? author.value : this.author),
      lastPoster: (lastPoster != null ? lastPoster.value : this.lastPoster),
      firstPostTime: (firstPostTime != null ? firstPostTime.value : this.firstPostTime),
      lastPostTime: (lastPostTime != null ? lastPostTime.value : this.lastPostTime),
      hasPoll: (hasPoll != null ? hasPoll.value : this.hasPoll),
      isLocked: (isLocked != null ? isLocked.value : this.isLocked),
      isSticky: (isSticky != null ? isSticky.value : this.isSticky),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ForumSubscribedThreadPostsCount {
  const ForumSubscribedThreadPostsCount({
    required this.$new,
    required this.total,
  });

  factory ForumSubscribedThreadPostsCount.fromJson(Map<String, dynamic> json) =>
      _$ForumSubscribedThreadPostsCountFromJson(json);

  static const toJsonFactory = _$ForumSubscribedThreadPostsCountToJson;
  Map<String, dynamic> toJson() => _$ForumSubscribedThreadPostsCountToJson(this);

  @JsonKey(name: 'new')
  final int $new;
  @JsonKey(name: 'total')
  final int total;
  static const fromJsonFactory = _$ForumSubscribedThreadPostsCountFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ForumSubscribedThreadPostsCount &&
            (identical(other.$new, $new) || const DeepCollectionEquality().equals(other.$new, $new)) &&
            (identical(other.total, total) || const DeepCollectionEquality().equals(other.total, total)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash($new) ^ const DeepCollectionEquality().hash(total) ^ runtimeType.hashCode;
}

extension $ForumSubscribedThreadPostsCountExtension on ForumSubscribedThreadPostsCount {
  ForumSubscribedThreadPostsCount copyWith({int? $new, int? total}) {
    return ForumSubscribedThreadPostsCount(
      $new: $new ?? this.$new,
      total: total ?? this.total,
    );
  }

  ForumSubscribedThreadPostsCount copyWithWrapped({
    Wrapped<int>? $new,
    Wrapped<int>? total,
  }) {
    return ForumSubscribedThreadPostsCount(
      $new: ($new != null ? $new.value : this.$new),
      total: (total != null ? total.value : this.total),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ForumSubscribedThread {
  const ForumSubscribedThread({
    required this.id,
    required this.forumId,
    required this.author,
    required this.title,
    required this.posts,
  });

  factory ForumSubscribedThread.fromJson(Map<String, dynamic> json) => _$ForumSubscribedThreadFromJson(json);

  static const toJsonFactory = _$ForumSubscribedThreadToJson;
  Map<String, dynamic> toJson() => _$ForumSubscribedThreadToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'forum_id')
  final int forumId;
  @JsonKey(name: 'author')
  final ForumThreadAuthor author;
  @JsonKey(name: 'title')
  final String title;
  @JsonKey(name: 'posts')
  final ForumSubscribedThreadPostsCount posts;
  static const fromJsonFactory = _$ForumSubscribedThreadFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ForumSubscribedThread &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.forumId, forumId) ||
                const DeepCollectionEquality().equals(
                  other.forumId,
                  forumId,
                )) &&
            (identical(other.author, author) || const DeepCollectionEquality().equals(other.author, author)) &&
            (identical(other.title, title) || const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.posts, posts) || const DeepCollectionEquality().equals(other.posts, posts)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(forumId) ^
      const DeepCollectionEquality().hash(author) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(posts) ^
      runtimeType.hashCode;
}

extension $ForumSubscribedThreadExtension on ForumSubscribedThread {
  ForumSubscribedThread copyWith({
    int? id,
    int? forumId,
    ForumThreadAuthor? author,
    String? title,
    ForumSubscribedThreadPostsCount? posts,
  }) {
    return ForumSubscribedThread(
      id: id ?? this.id,
      forumId: forumId ?? this.forumId,
      author: author ?? this.author,
      title: title ?? this.title,
      posts: posts ?? this.posts,
    );
  }

  ForumSubscribedThread copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<int>? forumId,
    Wrapped<ForumThreadAuthor>? author,
    Wrapped<String>? title,
    Wrapped<ForumSubscribedThreadPostsCount>? posts,
  }) {
    return ForumSubscribedThread(
      id: (id != null ? id.value : this.id),
      forumId: (forumId != null ? forumId.value : this.forumId),
      author: (author != null ? author.value : this.author),
      title: (title != null ? title.value : this.title),
      posts: (posts != null ? posts.value : this.posts),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ForumFeed {
  const ForumFeed({
    required this.threadId,
    required this.postId,
    required this.user,
    required this.title,
    required this.text,
    required this.timestamp,
    required this.isSeen,
    required this.type,
  });

  factory ForumFeed.fromJson(Map<String, dynamic> json) => _$ForumFeedFromJson(json);

  static const toJsonFactory = _$ForumFeedToJson;
  Map<String, dynamic> toJson() => _$ForumFeedToJson(this);

  @JsonKey(name: 'thread_id')
  final int threadId;
  @JsonKey(name: 'post_id')
  final int postId;
  @JsonKey(name: 'user')
  final ForumThreadAuthor user;
  @JsonKey(name: 'title')
  final String title;
  @JsonKey(name: 'text')
  final String text;
  @JsonKey(name: 'timestamp')
  final int timestamp;
  @JsonKey(name: 'is_seen')
  final bool isSeen;
  @JsonKey(
    name: 'type',
    toJson: forumFeedTypeEnumToJson,
    fromJson: forumFeedTypeEnumFromJson,
  )
  final enums.ForumFeedTypeEnum type;
  static const fromJsonFactory = _$ForumFeedFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ForumFeed &&
            (identical(other.threadId, threadId) ||
                const DeepCollectionEquality().equals(
                  other.threadId,
                  threadId,
                )) &&
            (identical(other.postId, postId) || const DeepCollectionEquality().equals(other.postId, postId)) &&
            (identical(other.user, user) || const DeepCollectionEquality().equals(other.user, user)) &&
            (identical(other.title, title) || const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.text, text) || const DeepCollectionEquality().equals(other.text, text)) &&
            (identical(other.timestamp, timestamp) ||
                const DeepCollectionEquality().equals(
                  other.timestamp,
                  timestamp,
                )) &&
            (identical(other.isSeen, isSeen) || const DeepCollectionEquality().equals(other.isSeen, isSeen)) &&
            (identical(other.type, type) || const DeepCollectionEquality().equals(other.type, type)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(threadId) ^
      const DeepCollectionEquality().hash(postId) ^
      const DeepCollectionEquality().hash(user) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(text) ^
      const DeepCollectionEquality().hash(timestamp) ^
      const DeepCollectionEquality().hash(isSeen) ^
      const DeepCollectionEquality().hash(type) ^
      runtimeType.hashCode;
}

extension $ForumFeedExtension on ForumFeed {
  ForumFeed copyWith({
    int? threadId,
    int? postId,
    ForumThreadAuthor? user,
    String? title,
    String? text,
    int? timestamp,
    bool? isSeen,
    enums.ForumFeedTypeEnum? type,
  }) {
    return ForumFeed(
      threadId: threadId ?? this.threadId,
      postId: postId ?? this.postId,
      user: user ?? this.user,
      title: title ?? this.title,
      text: text ?? this.text,
      timestamp: timestamp ?? this.timestamp,
      isSeen: isSeen ?? this.isSeen,
      type: type ?? this.type,
    );
  }

  ForumFeed copyWithWrapped({
    Wrapped<int>? threadId,
    Wrapped<int>? postId,
    Wrapped<ForumThreadAuthor>? user,
    Wrapped<String>? title,
    Wrapped<String>? text,
    Wrapped<int>? timestamp,
    Wrapped<bool>? isSeen,
    Wrapped<enums.ForumFeedTypeEnum>? type,
  }) {
    return ForumFeed(
      threadId: (threadId != null ? threadId.value : this.threadId),
      postId: (postId != null ? postId.value : this.postId),
      user: (user != null ? user.value : this.user),
      title: (title != null ? title.value : this.title),
      text: (text != null ? text.value : this.text),
      timestamp: (timestamp != null ? timestamp.value : this.timestamp),
      isSeen: (isSeen != null ? isSeen.value : this.isSeen),
      type: (type != null ? type.value : this.type),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ForumThreadsResponse {
  const ForumThreadsResponse({required this.threads, required this.metadata});

  factory ForumThreadsResponse.fromJson(Map<String, dynamic> json) => _$ForumThreadsResponseFromJson(json);

  static const toJsonFactory = _$ForumThreadsResponseToJson;
  Map<String, dynamic> toJson() => _$ForumThreadsResponseToJson(this);

  @JsonKey(name: 'threads', defaultValue: <ForumThreadBase>[])
  final List<ForumThreadBase> threads;
  @JsonKey(name: '_metadata')
  final RequestMetadataWithLinks metadata;
  static const fromJsonFactory = _$ForumThreadsResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ForumThreadsResponse &&
            (identical(other.threads, threads) ||
                const DeepCollectionEquality().equals(
                  other.threads,
                  threads,
                )) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality().equals(
                  other.metadata,
                  metadata,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(threads) ^
      const DeepCollectionEquality().hash(metadata) ^
      runtimeType.hashCode;
}

extension $ForumThreadsResponseExtension on ForumThreadsResponse {
  ForumThreadsResponse copyWith({
    List<ForumThreadBase>? threads,
    RequestMetadataWithLinks? metadata,
  }) {
    return ForumThreadsResponse(
      threads: threads ?? this.threads,
      metadata: metadata ?? this.metadata,
    );
  }

  ForumThreadsResponse copyWithWrapped({
    Wrapped<List<ForumThreadBase>>? threads,
    Wrapped<RequestMetadataWithLinks>? metadata,
  }) {
    return ForumThreadsResponse(
      threads: (threads != null ? threads.value : this.threads),
      metadata: (metadata != null ? metadata.value : this.metadata),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ForumThreadResponse {
  const ForumThreadResponse({required this.thread});

  factory ForumThreadResponse.fromJson(Map<String, dynamic> json) => _$ForumThreadResponseFromJson(json);

  static const toJsonFactory = _$ForumThreadResponseToJson;
  Map<String, dynamic> toJson() => _$ForumThreadResponseToJson(this);

  @JsonKey(name: 'thread')
  final ForumThreadExtended thread;
  static const fromJsonFactory = _$ForumThreadResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ForumThreadResponse &&
            (identical(other.thread, thread) || const DeepCollectionEquality().equals(other.thread, thread)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(thread) ^ runtimeType.hashCode;
}

extension $ForumThreadResponseExtension on ForumThreadResponse {
  ForumThreadResponse copyWith({ForumThreadExtended? thread}) {
    return ForumThreadResponse(thread: thread ?? this.thread);
  }

  ForumThreadResponse copyWithWrapped({Wrapped<ForumThreadExtended>? thread}) {
    return ForumThreadResponse(
      thread: (thread != null ? thread.value : this.thread),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ForumPostsResponse {
  const ForumPostsResponse({required this.posts, required this.metadata});

  factory ForumPostsResponse.fromJson(Map<String, dynamic> json) => _$ForumPostsResponseFromJson(json);

  static const toJsonFactory = _$ForumPostsResponseToJson;
  Map<String, dynamic> toJson() => _$ForumPostsResponseToJson(this);

  @JsonKey(name: 'posts', defaultValue: <ForumPost>[])
  final List<ForumPost> posts;
  @JsonKey(name: '_metadata')
  final RequestMetadataWithLinks metadata;
  static const fromJsonFactory = _$ForumPostsResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ForumPostsResponse &&
            (identical(other.posts, posts) || const DeepCollectionEquality().equals(other.posts, posts)) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality().equals(
                  other.metadata,
                  metadata,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(posts) ^ const DeepCollectionEquality().hash(metadata) ^ runtimeType.hashCode;
}

extension $ForumPostsResponseExtension on ForumPostsResponse {
  ForumPostsResponse copyWith({
    List<ForumPost>? posts,
    RequestMetadataWithLinks? metadata,
  }) {
    return ForumPostsResponse(
      posts: posts ?? this.posts,
      metadata: metadata ?? this.metadata,
    );
  }

  ForumPostsResponse copyWithWrapped({
    Wrapped<List<ForumPost>>? posts,
    Wrapped<RequestMetadataWithLinks>? metadata,
  }) {
    return ForumPostsResponse(
      posts: (posts != null ? posts.value : this.posts),
      metadata: (metadata != null ? metadata.value : this.metadata),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ForumSelectionName {
  const ForumSelectionName();

  factory ForumSelectionName.fromJson(Map<String, dynamic> json) => _$ForumSelectionNameFromJson(json);

  static const toJsonFactory = _$ForumSelectionNameToJson;
  Map<String, dynamic> toJson() => _$ForumSelectionNameToJson(this);

  static const fromJsonFactory = _$ForumSelectionNameFromJson;

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => runtimeType.hashCode;
}

@JsonSerializable(explicitToJson: true)
class ForumLookupResponse {
  const ForumLookupResponse({required this.selections});

  factory ForumLookupResponse.fromJson(Map<String, dynamic> json) => _$ForumLookupResponseFromJson(json);

  static const toJsonFactory = _$ForumLookupResponseToJson;
  Map<String, dynamic> toJson() => _$ForumLookupResponseToJson(this);

  @JsonKey(name: 'selections', defaultValue: <ForumSelectionName>[])
  final List<ForumSelectionName> selections;
  static const fromJsonFactory = _$ForumLookupResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ForumLookupResponse &&
            (identical(other.selections, selections) ||
                const DeepCollectionEquality().equals(
                  other.selections,
                  selections,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(selections) ^ runtimeType.hashCode;
}

extension $ForumLookupResponseExtension on ForumLookupResponse {
  ForumLookupResponse copyWith({List<ForumSelectionName>? selections}) {
    return ForumLookupResponse(selections: selections ?? this.selections);
  }

  ForumLookupResponse copyWithWrapped({
    Wrapped<List<ForumSelectionName>>? selections,
  }) {
    return ForumLookupResponse(
      selections: (selections != null ? selections.value : this.selections),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class KeyLogResponse {
  const KeyLogResponse({required this.log});

  factory KeyLogResponse.fromJson(Map<String, dynamic> json) => _$KeyLogResponseFromJson(json);

  static const toJsonFactory = _$KeyLogResponseToJson;
  Map<String, dynamic> toJson() => _$KeyLogResponseToJson(this);

  @JsonKey(name: 'log')
  final List<KeyLogResponse$Log$Item> log;
  static const fromJsonFactory = _$KeyLogResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is KeyLogResponse &&
            (identical(other.log, log) || const DeepCollectionEquality().equals(other.log, log)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(log) ^ runtimeType.hashCode;
}

extension $KeyLogResponseExtension on KeyLogResponse {
  KeyLogResponse copyWith({List<KeyLogResponse$Log$Item>? log}) {
    return KeyLogResponse(log: log ?? this.log);
  }

  KeyLogResponse copyWithWrapped({
    Wrapped<List<KeyLogResponse$Log$Item>>? log,
  }) {
    return KeyLogResponse(log: (log != null ? log.value : this.log));
  }
}

@JsonSerializable(explicitToJson: true)
class KeyInfoResponse {
  const KeyInfoResponse({required this.info});

  factory KeyInfoResponse.fromJson(Map<String, dynamic> json) => _$KeyInfoResponseFromJson(json);

  static const toJsonFactory = _$KeyInfoResponseToJson;
  Map<String, dynamic> toJson() => _$KeyInfoResponseToJson(this);

  @JsonKey(name: 'info')
  final KeyInfoResponse$Info info;
  static const fromJsonFactory = _$KeyInfoResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is KeyInfoResponse &&
            (identical(other.info, info) || const DeepCollectionEquality().equals(other.info, info)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(info) ^ runtimeType.hashCode;
}

extension $KeyInfoResponseExtension on KeyInfoResponse {
  KeyInfoResponse copyWith({KeyInfoResponse$Info? info}) {
    return KeyInfoResponse(info: info ?? this.info);
  }

  KeyInfoResponse copyWithWrapped({Wrapped<KeyInfoResponse$Info>? info}) {
    return KeyInfoResponse(info: (info != null ? info.value : this.info));
  }
}

@JsonSerializable(explicitToJson: true)
class KeySelectionName {
  const KeySelectionName();

  factory KeySelectionName.fromJson(Map<String, dynamic> json) => _$KeySelectionNameFromJson(json);

  static const toJsonFactory = _$KeySelectionNameToJson;
  Map<String, dynamic> toJson() => _$KeySelectionNameToJson(this);

  static const fromJsonFactory = _$KeySelectionNameFromJson;

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => runtimeType.hashCode;
}

@JsonSerializable(explicitToJson: true)
class BasicProperty {
  const BasicProperty({required this.id, required this.name});

  factory BasicProperty.fromJson(Map<String, dynamic> json) => _$BasicPropertyFromJson(json);

  static const toJsonFactory = _$BasicPropertyToJson;
  Map<String, dynamic> toJson() => _$BasicPropertyToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'name')
  final String name;
  static const fromJsonFactory = _$BasicPropertyFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BasicProperty &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^ const DeepCollectionEquality().hash(name) ^ runtimeType.hashCode;
}

extension $BasicPropertyExtension on BasicProperty {
  BasicProperty copyWith({int? id, String? name}) {
    return BasicProperty(id: id ?? this.id, name: name ?? this.name);
  }

  BasicProperty copyWithWrapped({Wrapped<int>? id, Wrapped<String>? name}) {
    return BasicProperty(
      id: (id != null ? id.value : this.id),
      name: (name != null ? name.value : this.name),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class MarketRentalDetails {
  const MarketRentalDetails({required this.listings, required this.property});

  factory MarketRentalDetails.fromJson(Map<String, dynamic> json) => _$MarketRentalDetailsFromJson(json);

  static const toJsonFactory = _$MarketRentalDetailsToJson;
  Map<String, dynamic> toJson() => _$MarketRentalDetailsToJson(this);

  @JsonKey(name: 'listings')
  final List<MarketRentalDetails$Listings$Item> listings;
  @JsonKey(name: 'property')
  final BasicProperty property;
  static const fromJsonFactory = _$MarketRentalDetailsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is MarketRentalDetails &&
            (identical(other.listings, listings) ||
                const DeepCollectionEquality().equals(
                  other.listings,
                  listings,
                )) &&
            (identical(other.property, property) ||
                const DeepCollectionEquality().equals(
                  other.property,
                  property,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(listings) ^
      const DeepCollectionEquality().hash(property) ^
      runtimeType.hashCode;
}

extension $MarketRentalDetailsExtension on MarketRentalDetails {
  MarketRentalDetails copyWith({
    List<MarketRentalDetails$Listings$Item>? listings,
    BasicProperty? property,
  }) {
    return MarketRentalDetails(
      listings: listings ?? this.listings,
      property: property ?? this.property,
    );
  }

  MarketRentalDetails copyWithWrapped({
    Wrapped<List<MarketRentalDetails$Listings$Item>>? listings,
    Wrapped<BasicProperty>? property,
  }) {
    return MarketRentalDetails(
      listings: (listings != null ? listings.value : this.listings),
      property: (property != null ? property.value : this.property),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class MarketRentalsResponse {
  const MarketRentalsResponse({
    required this.properties,
    required this.metadata,
  });

  factory MarketRentalsResponse.fromJson(Map<String, dynamic> json) => _$MarketRentalsResponseFromJson(json);

  static const toJsonFactory = _$MarketRentalsResponseToJson;
  Map<String, dynamic> toJson() => _$MarketRentalsResponseToJson(this);

  @JsonKey(name: 'properties')
  final MarketRentalDetails properties;
  @JsonKey(name: '_metadata')
  final RequestMetadataWithLinks metadata;
  static const fromJsonFactory = _$MarketRentalsResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is MarketRentalsResponse &&
            (identical(other.properties, properties) ||
                const DeepCollectionEquality().equals(
                  other.properties,
                  properties,
                )) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality().equals(
                  other.metadata,
                  metadata,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(properties) ^
      const DeepCollectionEquality().hash(metadata) ^
      runtimeType.hashCode;
}

extension $MarketRentalsResponseExtension on MarketRentalsResponse {
  MarketRentalsResponse copyWith({
    MarketRentalDetails? properties,
    RequestMetadataWithLinks? metadata,
  }) {
    return MarketRentalsResponse(
      properties: properties ?? this.properties,
      metadata: metadata ?? this.metadata,
    );
  }

  MarketRentalsResponse copyWithWrapped({
    Wrapped<MarketRentalDetails>? properties,
    Wrapped<RequestMetadataWithLinks>? metadata,
  }) {
    return MarketRentalsResponse(
      properties: (properties != null ? properties.value : this.properties),
      metadata: (metadata != null ? metadata.value : this.metadata),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class MarketPropertyDetails {
  const MarketPropertyDetails({required this.listings, required this.property});

  factory MarketPropertyDetails.fromJson(Map<String, dynamic> json) => _$MarketPropertyDetailsFromJson(json);

  static const toJsonFactory = _$MarketPropertyDetailsToJson;
  Map<String, dynamic> toJson() => _$MarketPropertyDetailsToJson(this);

  @JsonKey(name: 'listings')
  final List<MarketPropertyDetails$Listings$Item> listings;
  @JsonKey(name: 'property')
  final BasicProperty property;
  static const fromJsonFactory = _$MarketPropertyDetailsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is MarketPropertyDetails &&
            (identical(other.listings, listings) ||
                const DeepCollectionEquality().equals(
                  other.listings,
                  listings,
                )) &&
            (identical(other.property, property) ||
                const DeepCollectionEquality().equals(
                  other.property,
                  property,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(listings) ^
      const DeepCollectionEquality().hash(property) ^
      runtimeType.hashCode;
}

extension $MarketPropertyDetailsExtension on MarketPropertyDetails {
  MarketPropertyDetails copyWith({
    List<MarketPropertyDetails$Listings$Item>? listings,
    BasicProperty? property,
  }) {
    return MarketPropertyDetails(
      listings: listings ?? this.listings,
      property: property ?? this.property,
    );
  }

  MarketPropertyDetails copyWithWrapped({
    Wrapped<List<MarketPropertyDetails$Listings$Item>>? listings,
    Wrapped<BasicProperty>? property,
  }) {
    return MarketPropertyDetails(
      listings: (listings != null ? listings.value : this.listings),
      property: (property != null ? property.value : this.property),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class MarketPropertiesResponse {
  const MarketPropertiesResponse({
    required this.properties,
    required this.metadata,
  });

  factory MarketPropertiesResponse.fromJson(Map<String, dynamic> json) => _$MarketPropertiesResponseFromJson(json);

  static const toJsonFactory = _$MarketPropertiesResponseToJson;
  Map<String, dynamic> toJson() => _$MarketPropertiesResponseToJson(this);

  @JsonKey(name: 'properties')
  final MarketPropertyDetails properties;
  @JsonKey(name: '_metadata')
  final RequestMetadataWithLinks metadata;
  static const fromJsonFactory = _$MarketPropertiesResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is MarketPropertiesResponse &&
            (identical(other.properties, properties) ||
                const DeepCollectionEquality().equals(
                  other.properties,
                  properties,
                )) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality().equals(
                  other.metadata,
                  metadata,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(properties) ^
      const DeepCollectionEquality().hash(metadata) ^
      runtimeType.hashCode;
}

extension $MarketPropertiesResponseExtension on MarketPropertiesResponse {
  MarketPropertiesResponse copyWith({
    MarketPropertyDetails? properties,
    RequestMetadataWithLinks? metadata,
  }) {
    return MarketPropertiesResponse(
      properties: properties ?? this.properties,
      metadata: metadata ?? this.metadata,
    );
  }

  MarketPropertiesResponse copyWithWrapped({
    Wrapped<MarketPropertyDetails>? properties,
    Wrapped<RequestMetadataWithLinks>? metadata,
  }) {
    return MarketPropertiesResponse(
      properties: (properties != null ? properties.value : this.properties),
      metadata: (metadata != null ? metadata.value : this.metadata),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class BazaarWeekly {
  const BazaarWeekly({
    required this.busiest,
    required this.mostPopular,
    required this.trending,
    required this.topGrossing,
    required this.bulk,
    required this.advancedItem,
    required this.bargain,
    required this.dollarSale,
  });

  factory BazaarWeekly.fromJson(Map<String, dynamic> json) => _$BazaarWeeklyFromJson(json);

  static const toJsonFactory = _$BazaarWeeklyToJson;
  Map<String, dynamic> toJson() => _$BazaarWeeklyToJson(this);

  @JsonKey(name: 'busiest', defaultValue: <BazaarWeeklyCustomers>[])
  final List<BazaarWeeklyCustomers> busiest;
  @JsonKey(name: 'most_popular', defaultValue: <BazaarTotalFavorites>[])
  final List<BazaarTotalFavorites> mostPopular;
  @JsonKey(name: 'trending', defaultValue: <BazaarRecentFavorites>[])
  final List<BazaarRecentFavorites> trending;
  @JsonKey(name: 'top_grossing', defaultValue: <BazaarWeeklyIncome>[])
  final List<BazaarWeeklyIncome> topGrossing;
  @JsonKey(name: 'bulk', defaultValue: <BazaarBulkSales>[])
  final List<BazaarBulkSales> bulk;
  @JsonKey(name: 'advanced_item', defaultValue: <BazaarAdvancedItemSales>[])
  final List<BazaarAdvancedItemSales> advancedItem;
  @JsonKey(name: 'bargain', defaultValue: <BazaarBargainSales>[])
  final List<BazaarBargainSales> bargain;
  @JsonKey(name: 'dollar_sale', defaultValue: <BazaarDollarSales>[])
  final List<BazaarDollarSales> dollarSale;
  static const fromJsonFactory = _$BazaarWeeklyFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BazaarWeekly &&
            (identical(other.busiest, busiest) ||
                const DeepCollectionEquality().equals(
                  other.busiest,
                  busiest,
                )) &&
            (identical(other.mostPopular, mostPopular) ||
                const DeepCollectionEquality().equals(
                  other.mostPopular,
                  mostPopular,
                )) &&
            (identical(other.trending, trending) ||
                const DeepCollectionEquality().equals(
                  other.trending,
                  trending,
                )) &&
            (identical(other.topGrossing, topGrossing) ||
                const DeepCollectionEquality().equals(
                  other.topGrossing,
                  topGrossing,
                )) &&
            (identical(other.bulk, bulk) || const DeepCollectionEquality().equals(other.bulk, bulk)) &&
            (identical(other.advancedItem, advancedItem) ||
                const DeepCollectionEquality().equals(
                  other.advancedItem,
                  advancedItem,
                )) &&
            (identical(other.bargain, bargain) ||
                const DeepCollectionEquality().equals(
                  other.bargain,
                  bargain,
                )) &&
            (identical(other.dollarSale, dollarSale) ||
                const DeepCollectionEquality().equals(
                  other.dollarSale,
                  dollarSale,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(busiest) ^
      const DeepCollectionEquality().hash(mostPopular) ^
      const DeepCollectionEquality().hash(trending) ^
      const DeepCollectionEquality().hash(topGrossing) ^
      const DeepCollectionEquality().hash(bulk) ^
      const DeepCollectionEquality().hash(advancedItem) ^
      const DeepCollectionEquality().hash(bargain) ^
      const DeepCollectionEquality().hash(dollarSale) ^
      runtimeType.hashCode;
}

extension $BazaarWeeklyExtension on BazaarWeekly {
  BazaarWeekly copyWith({
    List<BazaarWeeklyCustomers>? busiest,
    List<BazaarTotalFavorites>? mostPopular,
    List<BazaarRecentFavorites>? trending,
    List<BazaarWeeklyIncome>? topGrossing,
    List<BazaarBulkSales>? bulk,
    List<BazaarAdvancedItemSales>? advancedItem,
    List<BazaarBargainSales>? bargain,
    List<BazaarDollarSales>? dollarSale,
  }) {
    return BazaarWeekly(
      busiest: busiest ?? this.busiest,
      mostPopular: mostPopular ?? this.mostPopular,
      trending: trending ?? this.trending,
      topGrossing: topGrossing ?? this.topGrossing,
      bulk: bulk ?? this.bulk,
      advancedItem: advancedItem ?? this.advancedItem,
      bargain: bargain ?? this.bargain,
      dollarSale: dollarSale ?? this.dollarSale,
    );
  }

  BazaarWeekly copyWithWrapped({
    Wrapped<List<BazaarWeeklyCustomers>>? busiest,
    Wrapped<List<BazaarTotalFavorites>>? mostPopular,
    Wrapped<List<BazaarRecentFavorites>>? trending,
    Wrapped<List<BazaarWeeklyIncome>>? topGrossing,
    Wrapped<List<BazaarBulkSales>>? bulk,
    Wrapped<List<BazaarAdvancedItemSales>>? advancedItem,
    Wrapped<List<BazaarBargainSales>>? bargain,
    Wrapped<List<BazaarDollarSales>>? dollarSale,
  }) {
    return BazaarWeekly(
      busiest: (busiest != null ? busiest.value : this.busiest),
      mostPopular: (mostPopular != null ? mostPopular.value : this.mostPopular),
      trending: (trending != null ? trending.value : this.trending),
      topGrossing: (topGrossing != null ? topGrossing.value : this.topGrossing),
      bulk: (bulk != null ? bulk.value : this.bulk),
      advancedItem: (advancedItem != null ? advancedItem.value : this.advancedItem),
      bargain: (bargain != null ? bargain.value : this.bargain),
      dollarSale: (dollarSale != null ? dollarSale.value : this.dollarSale),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class BazaarSpecialized {
  const BazaarSpecialized({required this.specialized});

  factory BazaarSpecialized.fromJson(Map<String, dynamic> json) => _$BazaarSpecializedFromJson(json);

  static const toJsonFactory = _$BazaarSpecializedToJson;
  Map<String, dynamic> toJson() => _$BazaarSpecializedToJson(this);

  @JsonKey(name: 'specialized', defaultValue: <BazaarWeeklyCustomers>[])
  final List<BazaarWeeklyCustomers> specialized;
  static const fromJsonFactory = _$BazaarSpecializedFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BazaarSpecialized &&
            (identical(other.specialized, specialized) ||
                const DeepCollectionEquality().equals(
                  other.specialized,
                  specialized,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(specialized) ^ runtimeType.hashCode;
}

extension $BazaarSpecializedExtension on BazaarSpecialized {
  BazaarSpecialized copyWith({List<BazaarWeeklyCustomers>? specialized}) {
    return BazaarSpecialized(specialized: specialized ?? this.specialized);
  }

  BazaarSpecialized copyWithWrapped({
    Wrapped<List<BazaarWeeklyCustomers>>? specialized,
  }) {
    return BazaarSpecialized(
      specialized: (specialized != null ? specialized.value : this.specialized),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class BazaarResponse {
  const BazaarResponse({required this.bazaar});

  factory BazaarResponse.fromJson(Map<String, dynamic> json) => _$BazaarResponseFromJson(json);

  static const toJsonFactory = _$BazaarResponseToJson;
  Map<String, dynamic> toJson() => _$BazaarResponseToJson(this);

  @JsonKey(name: 'bazaar')
  final dynamic bazaar;
  static const fromJsonFactory = _$BazaarResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BazaarResponse &&
            (identical(other.bazaar, bazaar) || const DeepCollectionEquality().equals(other.bazaar, bazaar)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(bazaar) ^ runtimeType.hashCode;
}

extension $BazaarResponseExtension on BazaarResponse {
  BazaarResponse copyWith({dynamic bazaar}) {
    return BazaarResponse(bazaar: bazaar ?? this.bazaar);
  }

  BazaarResponse copyWithWrapped({Wrapped<dynamic>? bazaar}) {
    return BazaarResponse(
      bazaar: (bazaar != null ? bazaar.value : this.bazaar),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class BazaarResponseSpecialized {
  const BazaarResponseSpecialized({required this.bazaar});

  factory BazaarResponseSpecialized.fromJson(Map<String, dynamic> json) => _$BazaarResponseSpecializedFromJson(json);

  static const toJsonFactory = _$BazaarResponseSpecializedToJson;
  Map<String, dynamic> toJson() => _$BazaarResponseSpecializedToJson(this);

  @JsonKey(name: 'bazaar')
  final BazaarSpecialized bazaar;
  static const fromJsonFactory = _$BazaarResponseSpecializedFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BazaarResponseSpecialized &&
            (identical(other.bazaar, bazaar) || const DeepCollectionEquality().equals(other.bazaar, bazaar)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(bazaar) ^ runtimeType.hashCode;
}

extension $BazaarResponseSpecializedExtension on BazaarResponseSpecialized {
  BazaarResponseSpecialized copyWith({BazaarSpecialized? bazaar}) {
    return BazaarResponseSpecialized(bazaar: bazaar ?? this.bazaar);
  }

  BazaarResponseSpecialized copyWithWrapped({
    Wrapped<BazaarSpecialized>? bazaar,
  }) {
    return BazaarResponseSpecialized(
      bazaar: (bazaar != null ? bazaar.value : this.bazaar),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class Bazaar {
  const Bazaar({required this.id, required this.name, required this.isOpen});

  factory Bazaar.fromJson(Map<String, dynamic> json) => _$BazaarFromJson(json);

  static const toJsonFactory = _$BazaarToJson;
  Map<String, dynamic> toJson() => _$BazaarToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'is_open')
  final bool isOpen;
  static const fromJsonFactory = _$BazaarFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Bazaar &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.isOpen, isOpen) || const DeepCollectionEquality().equals(other.isOpen, isOpen)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(isOpen) ^
      runtimeType.hashCode;
}

extension $BazaarExtension on Bazaar {
  Bazaar copyWith({int? id, String? name, bool? isOpen}) {
    return Bazaar(
      id: id ?? this.id,
      name: name ?? this.name,
      isOpen: isOpen ?? this.isOpen,
    );
  }

  Bazaar copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<String>? name,
    Wrapped<bool>? isOpen,
  }) {
    return Bazaar(
      id: (id != null ? id.value : this.id),
      name: (name != null ? name.value : this.name),
      isOpen: (isOpen != null ? isOpen.value : this.isOpen),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class BazaarWeeklyCustomers {
  const BazaarWeeklyCustomers({
    required this.weeklyCustomers,
    required this.id,
    required this.name,
    required this.isOpen,
  });

  factory BazaarWeeklyCustomers.fromJson(Map<String, dynamic> json) => _$BazaarWeeklyCustomersFromJson(json);

  static const toJsonFactory = _$BazaarWeeklyCustomersToJson;
  Map<String, dynamic> toJson() => _$BazaarWeeklyCustomersToJson(this);

  @JsonKey(name: 'weekly_customers')
  final int weeklyCustomers;
  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'is_open')
  final bool isOpen;
  static const fromJsonFactory = _$BazaarWeeklyCustomersFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BazaarWeeklyCustomers &&
            (identical(other.weeklyCustomers, weeklyCustomers) ||
                const DeepCollectionEquality().equals(
                  other.weeklyCustomers,
                  weeklyCustomers,
                )) &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.isOpen, isOpen) || const DeepCollectionEquality().equals(other.isOpen, isOpen)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(weeklyCustomers) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(isOpen) ^
      runtimeType.hashCode;
}

extension $BazaarWeeklyCustomersExtension on BazaarWeeklyCustomers {
  BazaarWeeklyCustomers copyWith({
    int? weeklyCustomers,
    int? id,
    String? name,
    bool? isOpen,
  }) {
    return BazaarWeeklyCustomers(
      weeklyCustomers: weeklyCustomers ?? this.weeklyCustomers,
      id: id ?? this.id,
      name: name ?? this.name,
      isOpen: isOpen ?? this.isOpen,
    );
  }

  BazaarWeeklyCustomers copyWithWrapped({
    Wrapped<int>? weeklyCustomers,
    Wrapped<int>? id,
    Wrapped<String>? name,
    Wrapped<bool>? isOpen,
  }) {
    return BazaarWeeklyCustomers(
      weeklyCustomers: (weeklyCustomers != null ? weeklyCustomers.value : this.weeklyCustomers),
      id: (id != null ? id.value : this.id),
      name: (name != null ? name.value : this.name),
      isOpen: (isOpen != null ? isOpen.value : this.isOpen),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class BazaarTotalFavorites {
  const BazaarTotalFavorites({
    required this.totalFavorites,
    required this.id,
    required this.name,
    required this.isOpen,
  });

  factory BazaarTotalFavorites.fromJson(Map<String, dynamic> json) => _$BazaarTotalFavoritesFromJson(json);

  static const toJsonFactory = _$BazaarTotalFavoritesToJson;
  Map<String, dynamic> toJson() => _$BazaarTotalFavoritesToJson(this);

  @JsonKey(name: 'total_favorites')
  final int totalFavorites;
  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'is_open')
  final bool isOpen;
  static const fromJsonFactory = _$BazaarTotalFavoritesFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BazaarTotalFavorites &&
            (identical(other.totalFavorites, totalFavorites) ||
                const DeepCollectionEquality().equals(
                  other.totalFavorites,
                  totalFavorites,
                )) &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.isOpen, isOpen) || const DeepCollectionEquality().equals(other.isOpen, isOpen)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(totalFavorites) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(isOpen) ^
      runtimeType.hashCode;
}

extension $BazaarTotalFavoritesExtension on BazaarTotalFavorites {
  BazaarTotalFavorites copyWith({
    int? totalFavorites,
    int? id,
    String? name,
    bool? isOpen,
  }) {
    return BazaarTotalFavorites(
      totalFavorites: totalFavorites ?? this.totalFavorites,
      id: id ?? this.id,
      name: name ?? this.name,
      isOpen: isOpen ?? this.isOpen,
    );
  }

  BazaarTotalFavorites copyWithWrapped({
    Wrapped<int>? totalFavorites,
    Wrapped<int>? id,
    Wrapped<String>? name,
    Wrapped<bool>? isOpen,
  }) {
    return BazaarTotalFavorites(
      totalFavorites: (totalFavorites != null ? totalFavorites.value : this.totalFavorites),
      id: (id != null ? id.value : this.id),
      name: (name != null ? name.value : this.name),
      isOpen: (isOpen != null ? isOpen.value : this.isOpen),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class BazaarRecentFavorites {
  const BazaarRecentFavorites({
    required this.recentFavorites,
    required this.id,
    required this.name,
    required this.isOpen,
  });

  factory BazaarRecentFavorites.fromJson(Map<String, dynamic> json) => _$BazaarRecentFavoritesFromJson(json);

  static const toJsonFactory = _$BazaarRecentFavoritesToJson;
  Map<String, dynamic> toJson() => _$BazaarRecentFavoritesToJson(this);

  @JsonKey(name: 'recent_favorites')
  final int recentFavorites;
  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'is_open')
  final bool isOpen;
  static const fromJsonFactory = _$BazaarRecentFavoritesFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BazaarRecentFavorites &&
            (identical(other.recentFavorites, recentFavorites) ||
                const DeepCollectionEquality().equals(
                  other.recentFavorites,
                  recentFavorites,
                )) &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.isOpen, isOpen) || const DeepCollectionEquality().equals(other.isOpen, isOpen)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(recentFavorites) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(isOpen) ^
      runtimeType.hashCode;
}

extension $BazaarRecentFavoritesExtension on BazaarRecentFavorites {
  BazaarRecentFavorites copyWith({
    int? recentFavorites,
    int? id,
    String? name,
    bool? isOpen,
  }) {
    return BazaarRecentFavorites(
      recentFavorites: recentFavorites ?? this.recentFavorites,
      id: id ?? this.id,
      name: name ?? this.name,
      isOpen: isOpen ?? this.isOpen,
    );
  }

  BazaarRecentFavorites copyWithWrapped({
    Wrapped<int>? recentFavorites,
    Wrapped<int>? id,
    Wrapped<String>? name,
    Wrapped<bool>? isOpen,
  }) {
    return BazaarRecentFavorites(
      recentFavorites: (recentFavorites != null ? recentFavorites.value : this.recentFavorites),
      id: (id != null ? id.value : this.id),
      name: (name != null ? name.value : this.name),
      isOpen: (isOpen != null ? isOpen.value : this.isOpen),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class BazaarWeeklyIncome {
  const BazaarWeeklyIncome({
    required this.weeklyIncome,
    required this.id,
    required this.name,
    required this.isOpen,
  });

  factory BazaarWeeklyIncome.fromJson(Map<String, dynamic> json) => _$BazaarWeeklyIncomeFromJson(json);

  static const toJsonFactory = _$BazaarWeeklyIncomeToJson;
  Map<String, dynamic> toJson() => _$BazaarWeeklyIncomeToJson(this);

  @JsonKey(name: 'weekly_income')
  final int weeklyIncome;
  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'is_open')
  final bool isOpen;
  static const fromJsonFactory = _$BazaarWeeklyIncomeFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BazaarWeeklyIncome &&
            (identical(other.weeklyIncome, weeklyIncome) ||
                const DeepCollectionEquality().equals(
                  other.weeklyIncome,
                  weeklyIncome,
                )) &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.isOpen, isOpen) || const DeepCollectionEquality().equals(other.isOpen, isOpen)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(weeklyIncome) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(isOpen) ^
      runtimeType.hashCode;
}

extension $BazaarWeeklyIncomeExtension on BazaarWeeklyIncome {
  BazaarWeeklyIncome copyWith({
    int? weeklyIncome,
    int? id,
    String? name,
    bool? isOpen,
  }) {
    return BazaarWeeklyIncome(
      weeklyIncome: weeklyIncome ?? this.weeklyIncome,
      id: id ?? this.id,
      name: name ?? this.name,
      isOpen: isOpen ?? this.isOpen,
    );
  }

  BazaarWeeklyIncome copyWithWrapped({
    Wrapped<int>? weeklyIncome,
    Wrapped<int>? id,
    Wrapped<String>? name,
    Wrapped<bool>? isOpen,
  }) {
    return BazaarWeeklyIncome(
      weeklyIncome: (weeklyIncome != null ? weeklyIncome.value : this.weeklyIncome),
      id: (id != null ? id.value : this.id),
      name: (name != null ? name.value : this.name),
      isOpen: (isOpen != null ? isOpen.value : this.isOpen),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class BazaarBulkSales {
  const BazaarBulkSales({
    required this.bulkSales,
    required this.id,
    required this.name,
    required this.isOpen,
  });

  factory BazaarBulkSales.fromJson(Map<String, dynamic> json) => _$BazaarBulkSalesFromJson(json);

  static const toJsonFactory = _$BazaarBulkSalesToJson;
  Map<String, dynamic> toJson() => _$BazaarBulkSalesToJson(this);

  @JsonKey(name: 'bulk_sales')
  final int bulkSales;
  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'is_open')
  final bool isOpen;
  static const fromJsonFactory = _$BazaarBulkSalesFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BazaarBulkSales &&
            (identical(other.bulkSales, bulkSales) ||
                const DeepCollectionEquality().equals(
                  other.bulkSales,
                  bulkSales,
                )) &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.isOpen, isOpen) || const DeepCollectionEquality().equals(other.isOpen, isOpen)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(bulkSales) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(isOpen) ^
      runtimeType.hashCode;
}

extension $BazaarBulkSalesExtension on BazaarBulkSales {
  BazaarBulkSales copyWith({
    int? bulkSales,
    int? id,
    String? name,
    bool? isOpen,
  }) {
    return BazaarBulkSales(
      bulkSales: bulkSales ?? this.bulkSales,
      id: id ?? this.id,
      name: name ?? this.name,
      isOpen: isOpen ?? this.isOpen,
    );
  }

  BazaarBulkSales copyWithWrapped({
    Wrapped<int>? bulkSales,
    Wrapped<int>? id,
    Wrapped<String>? name,
    Wrapped<bool>? isOpen,
  }) {
    return BazaarBulkSales(
      bulkSales: (bulkSales != null ? bulkSales.value : this.bulkSales),
      id: (id != null ? id.value : this.id),
      name: (name != null ? name.value : this.name),
      isOpen: (isOpen != null ? isOpen.value : this.isOpen),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class BazaarAdvancedItemSales {
  const BazaarAdvancedItemSales({
    required this.advancedItemSales,
    required this.id,
    required this.name,
    required this.isOpen,
  });

  factory BazaarAdvancedItemSales.fromJson(Map<String, dynamic> json) => _$BazaarAdvancedItemSalesFromJson(json);

  static const toJsonFactory = _$BazaarAdvancedItemSalesToJson;
  Map<String, dynamic> toJson() => _$BazaarAdvancedItemSalesToJson(this);

  @JsonKey(name: 'advanced_item_sales')
  final int advancedItemSales;
  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'is_open')
  final bool isOpen;
  static const fromJsonFactory = _$BazaarAdvancedItemSalesFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BazaarAdvancedItemSales &&
            (identical(other.advancedItemSales, advancedItemSales) ||
                const DeepCollectionEquality().equals(
                  other.advancedItemSales,
                  advancedItemSales,
                )) &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.isOpen, isOpen) || const DeepCollectionEquality().equals(other.isOpen, isOpen)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(advancedItemSales) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(isOpen) ^
      runtimeType.hashCode;
}

extension $BazaarAdvancedItemSalesExtension on BazaarAdvancedItemSales {
  BazaarAdvancedItemSales copyWith({
    int? advancedItemSales,
    int? id,
    String? name,
    bool? isOpen,
  }) {
    return BazaarAdvancedItemSales(
      advancedItemSales: advancedItemSales ?? this.advancedItemSales,
      id: id ?? this.id,
      name: name ?? this.name,
      isOpen: isOpen ?? this.isOpen,
    );
  }

  BazaarAdvancedItemSales copyWithWrapped({
    Wrapped<int>? advancedItemSales,
    Wrapped<int>? id,
    Wrapped<String>? name,
    Wrapped<bool>? isOpen,
  }) {
    return BazaarAdvancedItemSales(
      advancedItemSales: (advancedItemSales != null ? advancedItemSales.value : this.advancedItemSales),
      id: (id != null ? id.value : this.id),
      name: (name != null ? name.value : this.name),
      isOpen: (isOpen != null ? isOpen.value : this.isOpen),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class BazaarBargainSales {
  const BazaarBargainSales({
    required this.bargainSales,
    required this.id,
    required this.name,
    required this.isOpen,
  });

  factory BazaarBargainSales.fromJson(Map<String, dynamic> json) => _$BazaarBargainSalesFromJson(json);

  static const toJsonFactory = _$BazaarBargainSalesToJson;
  Map<String, dynamic> toJson() => _$BazaarBargainSalesToJson(this);

  @JsonKey(name: 'bargain_sales')
  final int bargainSales;
  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'is_open')
  final bool isOpen;
  static const fromJsonFactory = _$BazaarBargainSalesFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BazaarBargainSales &&
            (identical(other.bargainSales, bargainSales) ||
                const DeepCollectionEquality().equals(
                  other.bargainSales,
                  bargainSales,
                )) &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.isOpen, isOpen) || const DeepCollectionEquality().equals(other.isOpen, isOpen)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(bargainSales) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(isOpen) ^
      runtimeType.hashCode;
}

extension $BazaarBargainSalesExtension on BazaarBargainSales {
  BazaarBargainSales copyWith({
    int? bargainSales,
    int? id,
    String? name,
    bool? isOpen,
  }) {
    return BazaarBargainSales(
      bargainSales: bargainSales ?? this.bargainSales,
      id: id ?? this.id,
      name: name ?? this.name,
      isOpen: isOpen ?? this.isOpen,
    );
  }

  BazaarBargainSales copyWithWrapped({
    Wrapped<int>? bargainSales,
    Wrapped<int>? id,
    Wrapped<String>? name,
    Wrapped<bool>? isOpen,
  }) {
    return BazaarBargainSales(
      bargainSales: (bargainSales != null ? bargainSales.value : this.bargainSales),
      id: (id != null ? id.value : this.id),
      name: (name != null ? name.value : this.name),
      isOpen: (isOpen != null ? isOpen.value : this.isOpen),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class BazaarDollarSales {
  const BazaarDollarSales({
    required this.dollarSales,
    required this.id,
    required this.name,
    required this.isOpen,
  });

  factory BazaarDollarSales.fromJson(Map<String, dynamic> json) => _$BazaarDollarSalesFromJson(json);

  static const toJsonFactory = _$BazaarDollarSalesToJson;
  Map<String, dynamic> toJson() => _$BazaarDollarSalesToJson(this);

  @JsonKey(name: 'dollar_sales')
  final int dollarSales;
  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'is_open')
  final bool isOpen;
  static const fromJsonFactory = _$BazaarDollarSalesFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BazaarDollarSales &&
            (identical(other.dollarSales, dollarSales) ||
                const DeepCollectionEquality().equals(
                  other.dollarSales,
                  dollarSales,
                )) &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.isOpen, isOpen) || const DeepCollectionEquality().equals(other.isOpen, isOpen)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(dollarSales) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(isOpen) ^
      runtimeType.hashCode;
}

extension $BazaarDollarSalesExtension on BazaarDollarSales {
  BazaarDollarSales copyWith({
    int? dollarSales,
    int? id,
    String? name,
    bool? isOpen,
  }) {
    return BazaarDollarSales(
      dollarSales: dollarSales ?? this.dollarSales,
      id: id ?? this.id,
      name: name ?? this.name,
      isOpen: isOpen ?? this.isOpen,
    );
  }

  BazaarDollarSales copyWithWrapped({
    Wrapped<int>? dollarSales,
    Wrapped<int>? id,
    Wrapped<String>? name,
    Wrapped<bool>? isOpen,
  }) {
    return BazaarDollarSales(
      dollarSales: (dollarSales != null ? dollarSales.value : this.dollarSales),
      id: (id != null ? id.value : this.id),
      name: (name != null ? name.value : this.name),
      isOpen: (isOpen != null ? isOpen.value : this.isOpen),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ItemMarketListingItemBonus {
  const ItemMarketListingItemBonus({
    required this.id,
    required this.title,
    required this.description,
    required this.$value,
  });

  factory ItemMarketListingItemBonus.fromJson(Map<String, dynamic> json) => _$ItemMarketListingItemBonusFromJson(json);

  static const toJsonFactory = _$ItemMarketListingItemBonusToJson;
  Map<String, dynamic> toJson() => _$ItemMarketListingItemBonusToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'title')
  final String title;
  @JsonKey(name: 'description')
  final String description;
  @JsonKey(name: 'value')
  final int $value;
  static const fromJsonFactory = _$ItemMarketListingItemBonusFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ItemMarketListingItemBonus &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.title, title) || const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.$value, $value) || const DeepCollectionEquality().equals(other.$value, $value)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash($value) ^
      runtimeType.hashCode;
}

extension $ItemMarketListingItemBonusExtension on ItemMarketListingItemBonus {
  ItemMarketListingItemBonus copyWith({
    int? id,
    String? title,
    String? description,
    int? $value,
  }) {
    return ItemMarketListingItemBonus(
      id: id ?? this.id,
      title: title ?? this.title,
      description: description ?? this.description,
      $value: $value ?? this.$value,
    );
  }

  ItemMarketListingItemBonus copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<String>? title,
    Wrapped<String>? description,
    Wrapped<int>? $value,
  }) {
    return ItemMarketListingItemBonus(
      id: (id != null ? id.value : this.id),
      title: (title != null ? title.value : this.title),
      description: (description != null ? description.value : this.description),
      $value: ($value != null ? $value.value : this.$value),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ItemMarketListingItemStats {
  const ItemMarketListingItemStats({
    required this.damage,
    required this.accuracy,
    required this.armor,
    required this.quality,
  });

  factory ItemMarketListingItemStats.fromJson(Map<String, dynamic> json) => _$ItemMarketListingItemStatsFromJson(json);

  static const toJsonFactory = _$ItemMarketListingItemStatsToJson;
  Map<String, dynamic> toJson() => _$ItemMarketListingItemStatsToJson(this);

  @JsonKey(name: 'damage')
  final dynamic damage;
  @JsonKey(name: 'accuracy')
  final dynamic accuracy;
  @JsonKey(name: 'armor')
  final dynamic armor;
  @JsonKey(name: 'quality')
  final double quality;
  static const fromJsonFactory = _$ItemMarketListingItemStatsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ItemMarketListingItemStats &&
            (identical(other.damage, damage) || const DeepCollectionEquality().equals(other.damage, damage)) &&
            (identical(other.accuracy, accuracy) ||
                const DeepCollectionEquality().equals(
                  other.accuracy,
                  accuracy,
                )) &&
            (identical(other.armor, armor) || const DeepCollectionEquality().equals(other.armor, armor)) &&
            (identical(other.quality, quality) || const DeepCollectionEquality().equals(other.quality, quality)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(damage) ^
      const DeepCollectionEquality().hash(accuracy) ^
      const DeepCollectionEquality().hash(armor) ^
      const DeepCollectionEquality().hash(quality) ^
      runtimeType.hashCode;
}

extension $ItemMarketListingItemStatsExtension on ItemMarketListingItemStats {
  ItemMarketListingItemStats copyWith({
    dynamic damage,
    dynamic accuracy,
    dynamic armor,
    double? quality,
  }) {
    return ItemMarketListingItemStats(
      damage: damage ?? this.damage,
      accuracy: accuracy ?? this.accuracy,
      armor: armor ?? this.armor,
      quality: quality ?? this.quality,
    );
  }

  ItemMarketListingItemStats copyWithWrapped({
    Wrapped<dynamic>? damage,
    Wrapped<dynamic>? accuracy,
    Wrapped<dynamic>? armor,
    Wrapped<double>? quality,
  }) {
    return ItemMarketListingItemStats(
      damage: (damage != null ? damage.value : this.damage),
      accuracy: (accuracy != null ? accuracy.value : this.accuracy),
      armor: (armor != null ? armor.value : this.armor),
      quality: (quality != null ? quality.value : this.quality),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ItemMarketItem {
  const ItemMarketItem({
    required this.id,
    required this.name,
    required this.type,
    required this.averagePrice,
  });

  factory ItemMarketItem.fromJson(Map<String, dynamic> json) => _$ItemMarketItemFromJson(json);

  static const toJsonFactory = _$ItemMarketItemToJson;
  Map<String, dynamic> toJson() => _$ItemMarketItemToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'type')
  final String type;
  @JsonKey(name: 'average_price')
  final int averagePrice;
  static const fromJsonFactory = _$ItemMarketItemFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ItemMarketItem &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.type, type) || const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.averagePrice, averagePrice) ||
                const DeepCollectionEquality().equals(
                  other.averagePrice,
                  averagePrice,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(averagePrice) ^
      runtimeType.hashCode;
}

extension $ItemMarketItemExtension on ItemMarketItem {
  ItemMarketItem copyWith({
    int? id,
    String? name,
    String? type,
    int? averagePrice,
  }) {
    return ItemMarketItem(
      id: id ?? this.id,
      name: name ?? this.name,
      type: type ?? this.type,
      averagePrice: averagePrice ?? this.averagePrice,
    );
  }

  ItemMarketItem copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<String>? name,
    Wrapped<String>? type,
    Wrapped<int>? averagePrice,
  }) {
    return ItemMarketItem(
      id: (id != null ? id.value : this.id),
      name: (name != null ? name.value : this.name),
      type: (type != null ? type.value : this.type),
      averagePrice: (averagePrice != null ? averagePrice.value : this.averagePrice),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ItemMarketListingStackable {
  const ItemMarketListingStackable({required this.price, required this.amount});

  factory ItemMarketListingStackable.fromJson(Map<String, dynamic> json) => _$ItemMarketListingStackableFromJson(json);

  static const toJsonFactory = _$ItemMarketListingStackableToJson;
  Map<String, dynamic> toJson() => _$ItemMarketListingStackableToJson(this);

  @JsonKey(name: 'price')
  final int price;
  @JsonKey(name: 'amount')
  final int amount;
  static const fromJsonFactory = _$ItemMarketListingStackableFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ItemMarketListingStackable &&
            (identical(other.price, price) || const DeepCollectionEquality().equals(other.price, price)) &&
            (identical(other.amount, amount) || const DeepCollectionEquality().equals(other.amount, amount)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(price) ^ const DeepCollectionEquality().hash(amount) ^ runtimeType.hashCode;
}

extension $ItemMarketListingStackableExtension on ItemMarketListingStackable {
  ItemMarketListingStackable copyWith({int? price, int? amount}) {
    return ItemMarketListingStackable(
      price: price ?? this.price,
      amount: amount ?? this.amount,
    );
  }

  ItemMarketListingStackable copyWithWrapped({
    Wrapped<int>? price,
    Wrapped<int>? amount,
  }) {
    return ItemMarketListingStackable(
      price: (price != null ? price.value : this.price),
      amount: (amount != null ? amount.value : this.amount),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ItemMarketListingItemDetails {
  const ItemMarketListingItemDetails({
    required this.uid,
    required this.stats,
    required this.bonuses,
    required this.rarity,
  });

  factory ItemMarketListingItemDetails.fromJson(Map<String, dynamic> json) =>
      _$ItemMarketListingItemDetailsFromJson(json);

  static const toJsonFactory = _$ItemMarketListingItemDetailsToJson;
  Map<String, dynamic> toJson() => _$ItemMarketListingItemDetailsToJson(this);

  @JsonKey(name: 'uid')
  final int uid;
  @JsonKey(name: 'stats')
  final ItemMarketListingItemStats stats;
  @JsonKey(name: 'bonuses', defaultValue: <ItemMarketListingItemBonus>[])
  final List<ItemMarketListingItemBonus> bonuses;
  @JsonKey(name: 'rarity')
  final dynamic rarity;
  static const fromJsonFactory = _$ItemMarketListingItemDetailsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ItemMarketListingItemDetails &&
            (identical(other.uid, uid) || const DeepCollectionEquality().equals(other.uid, uid)) &&
            (identical(other.stats, stats) || const DeepCollectionEquality().equals(other.stats, stats)) &&
            (identical(other.bonuses, bonuses) ||
                const DeepCollectionEquality().equals(
                  other.bonuses,
                  bonuses,
                )) &&
            (identical(other.rarity, rarity) || const DeepCollectionEquality().equals(other.rarity, rarity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(uid) ^
      const DeepCollectionEquality().hash(stats) ^
      const DeepCollectionEquality().hash(bonuses) ^
      const DeepCollectionEquality().hash(rarity) ^
      runtimeType.hashCode;
}

extension $ItemMarketListingItemDetailsExtension on ItemMarketListingItemDetails {
  ItemMarketListingItemDetails copyWith({
    int? uid,
    ItemMarketListingItemStats? stats,
    List<ItemMarketListingItemBonus>? bonuses,
    dynamic rarity,
  }) {
    return ItemMarketListingItemDetails(
      uid: uid ?? this.uid,
      stats: stats ?? this.stats,
      bonuses: bonuses ?? this.bonuses,
      rarity: rarity ?? this.rarity,
    );
  }

  ItemMarketListingItemDetails copyWithWrapped({
    Wrapped<int>? uid,
    Wrapped<ItemMarketListingItemStats>? stats,
    Wrapped<List<ItemMarketListingItemBonus>>? bonuses,
    Wrapped<dynamic>? rarity,
  }) {
    return ItemMarketListingItemDetails(
      uid: (uid != null ? uid.value : this.uid),
      stats: (stats != null ? stats.value : this.stats),
      bonuses: (bonuses != null ? bonuses.value : this.bonuses),
      rarity: (rarity != null ? rarity.value : this.rarity),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ItemMarketListingNonstackable {
  const ItemMarketListingNonstackable({
    required this.price,
    required this.amount,
    required this.itemDetails,
  });

  factory ItemMarketListingNonstackable.fromJson(Map<String, dynamic> json) =>
      _$ItemMarketListingNonstackableFromJson(json);

  static const toJsonFactory = _$ItemMarketListingNonstackableToJson;
  Map<String, dynamic> toJson() => _$ItemMarketListingNonstackableToJson(this);

  @JsonKey(name: 'price')
  final int price;
  @JsonKey(name: 'amount')
  final int amount;
  @JsonKey(name: 'item_details')
  final ItemMarketListingItemDetails itemDetails;
  static const fromJsonFactory = _$ItemMarketListingNonstackableFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ItemMarketListingNonstackable &&
            (identical(other.price, price) || const DeepCollectionEquality().equals(other.price, price)) &&
            (identical(other.amount, amount) || const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.itemDetails, itemDetails) ||
                const DeepCollectionEquality().equals(
                  other.itemDetails,
                  itemDetails,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(price) ^
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(itemDetails) ^
      runtimeType.hashCode;
}

extension $ItemMarketListingNonstackableExtension on ItemMarketListingNonstackable {
  ItemMarketListingNonstackable copyWith({
    int? price,
    int? amount,
    ItemMarketListingItemDetails? itemDetails,
  }) {
    return ItemMarketListingNonstackable(
      price: price ?? this.price,
      amount: amount ?? this.amount,
      itemDetails: itemDetails ?? this.itemDetails,
    );
  }

  ItemMarketListingNonstackable copyWithWrapped({
    Wrapped<int>? price,
    Wrapped<int>? amount,
    Wrapped<ItemMarketListingItemDetails>? itemDetails,
  }) {
    return ItemMarketListingNonstackable(
      price: (price != null ? price.value : this.price),
      amount: (amount != null ? amount.value : this.amount),
      itemDetails: (itemDetails != null ? itemDetails.value : this.itemDetails),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ItemMarket {
  const ItemMarket({
    required this.item,
    required this.listings,
    required this.cacheTimestamp,
  });

  factory ItemMarket.fromJson(Map<String, dynamic> json) => _$ItemMarketFromJson(json);

  static const toJsonFactory = _$ItemMarketToJson;
  Map<String, dynamic> toJson() => _$ItemMarketToJson(this);

  @JsonKey(name: 'item')
  final ItemMarketItem item;
  @JsonKey(name: 'listings', defaultValue: <Object>[])
  final List<Object> listings;
  @JsonKey(name: 'cache_timestamp')
  final int cacheTimestamp;
  static const fromJsonFactory = _$ItemMarketFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ItemMarket &&
            (identical(other.item, item) || const DeepCollectionEquality().equals(other.item, item)) &&
            (identical(other.listings, listings) ||
                const DeepCollectionEquality().equals(
                  other.listings,
                  listings,
                )) &&
            (identical(other.cacheTimestamp, cacheTimestamp) ||
                const DeepCollectionEquality().equals(
                  other.cacheTimestamp,
                  cacheTimestamp,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(item) ^
      const DeepCollectionEquality().hash(listings) ^
      const DeepCollectionEquality().hash(cacheTimestamp) ^
      runtimeType.hashCode;
}

extension $ItemMarketExtension on ItemMarket {
  ItemMarket copyWith({
    ItemMarketItem? item,
    List<Object>? listings,
    int? cacheTimestamp,
  }) {
    return ItemMarket(
      item: item ?? this.item,
      listings: listings ?? this.listings,
      cacheTimestamp: cacheTimestamp ?? this.cacheTimestamp,
    );
  }

  ItemMarket copyWithWrapped({
    Wrapped<ItemMarketItem>? item,
    Wrapped<List<Object>>? listings,
    Wrapped<int>? cacheTimestamp,
  }) {
    return ItemMarket(
      item: (item != null ? item.value : this.item),
      listings: (listings != null ? listings.value : this.listings),
      cacheTimestamp: (cacheTimestamp != null ? cacheTimestamp.value : this.cacheTimestamp),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class MarketItemMarketResponse {
  const MarketItemMarketResponse({
    required this.itemmarket,
    required this.metadata,
  });

  factory MarketItemMarketResponse.fromJson(Map<String, dynamic> json) => _$MarketItemMarketResponseFromJson(json);

  static const toJsonFactory = _$MarketItemMarketResponseToJson;
  Map<String, dynamic> toJson() => _$MarketItemMarketResponseToJson(this);

  @JsonKey(name: 'itemmarket')
  final ItemMarket itemmarket;
  @JsonKey(name: '_metadata')
  final RequestMetadataWithLinks metadata;
  static const fromJsonFactory = _$MarketItemMarketResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is MarketItemMarketResponse &&
            (identical(other.itemmarket, itemmarket) ||
                const DeepCollectionEquality().equals(
                  other.itemmarket,
                  itemmarket,
                )) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality().equals(
                  other.metadata,
                  metadata,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(itemmarket) ^
      const DeepCollectionEquality().hash(metadata) ^
      runtimeType.hashCode;
}

extension $MarketItemMarketResponseExtension on MarketItemMarketResponse {
  MarketItemMarketResponse copyWith({
    ItemMarket? itemmarket,
    RequestMetadataWithLinks? metadata,
  }) {
    return MarketItemMarketResponse(
      itemmarket: itemmarket ?? this.itemmarket,
      metadata: metadata ?? this.metadata,
    );
  }

  MarketItemMarketResponse copyWithWrapped({
    Wrapped<ItemMarket>? itemmarket,
    Wrapped<RequestMetadataWithLinks>? metadata,
  }) {
    return MarketItemMarketResponse(
      itemmarket: (itemmarket != null ? itemmarket.value : this.itemmarket),
      metadata: (metadata != null ? metadata.value : this.metadata),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class MarketSelectionName {
  const MarketSelectionName();

  factory MarketSelectionName.fromJson(Map<String, dynamic> json) => _$MarketSelectionNameFromJson(json);

  static const toJsonFactory = _$MarketSelectionNameToJson;
  Map<String, dynamic> toJson() => _$MarketSelectionNameToJson(this);

  static const fromJsonFactory = _$MarketSelectionNameFromJson;

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => runtimeType.hashCode;
}

@JsonSerializable(explicitToJson: true)
class MarketLookupResponse {
  const MarketLookupResponse({required this.selections});

  factory MarketLookupResponse.fromJson(Map<String, dynamic> json) => _$MarketLookupResponseFromJson(json);

  static const toJsonFactory = _$MarketLookupResponseToJson;
  Map<String, dynamic> toJson() => _$MarketLookupResponseToJson(this);

  @JsonKey(name: 'selections', defaultValue: <MarketSelectionName>[])
  final List<MarketSelectionName> selections;
  static const fromJsonFactory = _$MarketLookupResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is MarketLookupResponse &&
            (identical(other.selections, selections) ||
                const DeepCollectionEquality().equals(
                  other.selections,
                  selections,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(selections) ^ runtimeType.hashCode;
}

extension $MarketLookupResponseExtension on MarketLookupResponse {
  MarketLookupResponse copyWith({List<MarketSelectionName>? selections}) {
    return MarketLookupResponse(selections: selections ?? this.selections);
  }

  MarketLookupResponse copyWithWrapped({
    Wrapped<List<MarketSelectionName>>? selections,
  }) {
    return MarketLookupResponse(
      selections: (selections != null ? selections.value : this.selections),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserRacingRecordsResponse {
  const UserRacingRecordsResponse({required this.racingrecords});

  factory UserRacingRecordsResponse.fromJson(Map<String, dynamic> json) => _$UserRacingRecordsResponseFromJson(json);

  static const toJsonFactory = _$UserRacingRecordsResponseToJson;
  Map<String, dynamic> toJson() => _$UserRacingRecordsResponseToJson(this);

  @JsonKey(name: 'racingrecords')
  final List<UserRacingRecordsResponse$Racingrecords$Item> racingrecords;
  static const fromJsonFactory = _$UserRacingRecordsResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserRacingRecordsResponse &&
            (identical(other.racingrecords, racingrecords) ||
                const DeepCollectionEquality().equals(
                  other.racingrecords,
                  racingrecords,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(racingrecords) ^ runtimeType.hashCode;
}

extension $UserRacingRecordsResponseExtension on UserRacingRecordsResponse {
  UserRacingRecordsResponse copyWith({
    List<UserRacingRecordsResponse$Racingrecords$Item>? racingrecords,
  }) {
    return UserRacingRecordsResponse(
      racingrecords: racingrecords ?? this.racingrecords,
    );
  }

  UserRacingRecordsResponse copyWithWrapped({
    Wrapped<List<UserRacingRecordsResponse$Racingrecords$Item>>? racingrecords,
  }) {
    return UserRacingRecordsResponse(
      racingrecords: (racingrecords != null ? racingrecords.value : this.racingrecords),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class RacingCarsResponse {
  const RacingCarsResponse({required this.cars});

  factory RacingCarsResponse.fromJson(Map<String, dynamic> json) => _$RacingCarsResponseFromJson(json);

  static const toJsonFactory = _$RacingCarsResponseToJson;
  Map<String, dynamic> toJson() => _$RacingCarsResponseToJson(this);

  @JsonKey(name: 'cars', defaultValue: <RaceCar>[])
  final List<RaceCar> cars;
  static const fromJsonFactory = _$RacingCarsResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RacingCarsResponse &&
            (identical(other.cars, cars) || const DeepCollectionEquality().equals(other.cars, cars)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(cars) ^ runtimeType.hashCode;
}

extension $RacingCarsResponseExtension on RacingCarsResponse {
  RacingCarsResponse copyWith({List<RaceCar>? cars}) {
    return RacingCarsResponse(cars: cars ?? this.cars);
  }

  RacingCarsResponse copyWithWrapped({Wrapped<List<RaceCar>>? cars}) {
    return RacingCarsResponse(cars: (cars != null ? cars.value : this.cars));
  }
}

@JsonSerializable(explicitToJson: true)
class RaceCar {
  const RaceCar({
    required this.carItemId,
    required this.carItemName,
    required this.topSpeed,
    required this.acceleration,
    required this.braking,
    required this.dirt,
    required this.handling,
    required this.safety,
    required this.tarmac,
    required this.$class,
  });

  factory RaceCar.fromJson(Map<String, dynamic> json) => _$RaceCarFromJson(json);

  static const toJsonFactory = _$RaceCarToJson;
  Map<String, dynamic> toJson() => _$RaceCarToJson(this);

  @JsonKey(name: 'car_item_id')
  final int carItemId;
  @JsonKey(name: 'car_item_name')
  final String carItemName;
  @JsonKey(name: 'top_speed')
  final int topSpeed;
  @JsonKey(name: 'acceleration')
  final int acceleration;
  @JsonKey(name: 'braking')
  final int braking;
  @JsonKey(name: 'dirt')
  final int dirt;
  @JsonKey(name: 'handling')
  final int handling;
  @JsonKey(name: 'safety')
  final int safety;
  @JsonKey(name: 'tarmac')
  final int tarmac;
  @JsonKey(
    name: 'class',
    toJson: raceClassEnumToJson,
    fromJson: raceClassEnumFromJson,
  )
  final enums.RaceClassEnum $class;
  static const fromJsonFactory = _$RaceCarFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RaceCar &&
            (identical(other.carItemId, carItemId) ||
                const DeepCollectionEquality().equals(
                  other.carItemId,
                  carItemId,
                )) &&
            (identical(other.carItemName, carItemName) ||
                const DeepCollectionEquality().equals(
                  other.carItemName,
                  carItemName,
                )) &&
            (identical(other.topSpeed, topSpeed) ||
                const DeepCollectionEquality().equals(
                  other.topSpeed,
                  topSpeed,
                )) &&
            (identical(other.acceleration, acceleration) ||
                const DeepCollectionEquality().equals(
                  other.acceleration,
                  acceleration,
                )) &&
            (identical(other.braking, braking) ||
                const DeepCollectionEquality().equals(
                  other.braking,
                  braking,
                )) &&
            (identical(other.dirt, dirt) || const DeepCollectionEquality().equals(other.dirt, dirt)) &&
            (identical(other.handling, handling) ||
                const DeepCollectionEquality().equals(
                  other.handling,
                  handling,
                )) &&
            (identical(other.safety, safety) || const DeepCollectionEquality().equals(other.safety, safety)) &&
            (identical(other.tarmac, tarmac) || const DeepCollectionEquality().equals(other.tarmac, tarmac)) &&
            (identical(other.$class, $class) || const DeepCollectionEquality().equals(other.$class, $class)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(carItemId) ^
      const DeepCollectionEquality().hash(carItemName) ^
      const DeepCollectionEquality().hash(topSpeed) ^
      const DeepCollectionEquality().hash(acceleration) ^
      const DeepCollectionEquality().hash(braking) ^
      const DeepCollectionEquality().hash(dirt) ^
      const DeepCollectionEquality().hash(handling) ^
      const DeepCollectionEquality().hash(safety) ^
      const DeepCollectionEquality().hash(tarmac) ^
      const DeepCollectionEquality().hash($class) ^
      runtimeType.hashCode;
}

extension $RaceCarExtension on RaceCar {
  RaceCar copyWith({
    int? carItemId,
    String? carItemName,
    int? topSpeed,
    int? acceleration,
    int? braking,
    int? dirt,
    int? handling,
    int? safety,
    int? tarmac,
    enums.RaceClassEnum? $class,
  }) {
    return RaceCar(
      carItemId: carItemId ?? this.carItemId,
      carItemName: carItemName ?? this.carItemName,
      topSpeed: topSpeed ?? this.topSpeed,
      acceleration: acceleration ?? this.acceleration,
      braking: braking ?? this.braking,
      dirt: dirt ?? this.dirt,
      handling: handling ?? this.handling,
      safety: safety ?? this.safety,
      tarmac: tarmac ?? this.tarmac,
      $class: $class ?? this.$class,
    );
  }

  RaceCar copyWithWrapped({
    Wrapped<int>? carItemId,
    Wrapped<String>? carItemName,
    Wrapped<int>? topSpeed,
    Wrapped<int>? acceleration,
    Wrapped<int>? braking,
    Wrapped<int>? dirt,
    Wrapped<int>? handling,
    Wrapped<int>? safety,
    Wrapped<int>? tarmac,
    Wrapped<enums.RaceClassEnum>? $class,
  }) {
    return RaceCar(
      carItemId: (carItemId != null ? carItemId.value : this.carItemId),
      carItemName: (carItemName != null ? carItemName.value : this.carItemName),
      topSpeed: (topSpeed != null ? topSpeed.value : this.topSpeed),
      acceleration: (acceleration != null ? acceleration.value : this.acceleration),
      braking: (braking != null ? braking.value : this.braking),
      dirt: (dirt != null ? dirt.value : this.dirt),
      handling: (handling != null ? handling.value : this.handling),
      safety: (safety != null ? safety.value : this.safety),
      tarmac: (tarmac != null ? tarmac.value : this.tarmac),
      $class: ($class != null ? $class.value : this.$class),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class RacingTracksResponse {
  const RacingTracksResponse({required this.tracks});

  factory RacingTracksResponse.fromJson(Map<String, dynamic> json) => _$RacingTracksResponseFromJson(json);

  static const toJsonFactory = _$RacingTracksResponseToJson;
  Map<String, dynamic> toJson() => _$RacingTracksResponseToJson(this);

  @JsonKey(name: 'tracks', defaultValue: <RaceTrack>[])
  final List<RaceTrack> tracks;
  static const fromJsonFactory = _$RacingTracksResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RacingTracksResponse &&
            (identical(other.tracks, tracks) || const DeepCollectionEquality().equals(other.tracks, tracks)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(tracks) ^ runtimeType.hashCode;
}

extension $RacingTracksResponseExtension on RacingTracksResponse {
  RacingTracksResponse copyWith({List<RaceTrack>? tracks}) {
    return RacingTracksResponse(tracks: tracks ?? this.tracks);
  }

  RacingTracksResponse copyWithWrapped({Wrapped<List<RaceTrack>>? tracks}) {
    return RacingTracksResponse(
      tracks: (tracks != null ? tracks.value : this.tracks),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class RaceTrack {
  const RaceTrack({
    required this.id,
    required this.title,
    required this.description,
  });

  factory RaceTrack.fromJson(Map<String, dynamic> json) => _$RaceTrackFromJson(json);

  static const toJsonFactory = _$RaceTrackToJson;
  Map<String, dynamic> toJson() => _$RaceTrackToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'title')
  final String title;
  @JsonKey(name: 'description')
  final String description;
  static const fromJsonFactory = _$RaceTrackFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RaceTrack &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.title, title) || const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(description) ^
      runtimeType.hashCode;
}

extension $RaceTrackExtension on RaceTrack {
  RaceTrack copyWith({int? id, String? title, String? description}) {
    return RaceTrack(
      id: id ?? this.id,
      title: title ?? this.title,
      description: description ?? this.description,
    );
  }

  RaceTrack copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<String>? title,
    Wrapped<String>? description,
  }) {
    return RaceTrack(
      id: (id != null ? id.value : this.id),
      title: (title != null ? title.value : this.title),
      description: (description != null ? description.value : this.description),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class RacingCarUpgradesResponse {
  const RacingCarUpgradesResponse({required this.carupgrades});

  factory RacingCarUpgradesResponse.fromJson(Map<String, dynamic> json) => _$RacingCarUpgradesResponseFromJson(json);

  static const toJsonFactory = _$RacingCarUpgradesResponseToJson;
  Map<String, dynamic> toJson() => _$RacingCarUpgradesResponseToJson(this);

  @JsonKey(name: 'carupgrades', defaultValue: <RaceCarUpgrade>[])
  final List<RaceCarUpgrade> carupgrades;
  static const fromJsonFactory = _$RacingCarUpgradesResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RacingCarUpgradesResponse &&
            (identical(other.carupgrades, carupgrades) ||
                const DeepCollectionEquality().equals(
                  other.carupgrades,
                  carupgrades,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(carupgrades) ^ runtimeType.hashCode;
}

extension $RacingCarUpgradesResponseExtension on RacingCarUpgradesResponse {
  RacingCarUpgradesResponse copyWith({List<RaceCarUpgrade>? carupgrades}) {
    return RacingCarUpgradesResponse(
      carupgrades: carupgrades ?? this.carupgrades,
    );
  }

  RacingCarUpgradesResponse copyWithWrapped({
    Wrapped<List<RaceCarUpgrade>>? carupgrades,
  }) {
    return RacingCarUpgradesResponse(
      carupgrades: (carupgrades != null ? carupgrades.value : this.carupgrades),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class RaceCarUpgrade {
  const RaceCarUpgrade({
    required this.id,
    required this.classRequired,
    required this.name,
    required this.description,
    required this.category,
    required this.subcategory,
    required this.effects,
    required this.cost,
  });

  factory RaceCarUpgrade.fromJson(Map<String, dynamic> json) => _$RaceCarUpgradeFromJson(json);

  static const toJsonFactory = _$RaceCarUpgradeToJson;
  Map<String, dynamic> toJson() => _$RaceCarUpgradeToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(
    name: 'class_required',
    toJson: raceClassEnumToJson,
    fromJson: raceClassEnumFromJson,
  )
  final enums.RaceClassEnum classRequired;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'description')
  final String description;
  @JsonKey(
    name: 'category',
    toJson: raceCarUpgradeCategoryToJson,
    fromJson: raceCarUpgradeCategoryFromJson,
  )
  final enums.RaceCarUpgradeCategory category;
  @JsonKey(
    name: 'subcategory',
    toJson: raceCarUpgradeSubCategoryToJson,
    fromJson: raceCarUpgradeSubCategoryFromJson,
  )
  final enums.RaceCarUpgradeSubCategory subcategory;
  @JsonKey(name: 'effects')
  final RaceCarUpgrade$Effects effects;
  @JsonKey(name: 'cost')
  final RaceCarUpgrade$Cost cost;
  static const fromJsonFactory = _$RaceCarUpgradeFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RaceCarUpgrade &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.classRequired, classRequired) ||
                const DeepCollectionEquality().equals(
                  other.classRequired,
                  classRequired,
                )) &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.category, category) ||
                const DeepCollectionEquality().equals(
                  other.category,
                  category,
                )) &&
            (identical(other.subcategory, subcategory) ||
                const DeepCollectionEquality().equals(
                  other.subcategory,
                  subcategory,
                )) &&
            (identical(other.effects, effects) ||
                const DeepCollectionEquality().equals(
                  other.effects,
                  effects,
                )) &&
            (identical(other.cost, cost) || const DeepCollectionEquality().equals(other.cost, cost)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(classRequired) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(category) ^
      const DeepCollectionEquality().hash(subcategory) ^
      const DeepCollectionEquality().hash(effects) ^
      const DeepCollectionEquality().hash(cost) ^
      runtimeType.hashCode;
}

extension $RaceCarUpgradeExtension on RaceCarUpgrade {
  RaceCarUpgrade copyWith({
    int? id,
    enums.RaceClassEnum? classRequired,
    String? name,
    String? description,
    enums.RaceCarUpgradeCategory? category,
    enums.RaceCarUpgradeSubCategory? subcategory,
    RaceCarUpgrade$Effects? effects,
    RaceCarUpgrade$Cost? cost,
  }) {
    return RaceCarUpgrade(
      id: id ?? this.id,
      classRequired: classRequired ?? this.classRequired,
      name: name ?? this.name,
      description: description ?? this.description,
      category: category ?? this.category,
      subcategory: subcategory ?? this.subcategory,
      effects: effects ?? this.effects,
      cost: cost ?? this.cost,
    );
  }

  RaceCarUpgrade copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<enums.RaceClassEnum>? classRequired,
    Wrapped<String>? name,
    Wrapped<String>? description,
    Wrapped<enums.RaceCarUpgradeCategory>? category,
    Wrapped<enums.RaceCarUpgradeSubCategory>? subcategory,
    Wrapped<RaceCarUpgrade$Effects>? effects,
    Wrapped<RaceCarUpgrade$Cost>? cost,
  }) {
    return RaceCarUpgrade(
      id: (id != null ? id.value : this.id),
      classRequired: (classRequired != null ? classRequired.value : this.classRequired),
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
      category: (category != null ? category.value : this.category),
      subcategory: (subcategory != null ? subcategory.value : this.subcategory),
      effects: (effects != null ? effects.value : this.effects),
      cost: (cost != null ? cost.value : this.cost),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class RacingRacesResponse {
  const RacingRacesResponse({required this.races, required this.metadata});

  factory RacingRacesResponse.fromJson(Map<String, dynamic> json) => _$RacingRacesResponseFromJson(json);

  static const toJsonFactory = _$RacingRacesResponseToJson;
  Map<String, dynamic> toJson() => _$RacingRacesResponseToJson(this);

  @JsonKey(name: 'races', defaultValue: <Race>[])
  final List<Race> races;
  @JsonKey(name: '_metadata')
  final RequestMetadataWithLinks metadata;
  static const fromJsonFactory = _$RacingRacesResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RacingRacesResponse &&
            (identical(other.races, races) || const DeepCollectionEquality().equals(other.races, races)) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality().equals(
                  other.metadata,
                  metadata,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(races) ^ const DeepCollectionEquality().hash(metadata) ^ runtimeType.hashCode;
}

extension $RacingRacesResponseExtension on RacingRacesResponse {
  RacingRacesResponse copyWith({
    List<Race>? races,
    RequestMetadataWithLinks? metadata,
  }) {
    return RacingRacesResponse(
      races: races ?? this.races,
      metadata: metadata ?? this.metadata,
    );
  }

  RacingRacesResponse copyWithWrapped({
    Wrapped<List<Race>>? races,
    Wrapped<RequestMetadataWithLinks>? metadata,
  }) {
    return RacingRacesResponse(
      races: (races != null ? races.value : this.races),
      metadata: (metadata != null ? metadata.value : this.metadata),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class Race {
  const Race({
    required this.id,
    required this.title,
    required this.trackId,
    required this.creatorId,
    required this.status,
    required this.laps,
    required this.participants,
    required this.schedule,
    required this.requirements,
    required this.isOfficial,
  });

  factory Race.fromJson(Map<String, dynamic> json) => _$RaceFromJson(json);

  static const toJsonFactory = _$RaceToJson;
  Map<String, dynamic> toJson() => _$RaceToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'title')
  final String title;
  @JsonKey(name: 'track_id')
  final int trackId;
  @JsonKey(name: 'creator_id')
  final int creatorId;
  @JsonKey(
    name: 'status',
    toJson: raceStatusEnumToJson,
    fromJson: raceStatusEnumFromJson,
  )
  final enums.RaceStatusEnum status;
  @JsonKey(name: 'laps')
  final int laps;
  @JsonKey(name: 'participants')
  final Race$Participants participants;
  @JsonKey(name: 'schedule')
  final Race$Schedule schedule;
  @JsonKey(name: 'requirements')
  final Race$Requirements requirements;
  @JsonKey(name: 'is_official')
  final bool isOfficial;
  static const fromJsonFactory = _$RaceFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Race &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.title, title) || const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.trackId, trackId) ||
                const DeepCollectionEquality().equals(
                  other.trackId,
                  trackId,
                )) &&
            (identical(other.creatorId, creatorId) ||
                const DeepCollectionEquality().equals(
                  other.creatorId,
                  creatorId,
                )) &&
            (identical(other.status, status) || const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.laps, laps) || const DeepCollectionEquality().equals(other.laps, laps)) &&
            (identical(other.participants, participants) ||
                const DeepCollectionEquality().equals(
                  other.participants,
                  participants,
                )) &&
            (identical(other.schedule, schedule) ||
                const DeepCollectionEquality().equals(
                  other.schedule,
                  schedule,
                )) &&
            (identical(other.requirements, requirements) ||
                const DeepCollectionEquality().equals(
                  other.requirements,
                  requirements,
                )) &&
            (identical(other.isOfficial, isOfficial) ||
                const DeepCollectionEquality().equals(
                  other.isOfficial,
                  isOfficial,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(trackId) ^
      const DeepCollectionEquality().hash(creatorId) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(laps) ^
      const DeepCollectionEquality().hash(participants) ^
      const DeepCollectionEquality().hash(schedule) ^
      const DeepCollectionEquality().hash(requirements) ^
      const DeepCollectionEquality().hash(isOfficial) ^
      runtimeType.hashCode;
}

extension $RaceExtension on Race {
  Race copyWith({
    int? id,
    String? title,
    int? trackId,
    int? creatorId,
    enums.RaceStatusEnum? status,
    int? laps,
    Race$Participants? participants,
    Race$Schedule? schedule,
    Race$Requirements? requirements,
    bool? isOfficial,
  }) {
    return Race(
      id: id ?? this.id,
      title: title ?? this.title,
      trackId: trackId ?? this.trackId,
      creatorId: creatorId ?? this.creatorId,
      status: status ?? this.status,
      laps: laps ?? this.laps,
      participants: participants ?? this.participants,
      schedule: schedule ?? this.schedule,
      requirements: requirements ?? this.requirements,
      isOfficial: isOfficial ?? this.isOfficial,
    );
  }

  Race copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<String>? title,
    Wrapped<int>? trackId,
    Wrapped<int>? creatorId,
    Wrapped<enums.RaceStatusEnum>? status,
    Wrapped<int>? laps,
    Wrapped<Race$Participants>? participants,
    Wrapped<Race$Schedule>? schedule,
    Wrapped<Race$Requirements>? requirements,
    Wrapped<bool>? isOfficial,
  }) {
    return Race(
      id: (id != null ? id.value : this.id),
      title: (title != null ? title.value : this.title),
      trackId: (trackId != null ? trackId.value : this.trackId),
      creatorId: (creatorId != null ? creatorId.value : this.creatorId),
      status: (status != null ? status.value : this.status),
      laps: (laps != null ? laps.value : this.laps),
      participants: (participants != null ? participants.value : this.participants),
      schedule: (schedule != null ? schedule.value : this.schedule),
      requirements: (requirements != null ? requirements.value : this.requirements),
      isOfficial: (isOfficial != null ? isOfficial.value : this.isOfficial),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class RacingTrackRecordsResponse {
  const RacingTrackRecordsResponse({required this.records});

  factory RacingTrackRecordsResponse.fromJson(Map<String, dynamic> json) => _$RacingTrackRecordsResponseFromJson(json);

  static const toJsonFactory = _$RacingTrackRecordsResponseToJson;
  Map<String, dynamic> toJson() => _$RacingTrackRecordsResponseToJson(this);

  @JsonKey(name: 'records', defaultValue: <RaceRecord>[])
  final List<RaceRecord> records;
  static const fromJsonFactory = _$RacingTrackRecordsResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RacingTrackRecordsResponse &&
            (identical(other.records, records) || const DeepCollectionEquality().equals(other.records, records)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(records) ^ runtimeType.hashCode;
}

extension $RacingTrackRecordsResponseExtension on RacingTrackRecordsResponse {
  RacingTrackRecordsResponse copyWith({List<RaceRecord>? records}) {
    return RacingTrackRecordsResponse(records: records ?? this.records);
  }

  RacingTrackRecordsResponse copyWithWrapped({
    Wrapped<List<RaceRecord>>? records,
  }) {
    return RacingTrackRecordsResponse(
      records: (records != null ? records.value : this.records),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class RaceRecord {
  const RaceRecord({
    required this.driverId,
    required this.driverName,
    required this.carItemId,
    required this.lapTime,
    required this.carItemName,
  });

  factory RaceRecord.fromJson(Map<String, dynamic> json) => _$RaceRecordFromJson(json);

  static const toJsonFactory = _$RaceRecordToJson;
  Map<String, dynamic> toJson() => _$RaceRecordToJson(this);

  @JsonKey(name: 'driver_id')
  final int driverId;
  @JsonKey(name: 'driver_name')
  final String driverName;
  @JsonKey(name: 'car_item_id')
  final int carItemId;
  @JsonKey(name: 'lap_time')
  final double lapTime;
  @JsonKey(name: 'car_item_name')
  final String carItemName;
  static const fromJsonFactory = _$RaceRecordFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RaceRecord &&
            (identical(other.driverId, driverId) ||
                const DeepCollectionEquality().equals(
                  other.driverId,
                  driverId,
                )) &&
            (identical(other.driverName, driverName) ||
                const DeepCollectionEquality().equals(
                  other.driverName,
                  driverName,
                )) &&
            (identical(other.carItemId, carItemId) ||
                const DeepCollectionEquality().equals(
                  other.carItemId,
                  carItemId,
                )) &&
            (identical(other.lapTime, lapTime) ||
                const DeepCollectionEquality().equals(
                  other.lapTime,
                  lapTime,
                )) &&
            (identical(other.carItemName, carItemName) ||
                const DeepCollectionEquality().equals(
                  other.carItemName,
                  carItemName,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(driverId) ^
      const DeepCollectionEquality().hash(driverName) ^
      const DeepCollectionEquality().hash(carItemId) ^
      const DeepCollectionEquality().hash(lapTime) ^
      const DeepCollectionEquality().hash(carItemName) ^
      runtimeType.hashCode;
}

extension $RaceRecordExtension on RaceRecord {
  RaceRecord copyWith({
    int? driverId,
    String? driverName,
    int? carItemId,
    double? lapTime,
    String? carItemName,
  }) {
    return RaceRecord(
      driverId: driverId ?? this.driverId,
      driverName: driverName ?? this.driverName,
      carItemId: carItemId ?? this.carItemId,
      lapTime: lapTime ?? this.lapTime,
      carItemName: carItemName ?? this.carItemName,
    );
  }

  RaceRecord copyWithWrapped({
    Wrapped<int>? driverId,
    Wrapped<String>? driverName,
    Wrapped<int>? carItemId,
    Wrapped<double>? lapTime,
    Wrapped<String>? carItemName,
  }) {
    return RaceRecord(
      driverId: (driverId != null ? driverId.value : this.driverId),
      driverName: (driverName != null ? driverName.value : this.driverName),
      carItemId: (carItemId != null ? carItemId.value : this.carItemId),
      lapTime: (lapTime != null ? lapTime.value : this.lapTime),
      carItemName: (carItemName != null ? carItemName.value : this.carItemName),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class RacerDetails {
  const RacerDetails({
    required this.driverId,
    required this.position,
    required this.carId,
    required this.carItemId,
    required this.carItemName,
    required this.carClass,
    required this.hasCrashed,
    required this.bestLapTime,
    required this.raceTime,
    required this.timeEnded,
  });

  factory RacerDetails.fromJson(Map<String, dynamic> json) => _$RacerDetailsFromJson(json);

  static const toJsonFactory = _$RacerDetailsToJson;
  Map<String, dynamic> toJson() => _$RacerDetailsToJson(this);

  @JsonKey(name: 'driver_id')
  final int driverId;
  @JsonKey(name: 'position')
  final dynamic position;
  @JsonKey(name: 'car_id')
  final int carId;
  @JsonKey(name: 'car_item_id')
  final int carItemId;
  @JsonKey(name: 'car_item_name')
  final String carItemName;
  @JsonKey(
    name: 'car_class',
    toJson: raceClassEnumToJson,
    fromJson: raceClassEnumFromJson,
  )
  final enums.RaceClassEnum carClass;
  @JsonKey(name: 'has_crashed')
  final dynamic hasCrashed;
  @JsonKey(name: 'best_lap_time')
  final dynamic bestLapTime;
  @JsonKey(name: 'race_time')
  final dynamic raceTime;
  @JsonKey(name: 'time_ended')
  final dynamic timeEnded;
  static const fromJsonFactory = _$RacerDetailsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RacerDetails &&
            (identical(other.driverId, driverId) ||
                const DeepCollectionEquality().equals(
                  other.driverId,
                  driverId,
                )) &&
            (identical(other.position, position) ||
                const DeepCollectionEquality().equals(
                  other.position,
                  position,
                )) &&
            (identical(other.carId, carId) || const DeepCollectionEquality().equals(other.carId, carId)) &&
            (identical(other.carItemId, carItemId) ||
                const DeepCollectionEquality().equals(
                  other.carItemId,
                  carItemId,
                )) &&
            (identical(other.carItemName, carItemName) ||
                const DeepCollectionEquality().equals(
                  other.carItemName,
                  carItemName,
                )) &&
            (identical(other.carClass, carClass) ||
                const DeepCollectionEquality().equals(
                  other.carClass,
                  carClass,
                )) &&
            (identical(other.hasCrashed, hasCrashed) ||
                const DeepCollectionEquality().equals(
                  other.hasCrashed,
                  hasCrashed,
                )) &&
            (identical(other.bestLapTime, bestLapTime) ||
                const DeepCollectionEquality().equals(
                  other.bestLapTime,
                  bestLapTime,
                )) &&
            (identical(other.raceTime, raceTime) ||
                const DeepCollectionEquality().equals(
                  other.raceTime,
                  raceTime,
                )) &&
            (identical(other.timeEnded, timeEnded) ||
                const DeepCollectionEquality().equals(
                  other.timeEnded,
                  timeEnded,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(driverId) ^
      const DeepCollectionEquality().hash(position) ^
      const DeepCollectionEquality().hash(carId) ^
      const DeepCollectionEquality().hash(carItemId) ^
      const DeepCollectionEquality().hash(carItemName) ^
      const DeepCollectionEquality().hash(carClass) ^
      const DeepCollectionEquality().hash(hasCrashed) ^
      const DeepCollectionEquality().hash(bestLapTime) ^
      const DeepCollectionEquality().hash(raceTime) ^
      const DeepCollectionEquality().hash(timeEnded) ^
      runtimeType.hashCode;
}

extension $RacerDetailsExtension on RacerDetails {
  RacerDetails copyWith({
    int? driverId,
    dynamic position,
    int? carId,
    int? carItemId,
    String? carItemName,
    enums.RaceClassEnum? carClass,
    dynamic hasCrashed,
    dynamic bestLapTime,
    dynamic raceTime,
    dynamic timeEnded,
  }) {
    return RacerDetails(
      driverId: driverId ?? this.driverId,
      position: position ?? this.position,
      carId: carId ?? this.carId,
      carItemId: carItemId ?? this.carItemId,
      carItemName: carItemName ?? this.carItemName,
      carClass: carClass ?? this.carClass,
      hasCrashed: hasCrashed ?? this.hasCrashed,
      bestLapTime: bestLapTime ?? this.bestLapTime,
      raceTime: raceTime ?? this.raceTime,
      timeEnded: timeEnded ?? this.timeEnded,
    );
  }

  RacerDetails copyWithWrapped({
    Wrapped<int>? driverId,
    Wrapped<dynamic>? position,
    Wrapped<int>? carId,
    Wrapped<int>? carItemId,
    Wrapped<String>? carItemName,
    Wrapped<enums.RaceClassEnum>? carClass,
    Wrapped<dynamic>? hasCrashed,
    Wrapped<dynamic>? bestLapTime,
    Wrapped<dynamic>? raceTime,
    Wrapped<dynamic>? timeEnded,
  }) {
    return RacerDetails(
      driverId: (driverId != null ? driverId.value : this.driverId),
      position: (position != null ? position.value : this.position),
      carId: (carId != null ? carId.value : this.carId),
      carItemId: (carItemId != null ? carItemId.value : this.carItemId),
      carItemName: (carItemName != null ? carItemName.value : this.carItemName),
      carClass: (carClass != null ? carClass.value : this.carClass),
      hasCrashed: (hasCrashed != null ? hasCrashed.value : this.hasCrashed),
      bestLapTime: (bestLapTime != null ? bestLapTime.value : this.bestLapTime),
      raceTime: (raceTime != null ? raceTime.value : this.raceTime),
      timeEnded: (timeEnded != null ? timeEnded.value : this.timeEnded),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class RacingRaceDetails {
  const RacingRaceDetails({
    required this.results,
    required this.isOfficial,
    required this.id,
    required this.title,
    required this.trackId,
    required this.creatorId,
    required this.status,
    required this.laps,
    required this.participants,
    required this.schedule,
    required this.requirements,
  });

  factory RacingRaceDetails.fromJson(Map<String, dynamic> json) => _$RacingRaceDetailsFromJson(json);

  static const toJsonFactory = _$RacingRaceDetailsToJson;
  Map<String, dynamic> toJson() => _$RacingRaceDetailsToJson(this);

  @JsonKey(name: 'results', defaultValue: <RacerDetails>[])
  final List<RacerDetails> results;
  @JsonKey(name: 'is_official')
  final bool isOfficial;
  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'title')
  final String title;
  @JsonKey(name: 'track_id')
  final int trackId;
  @JsonKey(name: 'creator_id')
  final int creatorId;
  @JsonKey(
    name: 'status',
    toJson: raceStatusEnumToJson,
    fromJson: raceStatusEnumFromJson,
  )
  final enums.RaceStatusEnum status;
  @JsonKey(name: 'laps')
  final int laps;
  @JsonKey(name: 'participants')
  final RacingRaceDetails$Participants participants;
  @JsonKey(name: 'schedule')
  final RacingRaceDetails$Schedule schedule;
  @JsonKey(name: 'requirements')
  final RacingRaceDetails$Requirements requirements;
  static const fromJsonFactory = _$RacingRaceDetailsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RacingRaceDetails &&
            (identical(other.results, results) ||
                const DeepCollectionEquality().equals(
                  other.results,
                  results,
                )) &&
            (identical(other.isOfficial, isOfficial) ||
                const DeepCollectionEquality().equals(
                  other.isOfficial,
                  isOfficial,
                )) &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.title, title) || const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.trackId, trackId) ||
                const DeepCollectionEquality().equals(
                  other.trackId,
                  trackId,
                )) &&
            (identical(other.creatorId, creatorId) ||
                const DeepCollectionEquality().equals(
                  other.creatorId,
                  creatorId,
                )) &&
            (identical(other.status, status) || const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.laps, laps) || const DeepCollectionEquality().equals(other.laps, laps)) &&
            (identical(other.participants, participants) ||
                const DeepCollectionEquality().equals(
                  other.participants,
                  participants,
                )) &&
            (identical(other.schedule, schedule) ||
                const DeepCollectionEquality().equals(
                  other.schedule,
                  schedule,
                )) &&
            (identical(other.requirements, requirements) ||
                const DeepCollectionEquality().equals(
                  other.requirements,
                  requirements,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(results) ^
      const DeepCollectionEquality().hash(isOfficial) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(trackId) ^
      const DeepCollectionEquality().hash(creatorId) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(laps) ^
      const DeepCollectionEquality().hash(participants) ^
      const DeepCollectionEquality().hash(schedule) ^
      const DeepCollectionEquality().hash(requirements) ^
      runtimeType.hashCode;
}

extension $RacingRaceDetailsExtension on RacingRaceDetails {
  RacingRaceDetails copyWith({
    List<RacerDetails>? results,
    bool? isOfficial,
    int? id,
    String? title,
    int? trackId,
    int? creatorId,
    enums.RaceStatusEnum? status,
    int? laps,
    RacingRaceDetails$Participants? participants,
    RacingRaceDetails$Schedule? schedule,
    RacingRaceDetails$Requirements? requirements,
  }) {
    return RacingRaceDetails(
      results: results ?? this.results,
      isOfficial: isOfficial ?? this.isOfficial,
      id: id ?? this.id,
      title: title ?? this.title,
      trackId: trackId ?? this.trackId,
      creatorId: creatorId ?? this.creatorId,
      status: status ?? this.status,
      laps: laps ?? this.laps,
      participants: participants ?? this.participants,
      schedule: schedule ?? this.schedule,
      requirements: requirements ?? this.requirements,
    );
  }

  RacingRaceDetails copyWithWrapped({
    Wrapped<List<RacerDetails>>? results,
    Wrapped<bool>? isOfficial,
    Wrapped<int>? id,
    Wrapped<String>? title,
    Wrapped<int>? trackId,
    Wrapped<int>? creatorId,
    Wrapped<enums.RaceStatusEnum>? status,
    Wrapped<int>? laps,
    Wrapped<RacingRaceDetails$Participants>? participants,
    Wrapped<RacingRaceDetails$Schedule>? schedule,
    Wrapped<RacingRaceDetails$Requirements>? requirements,
  }) {
    return RacingRaceDetails(
      results: (results != null ? results.value : this.results),
      isOfficial: (isOfficial != null ? isOfficial.value : this.isOfficial),
      id: (id != null ? id.value : this.id),
      title: (title != null ? title.value : this.title),
      trackId: (trackId != null ? trackId.value : this.trackId),
      creatorId: (creatorId != null ? creatorId.value : this.creatorId),
      status: (status != null ? status.value : this.status),
      laps: (laps != null ? laps.value : this.laps),
      participants: (participants != null ? participants.value : this.participants),
      schedule: (schedule != null ? schedule.value : this.schedule),
      requirements: (requirements != null ? requirements.value : this.requirements),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class RacingRaceDetailsResponse {
  const RacingRaceDetailsResponse({required this.race});

  factory RacingRaceDetailsResponse.fromJson(Map<String, dynamic> json) => _$RacingRaceDetailsResponseFromJson(json);

  static const toJsonFactory = _$RacingRaceDetailsResponseToJson;
  Map<String, dynamic> toJson() => _$RacingRaceDetailsResponseToJson(this);

  @JsonKey(name: 'race')
  final RacingRaceDetails race;
  static const fromJsonFactory = _$RacingRaceDetailsResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RacingRaceDetailsResponse &&
            (identical(other.race, race) || const DeepCollectionEquality().equals(other.race, race)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(race) ^ runtimeType.hashCode;
}

extension $RacingRaceDetailsResponseExtension on RacingRaceDetailsResponse {
  RacingRaceDetailsResponse copyWith({RacingRaceDetails? race}) {
    return RacingRaceDetailsResponse(race: race ?? this.race);
  }

  RacingRaceDetailsResponse copyWithWrapped({
    Wrapped<RacingRaceDetails>? race,
  }) {
    return RacingRaceDetailsResponse(
      race: (race != null ? race.value : this.race),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class RacingSelectionName {
  const RacingSelectionName();

  factory RacingSelectionName.fromJson(Map<String, dynamic> json) => _$RacingSelectionNameFromJson(json);

  static const toJsonFactory = _$RacingSelectionNameToJson;
  Map<String, dynamic> toJson() => _$RacingSelectionNameToJson(this);

  static const fromJsonFactory = _$RacingSelectionNameFromJson;

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => runtimeType.hashCode;
}

@JsonSerializable(explicitToJson: true)
class RacingLookupResponse {
  const RacingLookupResponse({required this.selections});

  factory RacingLookupResponse.fromJson(Map<String, dynamic> json) => _$RacingLookupResponseFromJson(json);

  static const toJsonFactory = _$RacingLookupResponseToJson;
  Map<String, dynamic> toJson() => _$RacingLookupResponseToJson(this);

  @JsonKey(name: 'selections', defaultValue: <RacingSelectionName>[])
  final List<RacingSelectionName> selections;
  static const fromJsonFactory = _$RacingLookupResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RacingLookupResponse &&
            (identical(other.selections, selections) ||
                const DeepCollectionEquality().equals(
                  other.selections,
                  selections,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(selections) ^ runtimeType.hashCode;
}

extension $RacingLookupResponseExtension on RacingLookupResponse {
  RacingLookupResponse copyWith({List<RacingSelectionName>? selections}) {
    return RacingLookupResponse(selections: selections ?? this.selections);
  }

  RacingLookupResponse copyWithWrapped({
    Wrapped<List<RacingSelectionName>>? selections,
  }) {
    return RacingLookupResponse(
      selections: (selections != null ? selections.value : this.selections),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PropertySelectionName {
  const PropertySelectionName();

  factory PropertySelectionName.fromJson(Map<String, dynamic> json) => _$PropertySelectionNameFromJson(json);

  static const toJsonFactory = _$PropertySelectionNameToJson;
  Map<String, dynamic> toJson() => _$PropertySelectionNameToJson(this);

  static const fromJsonFactory = _$PropertySelectionNameFromJson;

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => runtimeType.hashCode;
}

@JsonSerializable(explicitToJson: true)
class PropertyLookupResponse {
  const PropertyLookupResponse({required this.selections});

  factory PropertyLookupResponse.fromJson(Map<String, dynamic> json) => _$PropertyLookupResponseFromJson(json);

  static const toJsonFactory = _$PropertyLookupResponseToJson;
  Map<String, dynamic> toJson() => _$PropertyLookupResponseToJson(this);

  @JsonKey(name: 'selections', defaultValue: <PropertySelectionName>[])
  final List<PropertySelectionName> selections;
  static const fromJsonFactory = _$PropertyLookupResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PropertyLookupResponse &&
            (identical(other.selections, selections) ||
                const DeepCollectionEquality().equals(
                  other.selections,
                  selections,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(selections) ^ runtimeType.hashCode;
}

extension $PropertyLookupResponseExtension on PropertyLookupResponse {
  PropertyLookupResponse copyWith({List<PropertySelectionName>? selections}) {
    return PropertyLookupResponse(selections: selections ?? this.selections);
  }

  PropertyLookupResponse copyWithWrapped({
    Wrapped<List<PropertySelectionName>>? selections,
  }) {
    return PropertyLookupResponse(
      selections: (selections != null ? selections.value : this.selections),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TornOrganizedCrimeResponse {
  const TornOrganizedCrimeResponse({required this.organizedcrimes});

  factory TornOrganizedCrimeResponse.fromJson(Map<String, dynamic> json) => _$TornOrganizedCrimeResponseFromJson(json);

  static const toJsonFactory = _$TornOrganizedCrimeResponseToJson;
  Map<String, dynamic> toJson() => _$TornOrganizedCrimeResponseToJson(this);

  @JsonKey(name: 'organizedcrimes', defaultValue: <TornOrganizedCrime>[])
  final List<TornOrganizedCrime> organizedcrimes;
  static const fromJsonFactory = _$TornOrganizedCrimeResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TornOrganizedCrimeResponse &&
            (identical(other.organizedcrimes, organizedcrimes) ||
                const DeepCollectionEquality().equals(
                  other.organizedcrimes,
                  organizedcrimes,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(organizedcrimes) ^ runtimeType.hashCode;
}

extension $TornOrganizedCrimeResponseExtension on TornOrganizedCrimeResponse {
  TornOrganizedCrimeResponse copyWith({
    List<TornOrganizedCrime>? organizedcrimes,
  }) {
    return TornOrganizedCrimeResponse(
      organizedcrimes: organizedcrimes ?? this.organizedcrimes,
    );
  }

  TornOrganizedCrimeResponse copyWithWrapped({
    Wrapped<List<TornOrganizedCrime>>? organizedcrimes,
  }) {
    return TornOrganizedCrimeResponse(
      organizedcrimes: (organizedcrimes != null ? organizedcrimes.value : this.organizedcrimes),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TornOrganizedCrime {
  const TornOrganizedCrime({
    required this.name,
    required this.description,
    required this.difficulty,
    required this.spawn,
    required this.scope,
    required this.prerequisite,
    required this.slots,
  });

  factory TornOrganizedCrime.fromJson(Map<String, dynamic> json) => _$TornOrganizedCrimeFromJson(json);

  static const toJsonFactory = _$TornOrganizedCrimeToJson;
  Map<String, dynamic> toJson() => _$TornOrganizedCrimeToJson(this);

  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'description')
  final String description;
  @JsonKey(name: 'difficulty')
  final int difficulty;
  @JsonKey(name: 'spawn')
  final TornOrganizedCrimeSpawn spawn;
  @JsonKey(name: 'scope')
  final TornOrganizedCrimeScope scope;
  @JsonKey(name: 'prerequisite')
  final dynamic prerequisite;
  @JsonKey(name: 'slots', defaultValue: <TornOrganizedCrimeSlot>[])
  final List<TornOrganizedCrimeSlot> slots;
  static const fromJsonFactory = _$TornOrganizedCrimeFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TornOrganizedCrime &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.difficulty, difficulty) ||
                const DeepCollectionEquality().equals(
                  other.difficulty,
                  difficulty,
                )) &&
            (identical(other.spawn, spawn) || const DeepCollectionEquality().equals(other.spawn, spawn)) &&
            (identical(other.scope, scope) || const DeepCollectionEquality().equals(other.scope, scope)) &&
            (identical(other.prerequisite, prerequisite) ||
                const DeepCollectionEquality().equals(
                  other.prerequisite,
                  prerequisite,
                )) &&
            (identical(other.slots, slots) || const DeepCollectionEquality().equals(other.slots, slots)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(difficulty) ^
      const DeepCollectionEquality().hash(spawn) ^
      const DeepCollectionEquality().hash(scope) ^
      const DeepCollectionEquality().hash(prerequisite) ^
      const DeepCollectionEquality().hash(slots) ^
      runtimeType.hashCode;
}

extension $TornOrganizedCrimeExtension on TornOrganizedCrime {
  TornOrganizedCrime copyWith({
    String? name,
    String? description,
    int? difficulty,
    TornOrganizedCrimeSpawn? spawn,
    TornOrganizedCrimeScope? scope,
    dynamic prerequisite,
    List<TornOrganizedCrimeSlot>? slots,
  }) {
    return TornOrganizedCrime(
      name: name ?? this.name,
      description: description ?? this.description,
      difficulty: difficulty ?? this.difficulty,
      spawn: spawn ?? this.spawn,
      scope: scope ?? this.scope,
      prerequisite: prerequisite ?? this.prerequisite,
      slots: slots ?? this.slots,
    );
  }

  TornOrganizedCrime copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<String>? description,
    Wrapped<int>? difficulty,
    Wrapped<TornOrganizedCrimeSpawn>? spawn,
    Wrapped<TornOrganizedCrimeScope>? scope,
    Wrapped<dynamic>? prerequisite,
    Wrapped<List<TornOrganizedCrimeSlot>>? slots,
  }) {
    return TornOrganizedCrime(
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
      difficulty: (difficulty != null ? difficulty.value : this.difficulty),
      spawn: (spawn != null ? spawn.value : this.spawn),
      scope: (scope != null ? scope.value : this.scope),
      prerequisite: (prerequisite != null ? prerequisite.value : this.prerequisite),
      slots: (slots != null ? slots.value : this.slots),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TornOrganizedCrimeSpawn {
  const TornOrganizedCrimeSpawn({required this.level, required this.name});

  factory TornOrganizedCrimeSpawn.fromJson(Map<String, dynamic> json) => _$TornOrganizedCrimeSpawnFromJson(json);

  static const toJsonFactory = _$TornOrganizedCrimeSpawnToJson;
  Map<String, dynamic> toJson() => _$TornOrganizedCrimeSpawnToJson(this);

  @JsonKey(name: 'level')
  final int level;
  @JsonKey(name: 'name')
  final String name;
  static const fromJsonFactory = _$TornOrganizedCrimeSpawnFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TornOrganizedCrimeSpawn &&
            (identical(other.level, level) || const DeepCollectionEquality().equals(other.level, level)) &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(level) ^ const DeepCollectionEquality().hash(name) ^ runtimeType.hashCode;
}

extension $TornOrganizedCrimeSpawnExtension on TornOrganizedCrimeSpawn {
  TornOrganizedCrimeSpawn copyWith({int? level, String? name}) {
    return TornOrganizedCrimeSpawn(
      level: level ?? this.level,
      name: name ?? this.name,
    );
  }

  TornOrganizedCrimeSpawn copyWithWrapped({
    Wrapped<int>? level,
    Wrapped<String>? name,
  }) {
    return TornOrganizedCrimeSpawn(
      level: (level != null ? level.value : this.level),
      name: (name != null ? name.value : this.name),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TornOrganizedCrimeScope {
  const TornOrganizedCrimeScope({required this.cost, required this.$return});

  factory TornOrganizedCrimeScope.fromJson(Map<String, dynamic> json) => _$TornOrganizedCrimeScopeFromJson(json);

  static const toJsonFactory = _$TornOrganizedCrimeScopeToJson;
  Map<String, dynamic> toJson() => _$TornOrganizedCrimeScopeToJson(this);

  @JsonKey(name: 'cost')
  final int cost;
  @JsonKey(name: 'return')
  final int $return;
  static const fromJsonFactory = _$TornOrganizedCrimeScopeFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TornOrganizedCrimeScope &&
            (identical(other.cost, cost) || const DeepCollectionEquality().equals(other.cost, cost)) &&
            (identical(other.$return, $return) || const DeepCollectionEquality().equals(other.$return, $return)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(cost) ^ const DeepCollectionEquality().hash($return) ^ runtimeType.hashCode;
}

extension $TornOrganizedCrimeScopeExtension on TornOrganizedCrimeScope {
  TornOrganizedCrimeScope copyWith({int? cost, int? $return}) {
    return TornOrganizedCrimeScope(
      cost: cost ?? this.cost,
      $return: $return ?? this.$return,
    );
  }

  TornOrganizedCrimeScope copyWithWrapped({
    Wrapped<int>? cost,
    Wrapped<int>? $return,
  }) {
    return TornOrganizedCrimeScope(
      cost: (cost != null ? cost.value : this.cost),
      $return: ($return != null ? $return.value : this.$return),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TornOrganizedCrimeSlot {
  const TornOrganizedCrimeSlot({
    required this.id,
    required this.name,
    required this.requiredItem,
  });

  factory TornOrganizedCrimeSlot.fromJson(Map<String, dynamic> json) => _$TornOrganizedCrimeSlotFromJson(json);

  static const toJsonFactory = _$TornOrganizedCrimeSlotToJson;
  Map<String, dynamic> toJson() => _$TornOrganizedCrimeSlotToJson(this);

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'required_item')
  final dynamic requiredItem;
  static const fromJsonFactory = _$TornOrganizedCrimeSlotFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TornOrganizedCrimeSlot &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.requiredItem, requiredItem) ||
                const DeepCollectionEquality().equals(
                  other.requiredItem,
                  requiredItem,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(requiredItem) ^
      runtimeType.hashCode;
}

extension $TornOrganizedCrimeSlotExtension on TornOrganizedCrimeSlot {
  TornOrganizedCrimeSlot copyWith({
    String? id,
    String? name,
    dynamic requiredItem,
  }) {
    return TornOrganizedCrimeSlot(
      id: id ?? this.id,
      name: name ?? this.name,
      requiredItem: requiredItem ?? this.requiredItem,
    );
  }

  TornOrganizedCrimeSlot copyWithWrapped({
    Wrapped<String>? id,
    Wrapped<String>? name,
    Wrapped<dynamic>? requiredItem,
  }) {
    return TornOrganizedCrimeSlot(
      id: (id != null ? id.value : this.id),
      name: (name != null ? name.value : this.name),
      requiredItem: (requiredItem != null ? requiredItem.value : this.requiredItem),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TornOrganizedCrimeRequiredItem {
  const TornOrganizedCrimeRequiredItem({
    required this.id,
    required this.name,
    required this.isUsed,
  });

  factory TornOrganizedCrimeRequiredItem.fromJson(Map<String, dynamic> json) =>
      _$TornOrganizedCrimeRequiredItemFromJson(json);

  static const toJsonFactory = _$TornOrganizedCrimeRequiredItemToJson;
  Map<String, dynamic> toJson() => _$TornOrganizedCrimeRequiredItemToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'is_used')
  final bool isUsed;
  static const fromJsonFactory = _$TornOrganizedCrimeRequiredItemFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TornOrganizedCrimeRequiredItem &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.isUsed, isUsed) || const DeepCollectionEquality().equals(other.isUsed, isUsed)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(isUsed) ^
      runtimeType.hashCode;
}

extension $TornOrganizedCrimeRequiredItemExtension on TornOrganizedCrimeRequiredItem {
  TornOrganizedCrimeRequiredItem copyWith({
    int? id,
    String? name,
    bool? isUsed,
  }) {
    return TornOrganizedCrimeRequiredItem(
      id: id ?? this.id,
      name: name ?? this.name,
      isUsed: isUsed ?? this.isUsed,
    );
  }

  TornOrganizedCrimeRequiredItem copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<String>? name,
    Wrapped<bool>? isUsed,
  }) {
    return TornOrganizedCrimeRequiredItem(
      id: (id != null ? id.value : this.id),
      name: (name != null ? name.value : this.name),
      isUsed: (isUsed != null ? isUsed.value : this.isUsed),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TornProperties {
  const TornProperties({this.properties});

  factory TornProperties.fromJson(Map<String, dynamic> json) => _$TornPropertiesFromJson(json);

  static const toJsonFactory = _$TornPropertiesToJson;
  Map<String, dynamic> toJson() => _$TornPropertiesToJson(this);

  @JsonKey(name: 'properties')
  final List<TornProperties$Properties$Item>? properties;
  static const fromJsonFactory = _$TornPropertiesFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TornProperties &&
            (identical(other.properties, properties) ||
                const DeepCollectionEquality().equals(
                  other.properties,
                  properties,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(properties) ^ runtimeType.hashCode;
}

extension $TornPropertiesExtension on TornProperties {
  TornProperties copyWith({List<TornProperties$Properties$Item>? properties}) {
    return TornProperties(properties: properties ?? this.properties);
  }

  TornProperties copyWithWrapped({
    Wrapped<List<TornProperties$Properties$Item>?>? properties,
  }) {
    return TornProperties(
      properties: (properties != null ? properties.value : this.properties),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TornEducationRewards {
  const TornEducationRewards({
    required this.workingStats,
    required this.effect,
    required this.honor,
  });

  factory TornEducationRewards.fromJson(Map<String, dynamic> json) => _$TornEducationRewardsFromJson(json);

  static const toJsonFactory = _$TornEducationRewardsToJson;
  Map<String, dynamic> toJson() => _$TornEducationRewardsToJson(this);

  @JsonKey(name: 'working_stats')
  final TornEducationRewards$WorkingStats workingStats;
  @JsonKey(name: 'effect')
  final dynamic effect;
  @JsonKey(name: 'honor')
  final dynamic honor;
  static const fromJsonFactory = _$TornEducationRewardsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TornEducationRewards &&
            (identical(other.workingStats, workingStats) ||
                const DeepCollectionEquality().equals(
                  other.workingStats,
                  workingStats,
                )) &&
            (identical(other.effect, effect) || const DeepCollectionEquality().equals(other.effect, effect)) &&
            (identical(other.honor, honor) || const DeepCollectionEquality().equals(other.honor, honor)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(workingStats) ^
      const DeepCollectionEquality().hash(effect) ^
      const DeepCollectionEquality().hash(honor) ^
      runtimeType.hashCode;
}

extension $TornEducationRewardsExtension on TornEducationRewards {
  TornEducationRewards copyWith({
    TornEducationRewards$WorkingStats? workingStats,
    dynamic effect,
    dynamic honor,
  }) {
    return TornEducationRewards(
      workingStats: workingStats ?? this.workingStats,
      effect: effect ?? this.effect,
      honor: honor ?? this.honor,
    );
  }

  TornEducationRewards copyWithWrapped({
    Wrapped<TornEducationRewards$WorkingStats>? workingStats,
    Wrapped<dynamic>? effect,
    Wrapped<dynamic>? honor,
  }) {
    return TornEducationRewards(
      workingStats: (workingStats != null ? workingStats.value : this.workingStats),
      effect: (effect != null ? effect.value : this.effect),
      honor: (honor != null ? honor.value : this.honor),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TornEducationPrerequisites {
  const TornEducationPrerequisites({required this.cost, required this.courses});

  factory TornEducationPrerequisites.fromJson(Map<String, dynamic> json) => _$TornEducationPrerequisitesFromJson(json);

  static const toJsonFactory = _$TornEducationPrerequisitesToJson;
  Map<String, dynamic> toJson() => _$TornEducationPrerequisitesToJson(this);

  @JsonKey(name: 'cost')
  final int cost;
  @JsonKey(name: 'courses', defaultValue: <int>[])
  final List<int> courses;
  static const fromJsonFactory = _$TornEducationPrerequisitesFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TornEducationPrerequisites &&
            (identical(other.cost, cost) || const DeepCollectionEquality().equals(other.cost, cost)) &&
            (identical(other.courses, courses) || const DeepCollectionEquality().equals(other.courses, courses)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(cost) ^ const DeepCollectionEquality().hash(courses) ^ runtimeType.hashCode;
}

extension $TornEducationPrerequisitesExtension on TornEducationPrerequisites {
  TornEducationPrerequisites copyWith({int? cost, List<int>? courses}) {
    return TornEducationPrerequisites(
      cost: cost ?? this.cost,
      courses: courses ?? this.courses,
    );
  }

  TornEducationPrerequisites copyWithWrapped({
    Wrapped<int>? cost,
    Wrapped<List<int>>? courses,
  }) {
    return TornEducationPrerequisites(
      cost: (cost != null ? cost.value : this.cost),
      courses: (courses != null ? courses.value : this.courses),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TornEducationCourses {
  const TornEducationCourses({
    required this.id,
    required this.code,
    required this.name,
    required this.description,
    required this.duration,
    required this.rewards,
    required this.prerequisites,
  });

  factory TornEducationCourses.fromJson(Map<String, dynamic> json) => _$TornEducationCoursesFromJson(json);

  static const toJsonFactory = _$TornEducationCoursesToJson;
  Map<String, dynamic> toJson() => _$TornEducationCoursesToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'code')
  final String code;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'description')
  final String description;
  @JsonKey(name: 'duration')
  final int duration;
  @JsonKey(name: 'rewards')
  final TornEducationRewards rewards;
  @JsonKey(name: 'prerequisites')
  final TornEducationPrerequisites prerequisites;
  static const fromJsonFactory = _$TornEducationCoursesFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TornEducationCourses &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.code, code) || const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.duration, duration) ||
                const DeepCollectionEquality().equals(
                  other.duration,
                  duration,
                )) &&
            (identical(other.rewards, rewards) ||
                const DeepCollectionEquality().equals(
                  other.rewards,
                  rewards,
                )) &&
            (identical(other.prerequisites, prerequisites) ||
                const DeepCollectionEquality().equals(
                  other.prerequisites,
                  prerequisites,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(duration) ^
      const DeepCollectionEquality().hash(rewards) ^
      const DeepCollectionEquality().hash(prerequisites) ^
      runtimeType.hashCode;
}

extension $TornEducationCoursesExtension on TornEducationCourses {
  TornEducationCourses copyWith({
    int? id,
    String? code,
    String? name,
    String? description,
    int? duration,
    TornEducationRewards? rewards,
    TornEducationPrerequisites? prerequisites,
  }) {
    return TornEducationCourses(
      id: id ?? this.id,
      code: code ?? this.code,
      name: name ?? this.name,
      description: description ?? this.description,
      duration: duration ?? this.duration,
      rewards: rewards ?? this.rewards,
      prerequisites: prerequisites ?? this.prerequisites,
    );
  }

  TornEducationCourses copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<String>? code,
    Wrapped<String>? name,
    Wrapped<String>? description,
    Wrapped<int>? duration,
    Wrapped<TornEducationRewards>? rewards,
    Wrapped<TornEducationPrerequisites>? prerequisites,
  }) {
    return TornEducationCourses(
      id: (id != null ? id.value : this.id),
      code: (code != null ? code.value : this.code),
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
      duration: (duration != null ? duration.value : this.duration),
      rewards: (rewards != null ? rewards.value : this.rewards),
      prerequisites: (prerequisites != null ? prerequisites.value : this.prerequisites),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TornEducation {
  const TornEducation({
    required this.id,
    required this.name,
    required this.courses,
  });

  factory TornEducation.fromJson(Map<String, dynamic> json) => _$TornEducationFromJson(json);

  static const toJsonFactory = _$TornEducationToJson;
  Map<String, dynamic> toJson() => _$TornEducationToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'courses', defaultValue: <TornEducationCourses>[])
  final List<TornEducationCourses> courses;
  static const fromJsonFactory = _$TornEducationFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TornEducation &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.courses, courses) || const DeepCollectionEquality().equals(other.courses, courses)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(courses) ^
      runtimeType.hashCode;
}

extension $TornEducationExtension on TornEducation {
  TornEducation copyWith({
    int? id,
    String? name,
    List<TornEducationCourses>? courses,
  }) {
    return TornEducation(
      id: id ?? this.id,
      name: name ?? this.name,
      courses: courses ?? this.courses,
    );
  }

  TornEducation copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<String>? name,
    Wrapped<List<TornEducationCourses>>? courses,
  }) {
    return TornEducation(
      id: (id != null ? id.value : this.id),
      name: (name != null ? name.value : this.name),
      courses: (courses != null ? courses.value : this.courses),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TornEducationResponse {
  const TornEducationResponse({required this.education});

  factory TornEducationResponse.fromJson(Map<String, dynamic> json) => _$TornEducationResponseFromJson(json);

  static const toJsonFactory = _$TornEducationResponseToJson;
  Map<String, dynamic> toJson() => _$TornEducationResponseToJson(this);

  @JsonKey(name: 'education', defaultValue: <TornEducation>[])
  final List<TornEducation> education;
  static const fromJsonFactory = _$TornEducationResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TornEducationResponse &&
            (identical(other.education, education) ||
                const DeepCollectionEquality().equals(
                  other.education,
                  education,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(education) ^ runtimeType.hashCode;
}

extension $TornEducationResponseExtension on TornEducationResponse {
  TornEducationResponse copyWith({List<TornEducation>? education}) {
    return TornEducationResponse(education: education ?? this.education);
  }

  TornEducationResponse copyWithWrapped({
    Wrapped<List<TornEducation>>? education,
  }) {
    return TornEducationResponse(
      education: (education != null ? education.value : this.education),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TornTerritoryCoordinates {
  const TornTerritoryCoordinates({required this.x, required this.y});

  factory TornTerritoryCoordinates.fromJson(Map<String, dynamic> json) => _$TornTerritoryCoordinatesFromJson(json);

  static const toJsonFactory = _$TornTerritoryCoordinatesToJson;
  Map<String, dynamic> toJson() => _$TornTerritoryCoordinatesToJson(this);

  @JsonKey(name: 'x')
  final double x;
  @JsonKey(name: 'y')
  final double y;
  static const fromJsonFactory = _$TornTerritoryCoordinatesFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TornTerritoryCoordinates &&
            (identical(other.x, x) || const DeepCollectionEquality().equals(other.x, x)) &&
            (identical(other.y, y) || const DeepCollectionEquality().equals(other.y, y)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(x) ^ const DeepCollectionEquality().hash(y) ^ runtimeType.hashCode;
}

extension $TornTerritoryCoordinatesExtension on TornTerritoryCoordinates {
  TornTerritoryCoordinates copyWith({double? x, double? y}) {
    return TornTerritoryCoordinates(x: x ?? this.x, y: y ?? this.y);
  }

  TornTerritoryCoordinates copyWithWrapped({
    Wrapped<double>? x,
    Wrapped<double>? y,
  }) {
    return TornTerritoryCoordinates(
      x: (x != null ? x.value : this.x),
      y: (y != null ? y.value : this.y),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TornTerritory {
  const TornTerritory({
    required this.id,
    required this.sector,
    required this.size,
    required this.density,
    required this.slots,
    required this.respect,
    required this.coordinates,
    required this.neighbors,
  });

  factory TornTerritory.fromJson(Map<String, dynamic> json) => _$TornTerritoryFromJson(json);

  static const toJsonFactory = _$TornTerritoryToJson;
  Map<String, dynamic> toJson() => _$TornTerritoryToJson(this);

  @JsonKey(
    name: 'id',
    toJson: factionTerritoryEnumToJson,
    fromJson: factionTerritoryEnumFromJson,
  )
  final enums.FactionTerritoryEnum id;
  @JsonKey(name: 'sector')
  final int sector;
  @JsonKey(name: 'size')
  final int size;
  @JsonKey(name: 'density')
  final int density;
  @JsonKey(name: 'slots')
  final int slots;
  @JsonKey(name: 'respect')
  final int respect;
  @JsonKey(name: 'coordinates')
  final TornTerritoryCoordinates coordinates;
  @JsonKey(
    name: 'neighbors',
    toJson: factionTerritoryEnumListToJson,
    fromJson: factionTerritoryEnumListFromJson,
  )
  final List<enums.FactionTerritoryEnum> neighbors;
  static const fromJsonFactory = _$TornTerritoryFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TornTerritory &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.sector, sector) || const DeepCollectionEquality().equals(other.sector, sector)) &&
            (identical(other.size, size) || const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.density, density) ||
                const DeepCollectionEquality().equals(
                  other.density,
                  density,
                )) &&
            (identical(other.slots, slots) || const DeepCollectionEquality().equals(other.slots, slots)) &&
            (identical(other.respect, respect) ||
                const DeepCollectionEquality().equals(
                  other.respect,
                  respect,
                )) &&
            (identical(other.coordinates, coordinates) ||
                const DeepCollectionEquality().equals(
                  other.coordinates,
                  coordinates,
                )) &&
            (identical(other.neighbors, neighbors) ||
                const DeepCollectionEquality().equals(
                  other.neighbors,
                  neighbors,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(sector) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(density) ^
      const DeepCollectionEquality().hash(slots) ^
      const DeepCollectionEquality().hash(respect) ^
      const DeepCollectionEquality().hash(coordinates) ^
      const DeepCollectionEquality().hash(neighbors) ^
      runtimeType.hashCode;
}

extension $TornTerritoryExtension on TornTerritory {
  TornTerritory copyWith({
    enums.FactionTerritoryEnum? id,
    int? sector,
    int? size,
    int? density,
    int? slots,
    int? respect,
    TornTerritoryCoordinates? coordinates,
    List<enums.FactionTerritoryEnum>? neighbors,
  }) {
    return TornTerritory(
      id: id ?? this.id,
      sector: sector ?? this.sector,
      size: size ?? this.size,
      density: density ?? this.density,
      slots: slots ?? this.slots,
      respect: respect ?? this.respect,
      coordinates: coordinates ?? this.coordinates,
      neighbors: neighbors ?? this.neighbors,
    );
  }

  TornTerritory copyWithWrapped({
    Wrapped<enums.FactionTerritoryEnum>? id,
    Wrapped<int>? sector,
    Wrapped<int>? size,
    Wrapped<int>? density,
    Wrapped<int>? slots,
    Wrapped<int>? respect,
    Wrapped<TornTerritoryCoordinates>? coordinates,
    Wrapped<List<enums.FactionTerritoryEnum>>? neighbors,
  }) {
    return TornTerritory(
      id: (id != null ? id.value : this.id),
      sector: (sector != null ? sector.value : this.sector),
      size: (size != null ? size.value : this.size),
      density: (density != null ? density.value : this.density),
      slots: (slots != null ? slots.value : this.slots),
      respect: (respect != null ? respect.value : this.respect),
      coordinates: (coordinates != null ? coordinates.value : this.coordinates),
      neighbors: (neighbors != null ? neighbors.value : this.neighbors),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TornTerritoriesResponse {
  const TornTerritoriesResponse({
    required this.territory,
    required this.metadata,
  });

  factory TornTerritoriesResponse.fromJson(Map<String, dynamic> json) => _$TornTerritoriesResponseFromJson(json);

  static const toJsonFactory = _$TornTerritoriesResponseToJson;
  Map<String, dynamic> toJson() => _$TornTerritoriesResponseToJson(this);

  @JsonKey(name: 'territory', defaultValue: <TornTerritory>[])
  final List<TornTerritory> territory;
  @JsonKey(name: '_metadata')
  final RequestMetadataWithLinks metadata;
  static const fromJsonFactory = _$TornTerritoriesResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TornTerritoriesResponse &&
            (identical(other.territory, territory) ||
                const DeepCollectionEquality().equals(
                  other.territory,
                  territory,
                )) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality().equals(
                  other.metadata,
                  metadata,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(territory) ^
      const DeepCollectionEquality().hash(metadata) ^
      runtimeType.hashCode;
}

extension $TornTerritoriesResponseExtension on TornTerritoriesResponse {
  TornTerritoriesResponse copyWith({
    List<TornTerritory>? territory,
    RequestMetadataWithLinks? metadata,
  }) {
    return TornTerritoriesResponse(
      territory: territory ?? this.territory,
      metadata: metadata ?? this.metadata,
    );
  }

  TornTerritoriesResponse copyWithWrapped({
    Wrapped<List<TornTerritory>>? territory,
    Wrapped<RequestMetadataWithLinks>? metadata,
  }) {
    return TornTerritoriesResponse(
      territory: (territory != null ? territory.value : this.territory),
      metadata: (metadata != null ? metadata.value : this.metadata),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TornTerritoriesNoLinksResponse {
  const TornTerritoriesNoLinksResponse({required this.territory});

  factory TornTerritoriesNoLinksResponse.fromJson(Map<String, dynamic> json) =>
      _$TornTerritoriesNoLinksResponseFromJson(json);

  static const toJsonFactory = _$TornTerritoriesNoLinksResponseToJson;
  Map<String, dynamic> toJson() => _$TornTerritoriesNoLinksResponseToJson(this);

  @JsonKey(name: 'territory', defaultValue: <TornTerritory>[])
  final List<TornTerritory> territory;
  static const fromJsonFactory = _$TornTerritoriesNoLinksResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TornTerritoriesNoLinksResponse &&
            (identical(other.territory, territory) ||
                const DeepCollectionEquality().equals(
                  other.territory,
                  territory,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(territory) ^ runtimeType.hashCode;
}

extension $TornTerritoriesNoLinksResponseExtension on TornTerritoriesNoLinksResponse {
  TornTerritoriesNoLinksResponse copyWith({List<TornTerritory>? territory}) {
    return TornTerritoriesNoLinksResponse(
      territory: territory ?? this.territory,
    );
  }

  TornTerritoriesNoLinksResponse copyWithWrapped({
    Wrapped<List<TornTerritory>>? territory,
  }) {
    return TornTerritoriesNoLinksResponse(
      territory: (territory != null ? territory.value : this.territory),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TornSubcrimesResponse {
  const TornSubcrimesResponse({required this.subcrimes});

  factory TornSubcrimesResponse.fromJson(Map<String, dynamic> json) => _$TornSubcrimesResponseFromJson(json);

  static const toJsonFactory = _$TornSubcrimesResponseToJson;
  Map<String, dynamic> toJson() => _$TornSubcrimesResponseToJson(this);

  @JsonKey(name: 'subcrimes', defaultValue: <TornSubcrime>[])
  final List<TornSubcrime> subcrimes;
  static const fromJsonFactory = _$TornSubcrimesResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TornSubcrimesResponse &&
            (identical(other.subcrimes, subcrimes) ||
                const DeepCollectionEquality().equals(
                  other.subcrimes,
                  subcrimes,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(subcrimes) ^ runtimeType.hashCode;
}

extension $TornSubcrimesResponseExtension on TornSubcrimesResponse {
  TornSubcrimesResponse copyWith({List<TornSubcrime>? subcrimes}) {
    return TornSubcrimesResponse(subcrimes: subcrimes ?? this.subcrimes);
  }

  TornSubcrimesResponse copyWithWrapped({
    Wrapped<List<TornSubcrime>>? subcrimes,
  }) {
    return TornSubcrimesResponse(
      subcrimes: (subcrimes != null ? subcrimes.value : this.subcrimes),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TornSubcrime {
  const TornSubcrime({
    required this.id,
    required this.name,
    required this.nerveCost,
  });

  factory TornSubcrime.fromJson(Map<String, dynamic> json) => _$TornSubcrimeFromJson(json);

  static const toJsonFactory = _$TornSubcrimeToJson;
  Map<String, dynamic> toJson() => _$TornSubcrimeToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'nerve_cost')
  final int nerveCost;
  static const fromJsonFactory = _$TornSubcrimeFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TornSubcrime &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.nerveCost, nerveCost) ||
                const DeepCollectionEquality().equals(
                  other.nerveCost,
                  nerveCost,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(nerveCost) ^
      runtimeType.hashCode;
}

extension $TornSubcrimeExtension on TornSubcrime {
  TornSubcrime copyWith({int? id, String? name, int? nerveCost}) {
    return TornSubcrime(
      id: id ?? this.id,
      name: name ?? this.name,
      nerveCost: nerveCost ?? this.nerveCost,
    );
  }

  TornSubcrime copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<String>? name,
    Wrapped<int>? nerveCost,
  }) {
    return TornSubcrime(
      id: (id != null ? id.value : this.id),
      name: (name != null ? name.value : this.name),
      nerveCost: (nerveCost != null ? nerveCost.value : this.nerveCost),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TornCrime {
  const TornCrime({
    required this.id,
    required this.name,
    required this.categoryId,
    this.categoryName,
    required this.enhancerId,
    required this.enhancerName,
    required this.uniqueOutcomesCount,
    required this.uniqueOutcomesIds,
    required this.notes,
  });

  factory TornCrime.fromJson(Map<String, dynamic> json) => _$TornCrimeFromJson(json);

  static const toJsonFactory = _$TornCrimeToJson;
  Map<String, dynamic> toJson() => _$TornCrimeToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'category_id')
  final int categoryId;
  @JsonKey(name: 'category_name')
  final String? categoryName;
  @JsonKey(name: 'enhancer_id')
  final int enhancerId;
  @JsonKey(name: 'enhancer_name')
  final String enhancerName;
  @JsonKey(name: 'unique_outcomes_count')
  final int uniqueOutcomesCount;
  @JsonKey(name: 'unique_outcomes_ids', defaultValue: <int>[])
  final List<int> uniqueOutcomesIds;
  @JsonKey(name: 'notes', defaultValue: <String>[])
  final List<String> notes;
  static const fromJsonFactory = _$TornCrimeFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TornCrime &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.categoryId, categoryId) ||
                const DeepCollectionEquality().equals(
                  other.categoryId,
                  categoryId,
                )) &&
            (identical(other.categoryName, categoryName) ||
                const DeepCollectionEquality().equals(
                  other.categoryName,
                  categoryName,
                )) &&
            (identical(other.enhancerId, enhancerId) ||
                const DeepCollectionEquality().equals(
                  other.enhancerId,
                  enhancerId,
                )) &&
            (identical(other.enhancerName, enhancerName) ||
                const DeepCollectionEquality().equals(
                  other.enhancerName,
                  enhancerName,
                )) &&
            (identical(other.uniqueOutcomesCount, uniqueOutcomesCount) ||
                const DeepCollectionEquality().equals(
                  other.uniqueOutcomesCount,
                  uniqueOutcomesCount,
                )) &&
            (identical(other.uniqueOutcomesIds, uniqueOutcomesIds) ||
                const DeepCollectionEquality().equals(
                  other.uniqueOutcomesIds,
                  uniqueOutcomesIds,
                )) &&
            (identical(other.notes, notes) || const DeepCollectionEquality().equals(other.notes, notes)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(categoryId) ^
      const DeepCollectionEquality().hash(categoryName) ^
      const DeepCollectionEquality().hash(enhancerId) ^
      const DeepCollectionEquality().hash(enhancerName) ^
      const DeepCollectionEquality().hash(uniqueOutcomesCount) ^
      const DeepCollectionEquality().hash(uniqueOutcomesIds) ^
      const DeepCollectionEquality().hash(notes) ^
      runtimeType.hashCode;
}

extension $TornCrimeExtension on TornCrime {
  TornCrime copyWith({
    int? id,
    String? name,
    int? categoryId,
    String? categoryName,
    int? enhancerId,
    String? enhancerName,
    int? uniqueOutcomesCount,
    List<int>? uniqueOutcomesIds,
    List<String>? notes,
  }) {
    return TornCrime(
      id: id ?? this.id,
      name: name ?? this.name,
      categoryId: categoryId ?? this.categoryId,
      categoryName: categoryName ?? this.categoryName,
      enhancerId: enhancerId ?? this.enhancerId,
      enhancerName: enhancerName ?? this.enhancerName,
      uniqueOutcomesCount: uniqueOutcomesCount ?? this.uniqueOutcomesCount,
      uniqueOutcomesIds: uniqueOutcomesIds ?? this.uniqueOutcomesIds,
      notes: notes ?? this.notes,
    );
  }

  TornCrime copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<String>? name,
    Wrapped<int>? categoryId,
    Wrapped<String?>? categoryName,
    Wrapped<int>? enhancerId,
    Wrapped<String>? enhancerName,
    Wrapped<int>? uniqueOutcomesCount,
    Wrapped<List<int>>? uniqueOutcomesIds,
    Wrapped<List<String>>? notes,
  }) {
    return TornCrime(
      id: (id != null ? id.value : this.id),
      name: (name != null ? name.value : this.name),
      categoryId: (categoryId != null ? categoryId.value : this.categoryId),
      categoryName: (categoryName != null ? categoryName.value : this.categoryName),
      enhancerId: (enhancerId != null ? enhancerId.value : this.enhancerId),
      enhancerName: (enhancerName != null ? enhancerName.value : this.enhancerName),
      uniqueOutcomesCount: (uniqueOutcomesCount != null ? uniqueOutcomesCount.value : this.uniqueOutcomesCount),
      uniqueOutcomesIds: (uniqueOutcomesIds != null ? uniqueOutcomesIds.value : this.uniqueOutcomesIds),
      notes: (notes != null ? notes.value : this.notes),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TornCrimesResponse {
  const TornCrimesResponse({required this.crimes});

  factory TornCrimesResponse.fromJson(Map<String, dynamic> json) => _$TornCrimesResponseFromJson(json);

  static const toJsonFactory = _$TornCrimesResponseToJson;
  Map<String, dynamic> toJson() => _$TornCrimesResponseToJson(this);

  @JsonKey(name: 'crimes', defaultValue: <TornCrime>[])
  final List<TornCrime> crimes;
  static const fromJsonFactory = _$TornCrimesResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TornCrimesResponse &&
            (identical(other.crimes, crimes) || const DeepCollectionEquality().equals(other.crimes, crimes)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(crimes) ^ runtimeType.hashCode;
}

extension $TornCrimesResponseExtension on TornCrimesResponse {
  TornCrimesResponse copyWith({List<TornCrime>? crimes}) {
    return TornCrimesResponse(crimes: crimes ?? this.crimes);
  }

  TornCrimesResponse copyWithWrapped({Wrapped<List<TornCrime>>? crimes}) {
    return TornCrimesResponse(
      crimes: (crimes != null ? crimes.value : this.crimes),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TornCalendarActivity {
  const TornCalendarActivity({
    required this.title,
    required this.description,
    required this.start,
    required this.end,
  });

  factory TornCalendarActivity.fromJson(Map<String, dynamic> json) => _$TornCalendarActivityFromJson(json);

  static const toJsonFactory = _$TornCalendarActivityToJson;
  Map<String, dynamic> toJson() => _$TornCalendarActivityToJson(this);

  @JsonKey(name: 'title')
  final String title;
  @JsonKey(name: 'description')
  final String description;
  @JsonKey(name: 'start')
  final int start;
  @JsonKey(name: 'end')
  final int end;
  static const fromJsonFactory = _$TornCalendarActivityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TornCalendarActivity &&
            (identical(other.title, title) || const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.start, start) || const DeepCollectionEquality().equals(other.start, start)) &&
            (identical(other.end, end) || const DeepCollectionEquality().equals(other.end, end)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(start) ^
      const DeepCollectionEquality().hash(end) ^
      runtimeType.hashCode;
}

extension $TornCalendarActivityExtension on TornCalendarActivity {
  TornCalendarActivity copyWith({
    String? title,
    String? description,
    int? start,
    int? end,
  }) {
    return TornCalendarActivity(
      title: title ?? this.title,
      description: description ?? this.description,
      start: start ?? this.start,
      end: end ?? this.end,
    );
  }

  TornCalendarActivity copyWithWrapped({
    Wrapped<String>? title,
    Wrapped<String>? description,
    Wrapped<int>? start,
    Wrapped<int>? end,
  }) {
    return TornCalendarActivity(
      title: (title != null ? title.value : this.title),
      description: (description != null ? description.value : this.description),
      start: (start != null ? start.value : this.start),
      end: (end != null ? end.value : this.end),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TornCalendarResponse {
  const TornCalendarResponse({required this.calendar});

  factory TornCalendarResponse.fromJson(Map<String, dynamic> json) => _$TornCalendarResponseFromJson(json);

  static const toJsonFactory = _$TornCalendarResponseToJson;
  Map<String, dynamic> toJson() => _$TornCalendarResponseToJson(this);

  @JsonKey(name: 'calendar')
  final TornCalendarResponse$Calendar calendar;
  static const fromJsonFactory = _$TornCalendarResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TornCalendarResponse &&
            (identical(other.calendar, calendar) ||
                const DeepCollectionEquality().equals(
                  other.calendar,
                  calendar,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(calendar) ^ runtimeType.hashCode;
}

extension $TornCalendarResponseExtension on TornCalendarResponse {
  TornCalendarResponse copyWith({TornCalendarResponse$Calendar? calendar}) {
    return TornCalendarResponse(calendar: calendar ?? this.calendar);
  }

  TornCalendarResponse copyWithWrapped({
    Wrapped<TornCalendarResponse$Calendar>? calendar,
  }) {
    return TornCalendarResponse(
      calendar: (calendar != null ? calendar.value : this.calendar),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TornHof {
  const TornHof({
    required this.id,
    required this.username,
    required this.factionId,
    required this.level,
    required this.lastAction,
    required this.rankName,
    required this.rankNumber,
    required this.position,
    required this.signedUp,
    required this.ageInDays,
    required this.$value,
    required this.rank,
  });

  factory TornHof.fromJson(Map<String, dynamic> json) => _$TornHofFromJson(json);

  static const toJsonFactory = _$TornHofToJson;
  Map<String, dynamic> toJson() => _$TornHofToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'username')
  final String username;
  @JsonKey(name: 'faction_id')
  final int factionId;
  @JsonKey(name: 'level')
  final int level;
  @JsonKey(name: 'last_action')
  final int lastAction;
  @JsonKey(name: 'rank_name')
  final String rankName;
  @JsonKey(name: 'rank_number')
  final int rankNumber;
  @JsonKey(name: 'position')
  final int position;
  @JsonKey(name: 'signed_up')
  final int signedUp;
  @JsonKey(name: 'age_in_days')
  final int ageInDays;
  @JsonKey(name: 'value')
  final dynamic $value;
  @JsonKey(name: 'rank')
  final String rank;
  static const fromJsonFactory = _$TornHofFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TornHof &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.username, username) ||
                const DeepCollectionEquality().equals(
                  other.username,
                  username,
                )) &&
            (identical(other.factionId, factionId) ||
                const DeepCollectionEquality().equals(
                  other.factionId,
                  factionId,
                )) &&
            (identical(other.level, level) || const DeepCollectionEquality().equals(other.level, level)) &&
            (identical(other.lastAction, lastAction) ||
                const DeepCollectionEquality().equals(
                  other.lastAction,
                  lastAction,
                )) &&
            (identical(other.rankName, rankName) ||
                const DeepCollectionEquality().equals(
                  other.rankName,
                  rankName,
                )) &&
            (identical(other.rankNumber, rankNumber) ||
                const DeepCollectionEquality().equals(
                  other.rankNumber,
                  rankNumber,
                )) &&
            (identical(other.position, position) ||
                const DeepCollectionEquality().equals(
                  other.position,
                  position,
                )) &&
            (identical(other.signedUp, signedUp) ||
                const DeepCollectionEquality().equals(
                  other.signedUp,
                  signedUp,
                )) &&
            (identical(other.ageInDays, ageInDays) ||
                const DeepCollectionEquality().equals(
                  other.ageInDays,
                  ageInDays,
                )) &&
            (identical(other.$value, $value) || const DeepCollectionEquality().equals(other.$value, $value)) &&
            (identical(other.rank, rank) || const DeepCollectionEquality().equals(other.rank, rank)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(username) ^
      const DeepCollectionEquality().hash(factionId) ^
      const DeepCollectionEquality().hash(level) ^
      const DeepCollectionEquality().hash(lastAction) ^
      const DeepCollectionEquality().hash(rankName) ^
      const DeepCollectionEquality().hash(rankNumber) ^
      const DeepCollectionEquality().hash(position) ^
      const DeepCollectionEquality().hash(signedUp) ^
      const DeepCollectionEquality().hash(ageInDays) ^
      const DeepCollectionEquality().hash($value) ^
      const DeepCollectionEquality().hash(rank) ^
      runtimeType.hashCode;
}

extension $TornHofExtension on TornHof {
  TornHof copyWith({
    int? id,
    String? username,
    int? factionId,
    int? level,
    int? lastAction,
    String? rankName,
    int? rankNumber,
    int? position,
    int? signedUp,
    int? ageInDays,
    dynamic $value,
    String? rank,
  }) {
    return TornHof(
      id: id ?? this.id,
      username: username ?? this.username,
      factionId: factionId ?? this.factionId,
      level: level ?? this.level,
      lastAction: lastAction ?? this.lastAction,
      rankName: rankName ?? this.rankName,
      rankNumber: rankNumber ?? this.rankNumber,
      position: position ?? this.position,
      signedUp: signedUp ?? this.signedUp,
      ageInDays: ageInDays ?? this.ageInDays,
      $value: $value ?? this.$value,
      rank: rank ?? this.rank,
    );
  }

  TornHof copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<String>? username,
    Wrapped<int>? factionId,
    Wrapped<int>? level,
    Wrapped<int>? lastAction,
    Wrapped<String>? rankName,
    Wrapped<int>? rankNumber,
    Wrapped<int>? position,
    Wrapped<int>? signedUp,
    Wrapped<int>? ageInDays,
    Wrapped<dynamic>? $value,
    Wrapped<String>? rank,
  }) {
    return TornHof(
      id: (id != null ? id.value : this.id),
      username: (username != null ? username.value : this.username),
      factionId: (factionId != null ? factionId.value : this.factionId),
      level: (level != null ? level.value : this.level),
      lastAction: (lastAction != null ? lastAction.value : this.lastAction),
      rankName: (rankName != null ? rankName.value : this.rankName),
      rankNumber: (rankNumber != null ? rankNumber.value : this.rankNumber),
      position: (position != null ? position.value : this.position),
      signedUp: (signedUp != null ? signedUp.value : this.signedUp),
      ageInDays: (ageInDays != null ? ageInDays.value : this.ageInDays),
      $value: ($value != null ? $value.value : this.$value),
      rank: (rank != null ? rank.value : this.rank),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TornHofResponse {
  const TornHofResponse({required this.hof, required this.metadata});

  factory TornHofResponse.fromJson(Map<String, dynamic> json) => _$TornHofResponseFromJson(json);

  static const toJsonFactory = _$TornHofResponseToJson;
  Map<String, dynamic> toJson() => _$TornHofResponseToJson(this);

  @JsonKey(name: 'hof', defaultValue: <TornHof>[])
  final List<TornHof> hof;
  @JsonKey(name: '_metadata')
  final RequestMetadataWithLinks metadata;
  static const fromJsonFactory = _$TornHofResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TornHofResponse &&
            (identical(other.hof, hof) || const DeepCollectionEquality().equals(other.hof, hof)) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality().equals(
                  other.metadata,
                  metadata,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(hof) ^ const DeepCollectionEquality().hash(metadata) ^ runtimeType.hashCode;
}

extension $TornHofResponseExtension on TornHofResponse {
  TornHofResponse copyWith({
    List<TornHof>? hof,
    RequestMetadataWithLinks? metadata,
  }) {
    return TornHofResponse(
      hof: hof ?? this.hof,
      metadata: metadata ?? this.metadata,
    );
  }

  TornHofResponse copyWithWrapped({
    Wrapped<List<TornHof>>? hof,
    Wrapped<RequestMetadataWithLinks>? metadata,
  }) {
    return TornHofResponse(
      hof: (hof != null ? hof.value : this.hof),
      metadata: (metadata != null ? metadata.value : this.metadata),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionHofValues {
  const FactionHofValues({
    required this.chain,
    required this.chainDuration,
    required this.respect,
  });

  factory FactionHofValues.fromJson(Map<String, dynamic> json) => _$FactionHofValuesFromJson(json);

  static const toJsonFactory = _$FactionHofValuesToJson;
  Map<String, dynamic> toJson() => _$FactionHofValuesToJson(this);

  @JsonKey(name: 'chain')
  final dynamic chain;
  @JsonKey(name: 'chain_duration')
  final dynamic chainDuration;
  @JsonKey(name: 'respect')
  final dynamic respect;
  static const fromJsonFactory = _$FactionHofValuesFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionHofValues &&
            (identical(other.chain, chain) || const DeepCollectionEquality().equals(other.chain, chain)) &&
            (identical(other.chainDuration, chainDuration) ||
                const DeepCollectionEquality().equals(
                  other.chainDuration,
                  chainDuration,
                )) &&
            (identical(other.respect, respect) || const DeepCollectionEquality().equals(other.respect, respect)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(chain) ^
      const DeepCollectionEquality().hash(chainDuration) ^
      const DeepCollectionEquality().hash(respect) ^
      runtimeType.hashCode;
}

extension $FactionHofValuesExtension on FactionHofValues {
  FactionHofValues copyWith({
    dynamic chain,
    dynamic chainDuration,
    dynamic respect,
  }) {
    return FactionHofValues(
      chain: chain ?? this.chain,
      chainDuration: chainDuration ?? this.chainDuration,
      respect: respect ?? this.respect,
    );
  }

  FactionHofValues copyWithWrapped({
    Wrapped<dynamic>? chain,
    Wrapped<dynamic>? chainDuration,
    Wrapped<dynamic>? respect,
  }) {
    return FactionHofValues(
      chain: (chain != null ? chain.value : this.chain),
      chainDuration: (chainDuration != null ? chainDuration.value : this.chainDuration),
      respect: (respect != null ? respect.value : this.respect),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TornFactionHof {
  const TornFactionHof({
    required this.id,
    required this.name,
    required this.members,
    required this.position,
    required this.rank,
    required this.values,
  });

  factory TornFactionHof.fromJson(Map<String, dynamic> json) => _$TornFactionHofFromJson(json);

  static const toJsonFactory = _$TornFactionHofToJson;
  Map<String, dynamic> toJson() => _$TornFactionHofToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'members')
  final int members;
  @JsonKey(name: 'position')
  final int position;
  @JsonKey(name: 'rank')
  final String rank;
  @JsonKey(name: 'values')
  final FactionHofValues values;
  static const fromJsonFactory = _$TornFactionHofFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TornFactionHof &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.members, members) ||
                const DeepCollectionEquality().equals(
                  other.members,
                  members,
                )) &&
            (identical(other.position, position) ||
                const DeepCollectionEquality().equals(
                  other.position,
                  position,
                )) &&
            (identical(other.rank, rank) || const DeepCollectionEquality().equals(other.rank, rank)) &&
            (identical(other.values, values) || const DeepCollectionEquality().equals(other.values, values)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(members) ^
      const DeepCollectionEquality().hash(position) ^
      const DeepCollectionEquality().hash(rank) ^
      const DeepCollectionEquality().hash(values) ^
      runtimeType.hashCode;
}

extension $TornFactionHofExtension on TornFactionHof {
  TornFactionHof copyWith({
    int? id,
    String? name,
    int? members,
    int? position,
    String? rank,
    FactionHofValues? values,
  }) {
    return TornFactionHof(
      id: id ?? this.id,
      name: name ?? this.name,
      members: members ?? this.members,
      position: position ?? this.position,
      rank: rank ?? this.rank,
      values: values ?? this.values,
    );
  }

  TornFactionHof copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<String>? name,
    Wrapped<int>? members,
    Wrapped<int>? position,
    Wrapped<String>? rank,
    Wrapped<FactionHofValues>? values,
  }) {
    return TornFactionHof(
      id: (id != null ? id.value : this.id),
      name: (name != null ? name.value : this.name),
      members: (members != null ? members.value : this.members),
      position: (position != null ? position.value : this.position),
      rank: (rank != null ? rank.value : this.rank),
      values: (values != null ? values.value : this.values),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TornFactionHofResponse {
  const TornFactionHofResponse({
    required this.factionhof,
    required this.metadata,
  });

  factory TornFactionHofResponse.fromJson(Map<String, dynamic> json) => _$TornFactionHofResponseFromJson(json);

  static const toJsonFactory = _$TornFactionHofResponseToJson;
  Map<String, dynamic> toJson() => _$TornFactionHofResponseToJson(this);

  @JsonKey(name: 'factionhof', defaultValue: <TornFactionHof>[])
  final List<TornFactionHof> factionhof;
  @JsonKey(name: '_metadata')
  final RequestMetadataWithLinks metadata;
  static const fromJsonFactory = _$TornFactionHofResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TornFactionHofResponse &&
            (identical(other.factionhof, factionhof) ||
                const DeepCollectionEquality().equals(
                  other.factionhof,
                  factionhof,
                )) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality().equals(
                  other.metadata,
                  metadata,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(factionhof) ^
      const DeepCollectionEquality().hash(metadata) ^
      runtimeType.hashCode;
}

extension $TornFactionHofResponseExtension on TornFactionHofResponse {
  TornFactionHofResponse copyWith({
    List<TornFactionHof>? factionhof,
    RequestMetadataWithLinks? metadata,
  }) {
    return TornFactionHofResponse(
      factionhof: factionhof ?? this.factionhof,
      metadata: metadata ?? this.metadata,
    );
  }

  TornFactionHofResponse copyWithWrapped({
    Wrapped<List<TornFactionHof>>? factionhof,
    Wrapped<RequestMetadataWithLinks>? metadata,
  }) {
    return TornFactionHofResponse(
      factionhof: (factionhof != null ? factionhof.value : this.factionhof),
      metadata: (metadata != null ? metadata.value : this.metadata),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TornLog {
  const TornLog({required this.id, required this.title});

  factory TornLog.fromJson(Map<String, dynamic> json) => _$TornLogFromJson(json);

  static const toJsonFactory = _$TornLogToJson;
  Map<String, dynamic> toJson() => _$TornLogToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'title')
  final String title;
  static const fromJsonFactory = _$TornLogFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TornLog &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.title, title) || const DeepCollectionEquality().equals(other.title, title)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^ const DeepCollectionEquality().hash(title) ^ runtimeType.hashCode;
}

extension $TornLogExtension on TornLog {
  TornLog copyWith({int? id, String? title}) {
    return TornLog(id: id ?? this.id, title: title ?? this.title);
  }

  TornLog copyWithWrapped({Wrapped<int>? id, Wrapped<String>? title}) {
    return TornLog(
      id: (id != null ? id.value : this.id),
      title: (title != null ? title.value : this.title),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TornLogCategory {
  const TornLogCategory({required this.id, required this.title});

  factory TornLogCategory.fromJson(Map<String, dynamic> json) => _$TornLogCategoryFromJson(json);

  static const toJsonFactory = _$TornLogCategoryToJson;
  Map<String, dynamic> toJson() => _$TornLogCategoryToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'title')
  final String title;
  static const fromJsonFactory = _$TornLogCategoryFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TornLogCategory &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.title, title) || const DeepCollectionEquality().equals(other.title, title)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^ const DeepCollectionEquality().hash(title) ^ runtimeType.hashCode;
}

extension $TornLogCategoryExtension on TornLogCategory {
  TornLogCategory copyWith({int? id, String? title}) {
    return TornLogCategory(id: id ?? this.id, title: title ?? this.title);
  }

  TornLogCategory copyWithWrapped({Wrapped<int>? id, Wrapped<String>? title}) {
    return TornLogCategory(
      id: (id != null ? id.value : this.id),
      title: (title != null ? title.value : this.title),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TornLogTypesResponse {
  const TornLogTypesResponse({required this.logtypes});

  factory TornLogTypesResponse.fromJson(Map<String, dynamic> json) => _$TornLogTypesResponseFromJson(json);

  static const toJsonFactory = _$TornLogTypesResponseToJson;
  Map<String, dynamic> toJson() => _$TornLogTypesResponseToJson(this);

  @JsonKey(name: 'logtypes', defaultValue: <TornLog>[])
  final List<TornLog> logtypes;
  static const fromJsonFactory = _$TornLogTypesResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TornLogTypesResponse &&
            (identical(other.logtypes, logtypes) ||
                const DeepCollectionEquality().equals(
                  other.logtypes,
                  logtypes,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(logtypes) ^ runtimeType.hashCode;
}

extension $TornLogTypesResponseExtension on TornLogTypesResponse {
  TornLogTypesResponse copyWith({List<TornLog>? logtypes}) {
    return TornLogTypesResponse(logtypes: logtypes ?? this.logtypes);
  }

  TornLogTypesResponse copyWithWrapped({Wrapped<List<TornLog>>? logtypes}) {
    return TornLogTypesResponse(
      logtypes: (logtypes != null ? logtypes.value : this.logtypes),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TornLogCategoriesResponse {
  const TornLogCategoriesResponse({required this.logcategories});

  factory TornLogCategoriesResponse.fromJson(Map<String, dynamic> json) => _$TornLogCategoriesResponseFromJson(json);

  static const toJsonFactory = _$TornLogCategoriesResponseToJson;
  Map<String, dynamic> toJson() => _$TornLogCategoriesResponseToJson(this);

  @JsonKey(name: 'logcategories', defaultValue: <TornLogCategory>[])
  final List<TornLogCategory> logcategories;
  static const fromJsonFactory = _$TornLogCategoriesResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TornLogCategoriesResponse &&
            (identical(other.logcategories, logcategories) ||
                const DeepCollectionEquality().equals(
                  other.logcategories,
                  logcategories,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(logcategories) ^ runtimeType.hashCode;
}

extension $TornLogCategoriesResponseExtension on TornLogCategoriesResponse {
  TornLogCategoriesResponse copyWith({List<TornLogCategory>? logcategories}) {
    return TornLogCategoriesResponse(
      logcategories: logcategories ?? this.logcategories,
    );
  }

  TornLogCategoriesResponse copyWithWrapped({
    Wrapped<List<TornLogCategory>>? logcategories,
  }) {
    return TornLogCategoriesResponse(
      logcategories: (logcategories != null ? logcategories.value : this.logcategories),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class Bounty {
  const Bounty({
    required this.targetId,
    required this.targetName,
    required this.targetLevel,
    required this.listerId,
    required this.listerName,
    required this.reward,
    required this.reason,
    required this.quantity,
    required this.isAnonymous,
    required this.validUntil,
  });

  factory Bounty.fromJson(Map<String, dynamic> json) => _$BountyFromJson(json);

  static const toJsonFactory = _$BountyToJson;
  Map<String, dynamic> toJson() => _$BountyToJson(this);

  @JsonKey(name: 'target_id')
  final int targetId;
  @JsonKey(name: 'target_name')
  final String targetName;
  @JsonKey(name: 'target_level')
  final int targetLevel;
  @JsonKey(name: 'lister_id')
  final dynamic listerId;
  @JsonKey(name: 'lister_name')
  final dynamic listerName;
  @JsonKey(name: 'reward')
  final int reward;
  @JsonKey(name: 'reason')
  final dynamic reason;
  @JsonKey(name: 'quantity')
  final int quantity;
  @JsonKey(name: 'is_anonymous')
  final bool isAnonymous;
  @JsonKey(name: 'valid_until')
  final int validUntil;
  static const fromJsonFactory = _$BountyFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Bounty &&
            (identical(other.targetId, targetId) ||
                const DeepCollectionEquality().equals(
                  other.targetId,
                  targetId,
                )) &&
            (identical(other.targetName, targetName) ||
                const DeepCollectionEquality().equals(
                  other.targetName,
                  targetName,
                )) &&
            (identical(other.targetLevel, targetLevel) ||
                const DeepCollectionEquality().equals(
                  other.targetLevel,
                  targetLevel,
                )) &&
            (identical(other.listerId, listerId) ||
                const DeepCollectionEquality().equals(
                  other.listerId,
                  listerId,
                )) &&
            (identical(other.listerName, listerName) ||
                const DeepCollectionEquality().equals(
                  other.listerName,
                  listerName,
                )) &&
            (identical(other.reward, reward) || const DeepCollectionEquality().equals(other.reward, reward)) &&
            (identical(other.reason, reason) || const DeepCollectionEquality().equals(other.reason, reason)) &&
            (identical(other.quantity, quantity) ||
                const DeepCollectionEquality().equals(
                  other.quantity,
                  quantity,
                )) &&
            (identical(other.isAnonymous, isAnonymous) ||
                const DeepCollectionEquality().equals(
                  other.isAnonymous,
                  isAnonymous,
                )) &&
            (identical(other.validUntil, validUntil) ||
                const DeepCollectionEquality().equals(
                  other.validUntil,
                  validUntil,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(targetId) ^
      const DeepCollectionEquality().hash(targetName) ^
      const DeepCollectionEquality().hash(targetLevel) ^
      const DeepCollectionEquality().hash(listerId) ^
      const DeepCollectionEquality().hash(listerName) ^
      const DeepCollectionEquality().hash(reward) ^
      const DeepCollectionEquality().hash(reason) ^
      const DeepCollectionEquality().hash(quantity) ^
      const DeepCollectionEquality().hash(isAnonymous) ^
      const DeepCollectionEquality().hash(validUntil) ^
      runtimeType.hashCode;
}

extension $BountyExtension on Bounty {
  Bounty copyWith({
    int? targetId,
    String? targetName,
    int? targetLevel,
    dynamic listerId,
    dynamic listerName,
    int? reward,
    dynamic reason,
    int? quantity,
    bool? isAnonymous,
    int? validUntil,
  }) {
    return Bounty(
      targetId: targetId ?? this.targetId,
      targetName: targetName ?? this.targetName,
      targetLevel: targetLevel ?? this.targetLevel,
      listerId: listerId ?? this.listerId,
      listerName: listerName ?? this.listerName,
      reward: reward ?? this.reward,
      reason: reason ?? this.reason,
      quantity: quantity ?? this.quantity,
      isAnonymous: isAnonymous ?? this.isAnonymous,
      validUntil: validUntil ?? this.validUntil,
    );
  }

  Bounty copyWithWrapped({
    Wrapped<int>? targetId,
    Wrapped<String>? targetName,
    Wrapped<int>? targetLevel,
    Wrapped<dynamic>? listerId,
    Wrapped<dynamic>? listerName,
    Wrapped<int>? reward,
    Wrapped<dynamic>? reason,
    Wrapped<int>? quantity,
    Wrapped<bool>? isAnonymous,
    Wrapped<int>? validUntil,
  }) {
    return Bounty(
      targetId: (targetId != null ? targetId.value : this.targetId),
      targetName: (targetName != null ? targetName.value : this.targetName),
      targetLevel: (targetLevel != null ? targetLevel.value : this.targetLevel),
      listerId: (listerId != null ? listerId.value : this.listerId),
      listerName: (listerName != null ? listerName.value : this.listerName),
      reward: (reward != null ? reward.value : this.reward),
      reason: (reason != null ? reason.value : this.reason),
      quantity: (quantity != null ? quantity.value : this.quantity),
      isAnonymous: (isAnonymous != null ? isAnonymous.value : this.isAnonymous),
      validUntil: (validUntil != null ? validUntil.value : this.validUntil),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class AttackLogSummary {
  const AttackLogSummary({
    required this.id,
    required this.name,
    required this.hits,
    required this.misses,
    required this.damage,
  });

  factory AttackLogSummary.fromJson(Map<String, dynamic> json) => _$AttackLogSummaryFromJson(json);

  static const toJsonFactory = _$AttackLogSummaryToJson;
  Map<String, dynamic> toJson() => _$AttackLogSummaryToJson(this);

  @JsonKey(name: 'id')
  final dynamic id;
  @JsonKey(name: 'name')
  final dynamic name;
  @JsonKey(name: 'hits')
  final int hits;
  @JsonKey(name: 'misses')
  final int misses;
  @JsonKey(name: 'damage')
  final int damage;
  static const fromJsonFactory = _$AttackLogSummaryFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AttackLogSummary &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.hits, hits) || const DeepCollectionEquality().equals(other.hits, hits)) &&
            (identical(other.misses, misses) || const DeepCollectionEquality().equals(other.misses, misses)) &&
            (identical(other.damage, damage) || const DeepCollectionEquality().equals(other.damage, damage)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(hits) ^
      const DeepCollectionEquality().hash(misses) ^
      const DeepCollectionEquality().hash(damage) ^
      runtimeType.hashCode;
}

extension $AttackLogSummaryExtension on AttackLogSummary {
  AttackLogSummary copyWith({
    dynamic id,
    dynamic name,
    int? hits,
    int? misses,
    int? damage,
  }) {
    return AttackLogSummary(
      id: id ?? this.id,
      name: name ?? this.name,
      hits: hits ?? this.hits,
      misses: misses ?? this.misses,
      damage: damage ?? this.damage,
    );
  }

  AttackLogSummary copyWithWrapped({
    Wrapped<dynamic>? id,
    Wrapped<dynamic>? name,
    Wrapped<int>? hits,
    Wrapped<int>? misses,
    Wrapped<int>? damage,
  }) {
    return AttackLogSummary(
      id: (id != null ? id.value : this.id),
      name: (name != null ? name.value : this.name),
      hits: (hits != null ? hits.value : this.hits),
      misses: (misses != null ? misses.value : this.misses),
      damage: (damage != null ? damage.value : this.damage),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class AttackLog {
  const AttackLog({
    required this.text,
    required this.timestamp,
    required this.action,
    required this.icon,
    required this.attacker,
    required this.defender,
    this.attackerItem,
  });

  factory AttackLog.fromJson(Map<String, dynamic> json) => _$AttackLogFromJson(json);

  static const toJsonFactory = _$AttackLogToJson;
  Map<String, dynamic> toJson() => _$AttackLogToJson(this);

  @JsonKey(name: 'text')
  final String text;
  @JsonKey(name: 'timestamp')
  final int timestamp;
  @JsonKey(
    name: 'action',
    toJson: attackActionEnumToJson,
    fromJson: attackActionEnumFromJson,
  )
  final enums.AttackActionEnum action;
  @JsonKey(name: 'icon')
  final String icon;
  @JsonKey(name: 'attacker')
  final dynamic attacker;
  @JsonKey(name: 'defender')
  final dynamic defender;
  @JsonKey(name: 'attacker_item')
  final AttackLog$AttackerItem? attackerItem;
  static const fromJsonFactory = _$AttackLogFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AttackLog &&
            (identical(other.text, text) || const DeepCollectionEquality().equals(other.text, text)) &&
            (identical(other.timestamp, timestamp) ||
                const DeepCollectionEquality().equals(
                  other.timestamp,
                  timestamp,
                )) &&
            (identical(other.action, action) || const DeepCollectionEquality().equals(other.action, action)) &&
            (identical(other.icon, icon) || const DeepCollectionEquality().equals(other.icon, icon)) &&
            (identical(other.attacker, attacker) ||
                const DeepCollectionEquality().equals(
                  other.attacker,
                  attacker,
                )) &&
            (identical(other.defender, defender) ||
                const DeepCollectionEquality().equals(
                  other.defender,
                  defender,
                )) &&
            (identical(other.attackerItem, attackerItem) ||
                const DeepCollectionEquality().equals(
                  other.attackerItem,
                  attackerItem,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(text) ^
      const DeepCollectionEquality().hash(timestamp) ^
      const DeepCollectionEquality().hash(action) ^
      const DeepCollectionEquality().hash(icon) ^
      const DeepCollectionEquality().hash(attacker) ^
      const DeepCollectionEquality().hash(defender) ^
      const DeepCollectionEquality().hash(attackerItem) ^
      runtimeType.hashCode;
}

extension $AttackLogExtension on AttackLog {
  AttackLog copyWith({
    String? text,
    int? timestamp,
    enums.AttackActionEnum? action,
    String? icon,
    dynamic attacker,
    dynamic defender,
    AttackLog$AttackerItem? attackerItem,
  }) {
    return AttackLog(
      text: text ?? this.text,
      timestamp: timestamp ?? this.timestamp,
      action: action ?? this.action,
      icon: icon ?? this.icon,
      attacker: attacker ?? this.attacker,
      defender: defender ?? this.defender,
      attackerItem: attackerItem ?? this.attackerItem,
    );
  }

  AttackLog copyWithWrapped({
    Wrapped<String>? text,
    Wrapped<int>? timestamp,
    Wrapped<enums.AttackActionEnum>? action,
    Wrapped<String>? icon,
    Wrapped<dynamic>? attacker,
    Wrapped<dynamic>? defender,
    Wrapped<AttackLog$AttackerItem?>? attackerItem,
  }) {
    return AttackLog(
      text: (text != null ? text.value : this.text),
      timestamp: (timestamp != null ? timestamp.value : this.timestamp),
      action: (action != null ? action.value : this.action),
      icon: (icon != null ? icon.value : this.icon),
      attacker: (attacker != null ? attacker.value : this.attacker),
      defender: (defender != null ? defender.value : this.defender),
      attackerItem: (attackerItem != null ? attackerItem.value : this.attackerItem),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class AttackLogResponse {
  const AttackLogResponse({required this.attacklog, required this.metadata});

  factory AttackLogResponse.fromJson(Map<String, dynamic> json) => _$AttackLogResponseFromJson(json);

  static const toJsonFactory = _$AttackLogResponseToJson;
  Map<String, dynamic> toJson() => _$AttackLogResponseToJson(this);

  @JsonKey(name: 'attacklog')
  final AttackLogResponse$Attacklog attacklog;
  @JsonKey(name: '_metadata')
  final RequestMetadataWithLinks metadata;
  static const fromJsonFactory = _$AttackLogResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AttackLogResponse &&
            (identical(other.attacklog, attacklog) ||
                const DeepCollectionEquality().equals(
                  other.attacklog,
                  attacklog,
                )) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality().equals(
                  other.metadata,
                  metadata,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(attacklog) ^
      const DeepCollectionEquality().hash(metadata) ^
      runtimeType.hashCode;
}

extension $AttackLogResponseExtension on AttackLogResponse {
  AttackLogResponse copyWith({
    AttackLogResponse$Attacklog? attacklog,
    RequestMetadataWithLinks? metadata,
  }) {
    return AttackLogResponse(
      attacklog: attacklog ?? this.attacklog,
      metadata: metadata ?? this.metadata,
    );
  }

  AttackLogResponse copyWithWrapped({
    Wrapped<AttackLogResponse$Attacklog>? attacklog,
    Wrapped<RequestMetadataWithLinks>? metadata,
  }) {
    return AttackLogResponse(
      attacklog: (attacklog != null ? attacklog.value : this.attacklog),
      metadata: (metadata != null ? metadata.value : this.metadata),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TornBountiesResponse {
  const TornBountiesResponse({required this.bounties, required this.metadata});

  factory TornBountiesResponse.fromJson(Map<String, dynamic> json) => _$TornBountiesResponseFromJson(json);

  static const toJsonFactory = _$TornBountiesResponseToJson;
  Map<String, dynamic> toJson() => _$TornBountiesResponseToJson(this);

  @JsonKey(name: 'bounties', defaultValue: <Bounty>[])
  final List<Bounty> bounties;
  @JsonKey(name: '_metadata')
  final RequestMetadataWithLinks metadata;
  static const fromJsonFactory = _$TornBountiesResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TornBountiesResponse &&
            (identical(other.bounties, bounties) ||
                const DeepCollectionEquality().equals(
                  other.bounties,
                  bounties,
                )) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality().equals(
                  other.metadata,
                  metadata,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(bounties) ^
      const DeepCollectionEquality().hash(metadata) ^
      runtimeType.hashCode;
}

extension $TornBountiesResponseExtension on TornBountiesResponse {
  TornBountiesResponse copyWith({
    List<Bounty>? bounties,
    RequestMetadataWithLinks? metadata,
  }) {
    return TornBountiesResponse(
      bounties: bounties ?? this.bounties,
      metadata: metadata ?? this.metadata,
    );
  }

  TornBountiesResponse copyWithWrapped({
    Wrapped<List<Bounty>>? bounties,
    Wrapped<RequestMetadataWithLinks>? metadata,
  }) {
    return TornBountiesResponse(
      bounties: (bounties != null ? bounties.value : this.bounties),
      metadata: (metadata != null ? metadata.value : this.metadata),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TornItemAmmo {
  const TornItemAmmo({
    required this.id,
    required this.name,
    required this.price,
    required this.types,
  });

  factory TornItemAmmo.fromJson(Map<String, dynamic> json) => _$TornItemAmmoFromJson(json);

  static const toJsonFactory = _$TornItemAmmoToJson;
  Map<String, dynamic> toJson() => _$TornItemAmmoToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'price')
  final int price;
  @JsonKey(
    name: 'types',
    toJson: tornItemAmmoTypeEnumListToJson,
    fromJson: tornItemAmmoTypeEnumListFromJson,
  )
  final List<enums.TornItemAmmoTypeEnum> types;
  static const fromJsonFactory = _$TornItemAmmoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TornItemAmmo &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.price, price) || const DeepCollectionEquality().equals(other.price, price)) &&
            (identical(other.types, types) || const DeepCollectionEquality().equals(other.types, types)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(price) ^
      const DeepCollectionEquality().hash(types) ^
      runtimeType.hashCode;
}

extension $TornItemAmmoExtension on TornItemAmmo {
  TornItemAmmo copyWith({
    int? id,
    String? name,
    int? price,
    List<enums.TornItemAmmoTypeEnum>? types,
  }) {
    return TornItemAmmo(
      id: id ?? this.id,
      name: name ?? this.name,
      price: price ?? this.price,
      types: types ?? this.types,
    );
  }

  TornItemAmmo copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<String>? name,
    Wrapped<int>? price,
    Wrapped<List<enums.TornItemAmmoTypeEnum>>? types,
  }) {
    return TornItemAmmo(
      id: (id != null ? id.value : this.id),
      name: (name != null ? name.value : this.name),
      price: (price != null ? price.value : this.price),
      types: (types != null ? types.value : this.types),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TornItemAmmoResponse {
  const TornItemAmmoResponse({required this.itemammo});

  factory TornItemAmmoResponse.fromJson(Map<String, dynamic> json) => _$TornItemAmmoResponseFromJson(json);

  static const toJsonFactory = _$TornItemAmmoResponseToJson;
  Map<String, dynamic> toJson() => _$TornItemAmmoResponseToJson(this);

  @JsonKey(name: 'itemammo', defaultValue: <TornItemAmmo>[])
  final List<TornItemAmmo> itemammo;
  static const fromJsonFactory = _$TornItemAmmoResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TornItemAmmoResponse &&
            (identical(other.itemammo, itemammo) ||
                const DeepCollectionEquality().equals(
                  other.itemammo,
                  itemammo,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(itemammo) ^ runtimeType.hashCode;
}

extension $TornItemAmmoResponseExtension on TornItemAmmoResponse {
  TornItemAmmoResponse copyWith({List<TornItemAmmo>? itemammo}) {
    return TornItemAmmoResponse(itemammo: itemammo ?? this.itemammo);
  }

  TornItemAmmoResponse copyWithWrapped({
    Wrapped<List<TornItemAmmo>>? itemammo,
  }) {
    return TornItemAmmoResponse(
      itemammo: (itemammo != null ? itemammo.value : this.itemammo),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TornItemMods {
  const TornItemMods({
    required this.id,
    required this.name,
    required this.description,
    required this.dualFit,
    required this.weapons,
  });

  factory TornItemMods.fromJson(Map<String, dynamic> json) => _$TornItemModsFromJson(json);

  static const toJsonFactory = _$TornItemModsToJson;
  Map<String, dynamic> toJson() => _$TornItemModsToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'description')
  final String description;
  @JsonKey(name: 'dual_fit')
  final bool dualFit;
  @JsonKey(
    name: 'weapons',
    toJson: tornItemWeaponTypeEnumListToJson,
    fromJson: tornItemWeaponTypeEnumListFromJson,
  )
  final List<enums.TornItemWeaponTypeEnum> weapons;
  static const fromJsonFactory = _$TornItemModsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TornItemMods &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.dualFit, dualFit) ||
                const DeepCollectionEquality().equals(
                  other.dualFit,
                  dualFit,
                )) &&
            (identical(other.weapons, weapons) || const DeepCollectionEquality().equals(other.weapons, weapons)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(dualFit) ^
      const DeepCollectionEquality().hash(weapons) ^
      runtimeType.hashCode;
}

extension $TornItemModsExtension on TornItemMods {
  TornItemMods copyWith({
    int? id,
    String? name,
    String? description,
    bool? dualFit,
    List<enums.TornItemWeaponTypeEnum>? weapons,
  }) {
    return TornItemMods(
      id: id ?? this.id,
      name: name ?? this.name,
      description: description ?? this.description,
      dualFit: dualFit ?? this.dualFit,
      weapons: weapons ?? this.weapons,
    );
  }

  TornItemMods copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<String>? name,
    Wrapped<String>? description,
    Wrapped<bool>? dualFit,
    Wrapped<List<enums.TornItemWeaponTypeEnum>>? weapons,
  }) {
    return TornItemMods(
      id: (id != null ? id.value : this.id),
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
      dualFit: (dualFit != null ? dualFit.value : this.dualFit),
      weapons: (weapons != null ? weapons.value : this.weapons),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TornItemModsResponse {
  const TornItemModsResponse({required this.itemmods});

  factory TornItemModsResponse.fromJson(Map<String, dynamic> json) => _$TornItemModsResponseFromJson(json);

  static const toJsonFactory = _$TornItemModsResponseToJson;
  Map<String, dynamic> toJson() => _$TornItemModsResponseToJson(this);

  @JsonKey(name: 'itemmods', defaultValue: <TornItemMods>[])
  final List<TornItemMods> itemmods;
  static const fromJsonFactory = _$TornItemModsResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TornItemModsResponse &&
            (identical(other.itemmods, itemmods) ||
                const DeepCollectionEquality().equals(
                  other.itemmods,
                  itemmods,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(itemmods) ^ runtimeType.hashCode;
}

extension $TornItemModsResponseExtension on TornItemModsResponse {
  TornItemModsResponse copyWith({List<TornItemMods>? itemmods}) {
    return TornItemModsResponse(itemmods: itemmods ?? this.itemmods);
  }

  TornItemModsResponse copyWithWrapped({
    Wrapped<List<TornItemMods>>? itemmods,
  }) {
    return TornItemModsResponse(
      itemmods: (itemmods != null ? itemmods.value : this.itemmods),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TornItemBaseStats {
  const TornItemBaseStats({
    required this.damage,
    required this.accuracy,
    required this.armor,
  });

  factory TornItemBaseStats.fromJson(Map<String, dynamic> json) => _$TornItemBaseStatsFromJson(json);

  static const toJsonFactory = _$TornItemBaseStatsToJson;
  Map<String, dynamic> toJson() => _$TornItemBaseStatsToJson(this);

  @JsonKey(name: 'damage')
  final int damage;
  @JsonKey(name: 'accuracy')
  final int accuracy;
  @JsonKey(name: 'armor')
  final int armor;
  static const fromJsonFactory = _$TornItemBaseStatsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TornItemBaseStats &&
            (identical(other.damage, damage) || const DeepCollectionEquality().equals(other.damage, damage)) &&
            (identical(other.accuracy, accuracy) ||
                const DeepCollectionEquality().equals(
                  other.accuracy,
                  accuracy,
                )) &&
            (identical(other.armor, armor) || const DeepCollectionEquality().equals(other.armor, armor)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(damage) ^
      const DeepCollectionEquality().hash(accuracy) ^
      const DeepCollectionEquality().hash(armor) ^
      runtimeType.hashCode;
}

extension $TornItemBaseStatsExtension on TornItemBaseStats {
  TornItemBaseStats copyWith({int? damage, int? accuracy, int? armor}) {
    return TornItemBaseStats(
      damage: damage ?? this.damage,
      accuracy: accuracy ?? this.accuracy,
      armor: armor ?? this.armor,
    );
  }

  TornItemBaseStats copyWithWrapped({
    Wrapped<int>? damage,
    Wrapped<int>? accuracy,
    Wrapped<int>? armor,
  }) {
    return TornItemBaseStats(
      damage: (damage != null ? damage.value : this.damage),
      accuracy: (accuracy != null ? accuracy.value : this.accuracy),
      armor: (armor != null ? armor.value : this.armor),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TornItemWeaponDetails {
  const TornItemWeaponDetails({
    required this.stealthLevel,
    required this.baseStats,
    required this.category,
    required this.ammo,
    required this.mods,
  });

  factory TornItemWeaponDetails.fromJson(Map<String, dynamic> json) => _$TornItemWeaponDetailsFromJson(json);

  static const toJsonFactory = _$TornItemWeaponDetailsToJson;
  Map<String, dynamic> toJson() => _$TornItemWeaponDetailsToJson(this);

  @JsonKey(name: 'stealth_level')
  final double stealthLevel;
  @JsonKey(name: 'base_stats')
  final TornItemBaseStats baseStats;
  @JsonKey(
    name: 'category',
    toJson: tornItemWeaponCategoryEnumToJson,
    fromJson: tornItemWeaponCategoryEnumFromJson,
  )
  final enums.TornItemWeaponCategoryEnum category;
  @JsonKey(name: 'ammo')
  final dynamic ammo;
  @JsonKey(name: 'mods', defaultValue: <int>[])
  final List<int> mods;
  static const fromJsonFactory = _$TornItemWeaponDetailsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TornItemWeaponDetails &&
            (identical(other.stealthLevel, stealthLevel) ||
                const DeepCollectionEquality().equals(
                  other.stealthLevel,
                  stealthLevel,
                )) &&
            (identical(other.baseStats, baseStats) ||
                const DeepCollectionEquality().equals(
                  other.baseStats,
                  baseStats,
                )) &&
            (identical(other.category, category) ||
                const DeepCollectionEquality().equals(
                  other.category,
                  category,
                )) &&
            (identical(other.ammo, ammo) || const DeepCollectionEquality().equals(other.ammo, ammo)) &&
            (identical(other.mods, mods) || const DeepCollectionEquality().equals(other.mods, mods)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(stealthLevel) ^
      const DeepCollectionEquality().hash(baseStats) ^
      const DeepCollectionEquality().hash(category) ^
      const DeepCollectionEquality().hash(ammo) ^
      const DeepCollectionEquality().hash(mods) ^
      runtimeType.hashCode;
}

extension $TornItemWeaponDetailsExtension on TornItemWeaponDetails {
  TornItemWeaponDetails copyWith({
    double? stealthLevel,
    TornItemBaseStats? baseStats,
    enums.TornItemWeaponCategoryEnum? category,
    dynamic ammo,
    List<int>? mods,
  }) {
    return TornItemWeaponDetails(
      stealthLevel: stealthLevel ?? this.stealthLevel,
      baseStats: baseStats ?? this.baseStats,
      category: category ?? this.category,
      ammo: ammo ?? this.ammo,
      mods: mods ?? this.mods,
    );
  }

  TornItemWeaponDetails copyWithWrapped({
    Wrapped<double>? stealthLevel,
    Wrapped<TornItemBaseStats>? baseStats,
    Wrapped<enums.TornItemWeaponCategoryEnum>? category,
    Wrapped<dynamic>? ammo,
    Wrapped<List<int>>? mods,
  }) {
    return TornItemWeaponDetails(
      stealthLevel: (stealthLevel != null ? stealthLevel.value : this.stealthLevel),
      baseStats: (baseStats != null ? baseStats.value : this.baseStats),
      category: (category != null ? category.value : this.category),
      ammo: (ammo != null ? ammo.value : this.ammo),
      mods: (mods != null ? mods.value : this.mods),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TornItemArmorCoverage {
  const TornItemArmorCoverage({required this.name, required this.$value});

  factory TornItemArmorCoverage.fromJson(Map<String, dynamic> json) => _$TornItemArmorCoverageFromJson(json);

  static const toJsonFactory = _$TornItemArmorCoverageToJson;
  Map<String, dynamic> toJson() => _$TornItemArmorCoverageToJson(this);

  @JsonKey(
    name: 'name',
    toJson: tornItemArmorCoveragePartEnumToJson,
    fromJson: tornItemArmorCoveragePartEnumFromJson,
  )
  final enums.TornItemArmorCoveragePartEnum name;
  @JsonKey(name: 'value')
  final double $value;
  static const fromJsonFactory = _$TornItemArmorCoverageFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TornItemArmorCoverage &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.$value, $value) || const DeepCollectionEquality().equals(other.$value, $value)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^ const DeepCollectionEquality().hash($value) ^ runtimeType.hashCode;
}

extension $TornItemArmorCoverageExtension on TornItemArmorCoverage {
  TornItemArmorCoverage copyWith({
    enums.TornItemArmorCoveragePartEnum? name,
    double? $value,
  }) {
    return TornItemArmorCoverage(
      name: name ?? this.name,
      $value: $value ?? this.$value,
    );
  }

  TornItemArmorCoverage copyWithWrapped({
    Wrapped<enums.TornItemArmorCoveragePartEnum>? name,
    Wrapped<double>? $value,
  }) {
    return TornItemArmorCoverage(
      name: (name != null ? name.value : this.name),
      $value: ($value != null ? $value.value : this.$value),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TornItemArmorDetails {
  const TornItemArmorDetails({required this.coverage, required this.baseStats});

  factory TornItemArmorDetails.fromJson(Map<String, dynamic> json) => _$TornItemArmorDetailsFromJson(json);

  static const toJsonFactory = _$TornItemArmorDetailsToJson;
  Map<String, dynamic> toJson() => _$TornItemArmorDetailsToJson(this);

  @JsonKey(name: 'coverage', defaultValue: <TornItemArmorCoverage>[])
  final List<TornItemArmorCoverage> coverage;
  @JsonKey(name: 'base_stats')
  final TornItemBaseStats baseStats;
  static const fromJsonFactory = _$TornItemArmorDetailsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TornItemArmorDetails &&
            (identical(other.coverage, coverage) ||
                const DeepCollectionEquality().equals(
                  other.coverage,
                  coverage,
                )) &&
            (identical(other.baseStats, baseStats) ||
                const DeepCollectionEquality().equals(
                  other.baseStats,
                  baseStats,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(coverage) ^
      const DeepCollectionEquality().hash(baseStats) ^
      runtimeType.hashCode;
}

extension $TornItemArmorDetailsExtension on TornItemArmorDetails {
  TornItemArmorDetails copyWith({
    List<TornItemArmorCoverage>? coverage,
    TornItemBaseStats? baseStats,
  }) {
    return TornItemArmorDetails(
      coverage: coverage ?? this.coverage,
      baseStats: baseStats ?? this.baseStats,
    );
  }

  TornItemArmorDetails copyWithWrapped({
    Wrapped<List<TornItemArmorCoverage>>? coverage,
    Wrapped<TornItemBaseStats>? baseStats,
  }) {
    return TornItemArmorDetails(
      coverage: (coverage != null ? coverage.value : this.coverage),
      baseStats: (baseStats != null ? baseStats.value : this.baseStats),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TornItem {
  const TornItem({
    required this.id,
    required this.name,
    required this.description,
    required this.effect,
    required this.requirement,
    required this.image,
    required this.type,
    required this.subType,
    required this.isMasked,
    required this.isTradable,
    required this.isFoundInCity,
    required this.$value,
    required this.circulation,
    required this.details,
  });

  factory TornItem.fromJson(Map<String, dynamic> json) => _$TornItemFromJson(json);

  static const toJsonFactory = _$TornItemToJson;
  Map<String, dynamic> toJson() => _$TornItemToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'description')
  final String description;
  @JsonKey(name: 'effect')
  final dynamic effect;
  @JsonKey(name: 'requirement')
  final dynamic requirement;
  @JsonKey(name: 'image')
  final String image;
  @JsonKey(
    name: 'type',
    toJson: tornItemTypeEnumToJson,
    fromJson: tornItemTypeEnumFromJson,
  )
  final enums.TornItemTypeEnum type;
  @JsonKey(name: 'sub_type')
  final dynamic subType;
  @JsonKey(name: 'is_masked')
  final bool isMasked;
  @JsonKey(name: 'is_tradable')
  final bool isTradable;
  @JsonKey(name: 'is_found_in_city')
  final bool isFoundInCity;
  @JsonKey(name: 'value')
  final TornItem$Value $value;
  @JsonKey(name: 'circulation')
  final int circulation;
  @JsonKey(name: 'details')
  final dynamic details;
  static const fromJsonFactory = _$TornItemFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TornItem &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality().equals(
                  other.description,
                  description,
                )) &&
            (identical(other.effect, effect) || const DeepCollectionEquality().equals(other.effect, effect)) &&
            (identical(other.requirement, requirement) ||
                const DeepCollectionEquality().equals(
                  other.requirement,
                  requirement,
                )) &&
            (identical(other.image, image) || const DeepCollectionEquality().equals(other.image, image)) &&
            (identical(other.type, type) || const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.subType, subType) ||
                const DeepCollectionEquality().equals(
                  other.subType,
                  subType,
                )) &&
            (identical(other.isMasked, isMasked) ||
                const DeepCollectionEquality().equals(
                  other.isMasked,
                  isMasked,
                )) &&
            (identical(other.isTradable, isTradable) ||
                const DeepCollectionEquality().equals(
                  other.isTradable,
                  isTradable,
                )) &&
            (identical(other.isFoundInCity, isFoundInCity) ||
                const DeepCollectionEquality().equals(
                  other.isFoundInCity,
                  isFoundInCity,
                )) &&
            (identical(other.$value, $value) || const DeepCollectionEquality().equals(other.$value, $value)) &&
            (identical(other.circulation, circulation) ||
                const DeepCollectionEquality().equals(
                  other.circulation,
                  circulation,
                )) &&
            (identical(other.details, details) || const DeepCollectionEquality().equals(other.details, details)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(effect) ^
      const DeepCollectionEquality().hash(requirement) ^
      const DeepCollectionEquality().hash(image) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(subType) ^
      const DeepCollectionEquality().hash(isMasked) ^
      const DeepCollectionEquality().hash(isTradable) ^
      const DeepCollectionEquality().hash(isFoundInCity) ^
      const DeepCollectionEquality().hash($value) ^
      const DeepCollectionEquality().hash(circulation) ^
      const DeepCollectionEquality().hash(details) ^
      runtimeType.hashCode;
}

extension $TornItemExtension on TornItem {
  TornItem copyWith({
    int? id,
    String? name,
    String? description,
    dynamic effect,
    dynamic requirement,
    String? image,
    enums.TornItemTypeEnum? type,
    dynamic subType,
    bool? isMasked,
    bool? isTradable,
    bool? isFoundInCity,
    TornItem$Value? $value,
    int? circulation,
    dynamic details,
  }) {
    return TornItem(
      id: id ?? this.id,
      name: name ?? this.name,
      description: description ?? this.description,
      effect: effect ?? this.effect,
      requirement: requirement ?? this.requirement,
      image: image ?? this.image,
      type: type ?? this.type,
      subType: subType ?? this.subType,
      isMasked: isMasked ?? this.isMasked,
      isTradable: isTradable ?? this.isTradable,
      isFoundInCity: isFoundInCity ?? this.isFoundInCity,
      $value: $value ?? this.$value,
      circulation: circulation ?? this.circulation,
      details: details ?? this.details,
    );
  }

  TornItem copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<String>? name,
    Wrapped<String>? description,
    Wrapped<dynamic>? effect,
    Wrapped<dynamic>? requirement,
    Wrapped<String>? image,
    Wrapped<enums.TornItemTypeEnum>? type,
    Wrapped<dynamic>? subType,
    Wrapped<bool>? isMasked,
    Wrapped<bool>? isTradable,
    Wrapped<bool>? isFoundInCity,
    Wrapped<TornItem$Value>? $value,
    Wrapped<int>? circulation,
    Wrapped<dynamic>? details,
  }) {
    return TornItem(
      id: (id != null ? id.value : this.id),
      name: (name != null ? name.value : this.name),
      description: (description != null ? description.value : this.description),
      effect: (effect != null ? effect.value : this.effect),
      requirement: (requirement != null ? requirement.value : this.requirement),
      image: (image != null ? image.value : this.image),
      type: (type != null ? type.value : this.type),
      subType: (subType != null ? subType.value : this.subType),
      isMasked: (isMasked != null ? isMasked.value : this.isMasked),
      isTradable: (isTradable != null ? isTradable.value : this.isTradable),
      isFoundInCity: (isFoundInCity != null ? isFoundInCity.value : this.isFoundInCity),
      $value: ($value != null ? $value.value : this.$value),
      circulation: (circulation != null ? circulation.value : this.circulation),
      details: (details != null ? details.value : this.details),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TornItemsResponse {
  const TornItemsResponse({required this.items});

  factory TornItemsResponse.fromJson(Map<String, dynamic> json) => _$TornItemsResponseFromJson(json);

  static const toJsonFactory = _$TornItemsResponseToJson;
  Map<String, dynamic> toJson() => _$TornItemsResponseToJson(this);

  @JsonKey(name: 'items', defaultValue: <TornItem>[])
  final List<TornItem> items;
  static const fromJsonFactory = _$TornItemsResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TornItemsResponse &&
            (identical(other.items, items) || const DeepCollectionEquality().equals(other.items, items)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(items) ^ runtimeType.hashCode;
}

extension $TornItemsResponseExtension on TornItemsResponse {
  TornItemsResponse copyWith({List<TornItem>? items}) {
    return TornItemsResponse(items: items ?? this.items);
  }

  TornItemsResponse copyWithWrapped({Wrapped<List<TornItem>>? items}) {
    return TornItemsResponse(items: (items != null ? items.value : this.items));
  }
}

@JsonSerializable(explicitToJson: true)
class TornFactionTreeBranch {
  const TornFactionTreeBranch({
    required this.id,
    required this.name,
    required this.upgrades,
  });

  factory TornFactionTreeBranch.fromJson(Map<String, dynamic> json) => _$TornFactionTreeBranchFromJson(json);

  static const toJsonFactory = _$TornFactionTreeBranchToJson;
  Map<String, dynamic> toJson() => _$TornFactionTreeBranchToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'upgrades')
  final List<TornFactionTreeBranch$Upgrades$Item> upgrades;
  static const fromJsonFactory = _$TornFactionTreeBranchFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TornFactionTreeBranch &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.upgrades, upgrades) ||
                const DeepCollectionEquality().equals(
                  other.upgrades,
                  upgrades,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(upgrades) ^
      runtimeType.hashCode;
}

extension $TornFactionTreeBranchExtension on TornFactionTreeBranch {
  TornFactionTreeBranch copyWith({
    int? id,
    String? name,
    List<TornFactionTreeBranch$Upgrades$Item>? upgrades,
  }) {
    return TornFactionTreeBranch(
      id: id ?? this.id,
      name: name ?? this.name,
      upgrades: upgrades ?? this.upgrades,
    );
  }

  TornFactionTreeBranch copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<String>? name,
    Wrapped<List<TornFactionTreeBranch$Upgrades$Item>>? upgrades,
  }) {
    return TornFactionTreeBranch(
      id: (id != null ? id.value : this.id),
      name: (name != null ? name.value : this.name),
      upgrades: (upgrades != null ? upgrades.value : this.upgrades),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TornFactionTree {
  const TornFactionTree({required this.name, required this.branches});

  factory TornFactionTree.fromJson(Map<String, dynamic> json) => _$TornFactionTreeFromJson(json);

  static const toJsonFactory = _$TornFactionTreeToJson;
  Map<String, dynamic> toJson() => _$TornFactionTreeToJson(this);

  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'branches', defaultValue: <TornFactionTreeBranch>[])
  final List<TornFactionTreeBranch> branches;
  static const fromJsonFactory = _$TornFactionTreeFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TornFactionTree &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.branches, branches) ||
                const DeepCollectionEquality().equals(
                  other.branches,
                  branches,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^ const DeepCollectionEquality().hash(branches) ^ runtimeType.hashCode;
}

extension $TornFactionTreeExtension on TornFactionTree {
  TornFactionTree copyWith({
    String? name,
    List<TornFactionTreeBranch>? branches,
  }) {
    return TornFactionTree(
      name: name ?? this.name,
      branches: branches ?? this.branches,
    );
  }

  TornFactionTree copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<List<TornFactionTreeBranch>>? branches,
  }) {
    return TornFactionTree(
      name: (name != null ? name.value : this.name),
      branches: (branches != null ? branches.value : this.branches),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TornFactionTreeResponse {
  const TornFactionTreeResponse({required this.factionTree});

  factory TornFactionTreeResponse.fromJson(Map<String, dynamic> json) => _$TornFactionTreeResponseFromJson(json);

  static const toJsonFactory = _$TornFactionTreeResponseToJson;
  Map<String, dynamic> toJson() => _$TornFactionTreeResponseToJson(this);

  @JsonKey(name: 'factionTree', defaultValue: <TornFactionTree>[])
  final List<TornFactionTree> factionTree;
  static const fromJsonFactory = _$TornFactionTreeResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TornFactionTreeResponse &&
            (identical(other.factionTree, factionTree) ||
                const DeepCollectionEquality().equals(
                  other.factionTree,
                  factionTree,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(factionTree) ^ runtimeType.hashCode;
}

extension $TornFactionTreeResponseExtension on TornFactionTreeResponse {
  TornFactionTreeResponse copyWith({List<TornFactionTree>? factionTree}) {
    return TornFactionTreeResponse(
      factionTree: factionTree ?? this.factionTree,
    );
  }

  TornFactionTreeResponse copyWithWrapped({
    Wrapped<List<TornFactionTree>>? factionTree,
  }) {
    return TornFactionTreeResponse(
      factionTree: (factionTree != null ? factionTree.value : this.factionTree),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TornSelectionName {
  const TornSelectionName();

  factory TornSelectionName.fromJson(Map<String, dynamic> json) => _$TornSelectionNameFromJson(json);

  static const toJsonFactory = _$TornSelectionNameToJson;
  Map<String, dynamic> toJson() => _$TornSelectionNameToJson(this);

  static const fromJsonFactory = _$TornSelectionNameFromJson;

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => runtimeType.hashCode;
}

@JsonSerializable(explicitToJson: true)
class TornLookupResponse {
  const TornLookupResponse({required this.selections});

  factory TornLookupResponse.fromJson(Map<String, dynamic> json) => _$TornLookupResponseFromJson(json);

  static const toJsonFactory = _$TornLookupResponseToJson;
  Map<String, dynamic> toJson() => _$TornLookupResponseToJson(this);

  @JsonKey(name: 'selections', defaultValue: <TornSelectionName>[])
  final List<TornSelectionName> selections;
  static const fromJsonFactory = _$TornLookupResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TornLookupResponse &&
            (identical(other.selections, selections) ||
                const DeepCollectionEquality().equals(
                  other.selections,
                  selections,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(selections) ^ runtimeType.hashCode;
}

extension $TornLookupResponseExtension on TornLookupResponse {
  TornLookupResponse copyWith({List<TornSelectionName>? selections}) {
    return TornLookupResponse(selections: selections ?? this.selections);
  }

  TornLookupResponse copyWithWrapped({
    Wrapped<List<TornSelectionName>>? selections,
  }) {
    return TornLookupResponse(
      selections: (selections != null ? selections.value : this.selections),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class Attack$Modifiers {
  const Attack$Modifiers({
    required this.fairFight,
    required this.war,
    required this.retaliation,
    required this.group,
    required this.overseas,
    required this.chain,
    required this.warlord,
  });

  factory Attack$Modifiers.fromJson(Map<String, dynamic> json) => _$Attack$ModifiersFromJson(json);

  static const toJsonFactory = _$Attack$ModifiersToJson;
  Map<String, dynamic> toJson() => _$Attack$ModifiersToJson(this);

  @JsonKey(name: 'fair_fight')
  final double fairFight;
  @JsonKey(name: 'war')
  final double war;
  @JsonKey(name: 'retaliation')
  final double retaliation;
  @JsonKey(name: 'group')
  final double group;
  @JsonKey(name: 'overseas')
  final double overseas;
  @JsonKey(name: 'chain')
  final double chain;
  @JsonKey(name: 'warlord')
  final double warlord;
  static const fromJsonFactory = _$Attack$ModifiersFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Attack$Modifiers &&
            (identical(other.fairFight, fairFight) ||
                const DeepCollectionEquality().equals(
                  other.fairFight,
                  fairFight,
                )) &&
            (identical(other.war, war) || const DeepCollectionEquality().equals(other.war, war)) &&
            (identical(other.retaliation, retaliation) ||
                const DeepCollectionEquality().equals(
                  other.retaliation,
                  retaliation,
                )) &&
            (identical(other.group, group) || const DeepCollectionEquality().equals(other.group, group)) &&
            (identical(other.overseas, overseas) ||
                const DeepCollectionEquality().equals(
                  other.overseas,
                  overseas,
                )) &&
            (identical(other.chain, chain) || const DeepCollectionEquality().equals(other.chain, chain)) &&
            (identical(other.warlord, warlord) || const DeepCollectionEquality().equals(other.warlord, warlord)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(fairFight) ^
      const DeepCollectionEquality().hash(war) ^
      const DeepCollectionEquality().hash(retaliation) ^
      const DeepCollectionEquality().hash(group) ^
      const DeepCollectionEquality().hash(overseas) ^
      const DeepCollectionEquality().hash(chain) ^
      const DeepCollectionEquality().hash(warlord) ^
      runtimeType.hashCode;
}

extension $Attack$ModifiersExtension on Attack$Modifiers {
  Attack$Modifiers copyWith({
    double? fairFight,
    double? war,
    double? retaliation,
    double? group,
    double? overseas,
    double? chain,
    double? warlord,
  }) {
    return Attack$Modifiers(
      fairFight: fairFight ?? this.fairFight,
      war: war ?? this.war,
      retaliation: retaliation ?? this.retaliation,
      group: group ?? this.group,
      overseas: overseas ?? this.overseas,
      chain: chain ?? this.chain,
      warlord: warlord ?? this.warlord,
    );
  }

  Attack$Modifiers copyWithWrapped({
    Wrapped<double>? fairFight,
    Wrapped<double>? war,
    Wrapped<double>? retaliation,
    Wrapped<double>? group,
    Wrapped<double>? overseas,
    Wrapped<double>? chain,
    Wrapped<double>? warlord,
  }) {
    return Attack$Modifiers(
      fairFight: (fairFight != null ? fairFight.value : this.fairFight),
      war: (war != null ? war.value : this.war),
      retaliation: (retaliation != null ? retaliation.value : this.retaliation),
      group: (group != null ? group.value : this.group),
      overseas: (overseas != null ? overseas.value : this.overseas),
      chain: (chain != null ? chain.value : this.chain),
      warlord: (warlord != null ? warlord.value : this.warlord),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ReviveSimplified$Reviver {
  const ReviveSimplified$Reviver({required this.id, required this.factionId});

  factory ReviveSimplified$Reviver.fromJson(Map<String, dynamic> json) => _$ReviveSimplified$ReviverFromJson(json);

  static const toJsonFactory = _$ReviveSimplified$ReviverToJson;
  Map<String, dynamic> toJson() => _$ReviveSimplified$ReviverToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'faction_id')
  final dynamic factionId;
  static const fromJsonFactory = _$ReviveSimplified$ReviverFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ReviveSimplified$Reviver &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.factionId, factionId) ||
                const DeepCollectionEquality().equals(
                  other.factionId,
                  factionId,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^ const DeepCollectionEquality().hash(factionId) ^ runtimeType.hashCode;
}

extension $ReviveSimplified$ReviverExtension on ReviveSimplified$Reviver {
  ReviveSimplified$Reviver copyWith({int? id, dynamic factionId}) {
    return ReviveSimplified$Reviver(
      id: id ?? this.id,
      factionId: factionId ?? this.factionId,
    );
  }

  ReviveSimplified$Reviver copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<dynamic>? factionId,
  }) {
    return ReviveSimplified$Reviver(
      id: (id != null ? id.value : this.id),
      factionId: (factionId != null ? factionId.value : this.factionId),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ReviveSimplified$Target {
  const ReviveSimplified$Target({
    required this.id,
    required this.factionId,
    required this.hospitalReason,
    required this.earlyDischarge,
    required this.lastAction,
    required this.onlineStatus,
  });

  factory ReviveSimplified$Target.fromJson(Map<String, dynamic> json) => _$ReviveSimplified$TargetFromJson(json);

  static const toJsonFactory = _$ReviveSimplified$TargetToJson;
  Map<String, dynamic> toJson() => _$ReviveSimplified$TargetToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'faction_id')
  final dynamic factionId;
  @JsonKey(name: 'hospital_reason')
  final String hospitalReason;
  @JsonKey(name: 'early_discharge')
  final bool earlyDischarge;
  @JsonKey(name: 'last_action')
  final int lastAction;
  @JsonKey(name: 'online_status')
  final String onlineStatus;
  static const fromJsonFactory = _$ReviveSimplified$TargetFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ReviveSimplified$Target &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.factionId, factionId) ||
                const DeepCollectionEquality().equals(
                  other.factionId,
                  factionId,
                )) &&
            (identical(other.hospitalReason, hospitalReason) ||
                const DeepCollectionEquality().equals(
                  other.hospitalReason,
                  hospitalReason,
                )) &&
            (identical(other.earlyDischarge, earlyDischarge) ||
                const DeepCollectionEquality().equals(
                  other.earlyDischarge,
                  earlyDischarge,
                )) &&
            (identical(other.lastAction, lastAction) ||
                const DeepCollectionEquality().equals(
                  other.lastAction,
                  lastAction,
                )) &&
            (identical(other.onlineStatus, onlineStatus) ||
                const DeepCollectionEquality().equals(
                  other.onlineStatus,
                  onlineStatus,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(factionId) ^
      const DeepCollectionEquality().hash(hospitalReason) ^
      const DeepCollectionEquality().hash(earlyDischarge) ^
      const DeepCollectionEquality().hash(lastAction) ^
      const DeepCollectionEquality().hash(onlineStatus) ^
      runtimeType.hashCode;
}

extension $ReviveSimplified$TargetExtension on ReviveSimplified$Target {
  ReviveSimplified$Target copyWith({
    int? id,
    dynamic factionId,
    String? hospitalReason,
    bool? earlyDischarge,
    int? lastAction,
    String? onlineStatus,
  }) {
    return ReviveSimplified$Target(
      id: id ?? this.id,
      factionId: factionId ?? this.factionId,
      hospitalReason: hospitalReason ?? this.hospitalReason,
      earlyDischarge: earlyDischarge ?? this.earlyDischarge,
      lastAction: lastAction ?? this.lastAction,
      onlineStatus: onlineStatus ?? this.onlineStatus,
    );
  }

  ReviveSimplified$Target copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<dynamic>? factionId,
    Wrapped<String>? hospitalReason,
    Wrapped<bool>? earlyDischarge,
    Wrapped<int>? lastAction,
    Wrapped<String>? onlineStatus,
  }) {
    return ReviveSimplified$Target(
      id: (id != null ? id.value : this.id),
      factionId: (factionId != null ? factionId.value : this.factionId),
      hospitalReason: (hospitalReason != null ? hospitalReason.value : this.hospitalReason),
      earlyDischarge: (earlyDischarge != null ? earlyDischarge.value : this.earlyDischarge),
      lastAction: (lastAction != null ? lastAction.value : this.lastAction),
      onlineStatus: (onlineStatus != null ? onlineStatus.value : this.onlineStatus),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class Revive$Reviver {
  const Revive$Reviver({
    required this.id,
    required this.name,
    required this.faction,
    required this.skill,
  });

  factory Revive$Reviver.fromJson(Map<String, dynamic> json) => _$Revive$ReviverFromJson(json);

  static const toJsonFactory = _$Revive$ReviverToJson;
  Map<String, dynamic> toJson() => _$Revive$ReviverToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'faction')
  final dynamic faction;
  @JsonKey(name: 'skill')
  final dynamic skill;
  static const fromJsonFactory = _$Revive$ReviverFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Revive$Reviver &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.faction, faction) ||
                const DeepCollectionEquality().equals(
                  other.faction,
                  faction,
                )) &&
            (identical(other.skill, skill) || const DeepCollectionEquality().equals(other.skill, skill)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(faction) ^
      const DeepCollectionEquality().hash(skill) ^
      runtimeType.hashCode;
}

extension $Revive$ReviverExtension on Revive$Reviver {
  Revive$Reviver copyWith({
    int? id,
    String? name,
    dynamic faction,
    dynamic skill,
  }) {
    return Revive$Reviver(
      id: id ?? this.id,
      name: name ?? this.name,
      faction: faction ?? this.faction,
      skill: skill ?? this.skill,
    );
  }

  Revive$Reviver copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<String>? name,
    Wrapped<dynamic>? faction,
    Wrapped<dynamic>? skill,
  }) {
    return Revive$Reviver(
      id: (id != null ? id.value : this.id),
      name: (name != null ? name.value : this.name),
      faction: (faction != null ? faction.value : this.faction),
      skill: (skill != null ? skill.value : this.skill),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class Revive$Target {
  const Revive$Target({
    required this.id,
    required this.name,
    required this.faction,
    required this.hospitalReason,
    required this.earlyDischarge,
    required this.lastAction,
    required this.onlineStatus,
  });

  factory Revive$Target.fromJson(Map<String, dynamic> json) => _$Revive$TargetFromJson(json);

  static const toJsonFactory = _$Revive$TargetToJson;
  Map<String, dynamic> toJson() => _$Revive$TargetToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'faction')
  final dynamic faction;
  @JsonKey(name: 'hospital_reason')
  final String hospitalReason;
  @JsonKey(name: 'early_discharge')
  final bool earlyDischarge;
  @JsonKey(name: 'last_action')
  final int lastAction;
  @JsonKey(name: 'online_status')
  final String onlineStatus;
  static const fromJsonFactory = _$Revive$TargetFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Revive$Target &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.faction, faction) ||
                const DeepCollectionEquality().equals(
                  other.faction,
                  faction,
                )) &&
            (identical(other.hospitalReason, hospitalReason) ||
                const DeepCollectionEquality().equals(
                  other.hospitalReason,
                  hospitalReason,
                )) &&
            (identical(other.earlyDischarge, earlyDischarge) ||
                const DeepCollectionEquality().equals(
                  other.earlyDischarge,
                  earlyDischarge,
                )) &&
            (identical(other.lastAction, lastAction) ||
                const DeepCollectionEquality().equals(
                  other.lastAction,
                  lastAction,
                )) &&
            (identical(other.onlineStatus, onlineStatus) ||
                const DeepCollectionEquality().equals(
                  other.onlineStatus,
                  onlineStatus,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(faction) ^
      const DeepCollectionEquality().hash(hospitalReason) ^
      const DeepCollectionEquality().hash(earlyDischarge) ^
      const DeepCollectionEquality().hash(lastAction) ^
      const DeepCollectionEquality().hash(onlineStatus) ^
      runtimeType.hashCode;
}

extension $Revive$TargetExtension on Revive$Target {
  Revive$Target copyWith({
    int? id,
    String? name,
    dynamic faction,
    String? hospitalReason,
    bool? earlyDischarge,
    int? lastAction,
    String? onlineStatus,
  }) {
    return Revive$Target(
      id: id ?? this.id,
      name: name ?? this.name,
      faction: faction ?? this.faction,
      hospitalReason: hospitalReason ?? this.hospitalReason,
      earlyDischarge: earlyDischarge ?? this.earlyDischarge,
      lastAction: lastAction ?? this.lastAction,
      onlineStatus: onlineStatus ?? this.onlineStatus,
    );
  }

  Revive$Target copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<String>? name,
    Wrapped<dynamic>? faction,
    Wrapped<String>? hospitalReason,
    Wrapped<bool>? earlyDischarge,
    Wrapped<int>? lastAction,
    Wrapped<String>? onlineStatus,
  }) {
    return Revive$Target(
      id: (id != null ? id.value : this.id),
      name: (name != null ? name.value : this.name),
      faction: (faction != null ? faction.value : this.faction),
      hospitalReason: (hospitalReason != null ? hospitalReason.value : this.hospitalReason),
      earlyDischarge: (earlyDischarge != null ? earlyDischarge.value : this.earlyDischarge),
      lastAction: (lastAction != null ? lastAction.value : this.lastAction),
      onlineStatus: (onlineStatus != null ? onlineStatus.value : this.onlineStatus),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ReportCompanyFinancials$Wages {
  const ReportCompanyFinancials$Wages({
    required this.highest,
    required this.lowest,
    required this.average,
  });

  factory ReportCompanyFinancials$Wages.fromJson(Map<String, dynamic> json) =>
      _$ReportCompanyFinancials$WagesFromJson(json);

  static const toJsonFactory = _$ReportCompanyFinancials$WagesToJson;
  Map<String, dynamic> toJson() => _$ReportCompanyFinancials$WagesToJson(this);

  @JsonKey(name: 'highest')
  final int highest;
  @JsonKey(name: 'lowest')
  final int lowest;
  @JsonKey(name: 'average')
  final int average;
  static const fromJsonFactory = _$ReportCompanyFinancials$WagesFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ReportCompanyFinancials$Wages &&
            (identical(other.highest, highest) ||
                const DeepCollectionEquality().equals(
                  other.highest,
                  highest,
                )) &&
            (identical(other.lowest, lowest) || const DeepCollectionEquality().equals(other.lowest, lowest)) &&
            (identical(other.average, average) || const DeepCollectionEquality().equals(other.average, average)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(highest) ^
      const DeepCollectionEquality().hash(lowest) ^
      const DeepCollectionEquality().hash(average) ^
      runtimeType.hashCode;
}

extension $ReportCompanyFinancials$WagesExtension on ReportCompanyFinancials$Wages {
  ReportCompanyFinancials$Wages copyWith({
    int? highest,
    int? lowest,
    int? average,
  }) {
    return ReportCompanyFinancials$Wages(
      highest: highest ?? this.highest,
      lowest: lowest ?? this.lowest,
      average: average ?? this.average,
    );
  }

  ReportCompanyFinancials$Wages copyWithWrapped({
    Wrapped<int>? highest,
    Wrapped<int>? lowest,
    Wrapped<int>? average,
  }) {
    return ReportCompanyFinancials$Wages(
      highest: (highest != null ? highest.value : this.highest),
      lowest: (lowest != null ? lowest.value : this.lowest),
      average: (average != null ? average.value : this.average),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ReportStockAnalysis$Items$Item {
  const ReportStockAnalysis$Items$Item({
    required this.country,
    required this.item,
    required this.tripDuration,
    required this.hourlyProfit,
  });

  factory ReportStockAnalysis$Items$Item.fromJson(Map<String, dynamic> json) =>
      _$ReportStockAnalysis$Items$ItemFromJson(json);

  static const toJsonFactory = _$ReportStockAnalysis$Items$ItemToJson;
  Map<String, dynamic> toJson() => _$ReportStockAnalysis$Items$ItemToJson(this);

  @JsonKey(
    name: 'country',
    toJson: countryEnumToJson,
    fromJson: countryEnumFromJson,
  )
  final enums.CountryEnum country;
  @JsonKey(name: 'item')
  final ReportStockAnalysis$Items$Item$Item item;
  @JsonKey(name: 'trip_duration')
  final int tripDuration;
  @JsonKey(name: 'hourly_profit')
  final int hourlyProfit;
  static const fromJsonFactory = _$ReportStockAnalysis$Items$ItemFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ReportStockAnalysis$Items$Item &&
            (identical(other.country, country) ||
                const DeepCollectionEquality().equals(
                  other.country,
                  country,
                )) &&
            (identical(other.item, item) || const DeepCollectionEquality().equals(other.item, item)) &&
            (identical(other.tripDuration, tripDuration) ||
                const DeepCollectionEquality().equals(
                  other.tripDuration,
                  tripDuration,
                )) &&
            (identical(other.hourlyProfit, hourlyProfit) ||
                const DeepCollectionEquality().equals(
                  other.hourlyProfit,
                  hourlyProfit,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(country) ^
      const DeepCollectionEquality().hash(item) ^
      const DeepCollectionEquality().hash(tripDuration) ^
      const DeepCollectionEquality().hash(hourlyProfit) ^
      runtimeType.hashCode;
}

extension $ReportStockAnalysis$Items$ItemExtension on ReportStockAnalysis$Items$Item {
  ReportStockAnalysis$Items$Item copyWith({
    enums.CountryEnum? country,
    ReportStockAnalysis$Items$Item$Item? item,
    int? tripDuration,
    int? hourlyProfit,
  }) {
    return ReportStockAnalysis$Items$Item(
      country: country ?? this.country,
      item: item ?? this.item,
      tripDuration: tripDuration ?? this.tripDuration,
      hourlyProfit: hourlyProfit ?? this.hourlyProfit,
    );
  }

  ReportStockAnalysis$Items$Item copyWithWrapped({
    Wrapped<enums.CountryEnum>? country,
    Wrapped<ReportStockAnalysis$Items$Item$Item>? item,
    Wrapped<int>? tripDuration,
    Wrapped<int>? hourlyProfit,
  }) {
    return ReportStockAnalysis$Items$Item(
      country: (country != null ? country.value : this.country),
      item: (item != null ? item.value : this.item),
      tripDuration: (tripDuration != null ? tripDuration.value : this.tripDuration),
      hourlyProfit: (hourlyProfit != null ? hourlyProfit.value : this.hourlyProfit),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ReportAnonymousBounties$Bounties$Item {
  const ReportAnonymousBounties$Bounties$Item({
    required this.text,
    required this.bounty,
    required this.user,
  });

  factory ReportAnonymousBounties$Bounties$Item.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$ReportAnonymousBounties$Bounties$ItemFromJson(json);

  static const toJsonFactory = _$ReportAnonymousBounties$Bounties$ItemToJson;
  Map<String, dynamic> toJson() => _$ReportAnonymousBounties$Bounties$ItemToJson(this);

  @JsonKey(name: 'text')
  final String text;
  @JsonKey(name: 'bounty')
  final int bounty;
  @JsonKey(name: 'user')
  final dynamic user;
  static const fromJsonFactory = _$ReportAnonymousBounties$Bounties$ItemFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ReportAnonymousBounties$Bounties$Item &&
            (identical(other.text, text) || const DeepCollectionEquality().equals(other.text, text)) &&
            (identical(other.bounty, bounty) || const DeepCollectionEquality().equals(other.bounty, bounty)) &&
            (identical(other.user, user) || const DeepCollectionEquality().equals(other.user, user)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(text) ^
      const DeepCollectionEquality().hash(bounty) ^
      const DeepCollectionEquality().hash(user) ^
      runtimeType.hashCode;
}

extension $ReportAnonymousBounties$Bounties$ItemExtension on ReportAnonymousBounties$Bounties$Item {
  ReportAnonymousBounties$Bounties$Item copyWith({
    String? text,
    int? bounty,
    dynamic user,
  }) {
    return ReportAnonymousBounties$Bounties$Item(
      text: text ?? this.text,
      bounty: bounty ?? this.bounty,
      user: user ?? this.user,
    );
  }

  ReportAnonymousBounties$Bounties$Item copyWithWrapped({
    Wrapped<String>? text,
    Wrapped<int>? bounty,
    Wrapped<dynamic>? user,
  }) {
    return ReportAnonymousBounties$Bounties$Item(
      text: (text != null ? text.value : this.text),
      bounty: (bounty != null ? bounty.value : this.bounty),
      user: (user != null ? user.value : this.user),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserPropertyBasicDetails$Upkeep {
  const UserPropertyBasicDetails$Upkeep({
    required this.property,
    required this.staff,
  });

  factory UserPropertyBasicDetails$Upkeep.fromJson(Map<String, dynamic> json) =>
      _$UserPropertyBasicDetails$UpkeepFromJson(json);

  static const toJsonFactory = _$UserPropertyBasicDetails$UpkeepToJson;
  Map<String, dynamic> toJson() => _$UserPropertyBasicDetails$UpkeepToJson(this);

  @JsonKey(name: 'property')
  final int property;
  @JsonKey(name: 'staff')
  final int staff;
  static const fromJsonFactory = _$UserPropertyBasicDetails$UpkeepFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserPropertyBasicDetails$Upkeep &&
            (identical(other.property, property) ||
                const DeepCollectionEquality().equals(
                  other.property,
                  property,
                )) &&
            (identical(other.staff, staff) || const DeepCollectionEquality().equals(other.staff, staff)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(property) ^ const DeepCollectionEquality().hash(staff) ^ runtimeType.hashCode;
}

extension $UserPropertyBasicDetails$UpkeepExtension on UserPropertyBasicDetails$Upkeep {
  UserPropertyBasicDetails$Upkeep copyWith({int? property, int? staff}) {
    return UserPropertyBasicDetails$Upkeep(
      property: property ?? this.property,
      staff: staff ?? this.staff,
    );
  }

  UserPropertyBasicDetails$Upkeep copyWithWrapped({
    Wrapped<int>? property,
    Wrapped<int>? staff,
  }) {
    return UserPropertyBasicDetails$Upkeep(
      property: (property != null ? property.value : this.property),
      staff: (staff != null ? staff.value : this.staff),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserPropertyBasicDetails$Staff$Item {
  const UserPropertyBasicDetails$Staff$Item({
    required this.type,
    required this.amount,
  });

  factory UserPropertyBasicDetails$Staff$Item.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$UserPropertyBasicDetails$Staff$ItemFromJson(json);

  static const toJsonFactory = _$UserPropertyBasicDetails$Staff$ItemToJson;
  Map<String, dynamic> toJson() => _$UserPropertyBasicDetails$Staff$ItemToJson(this);

  @JsonKey(
    name: 'type',
    toJson: propertyStaffEnumToJson,
    fromJson: propertyStaffEnumFromJson,
  )
  final enums.PropertyStaffEnum type;
  @JsonKey(name: 'amount')
  final int amount;
  static const fromJsonFactory = _$UserPropertyBasicDetails$Staff$ItemFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserPropertyBasicDetails$Staff$Item &&
            (identical(other.type, type) || const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.amount, amount) || const DeepCollectionEquality().equals(other.amount, amount)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^ const DeepCollectionEquality().hash(amount) ^ runtimeType.hashCode;
}

extension $UserPropertyBasicDetails$Staff$ItemExtension on UserPropertyBasicDetails$Staff$Item {
  UserPropertyBasicDetails$Staff$Item copyWith({
    enums.PropertyStaffEnum? type,
    int? amount,
  }) {
    return UserPropertyBasicDetails$Staff$Item(
      type: type ?? this.type,
      amount: amount ?? this.amount,
    );
  }

  UserPropertyBasicDetails$Staff$Item copyWithWrapped({
    Wrapped<enums.PropertyStaffEnum>? type,
    Wrapped<int>? amount,
  }) {
    return UserPropertyBasicDetails$Staff$Item(
      type: (type != null ? type.value : this.type),
      amount: (amount != null ? amount.value : this.amount),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserPropertyDetailsExtended$Upkeep {
  const UserPropertyDetailsExtended$Upkeep({
    required this.property,
    required this.staff,
  });

  factory UserPropertyDetailsExtended$Upkeep.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$UserPropertyDetailsExtended$UpkeepFromJson(json);

  static const toJsonFactory = _$UserPropertyDetailsExtended$UpkeepToJson;
  Map<String, dynamic> toJson() => _$UserPropertyDetailsExtended$UpkeepToJson(this);

  @JsonKey(name: 'property')
  final int property;
  @JsonKey(name: 'staff')
  final int staff;
  static const fromJsonFactory = _$UserPropertyDetailsExtended$UpkeepFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserPropertyDetailsExtended$Upkeep &&
            (identical(other.property, property) ||
                const DeepCollectionEquality().equals(
                  other.property,
                  property,
                )) &&
            (identical(other.staff, staff) || const DeepCollectionEquality().equals(other.staff, staff)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(property) ^ const DeepCollectionEquality().hash(staff) ^ runtimeType.hashCode;
}

extension $UserPropertyDetailsExtended$UpkeepExtension on UserPropertyDetailsExtended$Upkeep {
  UserPropertyDetailsExtended$Upkeep copyWith({int? property, int? staff}) {
    return UserPropertyDetailsExtended$Upkeep(
      property: property ?? this.property,
      staff: staff ?? this.staff,
    );
  }

  UserPropertyDetailsExtended$Upkeep copyWithWrapped({
    Wrapped<int>? property,
    Wrapped<int>? staff,
  }) {
    return UserPropertyDetailsExtended$Upkeep(
      property: (property != null ? property.value : this.property),
      staff: (staff != null ? staff.value : this.staff),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserPropertyDetailsExtended$Staff$Item {
  const UserPropertyDetailsExtended$Staff$Item({
    required this.type,
    required this.amount,
  });

  factory UserPropertyDetailsExtended$Staff$Item.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$UserPropertyDetailsExtended$Staff$ItemFromJson(json);

  static const toJsonFactory = _$UserPropertyDetailsExtended$Staff$ItemToJson;
  Map<String, dynamic> toJson() => _$UserPropertyDetailsExtended$Staff$ItemToJson(this);

  @JsonKey(
    name: 'type',
    toJson: propertyStaffEnumToJson,
    fromJson: propertyStaffEnumFromJson,
  )
  final enums.PropertyStaffEnum type;
  @JsonKey(name: 'amount')
  final int amount;
  static const fromJsonFactory = _$UserPropertyDetailsExtended$Staff$ItemFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserPropertyDetailsExtended$Staff$Item &&
            (identical(other.type, type) || const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.amount, amount) || const DeepCollectionEquality().equals(other.amount, amount)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^ const DeepCollectionEquality().hash(amount) ^ runtimeType.hashCode;
}

extension $UserPropertyDetailsExtended$Staff$ItemExtension on UserPropertyDetailsExtended$Staff$Item {
  UserPropertyDetailsExtended$Staff$Item copyWith({
    enums.PropertyStaffEnum? type,
    int? amount,
  }) {
    return UserPropertyDetailsExtended$Staff$Item(
      type: type ?? this.type,
      amount: amount ?? this.amount,
    );
  }

  UserPropertyDetailsExtended$Staff$Item copyWithWrapped({
    Wrapped<enums.PropertyStaffEnum>? type,
    Wrapped<int>? amount,
  }) {
    return UserPropertyDetailsExtended$Staff$Item(
      type: (type != null ? type.value : this.type),
      amount: (amount != null ? amount.value : this.amount),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserPropertyDetails$Upkeep {
  const UserPropertyDetails$Upkeep({
    required this.property,
    required this.staff,
  });

  factory UserPropertyDetails$Upkeep.fromJson(Map<String, dynamic> json) => _$UserPropertyDetails$UpkeepFromJson(json);

  static const toJsonFactory = _$UserPropertyDetails$UpkeepToJson;
  Map<String, dynamic> toJson() => _$UserPropertyDetails$UpkeepToJson(this);

  @JsonKey(name: 'property')
  final int property;
  @JsonKey(name: 'staff')
  final int staff;
  static const fromJsonFactory = _$UserPropertyDetails$UpkeepFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserPropertyDetails$Upkeep &&
            (identical(other.property, property) ||
                const DeepCollectionEquality().equals(
                  other.property,
                  property,
                )) &&
            (identical(other.staff, staff) || const DeepCollectionEquality().equals(other.staff, staff)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(property) ^ const DeepCollectionEquality().hash(staff) ^ runtimeType.hashCode;
}

extension $UserPropertyDetails$UpkeepExtension on UserPropertyDetails$Upkeep {
  UserPropertyDetails$Upkeep copyWith({int? property, int? staff}) {
    return UserPropertyDetails$Upkeep(
      property: property ?? this.property,
      staff: staff ?? this.staff,
    );
  }

  UserPropertyDetails$Upkeep copyWithWrapped({
    Wrapped<int>? property,
    Wrapped<int>? staff,
  }) {
    return UserPropertyDetails$Upkeep(
      property: (property != null ? property.value : this.property),
      staff: (staff != null ? staff.value : this.staff),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserPropertyDetails$Staff$Item {
  const UserPropertyDetails$Staff$Item({
    required this.type,
    required this.amount,
  });

  factory UserPropertyDetails$Staff$Item.fromJson(Map<String, dynamic> json) =>
      _$UserPropertyDetails$Staff$ItemFromJson(json);

  static const toJsonFactory = _$UserPropertyDetails$Staff$ItemToJson;
  Map<String, dynamic> toJson() => _$UserPropertyDetails$Staff$ItemToJson(this);

  @JsonKey(
    name: 'type',
    toJson: propertyStaffEnumToJson,
    fromJson: propertyStaffEnumFromJson,
  )
  final enums.PropertyStaffEnum type;
  @JsonKey(name: 'amount')
  final int amount;
  static const fromJsonFactory = _$UserPropertyDetails$Staff$ItemFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserPropertyDetails$Staff$Item &&
            (identical(other.type, type) || const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.amount, amount) || const DeepCollectionEquality().equals(other.amount, amount)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^ const DeepCollectionEquality().hash(amount) ^ runtimeType.hashCode;
}

extension $UserPropertyDetails$Staff$ItemExtension on UserPropertyDetails$Staff$Item {
  UserPropertyDetails$Staff$Item copyWith({
    enums.PropertyStaffEnum? type,
    int? amount,
  }) {
    return UserPropertyDetails$Staff$Item(
      type: type ?? this.type,
      amount: amount ?? this.amount,
    );
  }

  UserPropertyDetails$Staff$Item copyWithWrapped({
    Wrapped<enums.PropertyStaffEnum>? type,
    Wrapped<int>? amount,
  }) {
    return UserPropertyDetails$Staff$Item(
      type: (type != null ? type.value : this.type),
      amount: (amount != null ? amount.value : this.amount),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserPropertyDetailsExtendedRented$Upkeep {
  const UserPropertyDetailsExtendedRented$Upkeep({
    required this.property,
    required this.staff,
  });

  factory UserPropertyDetailsExtendedRented$Upkeep.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$UserPropertyDetailsExtendedRented$UpkeepFromJson(json);

  static const toJsonFactory = _$UserPropertyDetailsExtendedRented$UpkeepToJson;
  Map<String, dynamic> toJson() => _$UserPropertyDetailsExtendedRented$UpkeepToJson(this);

  @JsonKey(name: 'property')
  final int property;
  @JsonKey(name: 'staff')
  final int staff;
  static const fromJsonFactory = _$UserPropertyDetailsExtendedRented$UpkeepFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserPropertyDetailsExtendedRented$Upkeep &&
            (identical(other.property, property) ||
                const DeepCollectionEquality().equals(
                  other.property,
                  property,
                )) &&
            (identical(other.staff, staff) || const DeepCollectionEquality().equals(other.staff, staff)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(property) ^ const DeepCollectionEquality().hash(staff) ^ runtimeType.hashCode;
}

extension $UserPropertyDetailsExtendedRented$UpkeepExtension on UserPropertyDetailsExtendedRented$Upkeep {
  UserPropertyDetailsExtendedRented$Upkeep copyWith({
    int? property,
    int? staff,
  }) {
    return UserPropertyDetailsExtendedRented$Upkeep(
      property: property ?? this.property,
      staff: staff ?? this.staff,
    );
  }

  UserPropertyDetailsExtendedRented$Upkeep copyWithWrapped({
    Wrapped<int>? property,
    Wrapped<int>? staff,
  }) {
    return UserPropertyDetailsExtendedRented$Upkeep(
      property: (property != null ? property.value : this.property),
      staff: (staff != null ? staff.value : this.staff),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserPropertyDetailsExtendedRented$Staff$Item {
  const UserPropertyDetailsExtendedRented$Staff$Item({
    required this.type,
    required this.amount,
  });

  factory UserPropertyDetailsExtendedRented$Staff$Item.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$UserPropertyDetailsExtendedRented$Staff$ItemFromJson(json);

  static const toJsonFactory = _$UserPropertyDetailsExtendedRented$Staff$ItemToJson;
  Map<String, dynamic> toJson() => _$UserPropertyDetailsExtendedRented$Staff$ItemToJson(this);

  @JsonKey(
    name: 'type',
    toJson: propertyStaffEnumToJson,
    fromJson: propertyStaffEnumFromJson,
  )
  final enums.PropertyStaffEnum type;
  @JsonKey(name: 'amount')
  final int amount;
  static const fromJsonFactory = _$UserPropertyDetailsExtendedRented$Staff$ItemFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserPropertyDetailsExtendedRented$Staff$Item &&
            (identical(other.type, type) || const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.amount, amount) || const DeepCollectionEquality().equals(other.amount, amount)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^ const DeepCollectionEquality().hash(amount) ^ runtimeType.hashCode;
}

extension $UserPropertyDetailsExtendedRented$Staff$ItemExtension on UserPropertyDetailsExtendedRented$Staff$Item {
  UserPropertyDetailsExtendedRented$Staff$Item copyWith({
    enums.PropertyStaffEnum? type,
    int? amount,
  }) {
    return UserPropertyDetailsExtendedRented$Staff$Item(
      type: type ?? this.type,
      amount: amount ?? this.amount,
    );
  }

  UserPropertyDetailsExtendedRented$Staff$Item copyWithWrapped({
    Wrapped<enums.PropertyStaffEnum>? type,
    Wrapped<int>? amount,
  }) {
    return UserPropertyDetailsExtendedRented$Staff$Item(
      type: (type != null ? type.value : this.type),
      amount: (amount != null ? amount.value : this.amount),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserPropertyDetailsExtendedForRent$Upkeep {
  const UserPropertyDetailsExtendedForRent$Upkeep({
    required this.property,
    required this.staff,
  });

  factory UserPropertyDetailsExtendedForRent$Upkeep.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$UserPropertyDetailsExtendedForRent$UpkeepFromJson(json);

  static const toJsonFactory = _$UserPropertyDetailsExtendedForRent$UpkeepToJson;
  Map<String, dynamic> toJson() => _$UserPropertyDetailsExtendedForRent$UpkeepToJson(this);

  @JsonKey(name: 'property')
  final int property;
  @JsonKey(name: 'staff')
  final int staff;
  static const fromJsonFactory = _$UserPropertyDetailsExtendedForRent$UpkeepFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserPropertyDetailsExtendedForRent$Upkeep &&
            (identical(other.property, property) ||
                const DeepCollectionEquality().equals(
                  other.property,
                  property,
                )) &&
            (identical(other.staff, staff) || const DeepCollectionEquality().equals(other.staff, staff)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(property) ^ const DeepCollectionEquality().hash(staff) ^ runtimeType.hashCode;
}

extension $UserPropertyDetailsExtendedForRent$UpkeepExtension on UserPropertyDetailsExtendedForRent$Upkeep {
  UserPropertyDetailsExtendedForRent$Upkeep copyWith({
    int? property,
    int? staff,
  }) {
    return UserPropertyDetailsExtendedForRent$Upkeep(
      property: property ?? this.property,
      staff: staff ?? this.staff,
    );
  }

  UserPropertyDetailsExtendedForRent$Upkeep copyWithWrapped({
    Wrapped<int>? property,
    Wrapped<int>? staff,
  }) {
    return UserPropertyDetailsExtendedForRent$Upkeep(
      property: (property != null ? property.value : this.property),
      staff: (staff != null ? staff.value : this.staff),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserPropertyDetailsExtendedForRent$Staff$Item {
  const UserPropertyDetailsExtendedForRent$Staff$Item({
    required this.type,
    required this.amount,
  });

  factory UserPropertyDetailsExtendedForRent$Staff$Item.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$UserPropertyDetailsExtendedForRent$Staff$ItemFromJson(json);

  static const toJsonFactory = _$UserPropertyDetailsExtendedForRent$Staff$ItemToJson;
  Map<String, dynamic> toJson() => _$UserPropertyDetailsExtendedForRent$Staff$ItemToJson(this);

  @JsonKey(
    name: 'type',
    toJson: propertyStaffEnumToJson,
    fromJson: propertyStaffEnumFromJson,
  )
  final enums.PropertyStaffEnum type;
  @JsonKey(name: 'amount')
  final int amount;
  static const fromJsonFactory = _$UserPropertyDetailsExtendedForRent$Staff$ItemFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserPropertyDetailsExtendedForRent$Staff$Item &&
            (identical(other.type, type) || const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.amount, amount) || const DeepCollectionEquality().equals(other.amount, amount)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^ const DeepCollectionEquality().hash(amount) ^ runtimeType.hashCode;
}

extension $UserPropertyDetailsExtendedForRent$Staff$ItemExtension on UserPropertyDetailsExtendedForRent$Staff$Item {
  UserPropertyDetailsExtendedForRent$Staff$Item copyWith({
    enums.PropertyStaffEnum? type,
    int? amount,
  }) {
    return UserPropertyDetailsExtendedForRent$Staff$Item(
      type: type ?? this.type,
      amount: amount ?? this.amount,
    );
  }

  UserPropertyDetailsExtendedForRent$Staff$Item copyWithWrapped({
    Wrapped<enums.PropertyStaffEnum>? type,
    Wrapped<int>? amount,
  }) {
    return UserPropertyDetailsExtendedForRent$Staff$Item(
      type: (type != null ? type.value : this.type),
      amount: (amount != null ? amount.value : this.amount),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserPropertyDetailsExtendedForSale$Upkeep {
  const UserPropertyDetailsExtendedForSale$Upkeep({
    required this.property,
    required this.staff,
  });

  factory UserPropertyDetailsExtendedForSale$Upkeep.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$UserPropertyDetailsExtendedForSale$UpkeepFromJson(json);

  static const toJsonFactory = _$UserPropertyDetailsExtendedForSale$UpkeepToJson;
  Map<String, dynamic> toJson() => _$UserPropertyDetailsExtendedForSale$UpkeepToJson(this);

  @JsonKey(name: 'property')
  final int property;
  @JsonKey(name: 'staff')
  final int staff;
  static const fromJsonFactory = _$UserPropertyDetailsExtendedForSale$UpkeepFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserPropertyDetailsExtendedForSale$Upkeep &&
            (identical(other.property, property) ||
                const DeepCollectionEquality().equals(
                  other.property,
                  property,
                )) &&
            (identical(other.staff, staff) || const DeepCollectionEquality().equals(other.staff, staff)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(property) ^ const DeepCollectionEquality().hash(staff) ^ runtimeType.hashCode;
}

extension $UserPropertyDetailsExtendedForSale$UpkeepExtension on UserPropertyDetailsExtendedForSale$Upkeep {
  UserPropertyDetailsExtendedForSale$Upkeep copyWith({
    int? property,
    int? staff,
  }) {
    return UserPropertyDetailsExtendedForSale$Upkeep(
      property: property ?? this.property,
      staff: staff ?? this.staff,
    );
  }

  UserPropertyDetailsExtendedForSale$Upkeep copyWithWrapped({
    Wrapped<int>? property,
    Wrapped<int>? staff,
  }) {
    return UserPropertyDetailsExtendedForSale$Upkeep(
      property: (property != null ? property.value : this.property),
      staff: (staff != null ? staff.value : this.staff),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserPropertyDetailsExtendedForSale$Staff$Item {
  const UserPropertyDetailsExtendedForSale$Staff$Item({
    required this.type,
    required this.amount,
  });

  factory UserPropertyDetailsExtendedForSale$Staff$Item.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$UserPropertyDetailsExtendedForSale$Staff$ItemFromJson(json);

  static const toJsonFactory = _$UserPropertyDetailsExtendedForSale$Staff$ItemToJson;
  Map<String, dynamic> toJson() => _$UserPropertyDetailsExtendedForSale$Staff$ItemToJson(this);

  @JsonKey(
    name: 'type',
    toJson: propertyStaffEnumToJson,
    fromJson: propertyStaffEnumFromJson,
  )
  final enums.PropertyStaffEnum type;
  @JsonKey(name: 'amount')
  final int amount;
  static const fromJsonFactory = _$UserPropertyDetailsExtendedForSale$Staff$ItemFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserPropertyDetailsExtendedForSale$Staff$Item &&
            (identical(other.type, type) || const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.amount, amount) || const DeepCollectionEquality().equals(other.amount, amount)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^ const DeepCollectionEquality().hash(amount) ^ runtimeType.hashCode;
}

extension $UserPropertyDetailsExtendedForSale$Staff$ItemExtension on UserPropertyDetailsExtendedForSale$Staff$Item {
  UserPropertyDetailsExtendedForSale$Staff$Item copyWith({
    enums.PropertyStaffEnum? type,
    int? amount,
  }) {
    return UserPropertyDetailsExtendedForSale$Staff$Item(
      type: type ?? this.type,
      amount: amount ?? this.amount,
    );
  }

  UserPropertyDetailsExtendedForSale$Staff$Item copyWithWrapped({
    Wrapped<enums.PropertyStaffEnum>? type,
    Wrapped<int>? amount,
  }) {
    return UserPropertyDetailsExtendedForSale$Staff$Item(
      type: (type != null ? type.value : this.type),
      amount: (amount != null ? amount.value : this.amount),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserCrimeDetailsBootlegging$OnlineStore {
  const UserCrimeDetailsBootlegging$OnlineStore({
    required this.earnings,
    required this.visits,
    required this.customers,
    required this.sales,
  });

  factory UserCrimeDetailsBootlegging$OnlineStore.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$UserCrimeDetailsBootlegging$OnlineStoreFromJson(json);

  static const toJsonFactory = _$UserCrimeDetailsBootlegging$OnlineStoreToJson;
  Map<String, dynamic> toJson() => _$UserCrimeDetailsBootlegging$OnlineStoreToJson(this);

  @JsonKey(name: 'earnings')
  final int earnings;
  @JsonKey(name: 'visits')
  final int visits;
  @JsonKey(name: 'customers')
  final int customers;
  @JsonKey(name: 'sales')
  final int sales;
  static const fromJsonFactory = _$UserCrimeDetailsBootlegging$OnlineStoreFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserCrimeDetailsBootlegging$OnlineStore &&
            (identical(other.earnings, earnings) ||
                const DeepCollectionEquality().equals(
                  other.earnings,
                  earnings,
                )) &&
            (identical(other.visits, visits) || const DeepCollectionEquality().equals(other.visits, visits)) &&
            (identical(other.customers, customers) ||
                const DeepCollectionEquality().equals(
                  other.customers,
                  customers,
                )) &&
            (identical(other.sales, sales) || const DeepCollectionEquality().equals(other.sales, sales)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(earnings) ^
      const DeepCollectionEquality().hash(visits) ^
      const DeepCollectionEquality().hash(customers) ^
      const DeepCollectionEquality().hash(sales) ^
      runtimeType.hashCode;
}

extension $UserCrimeDetailsBootlegging$OnlineStoreExtension on UserCrimeDetailsBootlegging$OnlineStore {
  UserCrimeDetailsBootlegging$OnlineStore copyWith({
    int? earnings,
    int? visits,
    int? customers,
    int? sales,
  }) {
    return UserCrimeDetailsBootlegging$OnlineStore(
      earnings: earnings ?? this.earnings,
      visits: visits ?? this.visits,
      customers: customers ?? this.customers,
      sales: sales ?? this.sales,
    );
  }

  UserCrimeDetailsBootlegging$OnlineStore copyWithWrapped({
    Wrapped<int>? earnings,
    Wrapped<int>? visits,
    Wrapped<int>? customers,
    Wrapped<int>? sales,
  }) {
    return UserCrimeDetailsBootlegging$OnlineStore(
      earnings: (earnings != null ? earnings.value : this.earnings),
      visits: (visits != null ? visits.value : this.visits),
      customers: (customers != null ? customers.value : this.customers),
      sales: (sales != null ? sales.value : this.sales),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserCrimeDetailsBootlegging$DvdSales {
  const UserCrimeDetailsBootlegging$DvdSales({
    required this.action,
    required this.comedy,
    required this.drama,
    required this.fantasy,
    required this.horror,
    required this.romance,
    required this.thriller,
    required this.sciFi,
    required this.total,
    required this.earnings,
  });

  factory UserCrimeDetailsBootlegging$DvdSales.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$UserCrimeDetailsBootlegging$DvdSalesFromJson(json);

  static const toJsonFactory = _$UserCrimeDetailsBootlegging$DvdSalesToJson;
  Map<String, dynamic> toJson() => _$UserCrimeDetailsBootlegging$DvdSalesToJson(this);

  @JsonKey(name: 'action')
  final int action;
  @JsonKey(name: 'comedy')
  final int comedy;
  @JsonKey(name: 'drama')
  final int drama;
  @JsonKey(name: 'fantasy')
  final int fantasy;
  @JsonKey(name: 'horror')
  final int horror;
  @JsonKey(name: 'romance')
  final int romance;
  @JsonKey(name: 'thriller')
  final int thriller;
  @JsonKey(name: 'sci_fi')
  final int sciFi;
  @JsonKey(name: 'total')
  final int total;
  @JsonKey(name: 'earnings')
  final int earnings;
  static const fromJsonFactory = _$UserCrimeDetailsBootlegging$DvdSalesFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserCrimeDetailsBootlegging$DvdSales &&
            (identical(other.action, action) || const DeepCollectionEquality().equals(other.action, action)) &&
            (identical(other.comedy, comedy) || const DeepCollectionEquality().equals(other.comedy, comedy)) &&
            (identical(other.drama, drama) || const DeepCollectionEquality().equals(other.drama, drama)) &&
            (identical(other.fantasy, fantasy) ||
                const DeepCollectionEquality().equals(
                  other.fantasy,
                  fantasy,
                )) &&
            (identical(other.horror, horror) || const DeepCollectionEquality().equals(other.horror, horror)) &&
            (identical(other.romance, romance) ||
                const DeepCollectionEquality().equals(
                  other.romance,
                  romance,
                )) &&
            (identical(other.thriller, thriller) ||
                const DeepCollectionEquality().equals(
                  other.thriller,
                  thriller,
                )) &&
            (identical(other.sciFi, sciFi) || const DeepCollectionEquality().equals(other.sciFi, sciFi)) &&
            (identical(other.total, total) || const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.earnings, earnings) ||
                const DeepCollectionEquality().equals(
                  other.earnings,
                  earnings,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(action) ^
      const DeepCollectionEquality().hash(comedy) ^
      const DeepCollectionEquality().hash(drama) ^
      const DeepCollectionEquality().hash(fantasy) ^
      const DeepCollectionEquality().hash(horror) ^
      const DeepCollectionEquality().hash(romance) ^
      const DeepCollectionEquality().hash(thriller) ^
      const DeepCollectionEquality().hash(sciFi) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(earnings) ^
      runtimeType.hashCode;
}

extension $UserCrimeDetailsBootlegging$DvdSalesExtension on UserCrimeDetailsBootlegging$DvdSales {
  UserCrimeDetailsBootlegging$DvdSales copyWith({
    int? action,
    int? comedy,
    int? drama,
    int? fantasy,
    int? horror,
    int? romance,
    int? thriller,
    int? sciFi,
    int? total,
    int? earnings,
  }) {
    return UserCrimeDetailsBootlegging$DvdSales(
      action: action ?? this.action,
      comedy: comedy ?? this.comedy,
      drama: drama ?? this.drama,
      fantasy: fantasy ?? this.fantasy,
      horror: horror ?? this.horror,
      romance: romance ?? this.romance,
      thriller: thriller ?? this.thriller,
      sciFi: sciFi ?? this.sciFi,
      total: total ?? this.total,
      earnings: earnings ?? this.earnings,
    );
  }

  UserCrimeDetailsBootlegging$DvdSales copyWithWrapped({
    Wrapped<int>? action,
    Wrapped<int>? comedy,
    Wrapped<int>? drama,
    Wrapped<int>? fantasy,
    Wrapped<int>? horror,
    Wrapped<int>? romance,
    Wrapped<int>? thriller,
    Wrapped<int>? sciFi,
    Wrapped<int>? total,
    Wrapped<int>? earnings,
  }) {
    return UserCrimeDetailsBootlegging$DvdSales(
      action: (action != null ? action.value : this.action),
      comedy: (comedy != null ? comedy.value : this.comedy),
      drama: (drama != null ? drama.value : this.drama),
      fantasy: (fantasy != null ? fantasy.value : this.fantasy),
      horror: (horror != null ? horror.value : this.horror),
      romance: (romance != null ? romance.value : this.romance),
      thriller: (thriller != null ? thriller.value : this.thriller),
      sciFi: (sciFi != null ? sciFi.value : this.sciFi),
      total: (total != null ? total.value : this.total),
      earnings: (earnings != null ? earnings.value : this.earnings),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserCrimeDetailsCardSkimming$CardDetails {
  const UserCrimeDetailsCardSkimming$CardDetails({
    required this.recoverable,
    required this.recovered,
    required this.sold,
    required this.lost,
    required this.areas,
  });

  factory UserCrimeDetailsCardSkimming$CardDetails.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$UserCrimeDetailsCardSkimming$CardDetailsFromJson(json);

  static const toJsonFactory = _$UserCrimeDetailsCardSkimming$CardDetailsToJson;
  Map<String, dynamic> toJson() => _$UserCrimeDetailsCardSkimming$CardDetailsToJson(this);

  @JsonKey(name: 'recoverable')
  final int recoverable;
  @JsonKey(name: 'recovered')
  final int recovered;
  @JsonKey(name: 'sold')
  final int sold;
  @JsonKey(name: 'lost')
  final int lost;
  @JsonKey(name: 'areas')
  final List<UserCrimeDetailsCardSkimming$CardDetails$Areas$Item> areas;
  static const fromJsonFactory = _$UserCrimeDetailsCardSkimming$CardDetailsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserCrimeDetailsCardSkimming$CardDetails &&
            (identical(other.recoverable, recoverable) ||
                const DeepCollectionEquality().equals(
                  other.recoverable,
                  recoverable,
                )) &&
            (identical(other.recovered, recovered) ||
                const DeepCollectionEquality().equals(
                  other.recovered,
                  recovered,
                )) &&
            (identical(other.sold, sold) || const DeepCollectionEquality().equals(other.sold, sold)) &&
            (identical(other.lost, lost) || const DeepCollectionEquality().equals(other.lost, lost)) &&
            (identical(other.areas, areas) || const DeepCollectionEquality().equals(other.areas, areas)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(recoverable) ^
      const DeepCollectionEquality().hash(recovered) ^
      const DeepCollectionEquality().hash(sold) ^
      const DeepCollectionEquality().hash(lost) ^
      const DeepCollectionEquality().hash(areas) ^
      runtimeType.hashCode;
}

extension $UserCrimeDetailsCardSkimming$CardDetailsExtension on UserCrimeDetailsCardSkimming$CardDetails {
  UserCrimeDetailsCardSkimming$CardDetails copyWith({
    int? recoverable,
    int? recovered,
    int? sold,
    int? lost,
    List<UserCrimeDetailsCardSkimming$CardDetails$Areas$Item>? areas,
  }) {
    return UserCrimeDetailsCardSkimming$CardDetails(
      recoverable: recoverable ?? this.recoverable,
      recovered: recovered ?? this.recovered,
      sold: sold ?? this.sold,
      lost: lost ?? this.lost,
      areas: areas ?? this.areas,
    );
  }

  UserCrimeDetailsCardSkimming$CardDetails copyWithWrapped({
    Wrapped<int>? recoverable,
    Wrapped<int>? recovered,
    Wrapped<int>? sold,
    Wrapped<int>? lost,
    Wrapped<List<UserCrimeDetailsCardSkimming$CardDetails$Areas$Item>>? areas,
  }) {
    return UserCrimeDetailsCardSkimming$CardDetails(
      recoverable: (recoverable != null ? recoverable.value : this.recoverable),
      recovered: (recovered != null ? recovered.value : this.recovered),
      sold: (sold != null ? sold.value : this.sold),
      lost: (lost != null ? lost.value : this.lost),
      areas: (areas != null ? areas.value : this.areas),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserCrimeDetailsCardSkimming$Skimmers {
  const UserCrimeDetailsCardSkimming$Skimmers({
    required this.active,
    required this.mostLucrative,
    required this.oldestRecovered,
    required this.lost,
  });

  factory UserCrimeDetailsCardSkimming$Skimmers.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$UserCrimeDetailsCardSkimming$SkimmersFromJson(json);

  static const toJsonFactory = _$UserCrimeDetailsCardSkimming$SkimmersToJson;
  Map<String, dynamic> toJson() => _$UserCrimeDetailsCardSkimming$SkimmersToJson(this);

  @JsonKey(name: 'active')
  final int active;
  @JsonKey(name: 'most_lucrative')
  final int mostLucrative;
  @JsonKey(name: 'oldest_recovered')
  final int oldestRecovered;
  @JsonKey(name: 'lost')
  final int lost;
  static const fromJsonFactory = _$UserCrimeDetailsCardSkimming$SkimmersFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserCrimeDetailsCardSkimming$Skimmers &&
            (identical(other.active, active) || const DeepCollectionEquality().equals(other.active, active)) &&
            (identical(other.mostLucrative, mostLucrative) ||
                const DeepCollectionEquality().equals(
                  other.mostLucrative,
                  mostLucrative,
                )) &&
            (identical(other.oldestRecovered, oldestRecovered) ||
                const DeepCollectionEquality().equals(
                  other.oldestRecovered,
                  oldestRecovered,
                )) &&
            (identical(other.lost, lost) || const DeepCollectionEquality().equals(other.lost, lost)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(active) ^
      const DeepCollectionEquality().hash(mostLucrative) ^
      const DeepCollectionEquality().hash(oldestRecovered) ^
      const DeepCollectionEquality().hash(lost) ^
      runtimeType.hashCode;
}

extension $UserCrimeDetailsCardSkimming$SkimmersExtension on UserCrimeDetailsCardSkimming$Skimmers {
  UserCrimeDetailsCardSkimming$Skimmers copyWith({
    int? active,
    int? mostLucrative,
    int? oldestRecovered,
    int? lost,
  }) {
    return UserCrimeDetailsCardSkimming$Skimmers(
      active: active ?? this.active,
      mostLucrative: mostLucrative ?? this.mostLucrative,
      oldestRecovered: oldestRecovered ?? this.oldestRecovered,
      lost: lost ?? this.lost,
    );
  }

  UserCrimeDetailsCardSkimming$Skimmers copyWithWrapped({
    Wrapped<int>? active,
    Wrapped<int>? mostLucrative,
    Wrapped<int>? oldestRecovered,
    Wrapped<int>? lost,
  }) {
    return UserCrimeDetailsCardSkimming$Skimmers(
      active: (active != null ? active.value : this.active),
      mostLucrative: (mostLucrative != null ? mostLucrative.value : this.mostLucrative),
      oldestRecovered: (oldestRecovered != null ? oldestRecovered.value : this.oldestRecovered),
      lost: (lost != null ? lost.value : this.lost),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserCrimeDetailsScamming$Zones {
  const UserCrimeDetailsScamming$Zones({
    required this.red,
    required this.neutral,
    required this.concern,
    required this.sensitivity,
    required this.temptation,
    required this.hesitation,
    required this.lowReward,
    required this.mediumReward,
    required this.highReward,
  });

  factory UserCrimeDetailsScamming$Zones.fromJson(Map<String, dynamic> json) =>
      _$UserCrimeDetailsScamming$ZonesFromJson(json);

  static const toJsonFactory = _$UserCrimeDetailsScamming$ZonesToJson;
  Map<String, dynamic> toJson() => _$UserCrimeDetailsScamming$ZonesToJson(this);

  @JsonKey(name: 'red')
  final int red;
  @JsonKey(name: 'neutral')
  final int neutral;
  @JsonKey(name: 'concern')
  final int concern;
  @JsonKey(name: 'sensitivity')
  final int sensitivity;
  @JsonKey(name: 'temptation')
  final int temptation;
  @JsonKey(name: 'hesitation')
  final int hesitation;
  @JsonKey(name: 'low_reward')
  final int lowReward;
  @JsonKey(name: 'medium_reward')
  final int mediumReward;
  @JsonKey(name: 'high_reward')
  final int highReward;
  static const fromJsonFactory = _$UserCrimeDetailsScamming$ZonesFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserCrimeDetailsScamming$Zones &&
            (identical(other.red, red) || const DeepCollectionEquality().equals(other.red, red)) &&
            (identical(other.neutral, neutral) ||
                const DeepCollectionEquality().equals(
                  other.neutral,
                  neutral,
                )) &&
            (identical(other.concern, concern) ||
                const DeepCollectionEquality().equals(
                  other.concern,
                  concern,
                )) &&
            (identical(other.sensitivity, sensitivity) ||
                const DeepCollectionEquality().equals(
                  other.sensitivity,
                  sensitivity,
                )) &&
            (identical(other.temptation, temptation) ||
                const DeepCollectionEquality().equals(
                  other.temptation,
                  temptation,
                )) &&
            (identical(other.hesitation, hesitation) ||
                const DeepCollectionEquality().equals(
                  other.hesitation,
                  hesitation,
                )) &&
            (identical(other.lowReward, lowReward) ||
                const DeepCollectionEquality().equals(
                  other.lowReward,
                  lowReward,
                )) &&
            (identical(other.mediumReward, mediumReward) ||
                const DeepCollectionEquality().equals(
                  other.mediumReward,
                  mediumReward,
                )) &&
            (identical(other.highReward, highReward) ||
                const DeepCollectionEquality().equals(
                  other.highReward,
                  highReward,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(red) ^
      const DeepCollectionEquality().hash(neutral) ^
      const DeepCollectionEquality().hash(concern) ^
      const DeepCollectionEquality().hash(sensitivity) ^
      const DeepCollectionEquality().hash(temptation) ^
      const DeepCollectionEquality().hash(hesitation) ^
      const DeepCollectionEquality().hash(lowReward) ^
      const DeepCollectionEquality().hash(mediumReward) ^
      const DeepCollectionEquality().hash(highReward) ^
      runtimeType.hashCode;
}

extension $UserCrimeDetailsScamming$ZonesExtension on UserCrimeDetailsScamming$Zones {
  UserCrimeDetailsScamming$Zones copyWith({
    int? red,
    int? neutral,
    int? concern,
    int? sensitivity,
    int? temptation,
    int? hesitation,
    int? lowReward,
    int? mediumReward,
    int? highReward,
  }) {
    return UserCrimeDetailsScamming$Zones(
      red: red ?? this.red,
      neutral: neutral ?? this.neutral,
      concern: concern ?? this.concern,
      sensitivity: sensitivity ?? this.sensitivity,
      temptation: temptation ?? this.temptation,
      hesitation: hesitation ?? this.hesitation,
      lowReward: lowReward ?? this.lowReward,
      mediumReward: mediumReward ?? this.mediumReward,
      highReward: highReward ?? this.highReward,
    );
  }

  UserCrimeDetailsScamming$Zones copyWithWrapped({
    Wrapped<int>? red,
    Wrapped<int>? neutral,
    Wrapped<int>? concern,
    Wrapped<int>? sensitivity,
    Wrapped<int>? temptation,
    Wrapped<int>? hesitation,
    Wrapped<int>? lowReward,
    Wrapped<int>? mediumReward,
    Wrapped<int>? highReward,
  }) {
    return UserCrimeDetailsScamming$Zones(
      red: (red != null ? red.value : this.red),
      neutral: (neutral != null ? neutral.value : this.neutral),
      concern: (concern != null ? concern.value : this.concern),
      sensitivity: (sensitivity != null ? sensitivity.value : this.sensitivity),
      temptation: (temptation != null ? temptation.value : this.temptation),
      hesitation: (hesitation != null ? hesitation.value : this.hesitation),
      lowReward: (lowReward != null ? lowReward.value : this.lowReward),
      mediumReward: (mediumReward != null ? mediumReward.value : this.mediumReward),
      highReward: (highReward != null ? highReward.value : this.highReward),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserCrimeDetailsScamming$Concerns {
  const UserCrimeDetailsScamming$Concerns({
    required this.attempts,
    required this.resolved,
  });

  factory UserCrimeDetailsScamming$Concerns.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$UserCrimeDetailsScamming$ConcernsFromJson(json);

  static const toJsonFactory = _$UserCrimeDetailsScamming$ConcernsToJson;
  Map<String, dynamic> toJson() => _$UserCrimeDetailsScamming$ConcernsToJson(this);

  @JsonKey(name: 'attempts')
  final int attempts;
  @JsonKey(name: 'resolved')
  final int resolved;
  static const fromJsonFactory = _$UserCrimeDetailsScamming$ConcernsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserCrimeDetailsScamming$Concerns &&
            (identical(other.attempts, attempts) ||
                const DeepCollectionEquality().equals(
                  other.attempts,
                  attempts,
                )) &&
            (identical(other.resolved, resolved) ||
                const DeepCollectionEquality().equals(
                  other.resolved,
                  resolved,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(attempts) ^
      const DeepCollectionEquality().hash(resolved) ^
      runtimeType.hashCode;
}

extension $UserCrimeDetailsScamming$ConcernsExtension on UserCrimeDetailsScamming$Concerns {
  UserCrimeDetailsScamming$Concerns copyWith({int? attempts, int? resolved}) {
    return UserCrimeDetailsScamming$Concerns(
      attempts: attempts ?? this.attempts,
      resolved: resolved ?? this.resolved,
    );
  }

  UserCrimeDetailsScamming$Concerns copyWithWrapped({
    Wrapped<int>? attempts,
    Wrapped<int>? resolved,
  }) {
    return UserCrimeDetailsScamming$Concerns(
      attempts: (attempts != null ? attempts.value : this.attempts),
      resolved: (resolved != null ? resolved.value : this.resolved),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserCrimeDetailsScamming$Payouts {
  const UserCrimeDetailsScamming$Payouts({
    required this.low,
    required this.medium,
    required this.high,
  });

  factory UserCrimeDetailsScamming$Payouts.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$UserCrimeDetailsScamming$PayoutsFromJson(json);

  static const toJsonFactory = _$UserCrimeDetailsScamming$PayoutsToJson;
  Map<String, dynamic> toJson() => _$UserCrimeDetailsScamming$PayoutsToJson(this);

  @JsonKey(name: 'low')
  final int low;
  @JsonKey(name: 'medium')
  final int medium;
  @JsonKey(name: 'high')
  final int high;
  static const fromJsonFactory = _$UserCrimeDetailsScamming$PayoutsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserCrimeDetailsScamming$Payouts &&
            (identical(other.low, low) || const DeepCollectionEquality().equals(other.low, low)) &&
            (identical(other.medium, medium) || const DeepCollectionEquality().equals(other.medium, medium)) &&
            (identical(other.high, high) || const DeepCollectionEquality().equals(other.high, high)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(low) ^
      const DeepCollectionEquality().hash(medium) ^
      const DeepCollectionEquality().hash(high) ^
      runtimeType.hashCode;
}

extension $UserCrimeDetailsScamming$PayoutsExtension on UserCrimeDetailsScamming$Payouts {
  UserCrimeDetailsScamming$Payouts copyWith({
    int? low,
    int? medium,
    int? high,
  }) {
    return UserCrimeDetailsScamming$Payouts(
      low: low ?? this.low,
      medium: medium ?? this.medium,
      high: high ?? this.high,
    );
  }

  UserCrimeDetailsScamming$Payouts copyWithWrapped({
    Wrapped<int>? low,
    Wrapped<int>? medium,
    Wrapped<int>? high,
  }) {
    return UserCrimeDetailsScamming$Payouts(
      low: (low != null ? low.value : this.low),
      medium: (medium != null ? medium.value : this.medium),
      high: (high != null ? high.value : this.high),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserCrimeDetailsScamming$Emails {
  const UserCrimeDetailsScamming$Emails({
    required this.scraper,
    required this.phisher,
  });

  factory UserCrimeDetailsScamming$Emails.fromJson(Map<String, dynamic> json) =>
      _$UserCrimeDetailsScamming$EmailsFromJson(json);

  static const toJsonFactory = _$UserCrimeDetailsScamming$EmailsToJson;
  Map<String, dynamic> toJson() => _$UserCrimeDetailsScamming$EmailsToJson(this);

  @JsonKey(name: 'scraper')
  final int scraper;
  @JsonKey(name: 'phisher')
  final int phisher;
  static const fromJsonFactory = _$UserCrimeDetailsScamming$EmailsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserCrimeDetailsScamming$Emails &&
            (identical(other.scraper, scraper) ||
                const DeepCollectionEquality().equals(
                  other.scraper,
                  scraper,
                )) &&
            (identical(other.phisher, phisher) || const DeepCollectionEquality().equals(other.phisher, phisher)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(scraper) ^
      const DeepCollectionEquality().hash(phisher) ^
      runtimeType.hashCode;
}

extension $UserCrimeDetailsScamming$EmailsExtension on UserCrimeDetailsScamming$Emails {
  UserCrimeDetailsScamming$Emails copyWith({int? scraper, int? phisher}) {
    return UserCrimeDetailsScamming$Emails(
      scraper: scraper ?? this.scraper,
      phisher: phisher ?? this.phisher,
    );
  }

  UserCrimeDetailsScamming$Emails copyWithWrapped({
    Wrapped<int>? scraper,
    Wrapped<int>? phisher,
  }) {
    return UserCrimeDetailsScamming$Emails(
      scraper: (scraper != null ? scraper.value : this.scraper),
      phisher: (phisher != null ? phisher.value : this.phisher),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsOther$Other {
  const PersonalStatsOther$Other({
    required this.activity,
    required this.awards,
    required this.meritsBought,
    required this.refills,
    required this.donatorDays,
    required this.rankedWarWins,
  });

  factory PersonalStatsOther$Other.fromJson(Map<String, dynamic> json) => _$PersonalStatsOther$OtherFromJson(json);

  static const toJsonFactory = _$PersonalStatsOther$OtherToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsOther$OtherToJson(this);

  @JsonKey(name: 'activity')
  final PersonalStatsOther$Other$Activity activity;
  @JsonKey(name: 'awards')
  final int awards;
  @JsonKey(name: 'merits_bought')
  final int meritsBought;
  @JsonKey(name: 'refills')
  final PersonalStatsOther$Other$Refills refills;
  @JsonKey(name: 'donator_days')
  final int donatorDays;
  @JsonKey(name: 'ranked_war_wins')
  final int rankedWarWins;
  static const fromJsonFactory = _$PersonalStatsOther$OtherFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsOther$Other &&
            (identical(other.activity, activity) ||
                const DeepCollectionEquality().equals(
                  other.activity,
                  activity,
                )) &&
            (identical(other.awards, awards) || const DeepCollectionEquality().equals(other.awards, awards)) &&
            (identical(other.meritsBought, meritsBought) ||
                const DeepCollectionEquality().equals(
                  other.meritsBought,
                  meritsBought,
                )) &&
            (identical(other.refills, refills) ||
                const DeepCollectionEquality().equals(
                  other.refills,
                  refills,
                )) &&
            (identical(other.donatorDays, donatorDays) ||
                const DeepCollectionEquality().equals(
                  other.donatorDays,
                  donatorDays,
                )) &&
            (identical(other.rankedWarWins, rankedWarWins) ||
                const DeepCollectionEquality().equals(
                  other.rankedWarWins,
                  rankedWarWins,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(activity) ^
      const DeepCollectionEquality().hash(awards) ^
      const DeepCollectionEquality().hash(meritsBought) ^
      const DeepCollectionEquality().hash(refills) ^
      const DeepCollectionEquality().hash(donatorDays) ^
      const DeepCollectionEquality().hash(rankedWarWins) ^
      runtimeType.hashCode;
}

extension $PersonalStatsOther$OtherExtension on PersonalStatsOther$Other {
  PersonalStatsOther$Other copyWith({
    PersonalStatsOther$Other$Activity? activity,
    int? awards,
    int? meritsBought,
    PersonalStatsOther$Other$Refills? refills,
    int? donatorDays,
    int? rankedWarWins,
  }) {
    return PersonalStatsOther$Other(
      activity: activity ?? this.activity,
      awards: awards ?? this.awards,
      meritsBought: meritsBought ?? this.meritsBought,
      refills: refills ?? this.refills,
      donatorDays: donatorDays ?? this.donatorDays,
      rankedWarWins: rankedWarWins ?? this.rankedWarWins,
    );
  }

  PersonalStatsOther$Other copyWithWrapped({
    Wrapped<PersonalStatsOther$Other$Activity>? activity,
    Wrapped<int>? awards,
    Wrapped<int>? meritsBought,
    Wrapped<PersonalStatsOther$Other$Refills>? refills,
    Wrapped<int>? donatorDays,
    Wrapped<int>? rankedWarWins,
  }) {
    return PersonalStatsOther$Other(
      activity: (activity != null ? activity.value : this.activity),
      awards: (awards != null ? awards.value : this.awards),
      meritsBought: (meritsBought != null ? meritsBought.value : this.meritsBought),
      refills: (refills != null ? refills.value : this.refills),
      donatorDays: (donatorDays != null ? donatorDays.value : this.donatorDays),
      rankedWarWins: (rankedWarWins != null ? rankedWarWins.value : this.rankedWarWins),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsOtherPopular$Other {
  const PersonalStatsOtherPopular$Other({
    required this.activity,
    required this.awards,
    required this.meritsBought,
    required this.refills,
    required this.donatorDays,
    required this.rankedWarWins,
  });

  factory PersonalStatsOtherPopular$Other.fromJson(Map<String, dynamic> json) =>
      _$PersonalStatsOtherPopular$OtherFromJson(json);

  static const toJsonFactory = _$PersonalStatsOtherPopular$OtherToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsOtherPopular$OtherToJson(this);

  @JsonKey(name: 'activity')
  final PersonalStatsOtherPopular$Other$Activity activity;
  @JsonKey(name: 'awards')
  final int awards;
  @JsonKey(name: 'merits_bought')
  final int meritsBought;
  @JsonKey(name: 'refills')
  final PersonalStatsOtherPopular$Other$Refills refills;
  @JsonKey(name: 'donator_days')
  final int donatorDays;
  @JsonKey(name: 'ranked_war_wins')
  final int rankedWarWins;
  static const fromJsonFactory = _$PersonalStatsOtherPopular$OtherFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsOtherPopular$Other &&
            (identical(other.activity, activity) ||
                const DeepCollectionEquality().equals(
                  other.activity,
                  activity,
                )) &&
            (identical(other.awards, awards) || const DeepCollectionEquality().equals(other.awards, awards)) &&
            (identical(other.meritsBought, meritsBought) ||
                const DeepCollectionEquality().equals(
                  other.meritsBought,
                  meritsBought,
                )) &&
            (identical(other.refills, refills) ||
                const DeepCollectionEquality().equals(
                  other.refills,
                  refills,
                )) &&
            (identical(other.donatorDays, donatorDays) ||
                const DeepCollectionEquality().equals(
                  other.donatorDays,
                  donatorDays,
                )) &&
            (identical(other.rankedWarWins, rankedWarWins) ||
                const DeepCollectionEquality().equals(
                  other.rankedWarWins,
                  rankedWarWins,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(activity) ^
      const DeepCollectionEquality().hash(awards) ^
      const DeepCollectionEquality().hash(meritsBought) ^
      const DeepCollectionEquality().hash(refills) ^
      const DeepCollectionEquality().hash(donatorDays) ^
      const DeepCollectionEquality().hash(rankedWarWins) ^
      runtimeType.hashCode;
}

extension $PersonalStatsOtherPopular$OtherExtension on PersonalStatsOtherPopular$Other {
  PersonalStatsOtherPopular$Other copyWith({
    PersonalStatsOtherPopular$Other$Activity? activity,
    int? awards,
    int? meritsBought,
    PersonalStatsOtherPopular$Other$Refills? refills,
    int? donatorDays,
    int? rankedWarWins,
  }) {
    return PersonalStatsOtherPopular$Other(
      activity: activity ?? this.activity,
      awards: awards ?? this.awards,
      meritsBought: meritsBought ?? this.meritsBought,
      refills: refills ?? this.refills,
      donatorDays: donatorDays ?? this.donatorDays,
      rankedWarWins: rankedWarWins ?? this.rankedWarWins,
    );
  }

  PersonalStatsOtherPopular$Other copyWithWrapped({
    Wrapped<PersonalStatsOtherPopular$Other$Activity>? activity,
    Wrapped<int>? awards,
    Wrapped<int>? meritsBought,
    Wrapped<PersonalStatsOtherPopular$Other$Refills>? refills,
    Wrapped<int>? donatorDays,
    Wrapped<int>? rankedWarWins,
  }) {
    return PersonalStatsOtherPopular$Other(
      activity: (activity != null ? activity.value : this.activity),
      awards: (awards != null ? awards.value : this.awards),
      meritsBought: (meritsBought != null ? meritsBought.value : this.meritsBought),
      refills: (refills != null ? refills.value : this.refills),
      donatorDays: (donatorDays != null ? donatorDays.value : this.donatorDays),
      rankedWarWins: (rankedWarWins != null ? rankedWarWins.value : this.rankedWarWins),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsNetworthExtended$Networth {
  const PersonalStatsNetworthExtended$Networth({
    required this.total,
    required this.wallet,
    required this.vaults,
    required this.bank,
    required this.overseasBank,
    required this.points,
    required this.inventory,
    required this.displayCase,
    required this.bazaar,
    required this.itemMarket,
    required this.property,
    required this.stockMarket,
    required this.auctionHouse,
    required this.bookie,
    required this.company,
    required this.enlistedCars,
    required this.piggyBank,
    required this.pending,
    required this.loans,
    required this.unpaidFees,
  });

  factory PersonalStatsNetworthExtended$Networth.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$PersonalStatsNetworthExtended$NetworthFromJson(json);

  static const toJsonFactory = _$PersonalStatsNetworthExtended$NetworthToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsNetworthExtended$NetworthToJson(this);

  @JsonKey(name: 'total')
  final int total;
  @JsonKey(name: 'wallet')
  final int wallet;
  @JsonKey(name: 'vaults')
  final int vaults;
  @JsonKey(name: 'bank')
  final int bank;
  @JsonKey(name: 'overseas_bank')
  final int overseasBank;
  @JsonKey(name: 'points')
  final int points;
  @JsonKey(name: 'inventory')
  final int inventory;
  @JsonKey(name: 'display_case')
  final int displayCase;
  @JsonKey(name: 'bazaar')
  final int bazaar;
  @JsonKey(name: 'item_market')
  final int itemMarket;
  @JsonKey(name: 'property')
  final int property;
  @JsonKey(name: 'stock_market')
  final int stockMarket;
  @JsonKey(name: 'auction_house')
  final int auctionHouse;
  @JsonKey(name: 'bookie')
  final int bookie;
  @JsonKey(name: 'company')
  final int company;
  @JsonKey(name: 'enlisted_cars')
  final int enlistedCars;
  @JsonKey(name: 'piggy_bank')
  final int piggyBank;
  @JsonKey(name: 'pending')
  final int pending;
  @JsonKey(name: 'loans')
  final int loans;
  @JsonKey(name: 'unpaid_fees')
  final int unpaidFees;
  static const fromJsonFactory = _$PersonalStatsNetworthExtended$NetworthFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsNetworthExtended$Networth &&
            (identical(other.total, total) || const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.wallet, wallet) || const DeepCollectionEquality().equals(other.wallet, wallet)) &&
            (identical(other.vaults, vaults) || const DeepCollectionEquality().equals(other.vaults, vaults)) &&
            (identical(other.bank, bank) || const DeepCollectionEquality().equals(other.bank, bank)) &&
            (identical(other.overseasBank, overseasBank) ||
                const DeepCollectionEquality().equals(
                  other.overseasBank,
                  overseasBank,
                )) &&
            (identical(other.points, points) || const DeepCollectionEquality().equals(other.points, points)) &&
            (identical(other.inventory, inventory) ||
                const DeepCollectionEquality().equals(
                  other.inventory,
                  inventory,
                )) &&
            (identical(other.displayCase, displayCase) ||
                const DeepCollectionEquality().equals(
                  other.displayCase,
                  displayCase,
                )) &&
            (identical(other.bazaar, bazaar) || const DeepCollectionEquality().equals(other.bazaar, bazaar)) &&
            (identical(other.itemMarket, itemMarket) ||
                const DeepCollectionEquality().equals(
                  other.itemMarket,
                  itemMarket,
                )) &&
            (identical(other.property, property) ||
                const DeepCollectionEquality().equals(
                  other.property,
                  property,
                )) &&
            (identical(other.stockMarket, stockMarket) ||
                const DeepCollectionEquality().equals(
                  other.stockMarket,
                  stockMarket,
                )) &&
            (identical(other.auctionHouse, auctionHouse) ||
                const DeepCollectionEquality().equals(
                  other.auctionHouse,
                  auctionHouse,
                )) &&
            (identical(other.bookie, bookie) || const DeepCollectionEquality().equals(other.bookie, bookie)) &&
            (identical(other.company, company) ||
                const DeepCollectionEquality().equals(
                  other.company,
                  company,
                )) &&
            (identical(other.enlistedCars, enlistedCars) ||
                const DeepCollectionEquality().equals(
                  other.enlistedCars,
                  enlistedCars,
                )) &&
            (identical(other.piggyBank, piggyBank) ||
                const DeepCollectionEquality().equals(
                  other.piggyBank,
                  piggyBank,
                )) &&
            (identical(other.pending, pending) ||
                const DeepCollectionEquality().equals(
                  other.pending,
                  pending,
                )) &&
            (identical(other.loans, loans) || const DeepCollectionEquality().equals(other.loans, loans)) &&
            (identical(other.unpaidFees, unpaidFees) ||
                const DeepCollectionEquality().equals(
                  other.unpaidFees,
                  unpaidFees,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(wallet) ^
      const DeepCollectionEquality().hash(vaults) ^
      const DeepCollectionEquality().hash(bank) ^
      const DeepCollectionEquality().hash(overseasBank) ^
      const DeepCollectionEquality().hash(points) ^
      const DeepCollectionEquality().hash(inventory) ^
      const DeepCollectionEquality().hash(displayCase) ^
      const DeepCollectionEquality().hash(bazaar) ^
      const DeepCollectionEquality().hash(itemMarket) ^
      const DeepCollectionEquality().hash(property) ^
      const DeepCollectionEquality().hash(stockMarket) ^
      const DeepCollectionEquality().hash(auctionHouse) ^
      const DeepCollectionEquality().hash(bookie) ^
      const DeepCollectionEquality().hash(company) ^
      const DeepCollectionEquality().hash(enlistedCars) ^
      const DeepCollectionEquality().hash(piggyBank) ^
      const DeepCollectionEquality().hash(pending) ^
      const DeepCollectionEquality().hash(loans) ^
      const DeepCollectionEquality().hash(unpaidFees) ^
      runtimeType.hashCode;
}

extension $PersonalStatsNetworthExtended$NetworthExtension on PersonalStatsNetworthExtended$Networth {
  PersonalStatsNetworthExtended$Networth copyWith({
    int? total,
    int? wallet,
    int? vaults,
    int? bank,
    int? overseasBank,
    int? points,
    int? inventory,
    int? displayCase,
    int? bazaar,
    int? itemMarket,
    int? property,
    int? stockMarket,
    int? auctionHouse,
    int? bookie,
    int? company,
    int? enlistedCars,
    int? piggyBank,
    int? pending,
    int? loans,
    int? unpaidFees,
  }) {
    return PersonalStatsNetworthExtended$Networth(
      total: total ?? this.total,
      wallet: wallet ?? this.wallet,
      vaults: vaults ?? this.vaults,
      bank: bank ?? this.bank,
      overseasBank: overseasBank ?? this.overseasBank,
      points: points ?? this.points,
      inventory: inventory ?? this.inventory,
      displayCase: displayCase ?? this.displayCase,
      bazaar: bazaar ?? this.bazaar,
      itemMarket: itemMarket ?? this.itemMarket,
      property: property ?? this.property,
      stockMarket: stockMarket ?? this.stockMarket,
      auctionHouse: auctionHouse ?? this.auctionHouse,
      bookie: bookie ?? this.bookie,
      company: company ?? this.company,
      enlistedCars: enlistedCars ?? this.enlistedCars,
      piggyBank: piggyBank ?? this.piggyBank,
      pending: pending ?? this.pending,
      loans: loans ?? this.loans,
      unpaidFees: unpaidFees ?? this.unpaidFees,
    );
  }

  PersonalStatsNetworthExtended$Networth copyWithWrapped({
    Wrapped<int>? total,
    Wrapped<int>? wallet,
    Wrapped<int>? vaults,
    Wrapped<int>? bank,
    Wrapped<int>? overseasBank,
    Wrapped<int>? points,
    Wrapped<int>? inventory,
    Wrapped<int>? displayCase,
    Wrapped<int>? bazaar,
    Wrapped<int>? itemMarket,
    Wrapped<int>? property,
    Wrapped<int>? stockMarket,
    Wrapped<int>? auctionHouse,
    Wrapped<int>? bookie,
    Wrapped<int>? company,
    Wrapped<int>? enlistedCars,
    Wrapped<int>? piggyBank,
    Wrapped<int>? pending,
    Wrapped<int>? loans,
    Wrapped<int>? unpaidFees,
  }) {
    return PersonalStatsNetworthExtended$Networth(
      total: (total != null ? total.value : this.total),
      wallet: (wallet != null ? wallet.value : this.wallet),
      vaults: (vaults != null ? vaults.value : this.vaults),
      bank: (bank != null ? bank.value : this.bank),
      overseasBank: (overseasBank != null ? overseasBank.value : this.overseasBank),
      points: (points != null ? points.value : this.points),
      inventory: (inventory != null ? inventory.value : this.inventory),
      displayCase: (displayCase != null ? displayCase.value : this.displayCase),
      bazaar: (bazaar != null ? bazaar.value : this.bazaar),
      itemMarket: (itemMarket != null ? itemMarket.value : this.itemMarket),
      property: (property != null ? property.value : this.property),
      stockMarket: (stockMarket != null ? stockMarket.value : this.stockMarket),
      auctionHouse: (auctionHouse != null ? auctionHouse.value : this.auctionHouse),
      bookie: (bookie != null ? bookie.value : this.bookie),
      company: (company != null ? company.value : this.company),
      enlistedCars: (enlistedCars != null ? enlistedCars.value : this.enlistedCars),
      piggyBank: (piggyBank != null ? piggyBank.value : this.piggyBank),
      pending: (pending != null ? pending.value : this.pending),
      loans: (loans != null ? loans.value : this.loans),
      unpaidFees: (unpaidFees != null ? unpaidFees.value : this.unpaidFees),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsNetworthPublic$Networth {
  const PersonalStatsNetworthPublic$Networth({required this.total});

  factory PersonalStatsNetworthPublic$Networth.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$PersonalStatsNetworthPublic$NetworthFromJson(json);

  static const toJsonFactory = _$PersonalStatsNetworthPublic$NetworthToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsNetworthPublic$NetworthToJson(this);

  @JsonKey(name: 'total')
  final int total;
  static const fromJsonFactory = _$PersonalStatsNetworthPublic$NetworthFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsNetworthPublic$Networth &&
            (identical(other.total, total) || const DeepCollectionEquality().equals(other.total, total)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(total) ^ runtimeType.hashCode;
}

extension $PersonalStatsNetworthPublic$NetworthExtension on PersonalStatsNetworthPublic$Networth {
  PersonalStatsNetworthPublic$Networth copyWith({int? total}) {
    return PersonalStatsNetworthPublic$Networth(total: total ?? this.total);
  }

  PersonalStatsNetworthPublic$Networth copyWithWrapped({Wrapped<int>? total}) {
    return PersonalStatsNetworthPublic$Networth(
      total: (total != null ? total.value : this.total),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsRacing$Racing {
  const PersonalStatsRacing$Racing({
    required this.skill,
    required this.points,
    required this.races,
  });

  factory PersonalStatsRacing$Racing.fromJson(Map<String, dynamic> json) => _$PersonalStatsRacing$RacingFromJson(json);

  static const toJsonFactory = _$PersonalStatsRacing$RacingToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsRacing$RacingToJson(this);

  @JsonKey(name: 'skill')
  final int skill;
  @JsonKey(name: 'points')
  final int points;
  @JsonKey(name: 'races')
  final PersonalStatsRacing$Racing$Races races;
  static const fromJsonFactory = _$PersonalStatsRacing$RacingFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsRacing$Racing &&
            (identical(other.skill, skill) || const DeepCollectionEquality().equals(other.skill, skill)) &&
            (identical(other.points, points) || const DeepCollectionEquality().equals(other.points, points)) &&
            (identical(other.races, races) || const DeepCollectionEquality().equals(other.races, races)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(skill) ^
      const DeepCollectionEquality().hash(points) ^
      const DeepCollectionEquality().hash(races) ^
      runtimeType.hashCode;
}

extension $PersonalStatsRacing$RacingExtension on PersonalStatsRacing$Racing {
  PersonalStatsRacing$Racing copyWith({
    int? skill,
    int? points,
    PersonalStatsRacing$Racing$Races? races,
  }) {
    return PersonalStatsRacing$Racing(
      skill: skill ?? this.skill,
      points: points ?? this.points,
      races: races ?? this.races,
    );
  }

  PersonalStatsRacing$Racing copyWithWrapped({
    Wrapped<int>? skill,
    Wrapped<int>? points,
    Wrapped<PersonalStatsRacing$Racing$Races>? races,
  }) {
    return PersonalStatsRacing$Racing(
      skill: (skill != null ? skill.value : this.skill),
      points: (points != null ? points.value : this.points),
      races: (races != null ? races.value : this.races),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsMissions$Missions {
  const PersonalStatsMissions$Missions({
    required this.missions,
    required this.contracts,
    required this.credits,
  });

  factory PersonalStatsMissions$Missions.fromJson(Map<String, dynamic> json) =>
      _$PersonalStatsMissions$MissionsFromJson(json);

  static const toJsonFactory = _$PersonalStatsMissions$MissionsToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsMissions$MissionsToJson(this);

  @JsonKey(name: 'missions')
  final int missions;
  @JsonKey(name: 'contracts')
  final PersonalStatsMissions$Missions$Contracts contracts;
  @JsonKey(name: 'credits')
  final int credits;
  static const fromJsonFactory = _$PersonalStatsMissions$MissionsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsMissions$Missions &&
            (identical(other.missions, missions) ||
                const DeepCollectionEquality().equals(
                  other.missions,
                  missions,
                )) &&
            (identical(other.contracts, contracts) ||
                const DeepCollectionEquality().equals(
                  other.contracts,
                  contracts,
                )) &&
            (identical(other.credits, credits) || const DeepCollectionEquality().equals(other.credits, credits)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(missions) ^
      const DeepCollectionEquality().hash(contracts) ^
      const DeepCollectionEquality().hash(credits) ^
      runtimeType.hashCode;
}

extension $PersonalStatsMissions$MissionsExtension on PersonalStatsMissions$Missions {
  PersonalStatsMissions$Missions copyWith({
    int? missions,
    PersonalStatsMissions$Missions$Contracts? contracts,
    int? credits,
  }) {
    return PersonalStatsMissions$Missions(
      missions: missions ?? this.missions,
      contracts: contracts ?? this.contracts,
      credits: credits ?? this.credits,
    );
  }

  PersonalStatsMissions$Missions copyWithWrapped({
    Wrapped<int>? missions,
    Wrapped<PersonalStatsMissions$Missions$Contracts>? contracts,
    Wrapped<int>? credits,
  }) {
    return PersonalStatsMissions$Missions(
      missions: (missions != null ? missions.value : this.missions),
      contracts: (contracts != null ? contracts.value : this.contracts),
      credits: (credits != null ? credits.value : this.credits),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsDrugs$Drugs {
  const PersonalStatsDrugs$Drugs({
    required this.cannabis,
    required this.ecstasy,
    required this.ketamine,
    required this.lsd,
    required this.opium,
    required this.pcp,
    required this.shrooms,
    required this.speed,
    required this.vicodin,
    required this.xanax,
    required this.total,
    required this.overdoses,
    required this.rehabilitations,
  });

  factory PersonalStatsDrugs$Drugs.fromJson(Map<String, dynamic> json) => _$PersonalStatsDrugs$DrugsFromJson(json);

  static const toJsonFactory = _$PersonalStatsDrugs$DrugsToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsDrugs$DrugsToJson(this);

  @JsonKey(name: 'cannabis')
  final int cannabis;
  @JsonKey(name: 'ecstasy')
  final int ecstasy;
  @JsonKey(name: 'ketamine')
  final int ketamine;
  @JsonKey(name: 'lsd')
  final int lsd;
  @JsonKey(name: 'opium')
  final int opium;
  @JsonKey(name: 'pcp')
  final int pcp;
  @JsonKey(name: 'shrooms')
  final int shrooms;
  @JsonKey(name: 'speed')
  final int speed;
  @JsonKey(name: 'vicodin')
  final int vicodin;
  @JsonKey(name: 'xanax')
  final int xanax;
  @JsonKey(name: 'total')
  final int total;
  @JsonKey(name: 'overdoses')
  final int overdoses;
  @JsonKey(name: 'rehabilitations')
  final PersonalStatsDrugs$Drugs$Rehabilitations rehabilitations;
  static const fromJsonFactory = _$PersonalStatsDrugs$DrugsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsDrugs$Drugs &&
            (identical(other.cannabis, cannabis) ||
                const DeepCollectionEquality().equals(
                  other.cannabis,
                  cannabis,
                )) &&
            (identical(other.ecstasy, ecstasy) ||
                const DeepCollectionEquality().equals(
                  other.ecstasy,
                  ecstasy,
                )) &&
            (identical(other.ketamine, ketamine) ||
                const DeepCollectionEquality().equals(
                  other.ketamine,
                  ketamine,
                )) &&
            (identical(other.lsd, lsd) || const DeepCollectionEquality().equals(other.lsd, lsd)) &&
            (identical(other.opium, opium) || const DeepCollectionEquality().equals(other.opium, opium)) &&
            (identical(other.pcp, pcp) || const DeepCollectionEquality().equals(other.pcp, pcp)) &&
            (identical(other.shrooms, shrooms) ||
                const DeepCollectionEquality().equals(
                  other.shrooms,
                  shrooms,
                )) &&
            (identical(other.speed, speed) || const DeepCollectionEquality().equals(other.speed, speed)) &&
            (identical(other.vicodin, vicodin) ||
                const DeepCollectionEquality().equals(
                  other.vicodin,
                  vicodin,
                )) &&
            (identical(other.xanax, xanax) || const DeepCollectionEquality().equals(other.xanax, xanax)) &&
            (identical(other.total, total) || const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.overdoses, overdoses) ||
                const DeepCollectionEquality().equals(
                  other.overdoses,
                  overdoses,
                )) &&
            (identical(other.rehabilitations, rehabilitations) ||
                const DeepCollectionEquality().equals(
                  other.rehabilitations,
                  rehabilitations,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(cannabis) ^
      const DeepCollectionEquality().hash(ecstasy) ^
      const DeepCollectionEquality().hash(ketamine) ^
      const DeepCollectionEquality().hash(lsd) ^
      const DeepCollectionEquality().hash(opium) ^
      const DeepCollectionEquality().hash(pcp) ^
      const DeepCollectionEquality().hash(shrooms) ^
      const DeepCollectionEquality().hash(speed) ^
      const DeepCollectionEquality().hash(vicodin) ^
      const DeepCollectionEquality().hash(xanax) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(overdoses) ^
      const DeepCollectionEquality().hash(rehabilitations) ^
      runtimeType.hashCode;
}

extension $PersonalStatsDrugs$DrugsExtension on PersonalStatsDrugs$Drugs {
  PersonalStatsDrugs$Drugs copyWith({
    int? cannabis,
    int? ecstasy,
    int? ketamine,
    int? lsd,
    int? opium,
    int? pcp,
    int? shrooms,
    int? speed,
    int? vicodin,
    int? xanax,
    int? total,
    int? overdoses,
    PersonalStatsDrugs$Drugs$Rehabilitations? rehabilitations,
  }) {
    return PersonalStatsDrugs$Drugs(
      cannabis: cannabis ?? this.cannabis,
      ecstasy: ecstasy ?? this.ecstasy,
      ketamine: ketamine ?? this.ketamine,
      lsd: lsd ?? this.lsd,
      opium: opium ?? this.opium,
      pcp: pcp ?? this.pcp,
      shrooms: shrooms ?? this.shrooms,
      speed: speed ?? this.speed,
      vicodin: vicodin ?? this.vicodin,
      xanax: xanax ?? this.xanax,
      total: total ?? this.total,
      overdoses: overdoses ?? this.overdoses,
      rehabilitations: rehabilitations ?? this.rehabilitations,
    );
  }

  PersonalStatsDrugs$Drugs copyWithWrapped({
    Wrapped<int>? cannabis,
    Wrapped<int>? ecstasy,
    Wrapped<int>? ketamine,
    Wrapped<int>? lsd,
    Wrapped<int>? opium,
    Wrapped<int>? pcp,
    Wrapped<int>? shrooms,
    Wrapped<int>? speed,
    Wrapped<int>? vicodin,
    Wrapped<int>? xanax,
    Wrapped<int>? total,
    Wrapped<int>? overdoses,
    Wrapped<PersonalStatsDrugs$Drugs$Rehabilitations>? rehabilitations,
  }) {
    return PersonalStatsDrugs$Drugs(
      cannabis: (cannabis != null ? cannabis.value : this.cannabis),
      ecstasy: (ecstasy != null ? ecstasy.value : this.ecstasy),
      ketamine: (ketamine != null ? ketamine.value : this.ketamine),
      lsd: (lsd != null ? lsd.value : this.lsd),
      opium: (opium != null ? opium.value : this.opium),
      pcp: (pcp != null ? pcp.value : this.pcp),
      shrooms: (shrooms != null ? shrooms.value : this.shrooms),
      speed: (speed != null ? speed.value : this.speed),
      vicodin: (vicodin != null ? vicodin.value : this.vicodin),
      xanax: (xanax != null ? xanax.value : this.xanax),
      total: (total != null ? total.value : this.total),
      overdoses: (overdoses != null ? overdoses.value : this.overdoses),
      rehabilitations: (rehabilitations != null ? rehabilitations.value : this.rehabilitations),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsTravel$Travel {
  const PersonalStatsTravel$Travel({
    required this.total,
    required this.timeSpent,
    required this.itemsBought,
    required this.hunting,
    required this.attacksWon,
    required this.defendsLost,
    required this.argentina,
    required this.canada,
    required this.caymanIslands,
    required this.china,
    required this.hawaii,
    required this.japan,
    required this.mexico,
    required this.unitedArabEmirates,
    required this.unitedKingdom,
    required this.southAfrica,
    required this.switzerland,
  });

  factory PersonalStatsTravel$Travel.fromJson(Map<String, dynamic> json) => _$PersonalStatsTravel$TravelFromJson(json);

  static const toJsonFactory = _$PersonalStatsTravel$TravelToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsTravel$TravelToJson(this);

  @JsonKey(name: 'total')
  final int total;
  @JsonKey(name: 'time_spent')
  final int timeSpent;
  @JsonKey(name: 'items_bought')
  final int itemsBought;
  @JsonKey(name: 'hunting')
  final PersonalStatsTravel$Travel$Hunting hunting;
  @JsonKey(name: 'attacks_won')
  final int attacksWon;
  @JsonKey(name: 'defends_lost')
  final int defendsLost;
  @JsonKey(name: 'argentina')
  final int argentina;
  @JsonKey(name: 'canada')
  final int canada;
  @JsonKey(name: 'cayman_islands')
  final int caymanIslands;
  @JsonKey(name: 'china')
  final int china;
  @JsonKey(name: 'hawaii')
  final int hawaii;
  @JsonKey(name: 'japan')
  final int japan;
  @JsonKey(name: 'mexico')
  final int mexico;
  @JsonKey(name: 'united_arab_emirates')
  final int unitedArabEmirates;
  @JsonKey(name: 'united_kingdom')
  final int unitedKingdom;
  @JsonKey(name: 'south_africa')
  final int southAfrica;
  @JsonKey(name: 'switzerland')
  final int switzerland;
  static const fromJsonFactory = _$PersonalStatsTravel$TravelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsTravel$Travel &&
            (identical(other.total, total) || const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.timeSpent, timeSpent) ||
                const DeepCollectionEquality().equals(
                  other.timeSpent,
                  timeSpent,
                )) &&
            (identical(other.itemsBought, itemsBought) ||
                const DeepCollectionEquality().equals(
                  other.itemsBought,
                  itemsBought,
                )) &&
            (identical(other.hunting, hunting) ||
                const DeepCollectionEquality().equals(
                  other.hunting,
                  hunting,
                )) &&
            (identical(other.attacksWon, attacksWon) ||
                const DeepCollectionEquality().equals(
                  other.attacksWon,
                  attacksWon,
                )) &&
            (identical(other.defendsLost, defendsLost) ||
                const DeepCollectionEquality().equals(
                  other.defendsLost,
                  defendsLost,
                )) &&
            (identical(other.argentina, argentina) ||
                const DeepCollectionEquality().equals(
                  other.argentina,
                  argentina,
                )) &&
            (identical(other.canada, canada) || const DeepCollectionEquality().equals(other.canada, canada)) &&
            (identical(other.caymanIslands, caymanIslands) ||
                const DeepCollectionEquality().equals(
                  other.caymanIslands,
                  caymanIslands,
                )) &&
            (identical(other.china, china) || const DeepCollectionEquality().equals(other.china, china)) &&
            (identical(other.hawaii, hawaii) || const DeepCollectionEquality().equals(other.hawaii, hawaii)) &&
            (identical(other.japan, japan) || const DeepCollectionEquality().equals(other.japan, japan)) &&
            (identical(other.mexico, mexico) || const DeepCollectionEquality().equals(other.mexico, mexico)) &&
            (identical(other.unitedArabEmirates, unitedArabEmirates) ||
                const DeepCollectionEquality().equals(
                  other.unitedArabEmirates,
                  unitedArabEmirates,
                )) &&
            (identical(other.unitedKingdom, unitedKingdom) ||
                const DeepCollectionEquality().equals(
                  other.unitedKingdom,
                  unitedKingdom,
                )) &&
            (identical(other.southAfrica, southAfrica) ||
                const DeepCollectionEquality().equals(
                  other.southAfrica,
                  southAfrica,
                )) &&
            (identical(other.switzerland, switzerland) ||
                const DeepCollectionEquality().equals(
                  other.switzerland,
                  switzerland,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(timeSpent) ^
      const DeepCollectionEquality().hash(itemsBought) ^
      const DeepCollectionEquality().hash(hunting) ^
      const DeepCollectionEquality().hash(attacksWon) ^
      const DeepCollectionEquality().hash(defendsLost) ^
      const DeepCollectionEquality().hash(argentina) ^
      const DeepCollectionEquality().hash(canada) ^
      const DeepCollectionEquality().hash(caymanIslands) ^
      const DeepCollectionEquality().hash(china) ^
      const DeepCollectionEquality().hash(hawaii) ^
      const DeepCollectionEquality().hash(japan) ^
      const DeepCollectionEquality().hash(mexico) ^
      const DeepCollectionEquality().hash(unitedArabEmirates) ^
      const DeepCollectionEquality().hash(unitedKingdom) ^
      const DeepCollectionEquality().hash(southAfrica) ^
      const DeepCollectionEquality().hash(switzerland) ^
      runtimeType.hashCode;
}

extension $PersonalStatsTravel$TravelExtension on PersonalStatsTravel$Travel {
  PersonalStatsTravel$Travel copyWith({
    int? total,
    int? timeSpent,
    int? itemsBought,
    PersonalStatsTravel$Travel$Hunting? hunting,
    int? attacksWon,
    int? defendsLost,
    int? argentina,
    int? canada,
    int? caymanIslands,
    int? china,
    int? hawaii,
    int? japan,
    int? mexico,
    int? unitedArabEmirates,
    int? unitedKingdom,
    int? southAfrica,
    int? switzerland,
  }) {
    return PersonalStatsTravel$Travel(
      total: total ?? this.total,
      timeSpent: timeSpent ?? this.timeSpent,
      itemsBought: itemsBought ?? this.itemsBought,
      hunting: hunting ?? this.hunting,
      attacksWon: attacksWon ?? this.attacksWon,
      defendsLost: defendsLost ?? this.defendsLost,
      argentina: argentina ?? this.argentina,
      canada: canada ?? this.canada,
      caymanIslands: caymanIslands ?? this.caymanIslands,
      china: china ?? this.china,
      hawaii: hawaii ?? this.hawaii,
      japan: japan ?? this.japan,
      mexico: mexico ?? this.mexico,
      unitedArabEmirates: unitedArabEmirates ?? this.unitedArabEmirates,
      unitedKingdom: unitedKingdom ?? this.unitedKingdom,
      southAfrica: southAfrica ?? this.southAfrica,
      switzerland: switzerland ?? this.switzerland,
    );
  }

  PersonalStatsTravel$Travel copyWithWrapped({
    Wrapped<int>? total,
    Wrapped<int>? timeSpent,
    Wrapped<int>? itemsBought,
    Wrapped<PersonalStatsTravel$Travel$Hunting>? hunting,
    Wrapped<int>? attacksWon,
    Wrapped<int>? defendsLost,
    Wrapped<int>? argentina,
    Wrapped<int>? canada,
    Wrapped<int>? caymanIslands,
    Wrapped<int>? china,
    Wrapped<int>? hawaii,
    Wrapped<int>? japan,
    Wrapped<int>? mexico,
    Wrapped<int>? unitedArabEmirates,
    Wrapped<int>? unitedKingdom,
    Wrapped<int>? southAfrica,
    Wrapped<int>? switzerland,
  }) {
    return PersonalStatsTravel$Travel(
      total: (total != null ? total.value : this.total),
      timeSpent: (timeSpent != null ? timeSpent.value : this.timeSpent),
      itemsBought: (itemsBought != null ? itemsBought.value : this.itemsBought),
      hunting: (hunting != null ? hunting.value : this.hunting),
      attacksWon: (attacksWon != null ? attacksWon.value : this.attacksWon),
      defendsLost: (defendsLost != null ? defendsLost.value : this.defendsLost),
      argentina: (argentina != null ? argentina.value : this.argentina),
      canada: (canada != null ? canada.value : this.canada),
      caymanIslands: (caymanIslands != null ? caymanIslands.value : this.caymanIslands),
      china: (china != null ? china.value : this.china),
      hawaii: (hawaii != null ? hawaii.value : this.hawaii),
      japan: (japan != null ? japan.value : this.japan),
      mexico: (mexico != null ? mexico.value : this.mexico),
      unitedArabEmirates: (unitedArabEmirates != null ? unitedArabEmirates.value : this.unitedArabEmirates),
      unitedKingdom: (unitedKingdom != null ? unitedKingdom.value : this.unitedKingdom),
      southAfrica: (southAfrica != null ? southAfrica.value : this.southAfrica),
      switzerland: (switzerland != null ? switzerland.value : this.switzerland),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsTravelPopular$Travel {
  const PersonalStatsTravelPopular$Travel({
    required this.total,
    required this.timeSpent,
  });

  factory PersonalStatsTravelPopular$Travel.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$PersonalStatsTravelPopular$TravelFromJson(json);

  static const toJsonFactory = _$PersonalStatsTravelPopular$TravelToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsTravelPopular$TravelToJson(this);

  @JsonKey(name: 'total')
  final int total;
  @JsonKey(name: 'time_spent')
  final int timeSpent;
  static const fromJsonFactory = _$PersonalStatsTravelPopular$TravelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsTravelPopular$Travel &&
            (identical(other.total, total) || const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.timeSpent, timeSpent) ||
                const DeepCollectionEquality().equals(
                  other.timeSpent,
                  timeSpent,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(timeSpent) ^
      runtimeType.hashCode;
}

extension $PersonalStatsTravelPopular$TravelExtension on PersonalStatsTravelPopular$Travel {
  PersonalStatsTravelPopular$Travel copyWith({int? total, int? timeSpent}) {
    return PersonalStatsTravelPopular$Travel(
      total: total ?? this.total,
      timeSpent: timeSpent ?? this.timeSpent,
    );
  }

  PersonalStatsTravelPopular$Travel copyWithWrapped({
    Wrapped<int>? total,
    Wrapped<int>? timeSpent,
  }) {
    return PersonalStatsTravelPopular$Travel(
      total: (total != null ? total.value : this.total),
      timeSpent: (timeSpent != null ? timeSpent.value : this.timeSpent),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsItems$Items {
  const PersonalStatsItems$Items({
    required this.found,
    required this.trashed,
    required this.used,
    required this.virusesCoded,
  });

  factory PersonalStatsItems$Items.fromJson(Map<String, dynamic> json) => _$PersonalStatsItems$ItemsFromJson(json);

  static const toJsonFactory = _$PersonalStatsItems$ItemsToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsItems$ItemsToJson(this);

  @JsonKey(name: 'found')
  final PersonalStatsItems$Items$Found found;
  @JsonKey(name: 'trashed')
  final int trashed;
  @JsonKey(name: 'used')
  final PersonalStatsItems$Items$Used used;
  @JsonKey(name: 'viruses_coded')
  final int virusesCoded;
  static const fromJsonFactory = _$PersonalStatsItems$ItemsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsItems$Items &&
            (identical(other.found, found) || const DeepCollectionEquality().equals(other.found, found)) &&
            (identical(other.trashed, trashed) ||
                const DeepCollectionEquality().equals(
                  other.trashed,
                  trashed,
                )) &&
            (identical(other.used, used) || const DeepCollectionEquality().equals(other.used, used)) &&
            (identical(other.virusesCoded, virusesCoded) ||
                const DeepCollectionEquality().equals(
                  other.virusesCoded,
                  virusesCoded,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(found) ^
      const DeepCollectionEquality().hash(trashed) ^
      const DeepCollectionEquality().hash(used) ^
      const DeepCollectionEquality().hash(virusesCoded) ^
      runtimeType.hashCode;
}

extension $PersonalStatsItems$ItemsExtension on PersonalStatsItems$Items {
  PersonalStatsItems$Items copyWith({
    PersonalStatsItems$Items$Found? found,
    int? trashed,
    PersonalStatsItems$Items$Used? used,
    int? virusesCoded,
  }) {
    return PersonalStatsItems$Items(
      found: found ?? this.found,
      trashed: trashed ?? this.trashed,
      used: used ?? this.used,
      virusesCoded: virusesCoded ?? this.virusesCoded,
    );
  }

  PersonalStatsItems$Items copyWithWrapped({
    Wrapped<PersonalStatsItems$Items$Found>? found,
    Wrapped<int>? trashed,
    Wrapped<PersonalStatsItems$Items$Used>? used,
    Wrapped<int>? virusesCoded,
  }) {
    return PersonalStatsItems$Items(
      found: (found != null ? found.value : this.found),
      trashed: (trashed != null ? trashed.value : this.trashed),
      used: (used != null ? used.value : this.used),
      virusesCoded: (virusesCoded != null ? virusesCoded.value : this.virusesCoded),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsItemsPopular$Items {
  const PersonalStatsItemsPopular$Items({
    required this.found,
    required this.used,
  });

  factory PersonalStatsItemsPopular$Items.fromJson(Map<String, dynamic> json) =>
      _$PersonalStatsItemsPopular$ItemsFromJson(json);

  static const toJsonFactory = _$PersonalStatsItemsPopular$ItemsToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsItemsPopular$ItemsToJson(this);

  @JsonKey(name: 'found')
  final PersonalStatsItemsPopular$Items$Found found;
  @JsonKey(name: 'used')
  final PersonalStatsItemsPopular$Items$Used used;
  static const fromJsonFactory = _$PersonalStatsItemsPopular$ItemsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsItemsPopular$Items &&
            (identical(other.found, found) || const DeepCollectionEquality().equals(other.found, found)) &&
            (identical(other.used, used) || const DeepCollectionEquality().equals(other.used, used)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(found) ^ const DeepCollectionEquality().hash(used) ^ runtimeType.hashCode;
}

extension $PersonalStatsItemsPopular$ItemsExtension on PersonalStatsItemsPopular$Items {
  PersonalStatsItemsPopular$Items copyWith({
    PersonalStatsItemsPopular$Items$Found? found,
    PersonalStatsItemsPopular$Items$Used? used,
  }) {
    return PersonalStatsItemsPopular$Items(
      found: found ?? this.found,
      used: used ?? this.used,
    );
  }

  PersonalStatsItemsPopular$Items copyWithWrapped({
    Wrapped<PersonalStatsItemsPopular$Items$Found>? found,
    Wrapped<PersonalStatsItemsPopular$Items$Used>? used,
  }) {
    return PersonalStatsItemsPopular$Items(
      found: (found != null ? found.value : this.found),
      used: (used != null ? used.value : this.used),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsInvestments$Investments {
  const PersonalStatsInvestments$Investments({
    required this.bank,
    required this.stocks,
  });

  factory PersonalStatsInvestments$Investments.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$PersonalStatsInvestments$InvestmentsFromJson(json);

  static const toJsonFactory = _$PersonalStatsInvestments$InvestmentsToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsInvestments$InvestmentsToJson(this);

  @JsonKey(name: 'bank')
  final PersonalStatsInvestments$Investments$Bank bank;
  @JsonKey(name: 'stocks')
  final PersonalStatsInvestments$Investments$Stocks stocks;
  static const fromJsonFactory = _$PersonalStatsInvestments$InvestmentsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsInvestments$Investments &&
            (identical(other.bank, bank) || const DeepCollectionEquality().equals(other.bank, bank)) &&
            (identical(other.stocks, stocks) || const DeepCollectionEquality().equals(other.stocks, stocks)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(bank) ^ const DeepCollectionEquality().hash(stocks) ^ runtimeType.hashCode;
}

extension $PersonalStatsInvestments$InvestmentsExtension on PersonalStatsInvestments$Investments {
  PersonalStatsInvestments$Investments copyWith({
    PersonalStatsInvestments$Investments$Bank? bank,
    PersonalStatsInvestments$Investments$Stocks? stocks,
  }) {
    return PersonalStatsInvestments$Investments(
      bank: bank ?? this.bank,
      stocks: stocks ?? this.stocks,
    );
  }

  PersonalStatsInvestments$Investments copyWithWrapped({
    Wrapped<PersonalStatsInvestments$Investments$Bank>? bank,
    Wrapped<PersonalStatsInvestments$Investments$Stocks>? stocks,
  }) {
    return PersonalStatsInvestments$Investments(
      bank: (bank != null ? bank.value : this.bank),
      stocks: (stocks != null ? stocks.value : this.stocks),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsBounties$Bounties {
  const PersonalStatsBounties$Bounties({
    required this.placed,
    required this.collected,
    required this.received,
  });

  factory PersonalStatsBounties$Bounties.fromJson(Map<String, dynamic> json) =>
      _$PersonalStatsBounties$BountiesFromJson(json);

  static const toJsonFactory = _$PersonalStatsBounties$BountiesToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsBounties$BountiesToJson(this);

  @JsonKey(name: 'placed')
  final PersonalStatsBounties$Bounties$Placed placed;
  @JsonKey(name: 'collected')
  final PersonalStatsBounties$Bounties$Collected collected;
  @JsonKey(name: 'received')
  final PersonalStatsBounties$Bounties$Received received;
  static const fromJsonFactory = _$PersonalStatsBounties$BountiesFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsBounties$Bounties &&
            (identical(other.placed, placed) || const DeepCollectionEquality().equals(other.placed, placed)) &&
            (identical(other.collected, collected) ||
                const DeepCollectionEquality().equals(
                  other.collected,
                  collected,
                )) &&
            (identical(other.received, received) ||
                const DeepCollectionEquality().equals(
                  other.received,
                  received,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(placed) ^
      const DeepCollectionEquality().hash(collected) ^
      const DeepCollectionEquality().hash(received) ^
      runtimeType.hashCode;
}

extension $PersonalStatsBounties$BountiesExtension on PersonalStatsBounties$Bounties {
  PersonalStatsBounties$Bounties copyWith({
    PersonalStatsBounties$Bounties$Placed? placed,
    PersonalStatsBounties$Bounties$Collected? collected,
    PersonalStatsBounties$Bounties$Received? received,
  }) {
    return PersonalStatsBounties$Bounties(
      placed: placed ?? this.placed,
      collected: collected ?? this.collected,
      received: received ?? this.received,
    );
  }

  PersonalStatsBounties$Bounties copyWithWrapped({
    Wrapped<PersonalStatsBounties$Bounties$Placed>? placed,
    Wrapped<PersonalStatsBounties$Bounties$Collected>? collected,
    Wrapped<PersonalStatsBounties$Bounties$Received>? received,
  }) {
    return PersonalStatsBounties$Bounties(
      placed: (placed != null ? placed.value : this.placed),
      collected: (collected != null ? collected.value : this.collected),
      received: (received != null ? received.value : this.received),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsCrimesV2$Offenses {
  const PersonalStatsCrimesV2$Offenses({
    required this.vandalism,
    required this.fraud,
    required this.theft,
    required this.counterfeiting,
    required this.illicitServices,
    required this.cybercrime,
    required this.extortion,
    required this.illegalProduction,
    required this.organizedCrimes,
    required this.total,
  });

  factory PersonalStatsCrimesV2$Offenses.fromJson(Map<String, dynamic> json) =>
      _$PersonalStatsCrimesV2$OffensesFromJson(json);

  static const toJsonFactory = _$PersonalStatsCrimesV2$OffensesToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsCrimesV2$OffensesToJson(this);

  @JsonKey(name: 'vandalism')
  final int vandalism;
  @JsonKey(name: 'fraud')
  final int fraud;
  @JsonKey(name: 'theft')
  final int theft;
  @JsonKey(name: 'counterfeiting')
  final int counterfeiting;
  @JsonKey(name: 'illicit_services')
  final int illicitServices;
  @JsonKey(name: 'cybercrime')
  final int cybercrime;
  @JsonKey(name: 'extortion')
  final int extortion;
  @JsonKey(name: 'illegal_production')
  final int illegalProduction;
  @JsonKey(name: 'organized_crimes')
  final int organizedCrimes;
  @JsonKey(name: 'total')
  final int total;
  static const fromJsonFactory = _$PersonalStatsCrimesV2$OffensesFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsCrimesV2$Offenses &&
            (identical(other.vandalism, vandalism) ||
                const DeepCollectionEquality().equals(
                  other.vandalism,
                  vandalism,
                )) &&
            (identical(other.fraud, fraud) || const DeepCollectionEquality().equals(other.fraud, fraud)) &&
            (identical(other.theft, theft) || const DeepCollectionEquality().equals(other.theft, theft)) &&
            (identical(other.counterfeiting, counterfeiting) ||
                const DeepCollectionEquality().equals(
                  other.counterfeiting,
                  counterfeiting,
                )) &&
            (identical(other.illicitServices, illicitServices) ||
                const DeepCollectionEquality().equals(
                  other.illicitServices,
                  illicitServices,
                )) &&
            (identical(other.cybercrime, cybercrime) ||
                const DeepCollectionEquality().equals(
                  other.cybercrime,
                  cybercrime,
                )) &&
            (identical(other.extortion, extortion) ||
                const DeepCollectionEquality().equals(
                  other.extortion,
                  extortion,
                )) &&
            (identical(other.illegalProduction, illegalProduction) ||
                const DeepCollectionEquality().equals(
                  other.illegalProduction,
                  illegalProduction,
                )) &&
            (identical(other.organizedCrimes, organizedCrimes) ||
                const DeepCollectionEquality().equals(
                  other.organizedCrimes,
                  organizedCrimes,
                )) &&
            (identical(other.total, total) || const DeepCollectionEquality().equals(other.total, total)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(vandalism) ^
      const DeepCollectionEquality().hash(fraud) ^
      const DeepCollectionEquality().hash(theft) ^
      const DeepCollectionEquality().hash(counterfeiting) ^
      const DeepCollectionEquality().hash(illicitServices) ^
      const DeepCollectionEquality().hash(cybercrime) ^
      const DeepCollectionEquality().hash(extortion) ^
      const DeepCollectionEquality().hash(illegalProduction) ^
      const DeepCollectionEquality().hash(organizedCrimes) ^
      const DeepCollectionEquality().hash(total) ^
      runtimeType.hashCode;
}

extension $PersonalStatsCrimesV2$OffensesExtension on PersonalStatsCrimesV2$Offenses {
  PersonalStatsCrimesV2$Offenses copyWith({
    int? vandalism,
    int? fraud,
    int? theft,
    int? counterfeiting,
    int? illicitServices,
    int? cybercrime,
    int? extortion,
    int? illegalProduction,
    int? organizedCrimes,
    int? total,
  }) {
    return PersonalStatsCrimesV2$Offenses(
      vandalism: vandalism ?? this.vandalism,
      fraud: fraud ?? this.fraud,
      theft: theft ?? this.theft,
      counterfeiting: counterfeiting ?? this.counterfeiting,
      illicitServices: illicitServices ?? this.illicitServices,
      cybercrime: cybercrime ?? this.cybercrime,
      extortion: extortion ?? this.extortion,
      illegalProduction: illegalProduction ?? this.illegalProduction,
      organizedCrimes: organizedCrimes ?? this.organizedCrimes,
      total: total ?? this.total,
    );
  }

  PersonalStatsCrimesV2$Offenses copyWithWrapped({
    Wrapped<int>? vandalism,
    Wrapped<int>? fraud,
    Wrapped<int>? theft,
    Wrapped<int>? counterfeiting,
    Wrapped<int>? illicitServices,
    Wrapped<int>? cybercrime,
    Wrapped<int>? extortion,
    Wrapped<int>? illegalProduction,
    Wrapped<int>? organizedCrimes,
    Wrapped<int>? total,
  }) {
    return PersonalStatsCrimesV2$Offenses(
      vandalism: (vandalism != null ? vandalism.value : this.vandalism),
      fraud: (fraud != null ? fraud.value : this.fraud),
      theft: (theft != null ? theft.value : this.theft),
      counterfeiting: (counterfeiting != null ? counterfeiting.value : this.counterfeiting),
      illicitServices: (illicitServices != null ? illicitServices.value : this.illicitServices),
      cybercrime: (cybercrime != null ? cybercrime.value : this.cybercrime),
      extortion: (extortion != null ? extortion.value : this.extortion),
      illegalProduction: (illegalProduction != null ? illegalProduction.value : this.illegalProduction),
      organizedCrimes: (organizedCrimes != null ? organizedCrimes.value : this.organizedCrimes),
      total: (total != null ? total.value : this.total),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsCrimesV2$Skills {
  const PersonalStatsCrimesV2$Skills({
    required this.searchForCash,
    required this.bootlegging,
    required this.graffiti,
    required this.shoplifting,
    required this.pickpocketing,
    required this.cardSkimming,
    required this.burglary,
    required this.hustling,
    required this.disposal,
    required this.cracking,
    required this.forgery,
    required this.scamming,
  });

  factory PersonalStatsCrimesV2$Skills.fromJson(Map<String, dynamic> json) =>
      _$PersonalStatsCrimesV2$SkillsFromJson(json);

  static const toJsonFactory = _$PersonalStatsCrimesV2$SkillsToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsCrimesV2$SkillsToJson(this);

  @JsonKey(name: 'search_for_cash')
  final int searchForCash;
  @JsonKey(name: 'bootlegging')
  final int bootlegging;
  @JsonKey(name: 'graffiti')
  final int graffiti;
  @JsonKey(name: 'shoplifting')
  final int shoplifting;
  @JsonKey(name: 'pickpocketing')
  final int pickpocketing;
  @JsonKey(name: 'card_skimming')
  final int cardSkimming;
  @JsonKey(name: 'burglary')
  final int burglary;
  @JsonKey(name: 'hustling')
  final int hustling;
  @JsonKey(name: 'disposal')
  final int disposal;
  @JsonKey(name: 'cracking')
  final int cracking;
  @JsonKey(name: 'forgery')
  final int forgery;
  @JsonKey(name: 'scamming')
  final int scamming;
  static const fromJsonFactory = _$PersonalStatsCrimesV2$SkillsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsCrimesV2$Skills &&
            (identical(other.searchForCash, searchForCash) ||
                const DeepCollectionEquality().equals(
                  other.searchForCash,
                  searchForCash,
                )) &&
            (identical(other.bootlegging, bootlegging) ||
                const DeepCollectionEquality().equals(
                  other.bootlegging,
                  bootlegging,
                )) &&
            (identical(other.graffiti, graffiti) ||
                const DeepCollectionEquality().equals(
                  other.graffiti,
                  graffiti,
                )) &&
            (identical(other.shoplifting, shoplifting) ||
                const DeepCollectionEquality().equals(
                  other.shoplifting,
                  shoplifting,
                )) &&
            (identical(other.pickpocketing, pickpocketing) ||
                const DeepCollectionEquality().equals(
                  other.pickpocketing,
                  pickpocketing,
                )) &&
            (identical(other.cardSkimming, cardSkimming) ||
                const DeepCollectionEquality().equals(
                  other.cardSkimming,
                  cardSkimming,
                )) &&
            (identical(other.burglary, burglary) ||
                const DeepCollectionEquality().equals(
                  other.burglary,
                  burglary,
                )) &&
            (identical(other.hustling, hustling) ||
                const DeepCollectionEquality().equals(
                  other.hustling,
                  hustling,
                )) &&
            (identical(other.disposal, disposal) ||
                const DeepCollectionEquality().equals(
                  other.disposal,
                  disposal,
                )) &&
            (identical(other.cracking, cracking) ||
                const DeepCollectionEquality().equals(
                  other.cracking,
                  cracking,
                )) &&
            (identical(other.forgery, forgery) ||
                const DeepCollectionEquality().equals(
                  other.forgery,
                  forgery,
                )) &&
            (identical(other.scamming, scamming) ||
                const DeepCollectionEquality().equals(
                  other.scamming,
                  scamming,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(searchForCash) ^
      const DeepCollectionEquality().hash(bootlegging) ^
      const DeepCollectionEquality().hash(graffiti) ^
      const DeepCollectionEquality().hash(shoplifting) ^
      const DeepCollectionEquality().hash(pickpocketing) ^
      const DeepCollectionEquality().hash(cardSkimming) ^
      const DeepCollectionEquality().hash(burglary) ^
      const DeepCollectionEquality().hash(hustling) ^
      const DeepCollectionEquality().hash(disposal) ^
      const DeepCollectionEquality().hash(cracking) ^
      const DeepCollectionEquality().hash(forgery) ^
      const DeepCollectionEquality().hash(scamming) ^
      runtimeType.hashCode;
}

extension $PersonalStatsCrimesV2$SkillsExtension on PersonalStatsCrimesV2$Skills {
  PersonalStatsCrimesV2$Skills copyWith({
    int? searchForCash,
    int? bootlegging,
    int? graffiti,
    int? shoplifting,
    int? pickpocketing,
    int? cardSkimming,
    int? burglary,
    int? hustling,
    int? disposal,
    int? cracking,
    int? forgery,
    int? scamming,
  }) {
    return PersonalStatsCrimesV2$Skills(
      searchForCash: searchForCash ?? this.searchForCash,
      bootlegging: bootlegging ?? this.bootlegging,
      graffiti: graffiti ?? this.graffiti,
      shoplifting: shoplifting ?? this.shoplifting,
      pickpocketing: pickpocketing ?? this.pickpocketing,
      cardSkimming: cardSkimming ?? this.cardSkimming,
      burglary: burglary ?? this.burglary,
      hustling: hustling ?? this.hustling,
      disposal: disposal ?? this.disposal,
      cracking: cracking ?? this.cracking,
      forgery: forgery ?? this.forgery,
      scamming: scamming ?? this.scamming,
    );
  }

  PersonalStatsCrimesV2$Skills copyWithWrapped({
    Wrapped<int>? searchForCash,
    Wrapped<int>? bootlegging,
    Wrapped<int>? graffiti,
    Wrapped<int>? shoplifting,
    Wrapped<int>? pickpocketing,
    Wrapped<int>? cardSkimming,
    Wrapped<int>? burglary,
    Wrapped<int>? hustling,
    Wrapped<int>? disposal,
    Wrapped<int>? cracking,
    Wrapped<int>? forgery,
    Wrapped<int>? scamming,
  }) {
    return PersonalStatsCrimesV2$Skills(
      searchForCash: (searchForCash != null ? searchForCash.value : this.searchForCash),
      bootlegging: (bootlegging != null ? bootlegging.value : this.bootlegging),
      graffiti: (graffiti != null ? graffiti.value : this.graffiti),
      shoplifting: (shoplifting != null ? shoplifting.value : this.shoplifting),
      pickpocketing: (pickpocketing != null ? pickpocketing.value : this.pickpocketing),
      cardSkimming: (cardSkimming != null ? cardSkimming.value : this.cardSkimming),
      burglary: (burglary != null ? burglary.value : this.burglary),
      hustling: (hustling != null ? hustling.value : this.hustling),
      disposal: (disposal != null ? disposal.value : this.disposal),
      cracking: (cracking != null ? cracking.value : this.cracking),
      forgery: (forgery != null ? forgery.value : this.forgery),
      scamming: (scamming != null ? scamming.value : this.scamming),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsCrimesPopular$Crimes {
  const PersonalStatsCrimesPopular$Crimes({
    required this.total,
    required this.version,
  });

  factory PersonalStatsCrimesPopular$Crimes.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$PersonalStatsCrimesPopular$CrimesFromJson(json);

  static const toJsonFactory = _$PersonalStatsCrimesPopular$CrimesToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsCrimesPopular$CrimesToJson(this);

  @JsonKey(name: 'total')
  final int total;
  @JsonKey(name: 'version')
  final String version;
  static const fromJsonFactory = _$PersonalStatsCrimesPopular$CrimesFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsCrimesPopular$Crimes &&
            (identical(other.total, total) || const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.version, version) || const DeepCollectionEquality().equals(other.version, version)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(total) ^ const DeepCollectionEquality().hash(version) ^ runtimeType.hashCode;
}

extension $PersonalStatsCrimesPopular$CrimesExtension on PersonalStatsCrimesPopular$Crimes {
  PersonalStatsCrimesPopular$Crimes copyWith({int? total, String? version}) {
    return PersonalStatsCrimesPopular$Crimes(
      total: total ?? this.total,
      version: version ?? this.version,
    );
  }

  PersonalStatsCrimesPopular$Crimes copyWithWrapped({
    Wrapped<int>? total,
    Wrapped<String>? version,
  }) {
    return PersonalStatsCrimesPopular$Crimes(
      total: (total != null ? total.value : this.total),
      version: (version != null ? version.value : this.version),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsCommunication$Communication {
  const PersonalStatsCommunication$Communication({
    required this.mailsSent,
    required this.classifiedAds,
    required this.personals,
  });

  factory PersonalStatsCommunication$Communication.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$PersonalStatsCommunication$CommunicationFromJson(json);

  static const toJsonFactory = _$PersonalStatsCommunication$CommunicationToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsCommunication$CommunicationToJson(this);

  @JsonKey(name: 'mails_sent')
  final PersonalStatsCommunication$Communication$MailsSent mailsSent;
  @JsonKey(name: 'classified_ads')
  final int classifiedAds;
  @JsonKey(name: 'personals')
  final int personals;
  static const fromJsonFactory = _$PersonalStatsCommunication$CommunicationFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsCommunication$Communication &&
            (identical(other.mailsSent, mailsSent) ||
                const DeepCollectionEquality().equals(
                  other.mailsSent,
                  mailsSent,
                )) &&
            (identical(other.classifiedAds, classifiedAds) ||
                const DeepCollectionEquality().equals(
                  other.classifiedAds,
                  classifiedAds,
                )) &&
            (identical(other.personals, personals) ||
                const DeepCollectionEquality().equals(
                  other.personals,
                  personals,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(mailsSent) ^
      const DeepCollectionEquality().hash(classifiedAds) ^
      const DeepCollectionEquality().hash(personals) ^
      runtimeType.hashCode;
}

extension $PersonalStatsCommunication$CommunicationExtension on PersonalStatsCommunication$Communication {
  PersonalStatsCommunication$Communication copyWith({
    PersonalStatsCommunication$Communication$MailsSent? mailsSent,
    int? classifiedAds,
    int? personals,
  }) {
    return PersonalStatsCommunication$Communication(
      mailsSent: mailsSent ?? this.mailsSent,
      classifiedAds: classifiedAds ?? this.classifiedAds,
      personals: personals ?? this.personals,
    );
  }

  PersonalStatsCommunication$Communication copyWithWrapped({
    Wrapped<PersonalStatsCommunication$Communication$MailsSent>? mailsSent,
    Wrapped<int>? classifiedAds,
    Wrapped<int>? personals,
  }) {
    return PersonalStatsCommunication$Communication(
      mailsSent: (mailsSent != null ? mailsSent.value : this.mailsSent),
      classifiedAds: (classifiedAds != null ? classifiedAds.value : this.classifiedAds),
      personals: (personals != null ? personals.value : this.personals),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsFinishingHits$FinishingHits {
  const PersonalStatsFinishingHits$FinishingHits({
    required this.heavyArtillery,
    required this.machineGuns,
    required this.rifles,
    required this.subMachineGuns,
    required this.shotguns,
    required this.pistols,
    required this.temporary,
    required this.piercing,
    required this.slashing,
    required this.clubbing,
    required this.mechanical,
    required this.handToHand,
  });

  factory PersonalStatsFinishingHits$FinishingHits.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$PersonalStatsFinishingHits$FinishingHitsFromJson(json);

  static const toJsonFactory = _$PersonalStatsFinishingHits$FinishingHitsToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsFinishingHits$FinishingHitsToJson(this);

  @JsonKey(name: 'heavy_artillery')
  final int heavyArtillery;
  @JsonKey(name: 'machine_guns')
  final int machineGuns;
  @JsonKey(name: 'rifles')
  final int rifles;
  @JsonKey(name: 'sub_machine_guns')
  final int subMachineGuns;
  @JsonKey(name: 'shotguns')
  final int shotguns;
  @JsonKey(name: 'pistols')
  final int pistols;
  @JsonKey(name: 'temporary')
  final int temporary;
  @JsonKey(name: 'piercing')
  final int piercing;
  @JsonKey(name: 'slashing')
  final int slashing;
  @JsonKey(name: 'clubbing')
  final int clubbing;
  @JsonKey(name: 'mechanical')
  final int mechanical;
  @JsonKey(name: 'hand_to_hand')
  final int handToHand;
  static const fromJsonFactory = _$PersonalStatsFinishingHits$FinishingHitsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsFinishingHits$FinishingHits &&
            (identical(other.heavyArtillery, heavyArtillery) ||
                const DeepCollectionEquality().equals(
                  other.heavyArtillery,
                  heavyArtillery,
                )) &&
            (identical(other.machineGuns, machineGuns) ||
                const DeepCollectionEquality().equals(
                  other.machineGuns,
                  machineGuns,
                )) &&
            (identical(other.rifles, rifles) || const DeepCollectionEquality().equals(other.rifles, rifles)) &&
            (identical(other.subMachineGuns, subMachineGuns) ||
                const DeepCollectionEquality().equals(
                  other.subMachineGuns,
                  subMachineGuns,
                )) &&
            (identical(other.shotguns, shotguns) ||
                const DeepCollectionEquality().equals(
                  other.shotguns,
                  shotguns,
                )) &&
            (identical(other.pistols, pistols) ||
                const DeepCollectionEquality().equals(
                  other.pistols,
                  pistols,
                )) &&
            (identical(other.temporary, temporary) ||
                const DeepCollectionEquality().equals(
                  other.temporary,
                  temporary,
                )) &&
            (identical(other.piercing, piercing) ||
                const DeepCollectionEquality().equals(
                  other.piercing,
                  piercing,
                )) &&
            (identical(other.slashing, slashing) ||
                const DeepCollectionEquality().equals(
                  other.slashing,
                  slashing,
                )) &&
            (identical(other.clubbing, clubbing) ||
                const DeepCollectionEquality().equals(
                  other.clubbing,
                  clubbing,
                )) &&
            (identical(other.mechanical, mechanical) ||
                const DeepCollectionEquality().equals(
                  other.mechanical,
                  mechanical,
                )) &&
            (identical(other.handToHand, handToHand) ||
                const DeepCollectionEquality().equals(
                  other.handToHand,
                  handToHand,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(heavyArtillery) ^
      const DeepCollectionEquality().hash(machineGuns) ^
      const DeepCollectionEquality().hash(rifles) ^
      const DeepCollectionEquality().hash(subMachineGuns) ^
      const DeepCollectionEquality().hash(shotguns) ^
      const DeepCollectionEquality().hash(pistols) ^
      const DeepCollectionEquality().hash(temporary) ^
      const DeepCollectionEquality().hash(piercing) ^
      const DeepCollectionEquality().hash(slashing) ^
      const DeepCollectionEquality().hash(clubbing) ^
      const DeepCollectionEquality().hash(mechanical) ^
      const DeepCollectionEquality().hash(handToHand) ^
      runtimeType.hashCode;
}

extension $PersonalStatsFinishingHits$FinishingHitsExtension on PersonalStatsFinishingHits$FinishingHits {
  PersonalStatsFinishingHits$FinishingHits copyWith({
    int? heavyArtillery,
    int? machineGuns,
    int? rifles,
    int? subMachineGuns,
    int? shotguns,
    int? pistols,
    int? temporary,
    int? piercing,
    int? slashing,
    int? clubbing,
    int? mechanical,
    int? handToHand,
  }) {
    return PersonalStatsFinishingHits$FinishingHits(
      heavyArtillery: heavyArtillery ?? this.heavyArtillery,
      machineGuns: machineGuns ?? this.machineGuns,
      rifles: rifles ?? this.rifles,
      subMachineGuns: subMachineGuns ?? this.subMachineGuns,
      shotguns: shotguns ?? this.shotguns,
      pistols: pistols ?? this.pistols,
      temporary: temporary ?? this.temporary,
      piercing: piercing ?? this.piercing,
      slashing: slashing ?? this.slashing,
      clubbing: clubbing ?? this.clubbing,
      mechanical: mechanical ?? this.mechanical,
      handToHand: handToHand ?? this.handToHand,
    );
  }

  PersonalStatsFinishingHits$FinishingHits copyWithWrapped({
    Wrapped<int>? heavyArtillery,
    Wrapped<int>? machineGuns,
    Wrapped<int>? rifles,
    Wrapped<int>? subMachineGuns,
    Wrapped<int>? shotguns,
    Wrapped<int>? pistols,
    Wrapped<int>? temporary,
    Wrapped<int>? piercing,
    Wrapped<int>? slashing,
    Wrapped<int>? clubbing,
    Wrapped<int>? mechanical,
    Wrapped<int>? handToHand,
  }) {
    return PersonalStatsFinishingHits$FinishingHits(
      heavyArtillery: (heavyArtillery != null ? heavyArtillery.value : this.heavyArtillery),
      machineGuns: (machineGuns != null ? machineGuns.value : this.machineGuns),
      rifles: (rifles != null ? rifles.value : this.rifles),
      subMachineGuns: (subMachineGuns != null ? subMachineGuns.value : this.subMachineGuns),
      shotguns: (shotguns != null ? shotguns.value : this.shotguns),
      pistols: (pistols != null ? pistols.value : this.pistols),
      temporary: (temporary != null ? temporary.value : this.temporary),
      piercing: (piercing != null ? piercing.value : this.piercing),
      slashing: (slashing != null ? slashing.value : this.slashing),
      clubbing: (clubbing != null ? clubbing.value : this.clubbing),
      mechanical: (mechanical != null ? mechanical.value : this.mechanical),
      handToHand: (handToHand != null ? handToHand.value : this.handToHand),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsHospital$Hospital {
  const PersonalStatsHospital$Hospital({
    required this.timesHospitalized,
    required this.medicalItemsUsed,
    required this.bloodWithdrawn,
    required this.reviving,
  });

  factory PersonalStatsHospital$Hospital.fromJson(Map<String, dynamic> json) =>
      _$PersonalStatsHospital$HospitalFromJson(json);

  static const toJsonFactory = _$PersonalStatsHospital$HospitalToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsHospital$HospitalToJson(this);

  @JsonKey(name: 'times_hospitalized')
  final int timesHospitalized;
  @JsonKey(name: 'medical_items_used')
  final int medicalItemsUsed;
  @JsonKey(name: 'blood_withdrawn')
  final int bloodWithdrawn;
  @JsonKey(name: 'reviving')
  final PersonalStatsHospital$Hospital$Reviving reviving;
  static const fromJsonFactory = _$PersonalStatsHospital$HospitalFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsHospital$Hospital &&
            (identical(other.timesHospitalized, timesHospitalized) ||
                const DeepCollectionEquality().equals(
                  other.timesHospitalized,
                  timesHospitalized,
                )) &&
            (identical(other.medicalItemsUsed, medicalItemsUsed) ||
                const DeepCollectionEquality().equals(
                  other.medicalItemsUsed,
                  medicalItemsUsed,
                )) &&
            (identical(other.bloodWithdrawn, bloodWithdrawn) ||
                const DeepCollectionEquality().equals(
                  other.bloodWithdrawn,
                  bloodWithdrawn,
                )) &&
            (identical(other.reviving, reviving) ||
                const DeepCollectionEquality().equals(
                  other.reviving,
                  reviving,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(timesHospitalized) ^
      const DeepCollectionEquality().hash(medicalItemsUsed) ^
      const DeepCollectionEquality().hash(bloodWithdrawn) ^
      const DeepCollectionEquality().hash(reviving) ^
      runtimeType.hashCode;
}

extension $PersonalStatsHospital$HospitalExtension on PersonalStatsHospital$Hospital {
  PersonalStatsHospital$Hospital copyWith({
    int? timesHospitalized,
    int? medicalItemsUsed,
    int? bloodWithdrawn,
    PersonalStatsHospital$Hospital$Reviving? reviving,
  }) {
    return PersonalStatsHospital$Hospital(
      timesHospitalized: timesHospitalized ?? this.timesHospitalized,
      medicalItemsUsed: medicalItemsUsed ?? this.medicalItemsUsed,
      bloodWithdrawn: bloodWithdrawn ?? this.bloodWithdrawn,
      reviving: reviving ?? this.reviving,
    );
  }

  PersonalStatsHospital$Hospital copyWithWrapped({
    Wrapped<int>? timesHospitalized,
    Wrapped<int>? medicalItemsUsed,
    Wrapped<int>? bloodWithdrawn,
    Wrapped<PersonalStatsHospital$Hospital$Reviving>? reviving,
  }) {
    return PersonalStatsHospital$Hospital(
      timesHospitalized: (timesHospitalized != null ? timesHospitalized.value : this.timesHospitalized),
      medicalItemsUsed: (medicalItemsUsed != null ? medicalItemsUsed.value : this.medicalItemsUsed),
      bloodWithdrawn: (bloodWithdrawn != null ? bloodWithdrawn.value : this.bloodWithdrawn),
      reviving: (reviving != null ? reviving.value : this.reviving),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsHospitalPopular$Hospital {
  const PersonalStatsHospitalPopular$Hospital({
    required this.medicalItemsUsed,
    required this.reviving,
  });

  factory PersonalStatsHospitalPopular$Hospital.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$PersonalStatsHospitalPopular$HospitalFromJson(json);

  static const toJsonFactory = _$PersonalStatsHospitalPopular$HospitalToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsHospitalPopular$HospitalToJson(this);

  @JsonKey(name: 'medical_items_used')
  final int medicalItemsUsed;
  @JsonKey(name: 'reviving')
  final PersonalStatsHospitalPopular$Hospital$Reviving reviving;
  static const fromJsonFactory = _$PersonalStatsHospitalPopular$HospitalFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsHospitalPopular$Hospital &&
            (identical(other.medicalItemsUsed, medicalItemsUsed) ||
                const DeepCollectionEquality().equals(
                  other.medicalItemsUsed,
                  medicalItemsUsed,
                )) &&
            (identical(other.reviving, reviving) ||
                const DeepCollectionEquality().equals(
                  other.reviving,
                  reviving,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(medicalItemsUsed) ^
      const DeepCollectionEquality().hash(reviving) ^
      runtimeType.hashCode;
}

extension $PersonalStatsHospitalPopular$HospitalExtension on PersonalStatsHospitalPopular$Hospital {
  PersonalStatsHospitalPopular$Hospital copyWith({
    int? medicalItemsUsed,
    PersonalStatsHospitalPopular$Hospital$Reviving? reviving,
  }) {
    return PersonalStatsHospitalPopular$Hospital(
      medicalItemsUsed: medicalItemsUsed ?? this.medicalItemsUsed,
      reviving: reviving ?? this.reviving,
    );
  }

  PersonalStatsHospitalPopular$Hospital copyWithWrapped({
    Wrapped<int>? medicalItemsUsed,
    Wrapped<PersonalStatsHospitalPopular$Hospital$Reviving>? reviving,
  }) {
    return PersonalStatsHospitalPopular$Hospital(
      medicalItemsUsed: (medicalItemsUsed != null ? medicalItemsUsed.value : this.medicalItemsUsed),
      reviving: (reviving != null ? reviving.value : this.reviving),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsJail$Jail {
  const PersonalStatsJail$Jail({
    required this.timesJailed,
    required this.busts,
    required this.bails,
  });

  factory PersonalStatsJail$Jail.fromJson(Map<String, dynamic> json) => _$PersonalStatsJail$JailFromJson(json);

  static const toJsonFactory = _$PersonalStatsJail$JailToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsJail$JailToJson(this);

  @JsonKey(name: 'times_jailed')
  final int timesJailed;
  @JsonKey(name: 'busts')
  final PersonalStatsJail$Jail$Busts busts;
  @JsonKey(name: 'bails')
  final PersonalStatsJail$Jail$Bails bails;
  static const fromJsonFactory = _$PersonalStatsJail$JailFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsJail$Jail &&
            (identical(other.timesJailed, timesJailed) ||
                const DeepCollectionEquality().equals(
                  other.timesJailed,
                  timesJailed,
                )) &&
            (identical(other.busts, busts) || const DeepCollectionEquality().equals(other.busts, busts)) &&
            (identical(other.bails, bails) || const DeepCollectionEquality().equals(other.bails, bails)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(timesJailed) ^
      const DeepCollectionEquality().hash(busts) ^
      const DeepCollectionEquality().hash(bails) ^
      runtimeType.hashCode;
}

extension $PersonalStatsJail$JailExtension on PersonalStatsJail$Jail {
  PersonalStatsJail$Jail copyWith({
    int? timesJailed,
    PersonalStatsJail$Jail$Busts? busts,
    PersonalStatsJail$Jail$Bails? bails,
  }) {
    return PersonalStatsJail$Jail(
      timesJailed: timesJailed ?? this.timesJailed,
      busts: busts ?? this.busts,
      bails: bails ?? this.bails,
    );
  }

  PersonalStatsJail$Jail copyWithWrapped({
    Wrapped<int>? timesJailed,
    Wrapped<PersonalStatsJail$Jail$Busts>? busts,
    Wrapped<PersonalStatsJail$Jail$Bails>? bails,
  }) {
    return PersonalStatsJail$Jail(
      timesJailed: (timesJailed != null ? timesJailed.value : this.timesJailed),
      busts: (busts != null ? busts.value : this.busts),
      bails: (bails != null ? bails.value : this.bails),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsTrading$Trading {
  const PersonalStatsTrading$Trading({
    required this.items,
    required this.trades,
    required this.points,
    required this.bazaar,
    this.itemMarket,
  });

  factory PersonalStatsTrading$Trading.fromJson(Map<String, dynamic> json) =>
      _$PersonalStatsTrading$TradingFromJson(json);

  static const toJsonFactory = _$PersonalStatsTrading$TradingToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsTrading$TradingToJson(this);

  @JsonKey(name: 'items')
  final PersonalStatsTrading$Trading$Items items;
  @JsonKey(name: 'trades')
  final int trades;
  @JsonKey(name: 'points')
  final PersonalStatsTrading$Trading$Points points;
  @JsonKey(name: 'bazaar')
  final PersonalStatsTrading$Trading$Bazaar bazaar;
  @JsonKey(name: 'item_market')
  final PersonalStatsTrading$Trading$ItemMarket? itemMarket;
  static const fromJsonFactory = _$PersonalStatsTrading$TradingFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsTrading$Trading &&
            (identical(other.items, items) || const DeepCollectionEquality().equals(other.items, items)) &&
            (identical(other.trades, trades) || const DeepCollectionEquality().equals(other.trades, trades)) &&
            (identical(other.points, points) || const DeepCollectionEquality().equals(other.points, points)) &&
            (identical(other.bazaar, bazaar) || const DeepCollectionEquality().equals(other.bazaar, bazaar)) &&
            (identical(other.itemMarket, itemMarket) ||
                const DeepCollectionEquality().equals(
                  other.itemMarket,
                  itemMarket,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(items) ^
      const DeepCollectionEquality().hash(trades) ^
      const DeepCollectionEquality().hash(points) ^
      const DeepCollectionEquality().hash(bazaar) ^
      const DeepCollectionEquality().hash(itemMarket) ^
      runtimeType.hashCode;
}

extension $PersonalStatsTrading$TradingExtension on PersonalStatsTrading$Trading {
  PersonalStatsTrading$Trading copyWith({
    PersonalStatsTrading$Trading$Items? items,
    int? trades,
    PersonalStatsTrading$Trading$Points? points,
    PersonalStatsTrading$Trading$Bazaar? bazaar,
    PersonalStatsTrading$Trading$ItemMarket? itemMarket,
  }) {
    return PersonalStatsTrading$Trading(
      items: items ?? this.items,
      trades: trades ?? this.trades,
      points: points ?? this.points,
      bazaar: bazaar ?? this.bazaar,
      itemMarket: itemMarket ?? this.itemMarket,
    );
  }

  PersonalStatsTrading$Trading copyWithWrapped({
    Wrapped<PersonalStatsTrading$Trading$Items>? items,
    Wrapped<int>? trades,
    Wrapped<PersonalStatsTrading$Trading$Points>? points,
    Wrapped<PersonalStatsTrading$Trading$Bazaar>? bazaar,
    Wrapped<PersonalStatsTrading$Trading$ItemMarket?>? itemMarket,
  }) {
    return PersonalStatsTrading$Trading(
      items: (items != null ? items.value : this.items),
      trades: (trades != null ? trades.value : this.trades),
      points: (points != null ? points.value : this.points),
      bazaar: (bazaar != null ? bazaar.value : this.bazaar),
      itemMarket: (itemMarket != null ? itemMarket.value : this.itemMarket),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsJobsPublic$Jobs {
  const PersonalStatsJobsPublic$Jobs({
    required this.jobPointsUsed,
    required this.trainsReceived,
  });

  factory PersonalStatsJobsPublic$Jobs.fromJson(Map<String, dynamic> json) =>
      _$PersonalStatsJobsPublic$JobsFromJson(json);

  static const toJsonFactory = _$PersonalStatsJobsPublic$JobsToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsJobsPublic$JobsToJson(this);

  @JsonKey(name: 'job_points_used')
  final int jobPointsUsed;
  @JsonKey(name: 'trains_received')
  final int trainsReceived;
  static const fromJsonFactory = _$PersonalStatsJobsPublic$JobsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsJobsPublic$Jobs &&
            (identical(other.jobPointsUsed, jobPointsUsed) ||
                const DeepCollectionEquality().equals(
                  other.jobPointsUsed,
                  jobPointsUsed,
                )) &&
            (identical(other.trainsReceived, trainsReceived) ||
                const DeepCollectionEquality().equals(
                  other.trainsReceived,
                  trainsReceived,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(jobPointsUsed) ^
      const DeepCollectionEquality().hash(trainsReceived) ^
      runtimeType.hashCode;
}

extension $PersonalStatsJobsPublic$JobsExtension on PersonalStatsJobsPublic$Jobs {
  PersonalStatsJobsPublic$Jobs copyWith({
    int? jobPointsUsed,
    int? trainsReceived,
  }) {
    return PersonalStatsJobsPublic$Jobs(
      jobPointsUsed: jobPointsUsed ?? this.jobPointsUsed,
      trainsReceived: trainsReceived ?? this.trainsReceived,
    );
  }

  PersonalStatsJobsPublic$Jobs copyWithWrapped({
    Wrapped<int>? jobPointsUsed,
    Wrapped<int>? trainsReceived,
  }) {
    return PersonalStatsJobsPublic$Jobs(
      jobPointsUsed: (jobPointsUsed != null ? jobPointsUsed.value : this.jobPointsUsed),
      trainsReceived: (trainsReceived != null ? trainsReceived.value : this.trainsReceived),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsJobsExtended$Jobs {
  const PersonalStatsJobsExtended$Jobs({
    required this.jobPointsUsed,
    required this.trainsReceived,
    required this.stats,
  });

  factory PersonalStatsJobsExtended$Jobs.fromJson(Map<String, dynamic> json) =>
      _$PersonalStatsJobsExtended$JobsFromJson(json);

  static const toJsonFactory = _$PersonalStatsJobsExtended$JobsToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsJobsExtended$JobsToJson(this);

  @JsonKey(name: 'job_points_used')
  final int jobPointsUsed;
  @JsonKey(name: 'trains_received')
  final int trainsReceived;
  @JsonKey(name: 'stats')
  final PersonalStatsJobsExtended$Jobs$Stats stats;
  static const fromJsonFactory = _$PersonalStatsJobsExtended$JobsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsJobsExtended$Jobs &&
            (identical(other.jobPointsUsed, jobPointsUsed) ||
                const DeepCollectionEquality().equals(
                  other.jobPointsUsed,
                  jobPointsUsed,
                )) &&
            (identical(other.trainsReceived, trainsReceived) ||
                const DeepCollectionEquality().equals(
                  other.trainsReceived,
                  trainsReceived,
                )) &&
            (identical(other.stats, stats) || const DeepCollectionEquality().equals(other.stats, stats)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(jobPointsUsed) ^
      const DeepCollectionEquality().hash(trainsReceived) ^
      const DeepCollectionEquality().hash(stats) ^
      runtimeType.hashCode;
}

extension $PersonalStatsJobsExtended$JobsExtension on PersonalStatsJobsExtended$Jobs {
  PersonalStatsJobsExtended$Jobs copyWith({
    int? jobPointsUsed,
    int? trainsReceived,
    PersonalStatsJobsExtended$Jobs$Stats? stats,
  }) {
    return PersonalStatsJobsExtended$Jobs(
      jobPointsUsed: jobPointsUsed ?? this.jobPointsUsed,
      trainsReceived: trainsReceived ?? this.trainsReceived,
      stats: stats ?? this.stats,
    );
  }

  PersonalStatsJobsExtended$Jobs copyWithWrapped({
    Wrapped<int>? jobPointsUsed,
    Wrapped<int>? trainsReceived,
    Wrapped<PersonalStatsJobsExtended$Jobs$Stats>? stats,
  }) {
    return PersonalStatsJobsExtended$Jobs(
      jobPointsUsed: (jobPointsUsed != null ? jobPointsUsed.value : this.jobPointsUsed),
      trainsReceived: (trainsReceived != null ? trainsReceived.value : this.trainsReceived),
      stats: (stats != null ? stats.value : this.stats),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsBattleStats$BattleStats {
  const PersonalStatsBattleStats$BattleStats({
    required this.strength,
    required this.defense,
    required this.speed,
    required this.dexterity,
    required this.total,
  });

  factory PersonalStatsBattleStats$BattleStats.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$PersonalStatsBattleStats$BattleStatsFromJson(json);

  static const toJsonFactory = _$PersonalStatsBattleStats$BattleStatsToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsBattleStats$BattleStatsToJson(this);

  @JsonKey(name: 'strength')
  final int strength;
  @JsonKey(name: 'defense')
  final int defense;
  @JsonKey(name: 'speed')
  final int speed;
  @JsonKey(name: 'dexterity')
  final int dexterity;
  @JsonKey(name: 'total')
  final int total;
  static const fromJsonFactory = _$PersonalStatsBattleStats$BattleStatsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsBattleStats$BattleStats &&
            (identical(other.strength, strength) ||
                const DeepCollectionEquality().equals(
                  other.strength,
                  strength,
                )) &&
            (identical(other.defense, defense) ||
                const DeepCollectionEquality().equals(
                  other.defense,
                  defense,
                )) &&
            (identical(other.speed, speed) || const DeepCollectionEquality().equals(other.speed, speed)) &&
            (identical(other.dexterity, dexterity) ||
                const DeepCollectionEquality().equals(
                  other.dexterity,
                  dexterity,
                )) &&
            (identical(other.total, total) || const DeepCollectionEquality().equals(other.total, total)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(strength) ^
      const DeepCollectionEquality().hash(defense) ^
      const DeepCollectionEquality().hash(speed) ^
      const DeepCollectionEquality().hash(dexterity) ^
      const DeepCollectionEquality().hash(total) ^
      runtimeType.hashCode;
}

extension $PersonalStatsBattleStats$BattleStatsExtension on PersonalStatsBattleStats$BattleStats {
  PersonalStatsBattleStats$BattleStats copyWith({
    int? strength,
    int? defense,
    int? speed,
    int? dexterity,
    int? total,
  }) {
    return PersonalStatsBattleStats$BattleStats(
      strength: strength ?? this.strength,
      defense: defense ?? this.defense,
      speed: speed ?? this.speed,
      dexterity: dexterity ?? this.dexterity,
      total: total ?? this.total,
    );
  }

  PersonalStatsBattleStats$BattleStats copyWithWrapped({
    Wrapped<int>? strength,
    Wrapped<int>? defense,
    Wrapped<int>? speed,
    Wrapped<int>? dexterity,
    Wrapped<int>? total,
  }) {
    return PersonalStatsBattleStats$BattleStats(
      strength: (strength != null ? strength.value : this.strength),
      defense: (defense != null ? defense.value : this.defense),
      speed: (speed != null ? speed.value : this.speed),
      dexterity: (dexterity != null ? dexterity.value : this.dexterity),
      total: (total != null ? total.value : this.total),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsAttackingPublic$Attacking {
  const PersonalStatsAttackingPublic$Attacking({
    required this.attacks,
    required this.defends,
    required this.elo,
    required this.unarmoredWins,
    required this.highestLevelBeaten,
    this.escapes,
    required this.killstreak,
    required this.hits,
    required this.damage,
    required this.networth,
    required this.ammunition,
    required this.faction,
  });

  factory PersonalStatsAttackingPublic$Attacking.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$PersonalStatsAttackingPublic$AttackingFromJson(json);

  static const toJsonFactory = _$PersonalStatsAttackingPublic$AttackingToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsAttackingPublic$AttackingToJson(this);

  @JsonKey(name: 'attacks')
  final PersonalStatsAttackingPublic$Attacking$Attacks attacks;
  @JsonKey(name: 'defends')
  final PersonalStatsAttackingPublic$Attacking$Defends defends;
  @JsonKey(name: 'elo')
  final int elo;
  @JsonKey(name: 'unarmored_wins')
  final int unarmoredWins;
  @JsonKey(name: 'highest_level_beaten')
  final int highestLevelBeaten;
  @JsonKey(name: 'escapes')
  final PersonalStatsAttackingPublic$Attacking$Escapes? escapes;
  @JsonKey(name: 'killstreak')
  final PersonalStatsAttackingPublic$Attacking$Killstreak killstreak;
  @JsonKey(name: 'hits')
  final PersonalStatsAttackingPublic$Attacking$Hits hits;
  @JsonKey(name: 'damage')
  final PersonalStatsAttackingPublic$Attacking$Damage damage;
  @JsonKey(name: 'networth')
  final PersonalStatsAttackingPublic$Attacking$Networth networth;
  @JsonKey(name: 'ammunition')
  final PersonalStatsAttackingPublic$Attacking$Ammunition ammunition;
  @JsonKey(name: 'faction')
  final PersonalStatsAttackingPublic$Attacking$Faction faction;
  static const fromJsonFactory = _$PersonalStatsAttackingPublic$AttackingFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsAttackingPublic$Attacking &&
            (identical(other.attacks, attacks) ||
                const DeepCollectionEquality().equals(
                  other.attacks,
                  attacks,
                )) &&
            (identical(other.defends, defends) ||
                const DeepCollectionEquality().equals(
                  other.defends,
                  defends,
                )) &&
            (identical(other.elo, elo) || const DeepCollectionEquality().equals(other.elo, elo)) &&
            (identical(other.unarmoredWins, unarmoredWins) ||
                const DeepCollectionEquality().equals(
                  other.unarmoredWins,
                  unarmoredWins,
                )) &&
            (identical(other.highestLevelBeaten, highestLevelBeaten) ||
                const DeepCollectionEquality().equals(
                  other.highestLevelBeaten,
                  highestLevelBeaten,
                )) &&
            (identical(other.escapes, escapes) ||
                const DeepCollectionEquality().equals(
                  other.escapes,
                  escapes,
                )) &&
            (identical(other.killstreak, killstreak) ||
                const DeepCollectionEquality().equals(
                  other.killstreak,
                  killstreak,
                )) &&
            (identical(other.hits, hits) || const DeepCollectionEquality().equals(other.hits, hits)) &&
            (identical(other.damage, damage) || const DeepCollectionEquality().equals(other.damage, damage)) &&
            (identical(other.networth, networth) ||
                const DeepCollectionEquality().equals(
                  other.networth,
                  networth,
                )) &&
            (identical(other.ammunition, ammunition) ||
                const DeepCollectionEquality().equals(
                  other.ammunition,
                  ammunition,
                )) &&
            (identical(other.faction, faction) || const DeepCollectionEquality().equals(other.faction, faction)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(attacks) ^
      const DeepCollectionEquality().hash(defends) ^
      const DeepCollectionEquality().hash(elo) ^
      const DeepCollectionEquality().hash(unarmoredWins) ^
      const DeepCollectionEquality().hash(highestLevelBeaten) ^
      const DeepCollectionEquality().hash(escapes) ^
      const DeepCollectionEquality().hash(killstreak) ^
      const DeepCollectionEquality().hash(hits) ^
      const DeepCollectionEquality().hash(damage) ^
      const DeepCollectionEquality().hash(networth) ^
      const DeepCollectionEquality().hash(ammunition) ^
      const DeepCollectionEquality().hash(faction) ^
      runtimeType.hashCode;
}

extension $PersonalStatsAttackingPublic$AttackingExtension on PersonalStatsAttackingPublic$Attacking {
  PersonalStatsAttackingPublic$Attacking copyWith({
    PersonalStatsAttackingPublic$Attacking$Attacks? attacks,
    PersonalStatsAttackingPublic$Attacking$Defends? defends,
    int? elo,
    int? unarmoredWins,
    int? highestLevelBeaten,
    PersonalStatsAttackingPublic$Attacking$Escapes? escapes,
    PersonalStatsAttackingPublic$Attacking$Killstreak? killstreak,
    PersonalStatsAttackingPublic$Attacking$Hits? hits,
    PersonalStatsAttackingPublic$Attacking$Damage? damage,
    PersonalStatsAttackingPublic$Attacking$Networth? networth,
    PersonalStatsAttackingPublic$Attacking$Ammunition? ammunition,
    PersonalStatsAttackingPublic$Attacking$Faction? faction,
  }) {
    return PersonalStatsAttackingPublic$Attacking(
      attacks: attacks ?? this.attacks,
      defends: defends ?? this.defends,
      elo: elo ?? this.elo,
      unarmoredWins: unarmoredWins ?? this.unarmoredWins,
      highestLevelBeaten: highestLevelBeaten ?? this.highestLevelBeaten,
      escapes: escapes ?? this.escapes,
      killstreak: killstreak ?? this.killstreak,
      hits: hits ?? this.hits,
      damage: damage ?? this.damage,
      networth: networth ?? this.networth,
      ammunition: ammunition ?? this.ammunition,
      faction: faction ?? this.faction,
    );
  }

  PersonalStatsAttackingPublic$Attacking copyWithWrapped({
    Wrapped<PersonalStatsAttackingPublic$Attacking$Attacks>? attacks,
    Wrapped<PersonalStatsAttackingPublic$Attacking$Defends>? defends,
    Wrapped<int>? elo,
    Wrapped<int>? unarmoredWins,
    Wrapped<int>? highestLevelBeaten,
    Wrapped<PersonalStatsAttackingPublic$Attacking$Escapes?>? escapes,
    Wrapped<PersonalStatsAttackingPublic$Attacking$Killstreak>? killstreak,
    Wrapped<PersonalStatsAttackingPublic$Attacking$Hits>? hits,
    Wrapped<PersonalStatsAttackingPublic$Attacking$Damage>? damage,
    Wrapped<PersonalStatsAttackingPublic$Attacking$Networth>? networth,
    Wrapped<PersonalStatsAttackingPublic$Attacking$Ammunition>? ammunition,
    Wrapped<PersonalStatsAttackingPublic$Attacking$Faction>? faction,
  }) {
    return PersonalStatsAttackingPublic$Attacking(
      attacks: (attacks != null ? attacks.value : this.attacks),
      defends: (defends != null ? defends.value : this.defends),
      elo: (elo != null ? elo.value : this.elo),
      unarmoredWins: (unarmoredWins != null ? unarmoredWins.value : this.unarmoredWins),
      highestLevelBeaten: (highestLevelBeaten != null ? highestLevelBeaten.value : this.highestLevelBeaten),
      escapes: (escapes != null ? escapes.value : this.escapes),
      killstreak: (killstreak != null ? killstreak.value : this.killstreak),
      hits: (hits != null ? hits.value : this.hits),
      damage: (damage != null ? damage.value : this.damage),
      networth: (networth != null ? networth.value : this.networth),
      ammunition: (ammunition != null ? ammunition.value : this.ammunition),
      faction: (faction != null ? faction.value : this.faction),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsAttackingExtended$Attacking {
  const PersonalStatsAttackingExtended$Attacking({
    required this.attacks,
    required this.defends,
    required this.elo,
    required this.unarmoredWins,
    required this.highestLevelBeaten,
    required this.escapes,
    required this.killstreak,
    required this.hits,
    required this.damage,
    required this.networth,
    required this.ammunition,
    required this.faction,
  });

  factory PersonalStatsAttackingExtended$Attacking.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$PersonalStatsAttackingExtended$AttackingFromJson(json);

  static const toJsonFactory = _$PersonalStatsAttackingExtended$AttackingToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsAttackingExtended$AttackingToJson(this);

  @JsonKey(name: 'attacks')
  final PersonalStatsAttackingExtended$Attacking$Attacks attacks;
  @JsonKey(name: 'defends')
  final PersonalStatsAttackingExtended$Attacking$Defends defends;
  @JsonKey(name: 'elo')
  final int elo;
  @JsonKey(name: 'unarmored_wins')
  final int unarmoredWins;
  @JsonKey(name: 'highest_level_beaten')
  final int highestLevelBeaten;
  @JsonKey(name: 'escapes')
  final PersonalStatsAttackingExtended$Attacking$Escapes escapes;
  @JsonKey(name: 'killstreak')
  final PersonalStatsAttackingExtended$Attacking$Killstreak killstreak;
  @JsonKey(name: 'hits')
  final PersonalStatsAttackingExtended$Attacking$Hits hits;
  @JsonKey(name: 'damage')
  final PersonalStatsAttackingExtended$Attacking$Damage damage;
  @JsonKey(name: 'networth')
  final PersonalStatsAttackingExtended$Attacking$Networth networth;
  @JsonKey(name: 'ammunition')
  final PersonalStatsAttackingExtended$Attacking$Ammunition ammunition;
  @JsonKey(name: 'faction')
  final PersonalStatsAttackingExtended$Attacking$Faction faction;
  static const fromJsonFactory = _$PersonalStatsAttackingExtended$AttackingFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsAttackingExtended$Attacking &&
            (identical(other.attacks, attacks) ||
                const DeepCollectionEquality().equals(
                  other.attacks,
                  attacks,
                )) &&
            (identical(other.defends, defends) ||
                const DeepCollectionEquality().equals(
                  other.defends,
                  defends,
                )) &&
            (identical(other.elo, elo) || const DeepCollectionEquality().equals(other.elo, elo)) &&
            (identical(other.unarmoredWins, unarmoredWins) ||
                const DeepCollectionEquality().equals(
                  other.unarmoredWins,
                  unarmoredWins,
                )) &&
            (identical(other.highestLevelBeaten, highestLevelBeaten) ||
                const DeepCollectionEquality().equals(
                  other.highestLevelBeaten,
                  highestLevelBeaten,
                )) &&
            (identical(other.escapes, escapes) ||
                const DeepCollectionEquality().equals(
                  other.escapes,
                  escapes,
                )) &&
            (identical(other.killstreak, killstreak) ||
                const DeepCollectionEquality().equals(
                  other.killstreak,
                  killstreak,
                )) &&
            (identical(other.hits, hits) || const DeepCollectionEquality().equals(other.hits, hits)) &&
            (identical(other.damage, damage) || const DeepCollectionEquality().equals(other.damage, damage)) &&
            (identical(other.networth, networth) ||
                const DeepCollectionEquality().equals(
                  other.networth,
                  networth,
                )) &&
            (identical(other.ammunition, ammunition) ||
                const DeepCollectionEquality().equals(
                  other.ammunition,
                  ammunition,
                )) &&
            (identical(other.faction, faction) || const DeepCollectionEquality().equals(other.faction, faction)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(attacks) ^
      const DeepCollectionEquality().hash(defends) ^
      const DeepCollectionEquality().hash(elo) ^
      const DeepCollectionEquality().hash(unarmoredWins) ^
      const DeepCollectionEquality().hash(highestLevelBeaten) ^
      const DeepCollectionEquality().hash(escapes) ^
      const DeepCollectionEquality().hash(killstreak) ^
      const DeepCollectionEquality().hash(hits) ^
      const DeepCollectionEquality().hash(damage) ^
      const DeepCollectionEquality().hash(networth) ^
      const DeepCollectionEquality().hash(ammunition) ^
      const DeepCollectionEquality().hash(faction) ^
      runtimeType.hashCode;
}

extension $PersonalStatsAttackingExtended$AttackingExtension on PersonalStatsAttackingExtended$Attacking {
  PersonalStatsAttackingExtended$Attacking copyWith({
    PersonalStatsAttackingExtended$Attacking$Attacks? attacks,
    PersonalStatsAttackingExtended$Attacking$Defends? defends,
    int? elo,
    int? unarmoredWins,
    int? highestLevelBeaten,
    PersonalStatsAttackingExtended$Attacking$Escapes? escapes,
    PersonalStatsAttackingExtended$Attacking$Killstreak? killstreak,
    PersonalStatsAttackingExtended$Attacking$Hits? hits,
    PersonalStatsAttackingExtended$Attacking$Damage? damage,
    PersonalStatsAttackingExtended$Attacking$Networth? networth,
    PersonalStatsAttackingExtended$Attacking$Ammunition? ammunition,
    PersonalStatsAttackingExtended$Attacking$Faction? faction,
  }) {
    return PersonalStatsAttackingExtended$Attacking(
      attacks: attacks ?? this.attacks,
      defends: defends ?? this.defends,
      elo: elo ?? this.elo,
      unarmoredWins: unarmoredWins ?? this.unarmoredWins,
      highestLevelBeaten: highestLevelBeaten ?? this.highestLevelBeaten,
      escapes: escapes ?? this.escapes,
      killstreak: killstreak ?? this.killstreak,
      hits: hits ?? this.hits,
      damage: damage ?? this.damage,
      networth: networth ?? this.networth,
      ammunition: ammunition ?? this.ammunition,
      faction: faction ?? this.faction,
    );
  }

  PersonalStatsAttackingExtended$Attacking copyWithWrapped({
    Wrapped<PersonalStatsAttackingExtended$Attacking$Attacks>? attacks,
    Wrapped<PersonalStatsAttackingExtended$Attacking$Defends>? defends,
    Wrapped<int>? elo,
    Wrapped<int>? unarmoredWins,
    Wrapped<int>? highestLevelBeaten,
    Wrapped<PersonalStatsAttackingExtended$Attacking$Escapes>? escapes,
    Wrapped<PersonalStatsAttackingExtended$Attacking$Killstreak>? killstreak,
    Wrapped<PersonalStatsAttackingExtended$Attacking$Hits>? hits,
    Wrapped<PersonalStatsAttackingExtended$Attacking$Damage>? damage,
    Wrapped<PersonalStatsAttackingExtended$Attacking$Networth>? networth,
    Wrapped<PersonalStatsAttackingExtended$Attacking$Ammunition>? ammunition,
    Wrapped<PersonalStatsAttackingExtended$Attacking$Faction>? faction,
  }) {
    return PersonalStatsAttackingExtended$Attacking(
      attacks: (attacks != null ? attacks.value : this.attacks),
      defends: (defends != null ? defends.value : this.defends),
      elo: (elo != null ? elo.value : this.elo),
      unarmoredWins: (unarmoredWins != null ? unarmoredWins.value : this.unarmoredWins),
      highestLevelBeaten: (highestLevelBeaten != null ? highestLevelBeaten.value : this.highestLevelBeaten),
      escapes: (escapes != null ? escapes.value : this.escapes),
      killstreak: (killstreak != null ? killstreak.value : this.killstreak),
      hits: (hits != null ? hits.value : this.hits),
      damage: (damage != null ? damage.value : this.damage),
      networth: (networth != null ? networth.value : this.networth),
      ammunition: (ammunition != null ? ammunition.value : this.ammunition),
      faction: (faction != null ? faction.value : this.faction),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsAttackingPopular$Attacking {
  const PersonalStatsAttackingPopular$Attacking({
    required this.attacks,
    required this.defends,
    required this.elo,
    required this.escapes,
    required this.killstreak,
    required this.hits,
    required this.damage,
    required this.networth,
    required this.ammunition,
    required this.faction,
  });

  factory PersonalStatsAttackingPopular$Attacking.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$PersonalStatsAttackingPopular$AttackingFromJson(json);

  static const toJsonFactory = _$PersonalStatsAttackingPopular$AttackingToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsAttackingPopular$AttackingToJson(this);

  @JsonKey(name: 'attacks')
  final PersonalStatsAttackingPopular$Attacking$Attacks attacks;
  @JsonKey(name: 'defends')
  final PersonalStatsAttackingPopular$Attacking$Defends defends;
  @JsonKey(name: 'elo')
  final int elo;
  @JsonKey(name: 'escapes')
  final PersonalStatsAttackingPopular$Attacking$Escapes escapes;
  @JsonKey(name: 'killstreak')
  final PersonalStatsAttackingPopular$Attacking$Killstreak killstreak;
  @JsonKey(name: 'hits')
  final PersonalStatsAttackingPopular$Attacking$Hits hits;
  @JsonKey(name: 'damage')
  final PersonalStatsAttackingPopular$Attacking$Damage damage;
  @JsonKey(name: 'networth')
  final PersonalStatsAttackingPopular$Attacking$Networth networth;
  @JsonKey(name: 'ammunition')
  final PersonalStatsAttackingPopular$Attacking$Ammunition ammunition;
  @JsonKey(name: 'faction')
  final PersonalStatsAttackingPopular$Attacking$Faction faction;
  static const fromJsonFactory = _$PersonalStatsAttackingPopular$AttackingFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsAttackingPopular$Attacking &&
            (identical(other.attacks, attacks) ||
                const DeepCollectionEquality().equals(
                  other.attacks,
                  attacks,
                )) &&
            (identical(other.defends, defends) ||
                const DeepCollectionEquality().equals(
                  other.defends,
                  defends,
                )) &&
            (identical(other.elo, elo) || const DeepCollectionEquality().equals(other.elo, elo)) &&
            (identical(other.escapes, escapes) ||
                const DeepCollectionEquality().equals(
                  other.escapes,
                  escapes,
                )) &&
            (identical(other.killstreak, killstreak) ||
                const DeepCollectionEquality().equals(
                  other.killstreak,
                  killstreak,
                )) &&
            (identical(other.hits, hits) || const DeepCollectionEquality().equals(other.hits, hits)) &&
            (identical(other.damage, damage) || const DeepCollectionEquality().equals(other.damage, damage)) &&
            (identical(other.networth, networth) ||
                const DeepCollectionEquality().equals(
                  other.networth,
                  networth,
                )) &&
            (identical(other.ammunition, ammunition) ||
                const DeepCollectionEquality().equals(
                  other.ammunition,
                  ammunition,
                )) &&
            (identical(other.faction, faction) || const DeepCollectionEquality().equals(other.faction, faction)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(attacks) ^
      const DeepCollectionEquality().hash(defends) ^
      const DeepCollectionEquality().hash(elo) ^
      const DeepCollectionEquality().hash(escapes) ^
      const DeepCollectionEquality().hash(killstreak) ^
      const DeepCollectionEquality().hash(hits) ^
      const DeepCollectionEquality().hash(damage) ^
      const DeepCollectionEquality().hash(networth) ^
      const DeepCollectionEquality().hash(ammunition) ^
      const DeepCollectionEquality().hash(faction) ^
      runtimeType.hashCode;
}

extension $PersonalStatsAttackingPopular$AttackingExtension on PersonalStatsAttackingPopular$Attacking {
  PersonalStatsAttackingPopular$Attacking copyWith({
    PersonalStatsAttackingPopular$Attacking$Attacks? attacks,
    PersonalStatsAttackingPopular$Attacking$Defends? defends,
    int? elo,
    PersonalStatsAttackingPopular$Attacking$Escapes? escapes,
    PersonalStatsAttackingPopular$Attacking$Killstreak? killstreak,
    PersonalStatsAttackingPopular$Attacking$Hits? hits,
    PersonalStatsAttackingPopular$Attacking$Damage? damage,
    PersonalStatsAttackingPopular$Attacking$Networth? networth,
    PersonalStatsAttackingPopular$Attacking$Ammunition? ammunition,
    PersonalStatsAttackingPopular$Attacking$Faction? faction,
  }) {
    return PersonalStatsAttackingPopular$Attacking(
      attacks: attacks ?? this.attacks,
      defends: defends ?? this.defends,
      elo: elo ?? this.elo,
      escapes: escapes ?? this.escapes,
      killstreak: killstreak ?? this.killstreak,
      hits: hits ?? this.hits,
      damage: damage ?? this.damage,
      networth: networth ?? this.networth,
      ammunition: ammunition ?? this.ammunition,
      faction: faction ?? this.faction,
    );
  }

  PersonalStatsAttackingPopular$Attacking copyWithWrapped({
    Wrapped<PersonalStatsAttackingPopular$Attacking$Attacks>? attacks,
    Wrapped<PersonalStatsAttackingPopular$Attacking$Defends>? defends,
    Wrapped<int>? elo,
    Wrapped<PersonalStatsAttackingPopular$Attacking$Escapes>? escapes,
    Wrapped<PersonalStatsAttackingPopular$Attacking$Killstreak>? killstreak,
    Wrapped<PersonalStatsAttackingPopular$Attacking$Hits>? hits,
    Wrapped<PersonalStatsAttackingPopular$Attacking$Damage>? damage,
    Wrapped<PersonalStatsAttackingPopular$Attacking$Networth>? networth,
    Wrapped<PersonalStatsAttackingPopular$Attacking$Ammunition>? ammunition,
    Wrapped<PersonalStatsAttackingPopular$Attacking$Faction>? faction,
  }) {
    return PersonalStatsAttackingPopular$Attacking(
      attacks: (attacks != null ? attacks.value : this.attacks),
      defends: (defends != null ? defends.value : this.defends),
      elo: (elo != null ? elo.value : this.elo),
      escapes: (escapes != null ? escapes.value : this.escapes),
      killstreak: (killstreak != null ? killstreak.value : this.killstreak),
      hits: (hits != null ? hits.value : this.hits),
      damage: (damage != null ? damage.value : this.damage),
      networth: (networth != null ? networth.value : this.networth),
      ammunition: (ammunition != null ? ammunition.value : this.ammunition),
      faction: (faction != null ? faction.value : this.faction),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionUpgrades$Core {
  const FactionUpgrades$Core({this.upgrades});

  factory FactionUpgrades$Core.fromJson(Map<String, dynamic> json) => _$FactionUpgrades$CoreFromJson(json);

  static const toJsonFactory = _$FactionUpgrades$CoreToJson;
  Map<String, dynamic> toJson() => _$FactionUpgrades$CoreToJson(this);

  @JsonKey(name: 'upgrades', defaultValue: <FactionUpgradeDetails>[])
  final List<FactionUpgradeDetails>? upgrades;
  static const fromJsonFactory = _$FactionUpgrades$CoreFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionUpgrades$Core &&
            (identical(other.upgrades, upgrades) ||
                const DeepCollectionEquality().equals(
                  other.upgrades,
                  upgrades,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(upgrades) ^ runtimeType.hashCode;
}

extension $FactionUpgrades$CoreExtension on FactionUpgrades$Core {
  FactionUpgrades$Core copyWith({List<FactionUpgradeDetails>? upgrades}) {
    return FactionUpgrades$Core(upgrades: upgrades ?? this.upgrades);
  }

  FactionUpgrades$Core copyWithWrapped({
    Wrapped<List<FactionUpgradeDetails>?>? upgrades,
  }) {
    return FactionUpgrades$Core(
      upgrades: (upgrades != null ? upgrades.value : this.upgrades),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionApplication$User {
  const FactionApplication$User({
    required this.id,
    required this.name,
    required this.level,
    required this.stats,
  });

  factory FactionApplication$User.fromJson(Map<String, dynamic> json) => _$FactionApplication$UserFromJson(json);

  static const toJsonFactory = _$FactionApplication$UserToJson;
  Map<String, dynamic> toJson() => _$FactionApplication$UserToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'level')
  final int level;
  @JsonKey(name: 'stats')
  final dynamic stats;
  static const fromJsonFactory = _$FactionApplication$UserFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionApplication$User &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.level, level) || const DeepCollectionEquality().equals(other.level, level)) &&
            (identical(other.stats, stats) || const DeepCollectionEquality().equals(other.stats, stats)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(level) ^
      const DeepCollectionEquality().hash(stats) ^
      runtimeType.hashCode;
}

extension $FactionApplication$UserExtension on FactionApplication$User {
  FactionApplication$User copyWith({
    int? id,
    String? name,
    int? level,
    dynamic stats,
  }) {
    return FactionApplication$User(
      id: id ?? this.id,
      name: name ?? this.name,
      level: level ?? this.level,
      stats: stats ?? this.stats,
    );
  }

  FactionApplication$User copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<String>? name,
    Wrapped<int>? level,
    Wrapped<dynamic>? stats,
  }) {
    return FactionApplication$User(
      id: (id != null ? id.value : this.id),
      name: (name != null ? name.value : this.name),
      level: (level != null ? level.value : this.level),
      stats: (stats != null ? stats.value : this.stats),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionChainWarfare$Faction {
  const FactionChainWarfare$Faction({required this.id, required this.name});

  factory FactionChainWarfare$Faction.fromJson(Map<String, dynamic> json) =>
      _$FactionChainWarfare$FactionFromJson(json);

  static const toJsonFactory = _$FactionChainWarfare$FactionToJson;
  Map<String, dynamic> toJson() => _$FactionChainWarfare$FactionToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'name')
  final String name;
  static const fromJsonFactory = _$FactionChainWarfare$FactionFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionChainWarfare$Faction &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^ const DeepCollectionEquality().hash(name) ^ runtimeType.hashCode;
}

extension $FactionChainWarfare$FactionExtension on FactionChainWarfare$Faction {
  FactionChainWarfare$Faction copyWith({int? id, String? name}) {
    return FactionChainWarfare$Faction(
      id: id ?? this.id,
      name: name ?? this.name,
    );
  }

  FactionChainWarfare$Faction copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<String>? name,
  }) {
    return FactionChainWarfare$Faction(
      id: (id != null ? id.value : this.id),
      name: (name != null ? name.value : this.name),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionBalance$Faction {
  const FactionBalance$Faction({
    required this.money,
    required this.points,
    required this.scope,
  });

  factory FactionBalance$Faction.fromJson(Map<String, dynamic> json) => _$FactionBalance$FactionFromJson(json);

  static const toJsonFactory = _$FactionBalance$FactionToJson;
  Map<String, dynamic> toJson() => _$FactionBalance$FactionToJson(this);

  @JsonKey(name: 'money')
  final int money;
  @JsonKey(name: 'points')
  final int points;
  @JsonKey(name: 'scope')
  final int scope;
  static const fromJsonFactory = _$FactionBalance$FactionFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionBalance$Faction &&
            (identical(other.money, money) || const DeepCollectionEquality().equals(other.money, money)) &&
            (identical(other.points, points) || const DeepCollectionEquality().equals(other.points, points)) &&
            (identical(other.scope, scope) || const DeepCollectionEquality().equals(other.scope, scope)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(money) ^
      const DeepCollectionEquality().hash(points) ^
      const DeepCollectionEquality().hash(scope) ^
      runtimeType.hashCode;
}

extension $FactionBalance$FactionExtension on FactionBalance$Faction {
  FactionBalance$Faction copyWith({int? money, int? points, int? scope}) {
    return FactionBalance$Faction(
      money: money ?? this.money,
      points: points ?? this.points,
      scope: scope ?? this.scope,
    );
  }

  FactionBalance$Faction copyWithWrapped({
    Wrapped<int>? money,
    Wrapped<int>? points,
    Wrapped<int>? scope,
  }) {
    return FactionBalance$Faction(
      money: (money != null ? money.value : this.money),
      points: (points != null ? points.value : this.points),
      scope: (scope != null ? scope.value : this.scope),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionBalance$Members$Item {
  const FactionBalance$Members$Item({
    required this.id,
    required this.username,
    required this.money,
    required this.points,
  });

  factory FactionBalance$Members$Item.fromJson(Map<String, dynamic> json) =>
      _$FactionBalance$Members$ItemFromJson(json);

  static const toJsonFactory = _$FactionBalance$Members$ItemToJson;
  Map<String, dynamic> toJson() => _$FactionBalance$Members$ItemToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'username')
  final String username;
  @JsonKey(name: 'money')
  final int money;
  @JsonKey(name: 'points')
  final int points;
  static const fromJsonFactory = _$FactionBalance$Members$ItemFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionBalance$Members$Item &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.username, username) ||
                const DeepCollectionEquality().equals(
                  other.username,
                  username,
                )) &&
            (identical(other.money, money) || const DeepCollectionEquality().equals(other.money, money)) &&
            (identical(other.points, points) || const DeepCollectionEquality().equals(other.points, points)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(username) ^
      const DeepCollectionEquality().hash(money) ^
      const DeepCollectionEquality().hash(points) ^
      runtimeType.hashCode;
}

extension $FactionBalance$Members$ItemExtension on FactionBalance$Members$Item {
  FactionBalance$Members$Item copyWith({
    int? id,
    String? username,
    int? money,
    int? points,
  }) {
    return FactionBalance$Members$Item(
      id: id ?? this.id,
      username: username ?? this.username,
      money: money ?? this.money,
      points: points ?? this.points,
    );
  }

  FactionBalance$Members$Item copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<String>? username,
    Wrapped<int>? money,
    Wrapped<int>? points,
  }) {
    return FactionBalance$Members$Item(
      id: (id != null ? id.value : this.id),
      username: (username != null ? username.value : this.username),
      money: (money != null ? money.value : this.money),
      points: (points != null ? points.value : this.points),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionRankedWarDetails$Factions$Item {
  const FactionRankedWarDetails$Factions$Item({
    required this.id,
    required this.name,
    required this.score,
    required this.chain,
  });

  factory FactionRankedWarDetails$Factions$Item.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$FactionRankedWarDetails$Factions$ItemFromJson(json);

  static const toJsonFactory = _$FactionRankedWarDetails$Factions$ItemToJson;
  Map<String, dynamic> toJson() => _$FactionRankedWarDetails$Factions$ItemToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'score')
  final int score;
  @JsonKey(name: 'chain')
  final int chain;
  static const fromJsonFactory = _$FactionRankedWarDetails$Factions$ItemFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionRankedWarDetails$Factions$Item &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.score, score) || const DeepCollectionEquality().equals(other.score, score)) &&
            (identical(other.chain, chain) || const DeepCollectionEquality().equals(other.chain, chain)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(score) ^
      const DeepCollectionEquality().hash(chain) ^
      runtimeType.hashCode;
}

extension $FactionRankedWarDetails$Factions$ItemExtension on FactionRankedWarDetails$Factions$Item {
  FactionRankedWarDetails$Factions$Item copyWith({
    int? id,
    String? name,
    int? score,
    int? chain,
  }) {
    return FactionRankedWarDetails$Factions$Item(
      id: id ?? this.id,
      name: name ?? this.name,
      score: score ?? this.score,
      chain: chain ?? this.chain,
    );
  }

  FactionRankedWarDetails$Factions$Item copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<String>? name,
    Wrapped<int>? score,
    Wrapped<int>? chain,
  }) {
    return FactionRankedWarDetails$Factions$Item(
      id: (id != null ? id.value : this.id),
      name: (name != null ? name.value : this.name),
      score: (score != null ? score.value : this.score),
      chain: (chain != null ? chain.value : this.chain),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionRankedWarReportResponse$Rankedwarreport {
  const FactionRankedWarReportResponse$Rankedwarreport({
    required this.id,
    required this.start,
    required this.end,
    required this.winner,
    required this.forfeit,
    required this.factions,
  });

  factory FactionRankedWarReportResponse$Rankedwarreport.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$FactionRankedWarReportResponse$RankedwarreportFromJson(json);

  static const toJsonFactory = _$FactionRankedWarReportResponse$RankedwarreportToJson;
  Map<String, dynamic> toJson() => _$FactionRankedWarReportResponse$RankedwarreportToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'start')
  final int start;
  @JsonKey(name: 'end')
  final int end;
  @JsonKey(name: 'winner')
  final int winner;
  @JsonKey(name: 'forfeit')
  final bool forfeit;
  @JsonKey(name: 'factions')
  final List<FactionRankedWarReportResponse$Rankedwarreport$Factions$Item> factions;
  static const fromJsonFactory = _$FactionRankedWarReportResponse$RankedwarreportFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionRankedWarReportResponse$Rankedwarreport &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.start, start) || const DeepCollectionEquality().equals(other.start, start)) &&
            (identical(other.end, end) || const DeepCollectionEquality().equals(other.end, end)) &&
            (identical(other.winner, winner) || const DeepCollectionEquality().equals(other.winner, winner)) &&
            (identical(other.forfeit, forfeit) ||
                const DeepCollectionEquality().equals(
                  other.forfeit,
                  forfeit,
                )) &&
            (identical(other.factions, factions) ||
                const DeepCollectionEquality().equals(
                  other.factions,
                  factions,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(start) ^
      const DeepCollectionEquality().hash(end) ^
      const DeepCollectionEquality().hash(winner) ^
      const DeepCollectionEquality().hash(forfeit) ^
      const DeepCollectionEquality().hash(factions) ^
      runtimeType.hashCode;
}

extension $FactionRankedWarReportResponse$RankedwarreportExtension on FactionRankedWarReportResponse$Rankedwarreport {
  FactionRankedWarReportResponse$Rankedwarreport copyWith({
    int? id,
    int? start,
    int? end,
    int? winner,
    bool? forfeit,
    List<FactionRankedWarReportResponse$Rankedwarreport$Factions$Item>? factions,
  }) {
    return FactionRankedWarReportResponse$Rankedwarreport(
      id: id ?? this.id,
      start: start ?? this.start,
      end: end ?? this.end,
      winner: winner ?? this.winner,
      forfeit: forfeit ?? this.forfeit,
      factions: factions ?? this.factions,
    );
  }

  FactionRankedWarReportResponse$Rankedwarreport copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<int>? start,
    Wrapped<int>? end,
    Wrapped<int>? winner,
    Wrapped<bool>? forfeit,
    Wrapped<List<FactionRankedWarReportResponse$Rankedwarreport$Factions$Item>>? factions,
  }) {
    return FactionRankedWarReportResponse$Rankedwarreport(
      id: (id != null ? id.value : this.id),
      start: (start != null ? start.value : this.start),
      end: (end != null ? end.value : this.end),
      winner: (winner != null ? winner.value : this.winner),
      forfeit: (forfeit != null ? forfeit.value : this.forfeit),
      factions: (factions != null ? factions.value : this.factions),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ForumCategoriesResponse$Categories$Item {
  const ForumCategoriesResponse$Categories$Item({
    required this.id,
    required this.title,
    required this.acronym,
    required this.threads,
  });

  factory ForumCategoriesResponse$Categories$Item.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$ForumCategoriesResponse$Categories$ItemFromJson(json);

  static const toJsonFactory = _$ForumCategoriesResponse$Categories$ItemToJson;
  Map<String, dynamic> toJson() => _$ForumCategoriesResponse$Categories$ItemToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'title')
  final String title;
  @JsonKey(name: 'acronym')
  final String acronym;
  @JsonKey(name: 'threads')
  final int threads;
  static const fromJsonFactory = _$ForumCategoriesResponse$Categories$ItemFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ForumCategoriesResponse$Categories$Item &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.title, title) || const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.acronym, acronym) ||
                const DeepCollectionEquality().equals(
                  other.acronym,
                  acronym,
                )) &&
            (identical(other.threads, threads) || const DeepCollectionEquality().equals(other.threads, threads)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(acronym) ^
      const DeepCollectionEquality().hash(threads) ^
      runtimeType.hashCode;
}

extension $ForumCategoriesResponse$Categories$ItemExtension on ForumCategoriesResponse$Categories$Item {
  ForumCategoriesResponse$Categories$Item copyWith({
    int? id,
    String? title,
    String? acronym,
    int? threads,
  }) {
    return ForumCategoriesResponse$Categories$Item(
      id: id ?? this.id,
      title: title ?? this.title,
      acronym: acronym ?? this.acronym,
      threads: threads ?? this.threads,
    );
  }

  ForumCategoriesResponse$Categories$Item copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<String>? title,
    Wrapped<String>? acronym,
    Wrapped<int>? threads,
  }) {
    return ForumCategoriesResponse$Categories$Item(
      id: (id != null ? id.value : this.id),
      title: (title != null ? title.value : this.title),
      acronym: (acronym != null ? acronym.value : this.acronym),
      threads: (threads != null ? threads.value : this.threads),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class KeyLogResponse$Log$Item {
  const KeyLogResponse$Log$Item({
    required this.timestamp,
    required this.type,
    required this.selections,
    required this.id,
    this.comment,
    required this.ip,
  });

  factory KeyLogResponse$Log$Item.fromJson(Map<String, dynamic> json) => _$KeyLogResponse$Log$ItemFromJson(json);

  static const toJsonFactory = _$KeyLogResponse$Log$ItemToJson;
  Map<String, dynamic> toJson() => _$KeyLogResponse$Log$ItemToJson(this);

  @JsonKey(name: 'timestamp')
  final int timestamp;
  @JsonKey(name: 'type')
  final String type;
  @JsonKey(name: 'selections')
  final String selections;
  @JsonKey(name: 'id')
  final dynamic id;
  @JsonKey(name: 'comment')
  final dynamic comment;
  @JsonKey(name: 'ip')
  final String ip;
  static const fromJsonFactory = _$KeyLogResponse$Log$ItemFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is KeyLogResponse$Log$Item &&
            (identical(other.timestamp, timestamp) ||
                const DeepCollectionEquality().equals(
                  other.timestamp,
                  timestamp,
                )) &&
            (identical(other.type, type) || const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.selections, selections) ||
                const DeepCollectionEquality().equals(
                  other.selections,
                  selections,
                )) &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.comment, comment) ||
                const DeepCollectionEquality().equals(
                  other.comment,
                  comment,
                )) &&
            (identical(other.ip, ip) || const DeepCollectionEquality().equals(other.ip, ip)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(timestamp) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(selections) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(comment) ^
      const DeepCollectionEquality().hash(ip) ^
      runtimeType.hashCode;
}

extension $KeyLogResponse$Log$ItemExtension on KeyLogResponse$Log$Item {
  KeyLogResponse$Log$Item copyWith({
    int? timestamp,
    String? type,
    String? selections,
    dynamic id,
    dynamic comment,
    String? ip,
  }) {
    return KeyLogResponse$Log$Item(
      timestamp: timestamp ?? this.timestamp,
      type: type ?? this.type,
      selections: selections ?? this.selections,
      id: id ?? this.id,
      comment: comment ?? this.comment,
      ip: ip ?? this.ip,
    );
  }

  KeyLogResponse$Log$Item copyWithWrapped({
    Wrapped<int>? timestamp,
    Wrapped<String>? type,
    Wrapped<String>? selections,
    Wrapped<dynamic>? id,
    Wrapped<dynamic>? comment,
    Wrapped<String>? ip,
  }) {
    return KeyLogResponse$Log$Item(
      timestamp: (timestamp != null ? timestamp.value : this.timestamp),
      type: (type != null ? type.value : this.type),
      selections: (selections != null ? selections.value : this.selections),
      id: (id != null ? id.value : this.id),
      comment: (comment != null ? comment.value : this.comment),
      ip: (ip != null ? ip.value : this.ip),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class KeyInfoResponse$Info {
  const KeyInfoResponse$Info({required this.selections, required this.access});

  factory KeyInfoResponse$Info.fromJson(Map<String, dynamic> json) => _$KeyInfoResponse$InfoFromJson(json);

  static const toJsonFactory = _$KeyInfoResponse$InfoToJson;
  Map<String, dynamic> toJson() => _$KeyInfoResponse$InfoToJson(this);

  @JsonKey(name: 'selections')
  final KeyInfoResponse$Info$Selections selections;
  @JsonKey(name: 'access')
  final KeyInfoResponse$Info$Access access;
  static const fromJsonFactory = _$KeyInfoResponse$InfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is KeyInfoResponse$Info &&
            (identical(other.selections, selections) ||
                const DeepCollectionEquality().equals(
                  other.selections,
                  selections,
                )) &&
            (identical(other.access, access) || const DeepCollectionEquality().equals(other.access, access)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(selections) ^
      const DeepCollectionEquality().hash(access) ^
      runtimeType.hashCode;
}

extension $KeyInfoResponse$InfoExtension on KeyInfoResponse$Info {
  KeyInfoResponse$Info copyWith({
    KeyInfoResponse$Info$Selections? selections,
    KeyInfoResponse$Info$Access? access,
  }) {
    return KeyInfoResponse$Info(
      selections: selections ?? this.selections,
      access: access ?? this.access,
    );
  }

  KeyInfoResponse$Info copyWithWrapped({
    Wrapped<KeyInfoResponse$Info$Selections>? selections,
    Wrapped<KeyInfoResponse$Info$Access>? access,
  }) {
    return KeyInfoResponse$Info(
      selections: (selections != null ? selections.value : this.selections),
      access: (access != null ? access.value : this.access),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class MarketRentalDetails$Listings$Item {
  const MarketRentalDetails$Listings$Item({
    required this.happy,
    required this.cost,
    required this.costPerDay,
    required this.rentalPeriod,
    required this.marketPrice,
    required this.upkeep,
    required this.modifications,
  });

  factory MarketRentalDetails$Listings$Item.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$MarketRentalDetails$Listings$ItemFromJson(json);

  static const toJsonFactory = _$MarketRentalDetails$Listings$ItemToJson;
  Map<String, dynamic> toJson() => _$MarketRentalDetails$Listings$ItemToJson(this);

  @JsonKey(name: 'happy')
  final int happy;
  @JsonKey(name: 'cost')
  final int cost;
  @JsonKey(name: 'cost_per_day')
  final int costPerDay;
  @JsonKey(name: 'rental_period')
  final int rentalPeriod;
  @JsonKey(name: 'market_price')
  final int marketPrice;
  @JsonKey(name: 'upkeep')
  final int upkeep;
  @JsonKey(name: 'modifications', defaultValue: <Object>[])
  final List<Object> modifications;
  static const fromJsonFactory = _$MarketRentalDetails$Listings$ItemFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is MarketRentalDetails$Listings$Item &&
            (identical(other.happy, happy) || const DeepCollectionEquality().equals(other.happy, happy)) &&
            (identical(other.cost, cost) || const DeepCollectionEquality().equals(other.cost, cost)) &&
            (identical(other.costPerDay, costPerDay) ||
                const DeepCollectionEquality().equals(
                  other.costPerDay,
                  costPerDay,
                )) &&
            (identical(other.rentalPeriod, rentalPeriod) ||
                const DeepCollectionEquality().equals(
                  other.rentalPeriod,
                  rentalPeriod,
                )) &&
            (identical(other.marketPrice, marketPrice) ||
                const DeepCollectionEquality().equals(
                  other.marketPrice,
                  marketPrice,
                )) &&
            (identical(other.upkeep, upkeep) || const DeepCollectionEquality().equals(other.upkeep, upkeep)) &&
            (identical(other.modifications, modifications) ||
                const DeepCollectionEquality().equals(
                  other.modifications,
                  modifications,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(happy) ^
      const DeepCollectionEquality().hash(cost) ^
      const DeepCollectionEquality().hash(costPerDay) ^
      const DeepCollectionEquality().hash(rentalPeriod) ^
      const DeepCollectionEquality().hash(marketPrice) ^
      const DeepCollectionEquality().hash(upkeep) ^
      const DeepCollectionEquality().hash(modifications) ^
      runtimeType.hashCode;
}

extension $MarketRentalDetails$Listings$ItemExtension on MarketRentalDetails$Listings$Item {
  MarketRentalDetails$Listings$Item copyWith({
    int? happy,
    int? cost,
    int? costPerDay,
    int? rentalPeriod,
    int? marketPrice,
    int? upkeep,
    List<Object>? modifications,
  }) {
    return MarketRentalDetails$Listings$Item(
      happy: happy ?? this.happy,
      cost: cost ?? this.cost,
      costPerDay: costPerDay ?? this.costPerDay,
      rentalPeriod: rentalPeriod ?? this.rentalPeriod,
      marketPrice: marketPrice ?? this.marketPrice,
      upkeep: upkeep ?? this.upkeep,
      modifications: modifications ?? this.modifications,
    );
  }

  MarketRentalDetails$Listings$Item copyWithWrapped({
    Wrapped<int>? happy,
    Wrapped<int>? cost,
    Wrapped<int>? costPerDay,
    Wrapped<int>? rentalPeriod,
    Wrapped<int>? marketPrice,
    Wrapped<int>? upkeep,
    Wrapped<List<Object>>? modifications,
  }) {
    return MarketRentalDetails$Listings$Item(
      happy: (happy != null ? happy.value : this.happy),
      cost: (cost != null ? cost.value : this.cost),
      costPerDay: (costPerDay != null ? costPerDay.value : this.costPerDay),
      rentalPeriod: (rentalPeriod != null ? rentalPeriod.value : this.rentalPeriod),
      marketPrice: (marketPrice != null ? marketPrice.value : this.marketPrice),
      upkeep: (upkeep != null ? upkeep.value : this.upkeep),
      modifications: (modifications != null ? modifications.value : this.modifications),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class MarketPropertyDetails$Listings$Item {
  const MarketPropertyDetails$Listings$Item({
    required this.happy,
    required this.cost,
    required this.marketPrice,
    required this.upkeep,
    required this.modifications,
  });

  factory MarketPropertyDetails$Listings$Item.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$MarketPropertyDetails$Listings$ItemFromJson(json);

  static const toJsonFactory = _$MarketPropertyDetails$Listings$ItemToJson;
  Map<String, dynamic> toJson() => _$MarketPropertyDetails$Listings$ItemToJson(this);

  @JsonKey(name: 'happy')
  final int happy;
  @JsonKey(name: 'cost')
  final int cost;
  @JsonKey(name: 'market_price')
  final int marketPrice;
  @JsonKey(name: 'upkeep')
  final int upkeep;
  @JsonKey(name: 'modifications', defaultValue: <Object>[])
  final List<Object> modifications;
  static const fromJsonFactory = _$MarketPropertyDetails$Listings$ItemFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is MarketPropertyDetails$Listings$Item &&
            (identical(other.happy, happy) || const DeepCollectionEquality().equals(other.happy, happy)) &&
            (identical(other.cost, cost) || const DeepCollectionEquality().equals(other.cost, cost)) &&
            (identical(other.marketPrice, marketPrice) ||
                const DeepCollectionEquality().equals(
                  other.marketPrice,
                  marketPrice,
                )) &&
            (identical(other.upkeep, upkeep) || const DeepCollectionEquality().equals(other.upkeep, upkeep)) &&
            (identical(other.modifications, modifications) ||
                const DeepCollectionEquality().equals(
                  other.modifications,
                  modifications,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(happy) ^
      const DeepCollectionEquality().hash(cost) ^
      const DeepCollectionEquality().hash(marketPrice) ^
      const DeepCollectionEquality().hash(upkeep) ^
      const DeepCollectionEquality().hash(modifications) ^
      runtimeType.hashCode;
}

extension $MarketPropertyDetails$Listings$ItemExtension on MarketPropertyDetails$Listings$Item {
  MarketPropertyDetails$Listings$Item copyWith({
    int? happy,
    int? cost,
    int? marketPrice,
    int? upkeep,
    List<Object>? modifications,
  }) {
    return MarketPropertyDetails$Listings$Item(
      happy: happy ?? this.happy,
      cost: cost ?? this.cost,
      marketPrice: marketPrice ?? this.marketPrice,
      upkeep: upkeep ?? this.upkeep,
      modifications: modifications ?? this.modifications,
    );
  }

  MarketPropertyDetails$Listings$Item copyWithWrapped({
    Wrapped<int>? happy,
    Wrapped<int>? cost,
    Wrapped<int>? marketPrice,
    Wrapped<int>? upkeep,
    Wrapped<List<Object>>? modifications,
  }) {
    return MarketPropertyDetails$Listings$Item(
      happy: (happy != null ? happy.value : this.happy),
      cost: (cost != null ? cost.value : this.cost),
      marketPrice: (marketPrice != null ? marketPrice.value : this.marketPrice),
      upkeep: (upkeep != null ? upkeep.value : this.upkeep),
      modifications: (modifications != null ? modifications.value : this.modifications),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserRacingRecordsResponse$Racingrecords$Item {
  const UserRacingRecordsResponse$Racingrecords$Item({
    required this.track,
    required this.records,
  });

  factory UserRacingRecordsResponse$Racingrecords$Item.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$UserRacingRecordsResponse$Racingrecords$ItemFromJson(json);

  static const toJsonFactory = _$UserRacingRecordsResponse$Racingrecords$ItemToJson;
  Map<String, dynamic> toJson() => _$UserRacingRecordsResponse$Racingrecords$ItemToJson(this);

  @JsonKey(name: 'track')
  final UserRacingRecordsResponse$Racingrecords$Item$Track track;
  @JsonKey(name: 'records')
  final List<UserRacingRecordsResponse$Racingrecords$Item$Records$Item> records;
  static const fromJsonFactory = _$UserRacingRecordsResponse$Racingrecords$ItemFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserRacingRecordsResponse$Racingrecords$Item &&
            (identical(other.track, track) || const DeepCollectionEquality().equals(other.track, track)) &&
            (identical(other.records, records) || const DeepCollectionEquality().equals(other.records, records)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(track) ^ const DeepCollectionEquality().hash(records) ^ runtimeType.hashCode;
}

extension $UserRacingRecordsResponse$Racingrecords$ItemExtension on UserRacingRecordsResponse$Racingrecords$Item {
  UserRacingRecordsResponse$Racingrecords$Item copyWith({
    UserRacingRecordsResponse$Racingrecords$Item$Track? track,
    List<UserRacingRecordsResponse$Racingrecords$Item$Records$Item>? records,
  }) {
    return UserRacingRecordsResponse$Racingrecords$Item(
      track: track ?? this.track,
      records: records ?? this.records,
    );
  }

  UserRacingRecordsResponse$Racingrecords$Item copyWithWrapped({
    Wrapped<UserRacingRecordsResponse$Racingrecords$Item$Track>? track,
    Wrapped<List<UserRacingRecordsResponse$Racingrecords$Item$Records$Item>>? records,
  }) {
    return UserRacingRecordsResponse$Racingrecords$Item(
      track: (track != null ? track.value : this.track),
      records: (records != null ? records.value : this.records),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class RaceCarUpgrade$Effects {
  const RaceCarUpgrade$Effects({
    required this.topSpeed,
    required this.acceleration,
    required this.braking,
    required this.handling,
    required this.safety,
    required this.dirt,
    required this.tarmac,
  });

  factory RaceCarUpgrade$Effects.fromJson(Map<String, dynamic> json) => _$RaceCarUpgrade$EffectsFromJson(json);

  static const toJsonFactory = _$RaceCarUpgrade$EffectsToJson;
  Map<String, dynamic> toJson() => _$RaceCarUpgrade$EffectsToJson(this);

  @JsonKey(name: 'top_speed')
  final int topSpeed;
  @JsonKey(name: 'acceleration')
  final int acceleration;
  @JsonKey(name: 'braking')
  final int braking;
  @JsonKey(name: 'handling')
  final int handling;
  @JsonKey(name: 'safety')
  final int safety;
  @JsonKey(name: 'dirt')
  final int dirt;
  @JsonKey(name: 'tarmac')
  final int tarmac;
  static const fromJsonFactory = _$RaceCarUpgrade$EffectsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RaceCarUpgrade$Effects &&
            (identical(other.topSpeed, topSpeed) ||
                const DeepCollectionEquality().equals(
                  other.topSpeed,
                  topSpeed,
                )) &&
            (identical(other.acceleration, acceleration) ||
                const DeepCollectionEquality().equals(
                  other.acceleration,
                  acceleration,
                )) &&
            (identical(other.braking, braking) ||
                const DeepCollectionEquality().equals(
                  other.braking,
                  braking,
                )) &&
            (identical(other.handling, handling) ||
                const DeepCollectionEquality().equals(
                  other.handling,
                  handling,
                )) &&
            (identical(other.safety, safety) || const DeepCollectionEquality().equals(other.safety, safety)) &&
            (identical(other.dirt, dirt) || const DeepCollectionEquality().equals(other.dirt, dirt)) &&
            (identical(other.tarmac, tarmac) || const DeepCollectionEquality().equals(other.tarmac, tarmac)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(topSpeed) ^
      const DeepCollectionEquality().hash(acceleration) ^
      const DeepCollectionEquality().hash(braking) ^
      const DeepCollectionEquality().hash(handling) ^
      const DeepCollectionEquality().hash(safety) ^
      const DeepCollectionEquality().hash(dirt) ^
      const DeepCollectionEquality().hash(tarmac) ^
      runtimeType.hashCode;
}

extension $RaceCarUpgrade$EffectsExtension on RaceCarUpgrade$Effects {
  RaceCarUpgrade$Effects copyWith({
    int? topSpeed,
    int? acceleration,
    int? braking,
    int? handling,
    int? safety,
    int? dirt,
    int? tarmac,
  }) {
    return RaceCarUpgrade$Effects(
      topSpeed: topSpeed ?? this.topSpeed,
      acceleration: acceleration ?? this.acceleration,
      braking: braking ?? this.braking,
      handling: handling ?? this.handling,
      safety: safety ?? this.safety,
      dirt: dirt ?? this.dirt,
      tarmac: tarmac ?? this.tarmac,
    );
  }

  RaceCarUpgrade$Effects copyWithWrapped({
    Wrapped<int>? topSpeed,
    Wrapped<int>? acceleration,
    Wrapped<int>? braking,
    Wrapped<int>? handling,
    Wrapped<int>? safety,
    Wrapped<int>? dirt,
    Wrapped<int>? tarmac,
  }) {
    return RaceCarUpgrade$Effects(
      topSpeed: (topSpeed != null ? topSpeed.value : this.topSpeed),
      acceleration: (acceleration != null ? acceleration.value : this.acceleration),
      braking: (braking != null ? braking.value : this.braking),
      handling: (handling != null ? handling.value : this.handling),
      safety: (safety != null ? safety.value : this.safety),
      dirt: (dirt != null ? dirt.value : this.dirt),
      tarmac: (tarmac != null ? tarmac.value : this.tarmac),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class RaceCarUpgrade$Cost {
  const RaceCarUpgrade$Cost({required this.points, required this.cash});

  factory RaceCarUpgrade$Cost.fromJson(Map<String, dynamic> json) => _$RaceCarUpgrade$CostFromJson(json);

  static const toJsonFactory = _$RaceCarUpgrade$CostToJson;
  Map<String, dynamic> toJson() => _$RaceCarUpgrade$CostToJson(this);

  @JsonKey(name: 'points')
  final int points;
  @JsonKey(name: 'cash')
  final int cash;
  static const fromJsonFactory = _$RaceCarUpgrade$CostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RaceCarUpgrade$Cost &&
            (identical(other.points, points) || const DeepCollectionEquality().equals(other.points, points)) &&
            (identical(other.cash, cash) || const DeepCollectionEquality().equals(other.cash, cash)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(points) ^ const DeepCollectionEquality().hash(cash) ^ runtimeType.hashCode;
}

extension $RaceCarUpgrade$CostExtension on RaceCarUpgrade$Cost {
  RaceCarUpgrade$Cost copyWith({int? points, int? cash}) {
    return RaceCarUpgrade$Cost(
      points: points ?? this.points,
      cash: cash ?? this.cash,
    );
  }

  RaceCarUpgrade$Cost copyWithWrapped({
    Wrapped<int>? points,
    Wrapped<int>? cash,
  }) {
    return RaceCarUpgrade$Cost(
      points: (points != null ? points.value : this.points),
      cash: (cash != null ? cash.value : this.cash),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class Race$Participants {
  const Race$Participants({
    required this.minimum,
    required this.maximum,
    required this.current,
  });

  factory Race$Participants.fromJson(Map<String, dynamic> json) => _$Race$ParticipantsFromJson(json);

  static const toJsonFactory = _$Race$ParticipantsToJson;
  Map<String, dynamic> toJson() => _$Race$ParticipantsToJson(this);

  @JsonKey(name: 'minimum')
  final int minimum;
  @JsonKey(name: 'maximum')
  final int maximum;
  @JsonKey(name: 'current')
  final int current;
  static const fromJsonFactory = _$Race$ParticipantsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Race$Participants &&
            (identical(other.minimum, minimum) ||
                const DeepCollectionEquality().equals(
                  other.minimum,
                  minimum,
                )) &&
            (identical(other.maximum, maximum) ||
                const DeepCollectionEquality().equals(
                  other.maximum,
                  maximum,
                )) &&
            (identical(other.current, current) || const DeepCollectionEquality().equals(other.current, current)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(minimum) ^
      const DeepCollectionEquality().hash(maximum) ^
      const DeepCollectionEquality().hash(current) ^
      runtimeType.hashCode;
}

extension $Race$ParticipantsExtension on Race$Participants {
  Race$Participants copyWith({int? minimum, int? maximum, int? current}) {
    return Race$Participants(
      minimum: minimum ?? this.minimum,
      maximum: maximum ?? this.maximum,
      current: current ?? this.current,
    );
  }

  Race$Participants copyWithWrapped({
    Wrapped<int>? minimum,
    Wrapped<int>? maximum,
    Wrapped<int>? current,
  }) {
    return Race$Participants(
      minimum: (minimum != null ? minimum.value : this.minimum),
      maximum: (maximum != null ? maximum.value : this.maximum),
      current: (current != null ? current.value : this.current),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class Race$Schedule {
  const Race$Schedule({
    required this.joinFrom,
    required this.joinUntil,
    required this.start,
    required this.end,
  });

  factory Race$Schedule.fromJson(Map<String, dynamic> json) => _$Race$ScheduleFromJson(json);

  static const toJsonFactory = _$Race$ScheduleToJson;
  Map<String, dynamic> toJson() => _$Race$ScheduleToJson(this);

  @JsonKey(name: 'join_from')
  final int joinFrom;
  @JsonKey(name: 'join_until')
  final int joinUntil;
  @JsonKey(name: 'start')
  final int start;
  @JsonKey(name: 'end')
  final dynamic end;
  static const fromJsonFactory = _$Race$ScheduleFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Race$Schedule &&
            (identical(other.joinFrom, joinFrom) ||
                const DeepCollectionEquality().equals(
                  other.joinFrom,
                  joinFrom,
                )) &&
            (identical(other.joinUntil, joinUntil) ||
                const DeepCollectionEquality().equals(
                  other.joinUntil,
                  joinUntil,
                )) &&
            (identical(other.start, start) || const DeepCollectionEquality().equals(other.start, start)) &&
            (identical(other.end, end) || const DeepCollectionEquality().equals(other.end, end)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(joinFrom) ^
      const DeepCollectionEquality().hash(joinUntil) ^
      const DeepCollectionEquality().hash(start) ^
      const DeepCollectionEquality().hash(end) ^
      runtimeType.hashCode;
}

extension $Race$ScheduleExtension on Race$Schedule {
  Race$Schedule copyWith({
    int? joinFrom,
    int? joinUntil,
    int? start,
    dynamic end,
  }) {
    return Race$Schedule(
      joinFrom: joinFrom ?? this.joinFrom,
      joinUntil: joinUntil ?? this.joinUntil,
      start: start ?? this.start,
      end: end ?? this.end,
    );
  }

  Race$Schedule copyWithWrapped({
    Wrapped<int>? joinFrom,
    Wrapped<int>? joinUntil,
    Wrapped<int>? start,
    Wrapped<dynamic>? end,
  }) {
    return Race$Schedule(
      joinFrom: (joinFrom != null ? joinFrom.value : this.joinFrom),
      joinUntil: (joinUntil != null ? joinUntil.value : this.joinUntil),
      start: (start != null ? start.value : this.start),
      end: (end != null ? end.value : this.end),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class Race$Requirements {
  const Race$Requirements({
    required this.carClass,
    required this.driverClass,
    required this.carItemId,
    required this.requiresStockCar,
    required this.requiresPassword,
    required this.joinFee,
  });

  factory Race$Requirements.fromJson(Map<String, dynamic> json) => _$Race$RequirementsFromJson(json);

  static const toJsonFactory = _$Race$RequirementsToJson;
  Map<String, dynamic> toJson() => _$Race$RequirementsToJson(this);

  @JsonKey(name: 'car_class')
  final dynamic carClass;
  @JsonKey(name: 'driver_class')
  final dynamic driverClass;
  @JsonKey(name: 'car_item_id')
  final dynamic carItemId;
  @JsonKey(name: 'requires_stock_car')
  final bool requiresStockCar;
  @JsonKey(name: 'requires_password')
  final bool requiresPassword;
  @JsonKey(name: 'join_fee')
  final int joinFee;
  static const fromJsonFactory = _$Race$RequirementsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Race$Requirements &&
            (identical(other.carClass, carClass) ||
                const DeepCollectionEquality().equals(
                  other.carClass,
                  carClass,
                )) &&
            (identical(other.driverClass, driverClass) ||
                const DeepCollectionEquality().equals(
                  other.driverClass,
                  driverClass,
                )) &&
            (identical(other.carItemId, carItemId) ||
                const DeepCollectionEquality().equals(
                  other.carItemId,
                  carItemId,
                )) &&
            (identical(other.requiresStockCar, requiresStockCar) ||
                const DeepCollectionEquality().equals(
                  other.requiresStockCar,
                  requiresStockCar,
                )) &&
            (identical(other.requiresPassword, requiresPassword) ||
                const DeepCollectionEquality().equals(
                  other.requiresPassword,
                  requiresPassword,
                )) &&
            (identical(other.joinFee, joinFee) || const DeepCollectionEquality().equals(other.joinFee, joinFee)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(carClass) ^
      const DeepCollectionEquality().hash(driverClass) ^
      const DeepCollectionEquality().hash(carItemId) ^
      const DeepCollectionEquality().hash(requiresStockCar) ^
      const DeepCollectionEquality().hash(requiresPassword) ^
      const DeepCollectionEquality().hash(joinFee) ^
      runtimeType.hashCode;
}

extension $Race$RequirementsExtension on Race$Requirements {
  Race$Requirements copyWith({
    dynamic carClass,
    dynamic driverClass,
    dynamic carItemId,
    bool? requiresStockCar,
    bool? requiresPassword,
    int? joinFee,
  }) {
    return Race$Requirements(
      carClass: carClass ?? this.carClass,
      driverClass: driverClass ?? this.driverClass,
      carItemId: carItemId ?? this.carItemId,
      requiresStockCar: requiresStockCar ?? this.requiresStockCar,
      requiresPassword: requiresPassword ?? this.requiresPassword,
      joinFee: joinFee ?? this.joinFee,
    );
  }

  Race$Requirements copyWithWrapped({
    Wrapped<dynamic>? carClass,
    Wrapped<dynamic>? driverClass,
    Wrapped<dynamic>? carItemId,
    Wrapped<bool>? requiresStockCar,
    Wrapped<bool>? requiresPassword,
    Wrapped<int>? joinFee,
  }) {
    return Race$Requirements(
      carClass: (carClass != null ? carClass.value : this.carClass),
      driverClass: (driverClass != null ? driverClass.value : this.driverClass),
      carItemId: (carItemId != null ? carItemId.value : this.carItemId),
      requiresStockCar: (requiresStockCar != null ? requiresStockCar.value : this.requiresStockCar),
      requiresPassword: (requiresPassword != null ? requiresPassword.value : this.requiresPassword),
      joinFee: (joinFee != null ? joinFee.value : this.joinFee),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class RacingRaceDetails$Participants {
  const RacingRaceDetails$Participants({
    required this.minimum,
    required this.maximum,
    required this.current,
  });

  factory RacingRaceDetails$Participants.fromJson(Map<String, dynamic> json) =>
      _$RacingRaceDetails$ParticipantsFromJson(json);

  static const toJsonFactory = _$RacingRaceDetails$ParticipantsToJson;
  Map<String, dynamic> toJson() => _$RacingRaceDetails$ParticipantsToJson(this);

  @JsonKey(name: 'minimum')
  final int minimum;
  @JsonKey(name: 'maximum')
  final int maximum;
  @JsonKey(name: 'current')
  final int current;
  static const fromJsonFactory = _$RacingRaceDetails$ParticipantsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RacingRaceDetails$Participants &&
            (identical(other.minimum, minimum) ||
                const DeepCollectionEquality().equals(
                  other.minimum,
                  minimum,
                )) &&
            (identical(other.maximum, maximum) ||
                const DeepCollectionEquality().equals(
                  other.maximum,
                  maximum,
                )) &&
            (identical(other.current, current) || const DeepCollectionEquality().equals(other.current, current)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(minimum) ^
      const DeepCollectionEquality().hash(maximum) ^
      const DeepCollectionEquality().hash(current) ^
      runtimeType.hashCode;
}

extension $RacingRaceDetails$ParticipantsExtension on RacingRaceDetails$Participants {
  RacingRaceDetails$Participants copyWith({
    int? minimum,
    int? maximum,
    int? current,
  }) {
    return RacingRaceDetails$Participants(
      minimum: minimum ?? this.minimum,
      maximum: maximum ?? this.maximum,
      current: current ?? this.current,
    );
  }

  RacingRaceDetails$Participants copyWithWrapped({
    Wrapped<int>? minimum,
    Wrapped<int>? maximum,
    Wrapped<int>? current,
  }) {
    return RacingRaceDetails$Participants(
      minimum: (minimum != null ? minimum.value : this.minimum),
      maximum: (maximum != null ? maximum.value : this.maximum),
      current: (current != null ? current.value : this.current),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class RacingRaceDetails$Schedule {
  const RacingRaceDetails$Schedule({
    required this.joinFrom,
    required this.joinUntil,
    required this.start,
    required this.end,
  });

  factory RacingRaceDetails$Schedule.fromJson(Map<String, dynamic> json) => _$RacingRaceDetails$ScheduleFromJson(json);

  static const toJsonFactory = _$RacingRaceDetails$ScheduleToJson;
  Map<String, dynamic> toJson() => _$RacingRaceDetails$ScheduleToJson(this);

  @JsonKey(name: 'join_from')
  final int joinFrom;
  @JsonKey(name: 'join_until')
  final int joinUntil;
  @JsonKey(name: 'start')
  final int start;
  @JsonKey(name: 'end')
  final dynamic end;
  static const fromJsonFactory = _$RacingRaceDetails$ScheduleFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RacingRaceDetails$Schedule &&
            (identical(other.joinFrom, joinFrom) ||
                const DeepCollectionEquality().equals(
                  other.joinFrom,
                  joinFrom,
                )) &&
            (identical(other.joinUntil, joinUntil) ||
                const DeepCollectionEquality().equals(
                  other.joinUntil,
                  joinUntil,
                )) &&
            (identical(other.start, start) || const DeepCollectionEquality().equals(other.start, start)) &&
            (identical(other.end, end) || const DeepCollectionEquality().equals(other.end, end)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(joinFrom) ^
      const DeepCollectionEquality().hash(joinUntil) ^
      const DeepCollectionEquality().hash(start) ^
      const DeepCollectionEquality().hash(end) ^
      runtimeType.hashCode;
}

extension $RacingRaceDetails$ScheduleExtension on RacingRaceDetails$Schedule {
  RacingRaceDetails$Schedule copyWith({
    int? joinFrom,
    int? joinUntil,
    int? start,
    dynamic end,
  }) {
    return RacingRaceDetails$Schedule(
      joinFrom: joinFrom ?? this.joinFrom,
      joinUntil: joinUntil ?? this.joinUntil,
      start: start ?? this.start,
      end: end ?? this.end,
    );
  }

  RacingRaceDetails$Schedule copyWithWrapped({
    Wrapped<int>? joinFrom,
    Wrapped<int>? joinUntil,
    Wrapped<int>? start,
    Wrapped<dynamic>? end,
  }) {
    return RacingRaceDetails$Schedule(
      joinFrom: (joinFrom != null ? joinFrom.value : this.joinFrom),
      joinUntil: (joinUntil != null ? joinUntil.value : this.joinUntil),
      start: (start != null ? start.value : this.start),
      end: (end != null ? end.value : this.end),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class RacingRaceDetails$Requirements {
  const RacingRaceDetails$Requirements({
    required this.carClass,
    required this.driverClass,
    required this.carItemId,
    required this.requiresStockCar,
    required this.requiresPassword,
    required this.joinFee,
  });

  factory RacingRaceDetails$Requirements.fromJson(Map<String, dynamic> json) =>
      _$RacingRaceDetails$RequirementsFromJson(json);

  static const toJsonFactory = _$RacingRaceDetails$RequirementsToJson;
  Map<String, dynamic> toJson() => _$RacingRaceDetails$RequirementsToJson(this);

  @JsonKey(name: 'car_class')
  final dynamic carClass;
  @JsonKey(name: 'driver_class')
  final dynamic driverClass;
  @JsonKey(name: 'car_item_id')
  final dynamic carItemId;
  @JsonKey(name: 'requires_stock_car')
  final bool requiresStockCar;
  @JsonKey(name: 'requires_password')
  final bool requiresPassword;
  @JsonKey(name: 'join_fee')
  final int joinFee;
  static const fromJsonFactory = _$RacingRaceDetails$RequirementsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RacingRaceDetails$Requirements &&
            (identical(other.carClass, carClass) ||
                const DeepCollectionEquality().equals(
                  other.carClass,
                  carClass,
                )) &&
            (identical(other.driverClass, driverClass) ||
                const DeepCollectionEquality().equals(
                  other.driverClass,
                  driverClass,
                )) &&
            (identical(other.carItemId, carItemId) ||
                const DeepCollectionEquality().equals(
                  other.carItemId,
                  carItemId,
                )) &&
            (identical(other.requiresStockCar, requiresStockCar) ||
                const DeepCollectionEquality().equals(
                  other.requiresStockCar,
                  requiresStockCar,
                )) &&
            (identical(other.requiresPassword, requiresPassword) ||
                const DeepCollectionEquality().equals(
                  other.requiresPassword,
                  requiresPassword,
                )) &&
            (identical(other.joinFee, joinFee) || const DeepCollectionEquality().equals(other.joinFee, joinFee)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(carClass) ^
      const DeepCollectionEquality().hash(driverClass) ^
      const DeepCollectionEquality().hash(carItemId) ^
      const DeepCollectionEquality().hash(requiresStockCar) ^
      const DeepCollectionEquality().hash(requiresPassword) ^
      const DeepCollectionEquality().hash(joinFee) ^
      runtimeType.hashCode;
}

extension $RacingRaceDetails$RequirementsExtension on RacingRaceDetails$Requirements {
  RacingRaceDetails$Requirements copyWith({
    dynamic carClass,
    dynamic driverClass,
    dynamic carItemId,
    bool? requiresStockCar,
    bool? requiresPassword,
    int? joinFee,
  }) {
    return RacingRaceDetails$Requirements(
      carClass: carClass ?? this.carClass,
      driverClass: driverClass ?? this.driverClass,
      carItemId: carItemId ?? this.carItemId,
      requiresStockCar: requiresStockCar ?? this.requiresStockCar,
      requiresPassword: requiresPassword ?? this.requiresPassword,
      joinFee: joinFee ?? this.joinFee,
    );
  }

  RacingRaceDetails$Requirements copyWithWrapped({
    Wrapped<dynamic>? carClass,
    Wrapped<dynamic>? driverClass,
    Wrapped<dynamic>? carItemId,
    Wrapped<bool>? requiresStockCar,
    Wrapped<bool>? requiresPassword,
    Wrapped<int>? joinFee,
  }) {
    return RacingRaceDetails$Requirements(
      carClass: (carClass != null ? carClass.value : this.carClass),
      driverClass: (driverClass != null ? driverClass.value : this.driverClass),
      carItemId: (carItemId != null ? carItemId.value : this.carItemId),
      requiresStockCar: (requiresStockCar != null ? requiresStockCar.value : this.requiresStockCar),
      requiresPassword: (requiresPassword != null ? requiresPassword.value : this.requiresPassword),
      joinFee: (joinFee != null ? joinFee.value : this.joinFee),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TornProperties$Properties$Item {
  const TornProperties$Properties$Item({
    required this.id,
    required this.name,
    required this.cost,
    required this.happy,
    required this.upkeep,
    required this.modifications,
    required this.staff,
  });

  factory TornProperties$Properties$Item.fromJson(Map<String, dynamic> json) =>
      _$TornProperties$Properties$ItemFromJson(json);

  static const toJsonFactory = _$TornProperties$Properties$ItemToJson;
  Map<String, dynamic> toJson() => _$TornProperties$Properties$ItemToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'cost')
  final int cost;
  @JsonKey(name: 'happy')
  final int happy;
  @JsonKey(name: 'upkeep')
  final int upkeep;
  @JsonKey(name: 'modifications', defaultValue: <Object>[])
  final List<Object> modifications;
  @JsonKey(name: 'staff', defaultValue: <Object>[])
  final List<Object> staff;
  static const fromJsonFactory = _$TornProperties$Properties$ItemFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TornProperties$Properties$Item &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.cost, cost) || const DeepCollectionEquality().equals(other.cost, cost)) &&
            (identical(other.happy, happy) || const DeepCollectionEquality().equals(other.happy, happy)) &&
            (identical(other.upkeep, upkeep) || const DeepCollectionEquality().equals(other.upkeep, upkeep)) &&
            (identical(other.modifications, modifications) ||
                const DeepCollectionEquality().equals(
                  other.modifications,
                  modifications,
                )) &&
            (identical(other.staff, staff) || const DeepCollectionEquality().equals(other.staff, staff)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(cost) ^
      const DeepCollectionEquality().hash(happy) ^
      const DeepCollectionEquality().hash(upkeep) ^
      const DeepCollectionEquality().hash(modifications) ^
      const DeepCollectionEquality().hash(staff) ^
      runtimeType.hashCode;
}

extension $TornProperties$Properties$ItemExtension on TornProperties$Properties$Item {
  TornProperties$Properties$Item copyWith({
    int? id,
    String? name,
    int? cost,
    int? happy,
    int? upkeep,
    List<Object>? modifications,
    List<Object>? staff,
  }) {
    return TornProperties$Properties$Item(
      id: id ?? this.id,
      name: name ?? this.name,
      cost: cost ?? this.cost,
      happy: happy ?? this.happy,
      upkeep: upkeep ?? this.upkeep,
      modifications: modifications ?? this.modifications,
      staff: staff ?? this.staff,
    );
  }

  TornProperties$Properties$Item copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<String>? name,
    Wrapped<int>? cost,
    Wrapped<int>? happy,
    Wrapped<int>? upkeep,
    Wrapped<List<Object>>? modifications,
    Wrapped<List<Object>>? staff,
  }) {
    return TornProperties$Properties$Item(
      id: (id != null ? id.value : this.id),
      name: (name != null ? name.value : this.name),
      cost: (cost != null ? cost.value : this.cost),
      happy: (happy != null ? happy.value : this.happy),
      upkeep: (upkeep != null ? upkeep.value : this.upkeep),
      modifications: (modifications != null ? modifications.value : this.modifications),
      staff: (staff != null ? staff.value : this.staff),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TornEducationRewards$WorkingStats {
  const TornEducationRewards$WorkingStats({
    required this.manualLabor,
    required this.intelligence,
    required this.endurance,
  });

  factory TornEducationRewards$WorkingStats.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$TornEducationRewards$WorkingStatsFromJson(json);

  static const toJsonFactory = _$TornEducationRewards$WorkingStatsToJson;
  Map<String, dynamic> toJson() => _$TornEducationRewards$WorkingStatsToJson(this);

  @JsonKey(name: 'manual_labor')
  final dynamic manualLabor;
  @JsonKey(name: 'intelligence')
  final dynamic intelligence;
  @JsonKey(name: 'endurance')
  final dynamic endurance;
  static const fromJsonFactory = _$TornEducationRewards$WorkingStatsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TornEducationRewards$WorkingStats &&
            (identical(other.manualLabor, manualLabor) ||
                const DeepCollectionEquality().equals(
                  other.manualLabor,
                  manualLabor,
                )) &&
            (identical(other.intelligence, intelligence) ||
                const DeepCollectionEquality().equals(
                  other.intelligence,
                  intelligence,
                )) &&
            (identical(other.endurance, endurance) ||
                const DeepCollectionEquality().equals(
                  other.endurance,
                  endurance,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(manualLabor) ^
      const DeepCollectionEquality().hash(intelligence) ^
      const DeepCollectionEquality().hash(endurance) ^
      runtimeType.hashCode;
}

extension $TornEducationRewards$WorkingStatsExtension on TornEducationRewards$WorkingStats {
  TornEducationRewards$WorkingStats copyWith({
    dynamic manualLabor,
    dynamic intelligence,
    dynamic endurance,
  }) {
    return TornEducationRewards$WorkingStats(
      manualLabor: manualLabor ?? this.manualLabor,
      intelligence: intelligence ?? this.intelligence,
      endurance: endurance ?? this.endurance,
    );
  }

  TornEducationRewards$WorkingStats copyWithWrapped({
    Wrapped<dynamic>? manualLabor,
    Wrapped<dynamic>? intelligence,
    Wrapped<dynamic>? endurance,
  }) {
    return TornEducationRewards$WorkingStats(
      manualLabor: (manualLabor != null ? manualLabor.value : this.manualLabor),
      intelligence: (intelligence != null ? intelligence.value : this.intelligence),
      endurance: (endurance != null ? endurance.value : this.endurance),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TornCalendarResponse$Calendar {
  const TornCalendarResponse$Calendar({
    required this.competitions,
    required this.events,
  });

  factory TornCalendarResponse$Calendar.fromJson(Map<String, dynamic> json) =>
      _$TornCalendarResponse$CalendarFromJson(json);

  static const toJsonFactory = _$TornCalendarResponse$CalendarToJson;
  Map<String, dynamic> toJson() => _$TornCalendarResponse$CalendarToJson(this);

  @JsonKey(name: 'competitions', defaultValue: <TornCalendarActivity>[])
  final List<TornCalendarActivity> competitions;
  @JsonKey(name: 'events', defaultValue: <TornCalendarActivity>[])
  final List<TornCalendarActivity> events;
  static const fromJsonFactory = _$TornCalendarResponse$CalendarFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TornCalendarResponse$Calendar &&
            (identical(other.competitions, competitions) ||
                const DeepCollectionEquality().equals(
                  other.competitions,
                  competitions,
                )) &&
            (identical(other.events, events) || const DeepCollectionEquality().equals(other.events, events)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(competitions) ^
      const DeepCollectionEquality().hash(events) ^
      runtimeType.hashCode;
}

extension $TornCalendarResponse$CalendarExtension on TornCalendarResponse$Calendar {
  TornCalendarResponse$Calendar copyWith({
    List<TornCalendarActivity>? competitions,
    List<TornCalendarActivity>? events,
  }) {
    return TornCalendarResponse$Calendar(
      competitions: competitions ?? this.competitions,
      events: events ?? this.events,
    );
  }

  TornCalendarResponse$Calendar copyWithWrapped({
    Wrapped<List<TornCalendarActivity>>? competitions,
    Wrapped<List<TornCalendarActivity>>? events,
  }) {
    return TornCalendarResponse$Calendar(
      competitions: (competitions != null ? competitions.value : this.competitions),
      events: (events != null ? events.value : this.events),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class AttackLog$AttackerItem {
  const AttackLog$AttackerItem({required this.id, required this.name});

  factory AttackLog$AttackerItem.fromJson(Map<String, dynamic> json) => _$AttackLog$AttackerItemFromJson(json);

  static const toJsonFactory = _$AttackLog$AttackerItemToJson;
  Map<String, dynamic> toJson() => _$AttackLog$AttackerItemToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'name')
  final String name;
  static const fromJsonFactory = _$AttackLog$AttackerItemFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AttackLog$AttackerItem &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^ const DeepCollectionEquality().hash(name) ^ runtimeType.hashCode;
}

extension $AttackLog$AttackerItemExtension on AttackLog$AttackerItem {
  AttackLog$AttackerItem copyWith({int? id, String? name}) {
    return AttackLog$AttackerItem(id: id ?? this.id, name: name ?? this.name);
  }

  AttackLog$AttackerItem copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<String>? name,
  }) {
    return AttackLog$AttackerItem(
      id: (id != null ? id.value : this.id),
      name: (name != null ? name.value : this.name),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class AttackLogResponse$Attacklog {
  const AttackLogResponse$Attacklog({required this.log, required this.summary});

  factory AttackLogResponse$Attacklog.fromJson(Map<String, dynamic> json) =>
      _$AttackLogResponse$AttacklogFromJson(json);

  static const toJsonFactory = _$AttackLogResponse$AttacklogToJson;
  Map<String, dynamic> toJson() => _$AttackLogResponse$AttacklogToJson(this);

  @JsonKey(name: 'log', defaultValue: <AttackLog>[])
  final List<AttackLog> log;
  @JsonKey(name: 'summary', defaultValue: <AttackLogSummary>[])
  final List<AttackLogSummary> summary;
  static const fromJsonFactory = _$AttackLogResponse$AttacklogFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AttackLogResponse$Attacklog &&
            (identical(other.log, log) || const DeepCollectionEquality().equals(other.log, log)) &&
            (identical(other.summary, summary) || const DeepCollectionEquality().equals(other.summary, summary)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(log) ^ const DeepCollectionEquality().hash(summary) ^ runtimeType.hashCode;
}

extension $AttackLogResponse$AttacklogExtension on AttackLogResponse$Attacklog {
  AttackLogResponse$Attacklog copyWith({
    List<AttackLog>? log,
    List<AttackLogSummary>? summary,
  }) {
    return AttackLogResponse$Attacklog(
      log: log ?? this.log,
      summary: summary ?? this.summary,
    );
  }

  AttackLogResponse$Attacklog copyWithWrapped({
    Wrapped<List<AttackLog>>? log,
    Wrapped<List<AttackLogSummary>>? summary,
  }) {
    return AttackLogResponse$Attacklog(
      log: (log != null ? log.value : this.log),
      summary: (summary != null ? summary.value : this.summary),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TornItem$Value {
  const TornItem$Value({
    required this.vendor,
    required this.buyPrice,
    required this.sellPrice,
    required this.marketPrice,
  });

  factory TornItem$Value.fromJson(Map<String, dynamic> json) => _$TornItem$ValueFromJson(json);

  static const toJsonFactory = _$TornItem$ValueToJson;
  Map<String, dynamic> toJson() => _$TornItem$ValueToJson(this);

  @JsonKey(name: 'vendor')
  final dynamic vendor;
  @JsonKey(name: 'buy_price')
  final dynamic buyPrice;
  @JsonKey(name: 'sell_price')
  final dynamic sellPrice;
  @JsonKey(name: 'market_price')
  final int marketPrice;
  static const fromJsonFactory = _$TornItem$ValueFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TornItem$Value &&
            (identical(other.vendor, vendor) || const DeepCollectionEquality().equals(other.vendor, vendor)) &&
            (identical(other.buyPrice, buyPrice) ||
                const DeepCollectionEquality().equals(
                  other.buyPrice,
                  buyPrice,
                )) &&
            (identical(other.sellPrice, sellPrice) ||
                const DeepCollectionEquality().equals(
                  other.sellPrice,
                  sellPrice,
                )) &&
            (identical(other.marketPrice, marketPrice) ||
                const DeepCollectionEquality().equals(
                  other.marketPrice,
                  marketPrice,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(vendor) ^
      const DeepCollectionEquality().hash(buyPrice) ^
      const DeepCollectionEquality().hash(sellPrice) ^
      const DeepCollectionEquality().hash(marketPrice) ^
      runtimeType.hashCode;
}

extension $TornItem$ValueExtension on TornItem$Value {
  TornItem$Value copyWith({
    dynamic vendor,
    dynamic buyPrice,
    dynamic sellPrice,
    int? marketPrice,
  }) {
    return TornItem$Value(
      vendor: vendor ?? this.vendor,
      buyPrice: buyPrice ?? this.buyPrice,
      sellPrice: sellPrice ?? this.sellPrice,
      marketPrice: marketPrice ?? this.marketPrice,
    );
  }

  TornItem$Value copyWithWrapped({
    Wrapped<dynamic>? vendor,
    Wrapped<dynamic>? buyPrice,
    Wrapped<dynamic>? sellPrice,
    Wrapped<int>? marketPrice,
  }) {
    return TornItem$Value(
      vendor: (vendor != null ? vendor.value : this.vendor),
      buyPrice: (buyPrice != null ? buyPrice.value : this.buyPrice),
      sellPrice: (sellPrice != null ? sellPrice.value : this.sellPrice),
      marketPrice: (marketPrice != null ? marketPrice.value : this.marketPrice),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class TornFactionTreeBranch$Upgrades$Item {
  const TornFactionTreeBranch$Upgrades$Item({
    required this.name,
    required this.level,
    required this.ability,
    required this.cost,
    required this.challenge,
  });

  factory TornFactionTreeBranch$Upgrades$Item.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$TornFactionTreeBranch$Upgrades$ItemFromJson(json);

  static const toJsonFactory = _$TornFactionTreeBranch$Upgrades$ItemToJson;
  Map<String, dynamic> toJson() => _$TornFactionTreeBranch$Upgrades$ItemToJson(this);

  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'level')
  final int level;
  @JsonKey(name: 'ability')
  final String ability;
  @JsonKey(name: 'cost')
  final int cost;
  @JsonKey(name: 'challenge')
  final dynamic challenge;
  static const fromJsonFactory = _$TornFactionTreeBranch$Upgrades$ItemFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TornFactionTreeBranch$Upgrades$Item &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.level, level) || const DeepCollectionEquality().equals(other.level, level)) &&
            (identical(other.ability, ability) ||
                const DeepCollectionEquality().equals(
                  other.ability,
                  ability,
                )) &&
            (identical(other.cost, cost) || const DeepCollectionEquality().equals(other.cost, cost)) &&
            (identical(other.challenge, challenge) ||
                const DeepCollectionEquality().equals(
                  other.challenge,
                  challenge,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(level) ^
      const DeepCollectionEquality().hash(ability) ^
      const DeepCollectionEquality().hash(cost) ^
      const DeepCollectionEquality().hash(challenge) ^
      runtimeType.hashCode;
}

extension $TornFactionTreeBranch$Upgrades$ItemExtension on TornFactionTreeBranch$Upgrades$Item {
  TornFactionTreeBranch$Upgrades$Item copyWith({
    String? name,
    int? level,
    String? ability,
    int? cost,
    dynamic challenge,
  }) {
    return TornFactionTreeBranch$Upgrades$Item(
      name: name ?? this.name,
      level: level ?? this.level,
      ability: ability ?? this.ability,
      cost: cost ?? this.cost,
      challenge: challenge ?? this.challenge,
    );
  }

  TornFactionTreeBranch$Upgrades$Item copyWithWrapped({
    Wrapped<String>? name,
    Wrapped<int>? level,
    Wrapped<String>? ability,
    Wrapped<int>? cost,
    Wrapped<dynamic>? challenge,
  }) {
    return TornFactionTreeBranch$Upgrades$Item(
      name: (name != null ? name.value : this.name),
      level: (level != null ? level.value : this.level),
      ability: (ability != null ? ability.value : this.ability),
      cost: (cost != null ? cost.value : this.cost),
      challenge: (challenge != null ? challenge.value : this.challenge),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class ReportStockAnalysis$Items$Item$Item {
  const ReportStockAnalysis$Items$Item$Item({
    required this.id,
    required this.name,
    required this.price,
    required this.$value,
    required this.due,
  });

  factory ReportStockAnalysis$Items$Item$Item.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$ReportStockAnalysis$Items$Item$ItemFromJson(json);

  static const toJsonFactory = _$ReportStockAnalysis$Items$Item$ItemToJson;
  Map<String, dynamic> toJson() => _$ReportStockAnalysis$Items$Item$ItemToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'price')
  final int price;
  @JsonKey(name: 'value')
  final int $value;
  @JsonKey(name: 'due')
  final dynamic due;
  static const fromJsonFactory = _$ReportStockAnalysis$Items$Item$ItemFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ReportStockAnalysis$Items$Item$Item &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.price, price) || const DeepCollectionEquality().equals(other.price, price)) &&
            (identical(other.$value, $value) || const DeepCollectionEquality().equals(other.$value, $value)) &&
            (identical(other.due, due) || const DeepCollectionEquality().equals(other.due, due)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(price) ^
      const DeepCollectionEquality().hash($value) ^
      const DeepCollectionEquality().hash(due) ^
      runtimeType.hashCode;
}

extension $ReportStockAnalysis$Items$Item$ItemExtension on ReportStockAnalysis$Items$Item$Item {
  ReportStockAnalysis$Items$Item$Item copyWith({
    int? id,
    String? name,
    int? price,
    int? $value,
    dynamic due,
  }) {
    return ReportStockAnalysis$Items$Item$Item(
      id: id ?? this.id,
      name: name ?? this.name,
      price: price ?? this.price,
      $value: $value ?? this.$value,
      due: due ?? this.due,
    );
  }

  ReportStockAnalysis$Items$Item$Item copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<String>? name,
    Wrapped<int>? price,
    Wrapped<int>? $value,
    Wrapped<dynamic>? due,
  }) {
    return ReportStockAnalysis$Items$Item$Item(
      id: (id != null ? id.value : this.id),
      name: (name != null ? name.value : this.name),
      price: (price != null ? price.value : this.price),
      $value: ($value != null ? $value.value : this.$value),
      due: (due != null ? due.value : this.due),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserCrimeDetailsCardSkimming$CardDetails$Areas$Item {
  const UserCrimeDetailsCardSkimming$CardDetails$Areas$Item({
    required this.id,
    required this.amount,
  });

  factory UserCrimeDetailsCardSkimming$CardDetails$Areas$Item.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$UserCrimeDetailsCardSkimming$CardDetails$Areas$ItemFromJson(json);

  static const toJsonFactory = _$UserCrimeDetailsCardSkimming$CardDetails$Areas$ItemToJson;
  Map<String, dynamic> toJson() => _$UserCrimeDetailsCardSkimming$CardDetails$Areas$ItemToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'amount')
  final int amount;
  static const fromJsonFactory = _$UserCrimeDetailsCardSkimming$CardDetails$Areas$ItemFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserCrimeDetailsCardSkimming$CardDetails$Areas$Item &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.amount, amount) || const DeepCollectionEquality().equals(other.amount, amount)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^ const DeepCollectionEquality().hash(amount) ^ runtimeType.hashCode;
}

extension $UserCrimeDetailsCardSkimming$CardDetails$Areas$ItemExtension
    on UserCrimeDetailsCardSkimming$CardDetails$Areas$Item {
  UserCrimeDetailsCardSkimming$CardDetails$Areas$Item copyWith({
    int? id,
    int? amount,
  }) {
    return UserCrimeDetailsCardSkimming$CardDetails$Areas$Item(
      id: id ?? this.id,
      amount: amount ?? this.amount,
    );
  }

  UserCrimeDetailsCardSkimming$CardDetails$Areas$Item copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<int>? amount,
  }) {
    return UserCrimeDetailsCardSkimming$CardDetails$Areas$Item(
      id: (id != null ? id.value : this.id),
      amount: (amount != null ? amount.value : this.amount),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsOther$Other$Activity {
  const PersonalStatsOther$Other$Activity({
    required this.time,
    required this.streak,
  });

  factory PersonalStatsOther$Other$Activity.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$PersonalStatsOther$Other$ActivityFromJson(json);

  static const toJsonFactory = _$PersonalStatsOther$Other$ActivityToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsOther$Other$ActivityToJson(this);

  @JsonKey(name: 'time')
  final int time;
  @JsonKey(name: 'streak')
  final PersonalStatsOther$Other$Activity$Streak streak;
  static const fromJsonFactory = _$PersonalStatsOther$Other$ActivityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsOther$Other$Activity &&
            (identical(other.time, time) || const DeepCollectionEquality().equals(other.time, time)) &&
            (identical(other.streak, streak) || const DeepCollectionEquality().equals(other.streak, streak)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(time) ^ const DeepCollectionEquality().hash(streak) ^ runtimeType.hashCode;
}

extension $PersonalStatsOther$Other$ActivityExtension on PersonalStatsOther$Other$Activity {
  PersonalStatsOther$Other$Activity copyWith({
    int? time,
    PersonalStatsOther$Other$Activity$Streak? streak,
  }) {
    return PersonalStatsOther$Other$Activity(
      time: time ?? this.time,
      streak: streak ?? this.streak,
    );
  }

  PersonalStatsOther$Other$Activity copyWithWrapped({
    Wrapped<int>? time,
    Wrapped<PersonalStatsOther$Other$Activity$Streak>? streak,
  }) {
    return PersonalStatsOther$Other$Activity(
      time: (time != null ? time.value : this.time),
      streak: (streak != null ? streak.value : this.streak),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsOther$Other$Refills {
  const PersonalStatsOther$Other$Refills({
    required this.energy,
    required this.nerve,
    required this.token,
  });

  factory PersonalStatsOther$Other$Refills.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$PersonalStatsOther$Other$RefillsFromJson(json);

  static const toJsonFactory = _$PersonalStatsOther$Other$RefillsToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsOther$Other$RefillsToJson(this);

  @JsonKey(name: 'energy')
  final int energy;
  @JsonKey(name: 'nerve')
  final int nerve;
  @JsonKey(name: 'token')
  final int token;
  static const fromJsonFactory = _$PersonalStatsOther$Other$RefillsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsOther$Other$Refills &&
            (identical(other.energy, energy) || const DeepCollectionEquality().equals(other.energy, energy)) &&
            (identical(other.nerve, nerve) || const DeepCollectionEquality().equals(other.nerve, nerve)) &&
            (identical(other.token, token) || const DeepCollectionEquality().equals(other.token, token)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(energy) ^
      const DeepCollectionEquality().hash(nerve) ^
      const DeepCollectionEquality().hash(token) ^
      runtimeType.hashCode;
}

extension $PersonalStatsOther$Other$RefillsExtension on PersonalStatsOther$Other$Refills {
  PersonalStatsOther$Other$Refills copyWith({
    int? energy,
    int? nerve,
    int? token,
  }) {
    return PersonalStatsOther$Other$Refills(
      energy: energy ?? this.energy,
      nerve: nerve ?? this.nerve,
      token: token ?? this.token,
    );
  }

  PersonalStatsOther$Other$Refills copyWithWrapped({
    Wrapped<int>? energy,
    Wrapped<int>? nerve,
    Wrapped<int>? token,
  }) {
    return PersonalStatsOther$Other$Refills(
      energy: (energy != null ? energy.value : this.energy),
      nerve: (nerve != null ? nerve.value : this.nerve),
      token: (token != null ? token.value : this.token),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsOtherPopular$Other$Activity {
  const PersonalStatsOtherPopular$Other$Activity({
    required this.time,
    required this.streak,
  });

  factory PersonalStatsOtherPopular$Other$Activity.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$PersonalStatsOtherPopular$Other$ActivityFromJson(json);

  static const toJsonFactory = _$PersonalStatsOtherPopular$Other$ActivityToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsOtherPopular$Other$ActivityToJson(this);

  @JsonKey(name: 'time')
  final int time;
  @JsonKey(name: 'streak')
  final PersonalStatsOtherPopular$Other$Activity$Streak streak;
  static const fromJsonFactory = _$PersonalStatsOtherPopular$Other$ActivityFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsOtherPopular$Other$Activity &&
            (identical(other.time, time) || const DeepCollectionEquality().equals(other.time, time)) &&
            (identical(other.streak, streak) || const DeepCollectionEquality().equals(other.streak, streak)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(time) ^ const DeepCollectionEquality().hash(streak) ^ runtimeType.hashCode;
}

extension $PersonalStatsOtherPopular$Other$ActivityExtension on PersonalStatsOtherPopular$Other$Activity {
  PersonalStatsOtherPopular$Other$Activity copyWith({
    int? time,
    PersonalStatsOtherPopular$Other$Activity$Streak? streak,
  }) {
    return PersonalStatsOtherPopular$Other$Activity(
      time: time ?? this.time,
      streak: streak ?? this.streak,
    );
  }

  PersonalStatsOtherPopular$Other$Activity copyWithWrapped({
    Wrapped<int>? time,
    Wrapped<PersonalStatsOtherPopular$Other$Activity$Streak>? streak,
  }) {
    return PersonalStatsOtherPopular$Other$Activity(
      time: (time != null ? time.value : this.time),
      streak: (streak != null ? streak.value : this.streak),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsOtherPopular$Other$Refills {
  const PersonalStatsOtherPopular$Other$Refills({
    required this.energy,
    required this.nerve,
  });

  factory PersonalStatsOtherPopular$Other$Refills.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$PersonalStatsOtherPopular$Other$RefillsFromJson(json);

  static const toJsonFactory = _$PersonalStatsOtherPopular$Other$RefillsToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsOtherPopular$Other$RefillsToJson(this);

  @JsonKey(name: 'energy')
  final int energy;
  @JsonKey(name: 'nerve')
  final int nerve;
  static const fromJsonFactory = _$PersonalStatsOtherPopular$Other$RefillsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsOtherPopular$Other$Refills &&
            (identical(other.energy, energy) || const DeepCollectionEquality().equals(other.energy, energy)) &&
            (identical(other.nerve, nerve) || const DeepCollectionEquality().equals(other.nerve, nerve)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(energy) ^ const DeepCollectionEquality().hash(nerve) ^ runtimeType.hashCode;
}

extension $PersonalStatsOtherPopular$Other$RefillsExtension on PersonalStatsOtherPopular$Other$Refills {
  PersonalStatsOtherPopular$Other$Refills copyWith({int? energy, int? nerve}) {
    return PersonalStatsOtherPopular$Other$Refills(
      energy: energy ?? this.energy,
      nerve: nerve ?? this.nerve,
    );
  }

  PersonalStatsOtherPopular$Other$Refills copyWithWrapped({
    Wrapped<int>? energy,
    Wrapped<int>? nerve,
  }) {
    return PersonalStatsOtherPopular$Other$Refills(
      energy: (energy != null ? energy.value : this.energy),
      nerve: (nerve != null ? nerve.value : this.nerve),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsRacing$Racing$Races {
  const PersonalStatsRacing$Racing$Races({
    required this.entered,
    required this.won,
  });

  factory PersonalStatsRacing$Racing$Races.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$PersonalStatsRacing$Racing$RacesFromJson(json);

  static const toJsonFactory = _$PersonalStatsRacing$Racing$RacesToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsRacing$Racing$RacesToJson(this);

  @JsonKey(name: 'entered')
  final int entered;
  @JsonKey(name: 'won')
  final int won;
  static const fromJsonFactory = _$PersonalStatsRacing$Racing$RacesFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsRacing$Racing$Races &&
            (identical(other.entered, entered) ||
                const DeepCollectionEquality().equals(
                  other.entered,
                  entered,
                )) &&
            (identical(other.won, won) || const DeepCollectionEquality().equals(other.won, won)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entered) ^ const DeepCollectionEquality().hash(won) ^ runtimeType.hashCode;
}

extension $PersonalStatsRacing$Racing$RacesExtension on PersonalStatsRacing$Racing$Races {
  PersonalStatsRacing$Racing$Races copyWith({int? entered, int? won}) {
    return PersonalStatsRacing$Racing$Races(
      entered: entered ?? this.entered,
      won: won ?? this.won,
    );
  }

  PersonalStatsRacing$Racing$Races copyWithWrapped({
    Wrapped<int>? entered,
    Wrapped<int>? won,
  }) {
    return PersonalStatsRacing$Racing$Races(
      entered: (entered != null ? entered.value : this.entered),
      won: (won != null ? won.value : this.won),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsMissions$Missions$Contracts {
  const PersonalStatsMissions$Missions$Contracts({
    required this.total,
    required this.duke,
  });

  factory PersonalStatsMissions$Missions$Contracts.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$PersonalStatsMissions$Missions$ContractsFromJson(json);

  static const toJsonFactory = _$PersonalStatsMissions$Missions$ContractsToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsMissions$Missions$ContractsToJson(this);

  @JsonKey(name: 'total')
  final int total;
  @JsonKey(name: 'duke')
  final int duke;
  static const fromJsonFactory = _$PersonalStatsMissions$Missions$ContractsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsMissions$Missions$Contracts &&
            (identical(other.total, total) || const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.duke, duke) || const DeepCollectionEquality().equals(other.duke, duke)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(total) ^ const DeepCollectionEquality().hash(duke) ^ runtimeType.hashCode;
}

extension $PersonalStatsMissions$Missions$ContractsExtension on PersonalStatsMissions$Missions$Contracts {
  PersonalStatsMissions$Missions$Contracts copyWith({int? total, int? duke}) {
    return PersonalStatsMissions$Missions$Contracts(
      total: total ?? this.total,
      duke: duke ?? this.duke,
    );
  }

  PersonalStatsMissions$Missions$Contracts copyWithWrapped({
    Wrapped<int>? total,
    Wrapped<int>? duke,
  }) {
    return PersonalStatsMissions$Missions$Contracts(
      total: (total != null ? total.value : this.total),
      duke: (duke != null ? duke.value : this.duke),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsDrugs$Drugs$Rehabilitations {
  const PersonalStatsDrugs$Drugs$Rehabilitations({
    required this.amount,
    required this.fees,
  });

  factory PersonalStatsDrugs$Drugs$Rehabilitations.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$PersonalStatsDrugs$Drugs$RehabilitationsFromJson(json);

  static const toJsonFactory = _$PersonalStatsDrugs$Drugs$RehabilitationsToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsDrugs$Drugs$RehabilitationsToJson(this);

  @JsonKey(name: 'amount')
  final int amount;
  @JsonKey(name: 'fees')
  final int fees;
  static const fromJsonFactory = _$PersonalStatsDrugs$Drugs$RehabilitationsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsDrugs$Drugs$Rehabilitations &&
            (identical(other.amount, amount) || const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.fees, fees) || const DeepCollectionEquality().equals(other.fees, fees)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(amount) ^ const DeepCollectionEquality().hash(fees) ^ runtimeType.hashCode;
}

extension $PersonalStatsDrugs$Drugs$RehabilitationsExtension on PersonalStatsDrugs$Drugs$Rehabilitations {
  PersonalStatsDrugs$Drugs$Rehabilitations copyWith({int? amount, int? fees}) {
    return PersonalStatsDrugs$Drugs$Rehabilitations(
      amount: amount ?? this.amount,
      fees: fees ?? this.fees,
    );
  }

  PersonalStatsDrugs$Drugs$Rehabilitations copyWithWrapped({
    Wrapped<int>? amount,
    Wrapped<int>? fees,
  }) {
    return PersonalStatsDrugs$Drugs$Rehabilitations(
      amount: (amount != null ? amount.value : this.amount),
      fees: (fees != null ? fees.value : this.fees),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsTravel$Travel$Hunting {
  const PersonalStatsTravel$Travel$Hunting({required this.skill});

  factory PersonalStatsTravel$Travel$Hunting.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$PersonalStatsTravel$Travel$HuntingFromJson(json);

  static const toJsonFactory = _$PersonalStatsTravel$Travel$HuntingToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsTravel$Travel$HuntingToJson(this);

  @JsonKey(name: 'skill')
  final int skill;
  static const fromJsonFactory = _$PersonalStatsTravel$Travel$HuntingFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsTravel$Travel$Hunting &&
            (identical(other.skill, skill) || const DeepCollectionEquality().equals(other.skill, skill)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(skill) ^ runtimeType.hashCode;
}

extension $PersonalStatsTravel$Travel$HuntingExtension on PersonalStatsTravel$Travel$Hunting {
  PersonalStatsTravel$Travel$Hunting copyWith({int? skill}) {
    return PersonalStatsTravel$Travel$Hunting(skill: skill ?? this.skill);
  }

  PersonalStatsTravel$Travel$Hunting copyWithWrapped({Wrapped<int>? skill}) {
    return PersonalStatsTravel$Travel$Hunting(
      skill: (skill != null ? skill.value : this.skill),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsItems$Items$Found {
  const PersonalStatsItems$Items$Found({
    required this.city,
    required this.dump,
    required this.easterEggs,
  });

  factory PersonalStatsItems$Items$Found.fromJson(Map<String, dynamic> json) =>
      _$PersonalStatsItems$Items$FoundFromJson(json);

  static const toJsonFactory = _$PersonalStatsItems$Items$FoundToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsItems$Items$FoundToJson(this);

  @JsonKey(name: 'city')
  final int city;
  @JsonKey(name: 'dump')
  final int dump;
  @JsonKey(name: 'easter_eggs')
  final int easterEggs;
  static const fromJsonFactory = _$PersonalStatsItems$Items$FoundFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsItems$Items$Found &&
            (identical(other.city, city) || const DeepCollectionEquality().equals(other.city, city)) &&
            (identical(other.dump, dump) || const DeepCollectionEquality().equals(other.dump, dump)) &&
            (identical(other.easterEggs, easterEggs) ||
                const DeepCollectionEquality().equals(
                  other.easterEggs,
                  easterEggs,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(city) ^
      const DeepCollectionEquality().hash(dump) ^
      const DeepCollectionEquality().hash(easterEggs) ^
      runtimeType.hashCode;
}

extension $PersonalStatsItems$Items$FoundExtension on PersonalStatsItems$Items$Found {
  PersonalStatsItems$Items$Found copyWith({
    int? city,
    int? dump,
    int? easterEggs,
  }) {
    return PersonalStatsItems$Items$Found(
      city: city ?? this.city,
      dump: dump ?? this.dump,
      easterEggs: easterEggs ?? this.easterEggs,
    );
  }

  PersonalStatsItems$Items$Found copyWithWrapped({
    Wrapped<int>? city,
    Wrapped<int>? dump,
    Wrapped<int>? easterEggs,
  }) {
    return PersonalStatsItems$Items$Found(
      city: (city != null ? city.value : this.city),
      dump: (dump != null ? dump.value : this.dump),
      easterEggs: (easterEggs != null ? easterEggs.value : this.easterEggs),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsItems$Items$Used {
  const PersonalStatsItems$Items$Used({
    required this.books,
    required this.boosters,
    required this.consumables,
    required this.candy,
    required this.alcohol,
    required this.energyDrinks,
    required this.statEnhancers,
    required this.easterEggs,
  });

  factory PersonalStatsItems$Items$Used.fromJson(Map<String, dynamic> json) =>
      _$PersonalStatsItems$Items$UsedFromJson(json);

  static const toJsonFactory = _$PersonalStatsItems$Items$UsedToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsItems$Items$UsedToJson(this);

  @JsonKey(name: 'books')
  final int books;
  @JsonKey(name: 'boosters')
  final int boosters;
  @JsonKey(name: 'consumables')
  final int consumables;
  @JsonKey(name: 'candy')
  final int candy;
  @JsonKey(name: 'alcohol')
  final int alcohol;
  @JsonKey(name: 'energy_drinks')
  final int energyDrinks;
  @JsonKey(name: 'stat_enhancers')
  final int statEnhancers;
  @JsonKey(name: 'easter_eggs')
  final int easterEggs;
  static const fromJsonFactory = _$PersonalStatsItems$Items$UsedFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsItems$Items$Used &&
            (identical(other.books, books) || const DeepCollectionEquality().equals(other.books, books)) &&
            (identical(other.boosters, boosters) ||
                const DeepCollectionEquality().equals(
                  other.boosters,
                  boosters,
                )) &&
            (identical(other.consumables, consumables) ||
                const DeepCollectionEquality().equals(
                  other.consumables,
                  consumables,
                )) &&
            (identical(other.candy, candy) || const DeepCollectionEquality().equals(other.candy, candy)) &&
            (identical(other.alcohol, alcohol) ||
                const DeepCollectionEquality().equals(
                  other.alcohol,
                  alcohol,
                )) &&
            (identical(other.energyDrinks, energyDrinks) ||
                const DeepCollectionEquality().equals(
                  other.energyDrinks,
                  energyDrinks,
                )) &&
            (identical(other.statEnhancers, statEnhancers) ||
                const DeepCollectionEquality().equals(
                  other.statEnhancers,
                  statEnhancers,
                )) &&
            (identical(other.easterEggs, easterEggs) ||
                const DeepCollectionEquality().equals(
                  other.easterEggs,
                  easterEggs,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(books) ^
      const DeepCollectionEquality().hash(boosters) ^
      const DeepCollectionEquality().hash(consumables) ^
      const DeepCollectionEquality().hash(candy) ^
      const DeepCollectionEquality().hash(alcohol) ^
      const DeepCollectionEquality().hash(energyDrinks) ^
      const DeepCollectionEquality().hash(statEnhancers) ^
      const DeepCollectionEquality().hash(easterEggs) ^
      runtimeType.hashCode;
}

extension $PersonalStatsItems$Items$UsedExtension on PersonalStatsItems$Items$Used {
  PersonalStatsItems$Items$Used copyWith({
    int? books,
    int? boosters,
    int? consumables,
    int? candy,
    int? alcohol,
    int? energyDrinks,
    int? statEnhancers,
    int? easterEggs,
  }) {
    return PersonalStatsItems$Items$Used(
      books: books ?? this.books,
      boosters: boosters ?? this.boosters,
      consumables: consumables ?? this.consumables,
      candy: candy ?? this.candy,
      alcohol: alcohol ?? this.alcohol,
      energyDrinks: energyDrinks ?? this.energyDrinks,
      statEnhancers: statEnhancers ?? this.statEnhancers,
      easterEggs: easterEggs ?? this.easterEggs,
    );
  }

  PersonalStatsItems$Items$Used copyWithWrapped({
    Wrapped<int>? books,
    Wrapped<int>? boosters,
    Wrapped<int>? consumables,
    Wrapped<int>? candy,
    Wrapped<int>? alcohol,
    Wrapped<int>? energyDrinks,
    Wrapped<int>? statEnhancers,
    Wrapped<int>? easterEggs,
  }) {
    return PersonalStatsItems$Items$Used(
      books: (books != null ? books.value : this.books),
      boosters: (boosters != null ? boosters.value : this.boosters),
      consumables: (consumables != null ? consumables.value : this.consumables),
      candy: (candy != null ? candy.value : this.candy),
      alcohol: (alcohol != null ? alcohol.value : this.alcohol),
      energyDrinks: (energyDrinks != null ? energyDrinks.value : this.energyDrinks),
      statEnhancers: (statEnhancers != null ? statEnhancers.value : this.statEnhancers),
      easterEggs: (easterEggs != null ? easterEggs.value : this.easterEggs),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsItemsPopular$Items$Found {
  const PersonalStatsItemsPopular$Items$Found({required this.dump});

  factory PersonalStatsItemsPopular$Items$Found.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$PersonalStatsItemsPopular$Items$FoundFromJson(json);

  static const toJsonFactory = _$PersonalStatsItemsPopular$Items$FoundToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsItemsPopular$Items$FoundToJson(this);

  @JsonKey(name: 'dump')
  final int dump;
  static const fromJsonFactory = _$PersonalStatsItemsPopular$Items$FoundFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsItemsPopular$Items$Found &&
            (identical(other.dump, dump) || const DeepCollectionEquality().equals(other.dump, dump)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(dump) ^ runtimeType.hashCode;
}

extension $PersonalStatsItemsPopular$Items$FoundExtension on PersonalStatsItemsPopular$Items$Found {
  PersonalStatsItemsPopular$Items$Found copyWith({int? dump}) {
    return PersonalStatsItemsPopular$Items$Found(dump: dump ?? this.dump);
  }

  PersonalStatsItemsPopular$Items$Found copyWithWrapped({Wrapped<int>? dump}) {
    return PersonalStatsItemsPopular$Items$Found(
      dump: (dump != null ? dump.value : this.dump),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsItemsPopular$Items$Used {
  const PersonalStatsItemsPopular$Items$Used({
    required this.books,
    required this.boosters,
    required this.consumables,
    required this.candy,
    required this.alcohol,
    required this.energyDrinks,
    required this.statEnhancers,
    required this.easterEggs,
  });

  factory PersonalStatsItemsPopular$Items$Used.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$PersonalStatsItemsPopular$Items$UsedFromJson(json);

  static const toJsonFactory = _$PersonalStatsItemsPopular$Items$UsedToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsItemsPopular$Items$UsedToJson(this);

  @JsonKey(name: 'books')
  final int books;
  @JsonKey(name: 'boosters')
  final int boosters;
  @JsonKey(name: 'consumables')
  final int consumables;
  @JsonKey(name: 'candy')
  final int candy;
  @JsonKey(name: 'alcohol')
  final int alcohol;
  @JsonKey(name: 'energy_drinks')
  final int energyDrinks;
  @JsonKey(name: 'stat_enhancers')
  final int statEnhancers;
  @JsonKey(name: 'easter_eggs')
  final int easterEggs;
  static const fromJsonFactory = _$PersonalStatsItemsPopular$Items$UsedFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsItemsPopular$Items$Used &&
            (identical(other.books, books) || const DeepCollectionEquality().equals(other.books, books)) &&
            (identical(other.boosters, boosters) ||
                const DeepCollectionEquality().equals(
                  other.boosters,
                  boosters,
                )) &&
            (identical(other.consumables, consumables) ||
                const DeepCollectionEquality().equals(
                  other.consumables,
                  consumables,
                )) &&
            (identical(other.candy, candy) || const DeepCollectionEquality().equals(other.candy, candy)) &&
            (identical(other.alcohol, alcohol) ||
                const DeepCollectionEquality().equals(
                  other.alcohol,
                  alcohol,
                )) &&
            (identical(other.energyDrinks, energyDrinks) ||
                const DeepCollectionEquality().equals(
                  other.energyDrinks,
                  energyDrinks,
                )) &&
            (identical(other.statEnhancers, statEnhancers) ||
                const DeepCollectionEquality().equals(
                  other.statEnhancers,
                  statEnhancers,
                )) &&
            (identical(other.easterEggs, easterEggs) ||
                const DeepCollectionEquality().equals(
                  other.easterEggs,
                  easterEggs,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(books) ^
      const DeepCollectionEquality().hash(boosters) ^
      const DeepCollectionEquality().hash(consumables) ^
      const DeepCollectionEquality().hash(candy) ^
      const DeepCollectionEquality().hash(alcohol) ^
      const DeepCollectionEquality().hash(energyDrinks) ^
      const DeepCollectionEquality().hash(statEnhancers) ^
      const DeepCollectionEquality().hash(easterEggs) ^
      runtimeType.hashCode;
}

extension $PersonalStatsItemsPopular$Items$UsedExtension on PersonalStatsItemsPopular$Items$Used {
  PersonalStatsItemsPopular$Items$Used copyWith({
    int? books,
    int? boosters,
    int? consumables,
    int? candy,
    int? alcohol,
    int? energyDrinks,
    int? statEnhancers,
    int? easterEggs,
  }) {
    return PersonalStatsItemsPopular$Items$Used(
      books: books ?? this.books,
      boosters: boosters ?? this.boosters,
      consumables: consumables ?? this.consumables,
      candy: candy ?? this.candy,
      alcohol: alcohol ?? this.alcohol,
      energyDrinks: energyDrinks ?? this.energyDrinks,
      statEnhancers: statEnhancers ?? this.statEnhancers,
      easterEggs: easterEggs ?? this.easterEggs,
    );
  }

  PersonalStatsItemsPopular$Items$Used copyWithWrapped({
    Wrapped<int>? books,
    Wrapped<int>? boosters,
    Wrapped<int>? consumables,
    Wrapped<int>? candy,
    Wrapped<int>? alcohol,
    Wrapped<int>? energyDrinks,
    Wrapped<int>? statEnhancers,
    Wrapped<int>? easterEggs,
  }) {
    return PersonalStatsItemsPopular$Items$Used(
      books: (books != null ? books.value : this.books),
      boosters: (boosters != null ? boosters.value : this.boosters),
      consumables: (consumables != null ? consumables.value : this.consumables),
      candy: (candy != null ? candy.value : this.candy),
      alcohol: (alcohol != null ? alcohol.value : this.alcohol),
      energyDrinks: (energyDrinks != null ? energyDrinks.value : this.energyDrinks),
      statEnhancers: (statEnhancers != null ? statEnhancers.value : this.statEnhancers),
      easterEggs: (easterEggs != null ? easterEggs.value : this.easterEggs),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsInvestments$Investments$Bank {
  const PersonalStatsInvestments$Investments$Bank({
    required this.total,
    required this.profit,
    required this.current,
    required this.timeRemaining,
  });

  factory PersonalStatsInvestments$Investments$Bank.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$PersonalStatsInvestments$Investments$BankFromJson(json);

  static const toJsonFactory = _$PersonalStatsInvestments$Investments$BankToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsInvestments$Investments$BankToJson(this);

  @JsonKey(name: 'total')
  final int total;
  @JsonKey(name: 'profit')
  final int profit;
  @JsonKey(name: 'current')
  final int current;
  @JsonKey(name: 'time_remaining')
  final int timeRemaining;
  static const fromJsonFactory = _$PersonalStatsInvestments$Investments$BankFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsInvestments$Investments$Bank &&
            (identical(other.total, total) || const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.profit, profit) || const DeepCollectionEquality().equals(other.profit, profit)) &&
            (identical(other.current, current) ||
                const DeepCollectionEquality().equals(
                  other.current,
                  current,
                )) &&
            (identical(other.timeRemaining, timeRemaining) ||
                const DeepCollectionEquality().equals(
                  other.timeRemaining,
                  timeRemaining,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(profit) ^
      const DeepCollectionEquality().hash(current) ^
      const DeepCollectionEquality().hash(timeRemaining) ^
      runtimeType.hashCode;
}

extension $PersonalStatsInvestments$Investments$BankExtension on PersonalStatsInvestments$Investments$Bank {
  PersonalStatsInvestments$Investments$Bank copyWith({
    int? total,
    int? profit,
    int? current,
    int? timeRemaining,
  }) {
    return PersonalStatsInvestments$Investments$Bank(
      total: total ?? this.total,
      profit: profit ?? this.profit,
      current: current ?? this.current,
      timeRemaining: timeRemaining ?? this.timeRemaining,
    );
  }

  PersonalStatsInvestments$Investments$Bank copyWithWrapped({
    Wrapped<int>? total,
    Wrapped<int>? profit,
    Wrapped<int>? current,
    Wrapped<int>? timeRemaining,
  }) {
    return PersonalStatsInvestments$Investments$Bank(
      total: (total != null ? total.value : this.total),
      profit: (profit != null ? profit.value : this.profit),
      current: (current != null ? current.value : this.current),
      timeRemaining: (timeRemaining != null ? timeRemaining.value : this.timeRemaining),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsInvestments$Investments$Stocks {
  const PersonalStatsInvestments$Investments$Stocks({
    required this.profits,
    required this.losses,
    required this.fees,
    required this.netProfits,
    required this.payouts,
  });

  factory PersonalStatsInvestments$Investments$Stocks.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$PersonalStatsInvestments$Investments$StocksFromJson(json);

  static const toJsonFactory = _$PersonalStatsInvestments$Investments$StocksToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsInvestments$Investments$StocksToJson(this);

  @JsonKey(name: 'profits')
  final int profits;
  @JsonKey(name: 'losses')
  final int losses;
  @JsonKey(name: 'fees')
  final int fees;
  @JsonKey(name: 'net_profits')
  final int netProfits;
  @JsonKey(name: 'payouts')
  final int payouts;
  static const fromJsonFactory = _$PersonalStatsInvestments$Investments$StocksFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsInvestments$Investments$Stocks &&
            (identical(other.profits, profits) ||
                const DeepCollectionEquality().equals(
                  other.profits,
                  profits,
                )) &&
            (identical(other.losses, losses) || const DeepCollectionEquality().equals(other.losses, losses)) &&
            (identical(other.fees, fees) || const DeepCollectionEquality().equals(other.fees, fees)) &&
            (identical(other.netProfits, netProfits) ||
                const DeepCollectionEquality().equals(
                  other.netProfits,
                  netProfits,
                )) &&
            (identical(other.payouts, payouts) || const DeepCollectionEquality().equals(other.payouts, payouts)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(profits) ^
      const DeepCollectionEquality().hash(losses) ^
      const DeepCollectionEquality().hash(fees) ^
      const DeepCollectionEquality().hash(netProfits) ^
      const DeepCollectionEquality().hash(payouts) ^
      runtimeType.hashCode;
}

extension $PersonalStatsInvestments$Investments$StocksExtension on PersonalStatsInvestments$Investments$Stocks {
  PersonalStatsInvestments$Investments$Stocks copyWith({
    int? profits,
    int? losses,
    int? fees,
    int? netProfits,
    int? payouts,
  }) {
    return PersonalStatsInvestments$Investments$Stocks(
      profits: profits ?? this.profits,
      losses: losses ?? this.losses,
      fees: fees ?? this.fees,
      netProfits: netProfits ?? this.netProfits,
      payouts: payouts ?? this.payouts,
    );
  }

  PersonalStatsInvestments$Investments$Stocks copyWithWrapped({
    Wrapped<int>? profits,
    Wrapped<int>? losses,
    Wrapped<int>? fees,
    Wrapped<int>? netProfits,
    Wrapped<int>? payouts,
  }) {
    return PersonalStatsInvestments$Investments$Stocks(
      profits: (profits != null ? profits.value : this.profits),
      losses: (losses != null ? losses.value : this.losses),
      fees: (fees != null ? fees.value : this.fees),
      netProfits: (netProfits != null ? netProfits.value : this.netProfits),
      payouts: (payouts != null ? payouts.value : this.payouts),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsBounties$Bounties$Placed {
  const PersonalStatsBounties$Bounties$Placed({
    required this.amount,
    required this.$value,
  });

  factory PersonalStatsBounties$Bounties$Placed.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$PersonalStatsBounties$Bounties$PlacedFromJson(json);

  static const toJsonFactory = _$PersonalStatsBounties$Bounties$PlacedToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsBounties$Bounties$PlacedToJson(this);

  @JsonKey(name: 'amount')
  final int amount;
  @JsonKey(name: 'value')
  final int $value;
  static const fromJsonFactory = _$PersonalStatsBounties$Bounties$PlacedFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsBounties$Bounties$Placed &&
            (identical(other.amount, amount) || const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.$value, $value) || const DeepCollectionEquality().equals(other.$value, $value)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(amount) ^ const DeepCollectionEquality().hash($value) ^ runtimeType.hashCode;
}

extension $PersonalStatsBounties$Bounties$PlacedExtension on PersonalStatsBounties$Bounties$Placed {
  PersonalStatsBounties$Bounties$Placed copyWith({int? amount, int? $value}) {
    return PersonalStatsBounties$Bounties$Placed(
      amount: amount ?? this.amount,
      $value: $value ?? this.$value,
    );
  }

  PersonalStatsBounties$Bounties$Placed copyWithWrapped({
    Wrapped<int>? amount,
    Wrapped<int>? $value,
  }) {
    return PersonalStatsBounties$Bounties$Placed(
      amount: (amount != null ? amount.value : this.amount),
      $value: ($value != null ? $value.value : this.$value),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsBounties$Bounties$Collected {
  const PersonalStatsBounties$Bounties$Collected({
    required this.amount,
    required this.$value,
  });

  factory PersonalStatsBounties$Bounties$Collected.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$PersonalStatsBounties$Bounties$CollectedFromJson(json);

  static const toJsonFactory = _$PersonalStatsBounties$Bounties$CollectedToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsBounties$Bounties$CollectedToJson(this);

  @JsonKey(name: 'amount')
  final int amount;
  @JsonKey(name: 'value')
  final int $value;
  static const fromJsonFactory = _$PersonalStatsBounties$Bounties$CollectedFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsBounties$Bounties$Collected &&
            (identical(other.amount, amount) || const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.$value, $value) || const DeepCollectionEquality().equals(other.$value, $value)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(amount) ^ const DeepCollectionEquality().hash($value) ^ runtimeType.hashCode;
}

extension $PersonalStatsBounties$Bounties$CollectedExtension on PersonalStatsBounties$Bounties$Collected {
  PersonalStatsBounties$Bounties$Collected copyWith({
    int? amount,
    int? $value,
  }) {
    return PersonalStatsBounties$Bounties$Collected(
      amount: amount ?? this.amount,
      $value: $value ?? this.$value,
    );
  }

  PersonalStatsBounties$Bounties$Collected copyWithWrapped({
    Wrapped<int>? amount,
    Wrapped<int>? $value,
  }) {
    return PersonalStatsBounties$Bounties$Collected(
      amount: (amount != null ? amount.value : this.amount),
      $value: ($value != null ? $value.value : this.$value),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsBounties$Bounties$Received {
  const PersonalStatsBounties$Bounties$Received({
    required this.amount,
    required this.$value,
  });

  factory PersonalStatsBounties$Bounties$Received.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$PersonalStatsBounties$Bounties$ReceivedFromJson(json);

  static const toJsonFactory = _$PersonalStatsBounties$Bounties$ReceivedToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsBounties$Bounties$ReceivedToJson(this);

  @JsonKey(name: 'amount')
  final int amount;
  @JsonKey(name: 'value')
  final int $value;
  static const fromJsonFactory = _$PersonalStatsBounties$Bounties$ReceivedFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsBounties$Bounties$Received &&
            (identical(other.amount, amount) || const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.$value, $value) || const DeepCollectionEquality().equals(other.$value, $value)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(amount) ^ const DeepCollectionEquality().hash($value) ^ runtimeType.hashCode;
}

extension $PersonalStatsBounties$Bounties$ReceivedExtension on PersonalStatsBounties$Bounties$Received {
  PersonalStatsBounties$Bounties$Received copyWith({int? amount, int? $value}) {
    return PersonalStatsBounties$Bounties$Received(
      amount: amount ?? this.amount,
      $value: $value ?? this.$value,
    );
  }

  PersonalStatsBounties$Bounties$Received copyWithWrapped({
    Wrapped<int>? amount,
    Wrapped<int>? $value,
  }) {
    return PersonalStatsBounties$Bounties$Received(
      amount: (amount != null ? amount.value : this.amount),
      $value: ($value != null ? $value.value : this.$value),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsCommunication$Communication$MailsSent {
  const PersonalStatsCommunication$Communication$MailsSent({
    required this.total,
    required this.friends,
    required this.faction,
    required this.colleagues,
    required this.spouse,
  });

  factory PersonalStatsCommunication$Communication$MailsSent.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$PersonalStatsCommunication$Communication$MailsSentFromJson(json);

  static const toJsonFactory = _$PersonalStatsCommunication$Communication$MailsSentToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsCommunication$Communication$MailsSentToJson(this);

  @JsonKey(name: 'total')
  final int total;
  @JsonKey(name: 'friends')
  final int friends;
  @JsonKey(name: 'faction')
  final int faction;
  @JsonKey(name: 'colleagues')
  final int colleagues;
  @JsonKey(name: 'spouse')
  final int spouse;
  static const fromJsonFactory = _$PersonalStatsCommunication$Communication$MailsSentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsCommunication$Communication$MailsSent &&
            (identical(other.total, total) || const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.friends, friends) ||
                const DeepCollectionEquality().equals(
                  other.friends,
                  friends,
                )) &&
            (identical(other.faction, faction) ||
                const DeepCollectionEquality().equals(
                  other.faction,
                  faction,
                )) &&
            (identical(other.colleagues, colleagues) ||
                const DeepCollectionEquality().equals(
                  other.colleagues,
                  colleagues,
                )) &&
            (identical(other.spouse, spouse) || const DeepCollectionEquality().equals(other.spouse, spouse)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(friends) ^
      const DeepCollectionEquality().hash(faction) ^
      const DeepCollectionEquality().hash(colleagues) ^
      const DeepCollectionEquality().hash(spouse) ^
      runtimeType.hashCode;
}

extension $PersonalStatsCommunication$Communication$MailsSentExtension
    on PersonalStatsCommunication$Communication$MailsSent {
  PersonalStatsCommunication$Communication$MailsSent copyWith({
    int? total,
    int? friends,
    int? faction,
    int? colleagues,
    int? spouse,
  }) {
    return PersonalStatsCommunication$Communication$MailsSent(
      total: total ?? this.total,
      friends: friends ?? this.friends,
      faction: faction ?? this.faction,
      colleagues: colleagues ?? this.colleagues,
      spouse: spouse ?? this.spouse,
    );
  }

  PersonalStatsCommunication$Communication$MailsSent copyWithWrapped({
    Wrapped<int>? total,
    Wrapped<int>? friends,
    Wrapped<int>? faction,
    Wrapped<int>? colleagues,
    Wrapped<int>? spouse,
  }) {
    return PersonalStatsCommunication$Communication$MailsSent(
      total: (total != null ? total.value : this.total),
      friends: (friends != null ? friends.value : this.friends),
      faction: (faction != null ? faction.value : this.faction),
      colleagues: (colleagues != null ? colleagues.value : this.colleagues),
      spouse: (spouse != null ? spouse.value : this.spouse),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsHospital$Hospital$Reviving {
  const PersonalStatsHospital$Hospital$Reviving({
    required this.skill,
    required this.revives,
    required this.revivesReceived,
  });

  factory PersonalStatsHospital$Hospital$Reviving.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$PersonalStatsHospital$Hospital$RevivingFromJson(json);

  static const toJsonFactory = _$PersonalStatsHospital$Hospital$RevivingToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsHospital$Hospital$RevivingToJson(this);

  @JsonKey(name: 'skill')
  final int skill;
  @JsonKey(name: 'revives')
  final int revives;
  @JsonKey(name: 'revives_received')
  final int revivesReceived;
  static const fromJsonFactory = _$PersonalStatsHospital$Hospital$RevivingFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsHospital$Hospital$Reviving &&
            (identical(other.skill, skill) || const DeepCollectionEquality().equals(other.skill, skill)) &&
            (identical(other.revives, revives) ||
                const DeepCollectionEquality().equals(
                  other.revives,
                  revives,
                )) &&
            (identical(other.revivesReceived, revivesReceived) ||
                const DeepCollectionEquality().equals(
                  other.revivesReceived,
                  revivesReceived,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(skill) ^
      const DeepCollectionEquality().hash(revives) ^
      const DeepCollectionEquality().hash(revivesReceived) ^
      runtimeType.hashCode;
}

extension $PersonalStatsHospital$Hospital$RevivingExtension on PersonalStatsHospital$Hospital$Reviving {
  PersonalStatsHospital$Hospital$Reviving copyWith({
    int? skill,
    int? revives,
    int? revivesReceived,
  }) {
    return PersonalStatsHospital$Hospital$Reviving(
      skill: skill ?? this.skill,
      revives: revives ?? this.revives,
      revivesReceived: revivesReceived ?? this.revivesReceived,
    );
  }

  PersonalStatsHospital$Hospital$Reviving copyWithWrapped({
    Wrapped<int>? skill,
    Wrapped<int>? revives,
    Wrapped<int>? revivesReceived,
  }) {
    return PersonalStatsHospital$Hospital$Reviving(
      skill: (skill != null ? skill.value : this.skill),
      revives: (revives != null ? revives.value : this.revives),
      revivesReceived: (revivesReceived != null ? revivesReceived.value : this.revivesReceived),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsHospitalPopular$Hospital$Reviving {
  const PersonalStatsHospitalPopular$Hospital$Reviving({
    required this.skill,
    required this.revives,
  });

  factory PersonalStatsHospitalPopular$Hospital$Reviving.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$PersonalStatsHospitalPopular$Hospital$RevivingFromJson(json);

  static const toJsonFactory = _$PersonalStatsHospitalPopular$Hospital$RevivingToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsHospitalPopular$Hospital$RevivingToJson(this);

  @JsonKey(name: 'skill')
  final int skill;
  @JsonKey(name: 'revives')
  final int revives;
  static const fromJsonFactory = _$PersonalStatsHospitalPopular$Hospital$RevivingFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsHospitalPopular$Hospital$Reviving &&
            (identical(other.skill, skill) || const DeepCollectionEquality().equals(other.skill, skill)) &&
            (identical(other.revives, revives) || const DeepCollectionEquality().equals(other.revives, revives)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(skill) ^ const DeepCollectionEquality().hash(revives) ^ runtimeType.hashCode;
}

extension $PersonalStatsHospitalPopular$Hospital$RevivingExtension on PersonalStatsHospitalPopular$Hospital$Reviving {
  PersonalStatsHospitalPopular$Hospital$Reviving copyWith({
    int? skill,
    int? revives,
  }) {
    return PersonalStatsHospitalPopular$Hospital$Reviving(
      skill: skill ?? this.skill,
      revives: revives ?? this.revives,
    );
  }

  PersonalStatsHospitalPopular$Hospital$Reviving copyWithWrapped({
    Wrapped<int>? skill,
    Wrapped<int>? revives,
  }) {
    return PersonalStatsHospitalPopular$Hospital$Reviving(
      skill: (skill != null ? skill.value : this.skill),
      revives: (revives != null ? revives.value : this.revives),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsJail$Jail$Busts {
  const PersonalStatsJail$Jail$Busts({
    required this.success,
    required this.fails,
  });

  factory PersonalStatsJail$Jail$Busts.fromJson(Map<String, dynamic> json) =>
      _$PersonalStatsJail$Jail$BustsFromJson(json);

  static const toJsonFactory = _$PersonalStatsJail$Jail$BustsToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsJail$Jail$BustsToJson(this);

  @JsonKey(name: 'success')
  final int success;
  @JsonKey(name: 'fails')
  final int fails;
  static const fromJsonFactory = _$PersonalStatsJail$Jail$BustsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsJail$Jail$Busts &&
            (identical(other.success, success) ||
                const DeepCollectionEquality().equals(
                  other.success,
                  success,
                )) &&
            (identical(other.fails, fails) || const DeepCollectionEquality().equals(other.fails, fails)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(success) ^ const DeepCollectionEquality().hash(fails) ^ runtimeType.hashCode;
}

extension $PersonalStatsJail$Jail$BustsExtension on PersonalStatsJail$Jail$Busts {
  PersonalStatsJail$Jail$Busts copyWith({int? success, int? fails}) {
    return PersonalStatsJail$Jail$Busts(
      success: success ?? this.success,
      fails: fails ?? this.fails,
    );
  }

  PersonalStatsJail$Jail$Busts copyWithWrapped({
    Wrapped<int>? success,
    Wrapped<int>? fails,
  }) {
    return PersonalStatsJail$Jail$Busts(
      success: (success != null ? success.value : this.success),
      fails: (fails != null ? fails.value : this.fails),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsJail$Jail$Bails {
  const PersonalStatsJail$Jail$Bails({
    required this.amount,
    required this.fees,
  });

  factory PersonalStatsJail$Jail$Bails.fromJson(Map<String, dynamic> json) =>
      _$PersonalStatsJail$Jail$BailsFromJson(json);

  static const toJsonFactory = _$PersonalStatsJail$Jail$BailsToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsJail$Jail$BailsToJson(this);

  @JsonKey(name: 'amount')
  final int amount;
  @JsonKey(name: 'fees')
  final int fees;
  static const fromJsonFactory = _$PersonalStatsJail$Jail$BailsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsJail$Jail$Bails &&
            (identical(other.amount, amount) || const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.fees, fees) || const DeepCollectionEquality().equals(other.fees, fees)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(amount) ^ const DeepCollectionEquality().hash(fees) ^ runtimeType.hashCode;
}

extension $PersonalStatsJail$Jail$BailsExtension on PersonalStatsJail$Jail$Bails {
  PersonalStatsJail$Jail$Bails copyWith({int? amount, int? fees}) {
    return PersonalStatsJail$Jail$Bails(
      amount: amount ?? this.amount,
      fees: fees ?? this.fees,
    );
  }

  PersonalStatsJail$Jail$Bails copyWithWrapped({
    Wrapped<int>? amount,
    Wrapped<int>? fees,
  }) {
    return PersonalStatsJail$Jail$Bails(
      amount: (amount != null ? amount.value : this.amount),
      fees: (fees != null ? fees.value : this.fees),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsTrading$Trading$Items {
  const PersonalStatsTrading$Trading$Items({
    required this.bought,
    required this.auctions,
    required this.sent,
  });

  factory PersonalStatsTrading$Trading$Items.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$PersonalStatsTrading$Trading$ItemsFromJson(json);

  static const toJsonFactory = _$PersonalStatsTrading$Trading$ItemsToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsTrading$Trading$ItemsToJson(this);

  @JsonKey(name: 'bought')
  final PersonalStatsTrading$Trading$Items$Bought bought;
  @JsonKey(name: 'auctions')
  final PersonalStatsTrading$Trading$Items$Auctions auctions;
  @JsonKey(name: 'sent')
  final int sent;
  static const fromJsonFactory = _$PersonalStatsTrading$Trading$ItemsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsTrading$Trading$Items &&
            (identical(other.bought, bought) || const DeepCollectionEquality().equals(other.bought, bought)) &&
            (identical(other.auctions, auctions) ||
                const DeepCollectionEquality().equals(
                  other.auctions,
                  auctions,
                )) &&
            (identical(other.sent, sent) || const DeepCollectionEquality().equals(other.sent, sent)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(bought) ^
      const DeepCollectionEquality().hash(auctions) ^
      const DeepCollectionEquality().hash(sent) ^
      runtimeType.hashCode;
}

extension $PersonalStatsTrading$Trading$ItemsExtension on PersonalStatsTrading$Trading$Items {
  PersonalStatsTrading$Trading$Items copyWith({
    PersonalStatsTrading$Trading$Items$Bought? bought,
    PersonalStatsTrading$Trading$Items$Auctions? auctions,
    int? sent,
  }) {
    return PersonalStatsTrading$Trading$Items(
      bought: bought ?? this.bought,
      auctions: auctions ?? this.auctions,
      sent: sent ?? this.sent,
    );
  }

  PersonalStatsTrading$Trading$Items copyWithWrapped({
    Wrapped<PersonalStatsTrading$Trading$Items$Bought>? bought,
    Wrapped<PersonalStatsTrading$Trading$Items$Auctions>? auctions,
    Wrapped<int>? sent,
  }) {
    return PersonalStatsTrading$Trading$Items(
      bought: (bought != null ? bought.value : this.bought),
      auctions: (auctions != null ? auctions.value : this.auctions),
      sent: (sent != null ? sent.value : this.sent),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsTrading$Trading$Points {
  const PersonalStatsTrading$Trading$Points({
    required this.bought,
    required this.sold,
  });

  factory PersonalStatsTrading$Trading$Points.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$PersonalStatsTrading$Trading$PointsFromJson(json);

  static const toJsonFactory = _$PersonalStatsTrading$Trading$PointsToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsTrading$Trading$PointsToJson(this);

  @JsonKey(name: 'bought')
  final int bought;
  @JsonKey(name: 'sold')
  final int sold;
  static const fromJsonFactory = _$PersonalStatsTrading$Trading$PointsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsTrading$Trading$Points &&
            (identical(other.bought, bought) || const DeepCollectionEquality().equals(other.bought, bought)) &&
            (identical(other.sold, sold) || const DeepCollectionEquality().equals(other.sold, sold)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(bought) ^ const DeepCollectionEquality().hash(sold) ^ runtimeType.hashCode;
}

extension $PersonalStatsTrading$Trading$PointsExtension on PersonalStatsTrading$Trading$Points {
  PersonalStatsTrading$Trading$Points copyWith({int? bought, int? sold}) {
    return PersonalStatsTrading$Trading$Points(
      bought: bought ?? this.bought,
      sold: sold ?? this.sold,
    );
  }

  PersonalStatsTrading$Trading$Points copyWithWrapped({
    Wrapped<int>? bought,
    Wrapped<int>? sold,
  }) {
    return PersonalStatsTrading$Trading$Points(
      bought: (bought != null ? bought.value : this.bought),
      sold: (sold != null ? sold.value : this.sold),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsTrading$Trading$Bazaar {
  const PersonalStatsTrading$Trading$Bazaar({
    required this.customers,
    required this.sales,
    required this.profit,
  });

  factory PersonalStatsTrading$Trading$Bazaar.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$PersonalStatsTrading$Trading$BazaarFromJson(json);

  static const toJsonFactory = _$PersonalStatsTrading$Trading$BazaarToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsTrading$Trading$BazaarToJson(this);

  @JsonKey(name: 'customers')
  final int customers;
  @JsonKey(name: 'sales')
  final int sales;
  @JsonKey(name: 'profit')
  final int profit;
  static const fromJsonFactory = _$PersonalStatsTrading$Trading$BazaarFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsTrading$Trading$Bazaar &&
            (identical(other.customers, customers) ||
                const DeepCollectionEquality().equals(
                  other.customers,
                  customers,
                )) &&
            (identical(other.sales, sales) || const DeepCollectionEquality().equals(other.sales, sales)) &&
            (identical(other.profit, profit) || const DeepCollectionEquality().equals(other.profit, profit)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(customers) ^
      const DeepCollectionEquality().hash(sales) ^
      const DeepCollectionEquality().hash(profit) ^
      runtimeType.hashCode;
}

extension $PersonalStatsTrading$Trading$BazaarExtension on PersonalStatsTrading$Trading$Bazaar {
  PersonalStatsTrading$Trading$Bazaar copyWith({
    int? customers,
    int? sales,
    int? profit,
  }) {
    return PersonalStatsTrading$Trading$Bazaar(
      customers: customers ?? this.customers,
      sales: sales ?? this.sales,
      profit: profit ?? this.profit,
    );
  }

  PersonalStatsTrading$Trading$Bazaar copyWithWrapped({
    Wrapped<int>? customers,
    Wrapped<int>? sales,
    Wrapped<int>? profit,
  }) {
    return PersonalStatsTrading$Trading$Bazaar(
      customers: (customers != null ? customers.value : this.customers),
      sales: (sales != null ? sales.value : this.sales),
      profit: (profit != null ? profit.value : this.profit),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsTrading$Trading$ItemMarket {
  const PersonalStatsTrading$Trading$ItemMarket({
    required this.customers,
    required this.sales,
    required this.revenue,
    required this.fees,
  });

  factory PersonalStatsTrading$Trading$ItemMarket.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$PersonalStatsTrading$Trading$ItemMarketFromJson(json);

  static const toJsonFactory = _$PersonalStatsTrading$Trading$ItemMarketToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsTrading$Trading$ItemMarketToJson(this);

  @JsonKey(name: 'customers')
  final int customers;
  @JsonKey(name: 'sales')
  final int sales;
  @JsonKey(name: 'revenue')
  final int revenue;
  @JsonKey(name: 'fees')
  final int fees;
  static const fromJsonFactory = _$PersonalStatsTrading$Trading$ItemMarketFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsTrading$Trading$ItemMarket &&
            (identical(other.customers, customers) ||
                const DeepCollectionEquality().equals(
                  other.customers,
                  customers,
                )) &&
            (identical(other.sales, sales) || const DeepCollectionEquality().equals(other.sales, sales)) &&
            (identical(other.revenue, revenue) ||
                const DeepCollectionEquality().equals(
                  other.revenue,
                  revenue,
                )) &&
            (identical(other.fees, fees) || const DeepCollectionEquality().equals(other.fees, fees)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(customers) ^
      const DeepCollectionEquality().hash(sales) ^
      const DeepCollectionEquality().hash(revenue) ^
      const DeepCollectionEquality().hash(fees) ^
      runtimeType.hashCode;
}

extension $PersonalStatsTrading$Trading$ItemMarketExtension on PersonalStatsTrading$Trading$ItemMarket {
  PersonalStatsTrading$Trading$ItemMarket copyWith({
    int? customers,
    int? sales,
    int? revenue,
    int? fees,
  }) {
    return PersonalStatsTrading$Trading$ItemMarket(
      customers: customers ?? this.customers,
      sales: sales ?? this.sales,
      revenue: revenue ?? this.revenue,
      fees: fees ?? this.fees,
    );
  }

  PersonalStatsTrading$Trading$ItemMarket copyWithWrapped({
    Wrapped<int>? customers,
    Wrapped<int>? sales,
    Wrapped<int>? revenue,
    Wrapped<int>? fees,
  }) {
    return PersonalStatsTrading$Trading$ItemMarket(
      customers: (customers != null ? customers.value : this.customers),
      sales: (sales != null ? sales.value : this.sales),
      revenue: (revenue != null ? revenue.value : this.revenue),
      fees: (fees != null ? fees.value : this.fees),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsJobsExtended$Jobs$Stats {
  const PersonalStatsJobsExtended$Jobs$Stats({
    required this.manual,
    required this.intelligence,
    required this.endurance,
    required this.total,
  });

  factory PersonalStatsJobsExtended$Jobs$Stats.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$PersonalStatsJobsExtended$Jobs$StatsFromJson(json);

  static const toJsonFactory = _$PersonalStatsJobsExtended$Jobs$StatsToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsJobsExtended$Jobs$StatsToJson(this);

  @JsonKey(name: 'manual')
  final int manual;
  @JsonKey(name: 'intelligence')
  final int intelligence;
  @JsonKey(name: 'endurance')
  final int endurance;
  @JsonKey(name: 'total')
  final int total;
  static const fromJsonFactory = _$PersonalStatsJobsExtended$Jobs$StatsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsJobsExtended$Jobs$Stats &&
            (identical(other.manual, manual) || const DeepCollectionEquality().equals(other.manual, manual)) &&
            (identical(other.intelligence, intelligence) ||
                const DeepCollectionEquality().equals(
                  other.intelligence,
                  intelligence,
                )) &&
            (identical(other.endurance, endurance) ||
                const DeepCollectionEquality().equals(
                  other.endurance,
                  endurance,
                )) &&
            (identical(other.total, total) || const DeepCollectionEquality().equals(other.total, total)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(manual) ^
      const DeepCollectionEquality().hash(intelligence) ^
      const DeepCollectionEquality().hash(endurance) ^
      const DeepCollectionEquality().hash(total) ^
      runtimeType.hashCode;
}

extension $PersonalStatsJobsExtended$Jobs$StatsExtension on PersonalStatsJobsExtended$Jobs$Stats {
  PersonalStatsJobsExtended$Jobs$Stats copyWith({
    int? manual,
    int? intelligence,
    int? endurance,
    int? total,
  }) {
    return PersonalStatsJobsExtended$Jobs$Stats(
      manual: manual ?? this.manual,
      intelligence: intelligence ?? this.intelligence,
      endurance: endurance ?? this.endurance,
      total: total ?? this.total,
    );
  }

  PersonalStatsJobsExtended$Jobs$Stats copyWithWrapped({
    Wrapped<int>? manual,
    Wrapped<int>? intelligence,
    Wrapped<int>? endurance,
    Wrapped<int>? total,
  }) {
    return PersonalStatsJobsExtended$Jobs$Stats(
      manual: (manual != null ? manual.value : this.manual),
      intelligence: (intelligence != null ? intelligence.value : this.intelligence),
      endurance: (endurance != null ? endurance.value : this.endurance),
      total: (total != null ? total.value : this.total),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsAttackingPublic$Attacking$Attacks {
  const PersonalStatsAttackingPublic$Attacking$Attacks({
    required this.won,
    required this.lost,
    required this.stalemate,
    required this.assist,
    required this.stealth,
  });

  factory PersonalStatsAttackingPublic$Attacking$Attacks.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$PersonalStatsAttackingPublic$Attacking$AttacksFromJson(json);

  static const toJsonFactory = _$PersonalStatsAttackingPublic$Attacking$AttacksToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsAttackingPublic$Attacking$AttacksToJson(this);

  @JsonKey(name: 'won')
  final int won;
  @JsonKey(name: 'lost')
  final int lost;
  @JsonKey(name: 'stalemate')
  final int stalemate;
  @JsonKey(name: 'assist')
  final int assist;
  @JsonKey(name: 'stealth')
  final int stealth;
  static const fromJsonFactory = _$PersonalStatsAttackingPublic$Attacking$AttacksFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsAttackingPublic$Attacking$Attacks &&
            (identical(other.won, won) || const DeepCollectionEquality().equals(other.won, won)) &&
            (identical(other.lost, lost) || const DeepCollectionEquality().equals(other.lost, lost)) &&
            (identical(other.stalemate, stalemate) ||
                const DeepCollectionEquality().equals(
                  other.stalemate,
                  stalemate,
                )) &&
            (identical(other.assist, assist) || const DeepCollectionEquality().equals(other.assist, assist)) &&
            (identical(other.stealth, stealth) || const DeepCollectionEquality().equals(other.stealth, stealth)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(won) ^
      const DeepCollectionEquality().hash(lost) ^
      const DeepCollectionEquality().hash(stalemate) ^
      const DeepCollectionEquality().hash(assist) ^
      const DeepCollectionEquality().hash(stealth) ^
      runtimeType.hashCode;
}

extension $PersonalStatsAttackingPublic$Attacking$AttacksExtension on PersonalStatsAttackingPublic$Attacking$Attacks {
  PersonalStatsAttackingPublic$Attacking$Attacks copyWith({
    int? won,
    int? lost,
    int? stalemate,
    int? assist,
    int? stealth,
  }) {
    return PersonalStatsAttackingPublic$Attacking$Attacks(
      won: won ?? this.won,
      lost: lost ?? this.lost,
      stalemate: stalemate ?? this.stalemate,
      assist: assist ?? this.assist,
      stealth: stealth ?? this.stealth,
    );
  }

  PersonalStatsAttackingPublic$Attacking$Attacks copyWithWrapped({
    Wrapped<int>? won,
    Wrapped<int>? lost,
    Wrapped<int>? stalemate,
    Wrapped<int>? assist,
    Wrapped<int>? stealth,
  }) {
    return PersonalStatsAttackingPublic$Attacking$Attacks(
      won: (won != null ? won.value : this.won),
      lost: (lost != null ? lost.value : this.lost),
      stalemate: (stalemate != null ? stalemate.value : this.stalemate),
      assist: (assist != null ? assist.value : this.assist),
      stealth: (stealth != null ? stealth.value : this.stealth),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsAttackingPublic$Attacking$Defends {
  const PersonalStatsAttackingPublic$Attacking$Defends({
    required this.won,
    required this.lost,
    required this.stalemate,
    required this.total,
  });

  factory PersonalStatsAttackingPublic$Attacking$Defends.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$PersonalStatsAttackingPublic$Attacking$DefendsFromJson(json);

  static const toJsonFactory = _$PersonalStatsAttackingPublic$Attacking$DefendsToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsAttackingPublic$Attacking$DefendsToJson(this);

  @JsonKey(name: 'won')
  final int won;
  @JsonKey(name: 'lost')
  final int lost;
  @JsonKey(name: 'stalemate')
  final int stalemate;
  @JsonKey(name: 'total')
  final int total;
  static const fromJsonFactory = _$PersonalStatsAttackingPublic$Attacking$DefendsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsAttackingPublic$Attacking$Defends &&
            (identical(other.won, won) || const DeepCollectionEquality().equals(other.won, won)) &&
            (identical(other.lost, lost) || const DeepCollectionEquality().equals(other.lost, lost)) &&
            (identical(other.stalemate, stalemate) ||
                const DeepCollectionEquality().equals(
                  other.stalemate,
                  stalemate,
                )) &&
            (identical(other.total, total) || const DeepCollectionEquality().equals(other.total, total)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(won) ^
      const DeepCollectionEquality().hash(lost) ^
      const DeepCollectionEquality().hash(stalemate) ^
      const DeepCollectionEquality().hash(total) ^
      runtimeType.hashCode;
}

extension $PersonalStatsAttackingPublic$Attacking$DefendsExtension on PersonalStatsAttackingPublic$Attacking$Defends {
  PersonalStatsAttackingPublic$Attacking$Defends copyWith({
    int? won,
    int? lost,
    int? stalemate,
    int? total,
  }) {
    return PersonalStatsAttackingPublic$Attacking$Defends(
      won: won ?? this.won,
      lost: lost ?? this.lost,
      stalemate: stalemate ?? this.stalemate,
      total: total ?? this.total,
    );
  }

  PersonalStatsAttackingPublic$Attacking$Defends copyWithWrapped({
    Wrapped<int>? won,
    Wrapped<int>? lost,
    Wrapped<int>? stalemate,
    Wrapped<int>? total,
  }) {
    return PersonalStatsAttackingPublic$Attacking$Defends(
      won: (won != null ? won.value : this.won),
      lost: (lost != null ? lost.value : this.lost),
      stalemate: (stalemate != null ? stalemate.value : this.stalemate),
      total: (total != null ? total.value : this.total),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsAttackingPublic$Attacking$Escapes {
  const PersonalStatsAttackingPublic$Attacking$Escapes({
    required this.player,
    required this.foes,
  });

  factory PersonalStatsAttackingPublic$Attacking$Escapes.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$PersonalStatsAttackingPublic$Attacking$EscapesFromJson(json);

  static const toJsonFactory = _$PersonalStatsAttackingPublic$Attacking$EscapesToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsAttackingPublic$Attacking$EscapesToJson(this);

  @JsonKey(name: 'player')
  final int player;
  @JsonKey(name: 'foes')
  final int foes;
  static const fromJsonFactory = _$PersonalStatsAttackingPublic$Attacking$EscapesFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsAttackingPublic$Attacking$Escapes &&
            (identical(other.player, player) || const DeepCollectionEquality().equals(other.player, player)) &&
            (identical(other.foes, foes) || const DeepCollectionEquality().equals(other.foes, foes)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(player) ^ const DeepCollectionEquality().hash(foes) ^ runtimeType.hashCode;
}

extension $PersonalStatsAttackingPublic$Attacking$EscapesExtension on PersonalStatsAttackingPublic$Attacking$Escapes {
  PersonalStatsAttackingPublic$Attacking$Escapes copyWith({
    int? player,
    int? foes,
  }) {
    return PersonalStatsAttackingPublic$Attacking$Escapes(
      player: player ?? this.player,
      foes: foes ?? this.foes,
    );
  }

  PersonalStatsAttackingPublic$Attacking$Escapes copyWithWrapped({
    Wrapped<int>? player,
    Wrapped<int>? foes,
  }) {
    return PersonalStatsAttackingPublic$Attacking$Escapes(
      player: (player != null ? player.value : this.player),
      foes: (foes != null ? foes.value : this.foes),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsAttackingPublic$Attacking$Killstreak {
  const PersonalStatsAttackingPublic$Attacking$Killstreak({required this.best});

  factory PersonalStatsAttackingPublic$Attacking$Killstreak.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$PersonalStatsAttackingPublic$Attacking$KillstreakFromJson(json);

  static const toJsonFactory = _$PersonalStatsAttackingPublic$Attacking$KillstreakToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsAttackingPublic$Attacking$KillstreakToJson(this);

  @JsonKey(name: 'best')
  final int best;
  static const fromJsonFactory = _$PersonalStatsAttackingPublic$Attacking$KillstreakFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsAttackingPublic$Attacking$Killstreak &&
            (identical(other.best, best) || const DeepCollectionEquality().equals(other.best, best)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(best) ^ runtimeType.hashCode;
}

extension $PersonalStatsAttackingPublic$Attacking$KillstreakExtension
    on PersonalStatsAttackingPublic$Attacking$Killstreak {
  PersonalStatsAttackingPublic$Attacking$Killstreak copyWith({int? best}) {
    return PersonalStatsAttackingPublic$Attacking$Killstreak(
      best: best ?? this.best,
    );
  }

  PersonalStatsAttackingPublic$Attacking$Killstreak copyWithWrapped({
    Wrapped<int>? best,
  }) {
    return PersonalStatsAttackingPublic$Attacking$Killstreak(
      best: (best != null ? best.value : this.best),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsAttackingPublic$Attacking$Hits {
  const PersonalStatsAttackingPublic$Attacking$Hits({
    required this.success,
    required this.miss,
    required this.critical,
    required this.oneHitKills,
  });

  factory PersonalStatsAttackingPublic$Attacking$Hits.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$PersonalStatsAttackingPublic$Attacking$HitsFromJson(json);

  static const toJsonFactory = _$PersonalStatsAttackingPublic$Attacking$HitsToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsAttackingPublic$Attacking$HitsToJson(this);

  @JsonKey(name: 'success')
  final int success;
  @JsonKey(name: 'miss')
  final int miss;
  @JsonKey(name: 'critical')
  final int critical;
  @JsonKey(name: 'one_hit_kills')
  final int oneHitKills;
  static const fromJsonFactory = _$PersonalStatsAttackingPublic$Attacking$HitsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsAttackingPublic$Attacking$Hits &&
            (identical(other.success, success) ||
                const DeepCollectionEquality().equals(
                  other.success,
                  success,
                )) &&
            (identical(other.miss, miss) || const DeepCollectionEquality().equals(other.miss, miss)) &&
            (identical(other.critical, critical) ||
                const DeepCollectionEquality().equals(
                  other.critical,
                  critical,
                )) &&
            (identical(other.oneHitKills, oneHitKills) ||
                const DeepCollectionEquality().equals(
                  other.oneHitKills,
                  oneHitKills,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(success) ^
      const DeepCollectionEquality().hash(miss) ^
      const DeepCollectionEquality().hash(critical) ^
      const DeepCollectionEquality().hash(oneHitKills) ^
      runtimeType.hashCode;
}

extension $PersonalStatsAttackingPublic$Attacking$HitsExtension on PersonalStatsAttackingPublic$Attacking$Hits {
  PersonalStatsAttackingPublic$Attacking$Hits copyWith({
    int? success,
    int? miss,
    int? critical,
    int? oneHitKills,
  }) {
    return PersonalStatsAttackingPublic$Attacking$Hits(
      success: success ?? this.success,
      miss: miss ?? this.miss,
      critical: critical ?? this.critical,
      oneHitKills: oneHitKills ?? this.oneHitKills,
    );
  }

  PersonalStatsAttackingPublic$Attacking$Hits copyWithWrapped({
    Wrapped<int>? success,
    Wrapped<int>? miss,
    Wrapped<int>? critical,
    Wrapped<int>? oneHitKills,
  }) {
    return PersonalStatsAttackingPublic$Attacking$Hits(
      success: (success != null ? success.value : this.success),
      miss: (miss != null ? miss.value : this.miss),
      critical: (critical != null ? critical.value : this.critical),
      oneHitKills: (oneHitKills != null ? oneHitKills.value : this.oneHitKills),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsAttackingPublic$Attacking$Damage {
  const PersonalStatsAttackingPublic$Attacking$Damage({
    required this.total,
    required this.best,
  });

  factory PersonalStatsAttackingPublic$Attacking$Damage.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$PersonalStatsAttackingPublic$Attacking$DamageFromJson(json);

  static const toJsonFactory = _$PersonalStatsAttackingPublic$Attacking$DamageToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsAttackingPublic$Attacking$DamageToJson(this);

  @JsonKey(name: 'total')
  final int total;
  @JsonKey(name: 'best')
  final int best;
  static const fromJsonFactory = _$PersonalStatsAttackingPublic$Attacking$DamageFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsAttackingPublic$Attacking$Damage &&
            (identical(other.total, total) || const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.best, best) || const DeepCollectionEquality().equals(other.best, best)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(total) ^ const DeepCollectionEquality().hash(best) ^ runtimeType.hashCode;
}

extension $PersonalStatsAttackingPublic$Attacking$DamageExtension on PersonalStatsAttackingPublic$Attacking$Damage {
  PersonalStatsAttackingPublic$Attacking$Damage copyWith({
    int? total,
    int? best,
  }) {
    return PersonalStatsAttackingPublic$Attacking$Damage(
      total: total ?? this.total,
      best: best ?? this.best,
    );
  }

  PersonalStatsAttackingPublic$Attacking$Damage copyWithWrapped({
    Wrapped<int>? total,
    Wrapped<int>? best,
  }) {
    return PersonalStatsAttackingPublic$Attacking$Damage(
      total: (total != null ? total.value : this.total),
      best: (best != null ? best.value : this.best),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsAttackingPublic$Attacking$Networth {
  const PersonalStatsAttackingPublic$Attacking$Networth({
    required this.moneyMugged,
    required this.largestMug,
    required this.itemsLooted,
  });

  factory PersonalStatsAttackingPublic$Attacking$Networth.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$PersonalStatsAttackingPublic$Attacking$NetworthFromJson(json);

  static const toJsonFactory = _$PersonalStatsAttackingPublic$Attacking$NetworthToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsAttackingPublic$Attacking$NetworthToJson(this);

  @JsonKey(name: 'money_mugged')
  final int moneyMugged;
  @JsonKey(name: 'largest_mug')
  final int largestMug;
  @JsonKey(name: 'items_looted')
  final int itemsLooted;
  static const fromJsonFactory = _$PersonalStatsAttackingPublic$Attacking$NetworthFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsAttackingPublic$Attacking$Networth &&
            (identical(other.moneyMugged, moneyMugged) ||
                const DeepCollectionEquality().equals(
                  other.moneyMugged,
                  moneyMugged,
                )) &&
            (identical(other.largestMug, largestMug) ||
                const DeepCollectionEquality().equals(
                  other.largestMug,
                  largestMug,
                )) &&
            (identical(other.itemsLooted, itemsLooted) ||
                const DeepCollectionEquality().equals(
                  other.itemsLooted,
                  itemsLooted,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(moneyMugged) ^
      const DeepCollectionEquality().hash(largestMug) ^
      const DeepCollectionEquality().hash(itemsLooted) ^
      runtimeType.hashCode;
}

extension $PersonalStatsAttackingPublic$Attacking$NetworthExtension on PersonalStatsAttackingPublic$Attacking$Networth {
  PersonalStatsAttackingPublic$Attacking$Networth copyWith({
    int? moneyMugged,
    int? largestMug,
    int? itemsLooted,
  }) {
    return PersonalStatsAttackingPublic$Attacking$Networth(
      moneyMugged: moneyMugged ?? this.moneyMugged,
      largestMug: largestMug ?? this.largestMug,
      itemsLooted: itemsLooted ?? this.itemsLooted,
    );
  }

  PersonalStatsAttackingPublic$Attacking$Networth copyWithWrapped({
    Wrapped<int>? moneyMugged,
    Wrapped<int>? largestMug,
    Wrapped<int>? itemsLooted,
  }) {
    return PersonalStatsAttackingPublic$Attacking$Networth(
      moneyMugged: (moneyMugged != null ? moneyMugged.value : this.moneyMugged),
      largestMug: (largestMug != null ? largestMug.value : this.largestMug),
      itemsLooted: (itemsLooted != null ? itemsLooted.value : this.itemsLooted),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsAttackingPublic$Attacking$Ammunition {
  const PersonalStatsAttackingPublic$Attacking$Ammunition({
    required this.total,
    required this.special,
    required this.hollowPoint,
    required this.tracer,
    required this.piercing,
    required this.incendiary,
  });

  factory PersonalStatsAttackingPublic$Attacking$Ammunition.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$PersonalStatsAttackingPublic$Attacking$AmmunitionFromJson(json);

  static const toJsonFactory = _$PersonalStatsAttackingPublic$Attacking$AmmunitionToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsAttackingPublic$Attacking$AmmunitionToJson(this);

  @JsonKey(name: 'total')
  final int total;
  @JsonKey(name: 'special')
  final int special;
  @JsonKey(name: 'hollow_point')
  final int hollowPoint;
  @JsonKey(name: 'tracer')
  final int tracer;
  @JsonKey(name: 'piercing')
  final int piercing;
  @JsonKey(name: 'incendiary')
  final int incendiary;
  static const fromJsonFactory = _$PersonalStatsAttackingPublic$Attacking$AmmunitionFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsAttackingPublic$Attacking$Ammunition &&
            (identical(other.total, total) || const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.special, special) ||
                const DeepCollectionEquality().equals(
                  other.special,
                  special,
                )) &&
            (identical(other.hollowPoint, hollowPoint) ||
                const DeepCollectionEquality().equals(
                  other.hollowPoint,
                  hollowPoint,
                )) &&
            (identical(other.tracer, tracer) || const DeepCollectionEquality().equals(other.tracer, tracer)) &&
            (identical(other.piercing, piercing) ||
                const DeepCollectionEquality().equals(
                  other.piercing,
                  piercing,
                )) &&
            (identical(other.incendiary, incendiary) ||
                const DeepCollectionEquality().equals(
                  other.incendiary,
                  incendiary,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(special) ^
      const DeepCollectionEquality().hash(hollowPoint) ^
      const DeepCollectionEquality().hash(tracer) ^
      const DeepCollectionEquality().hash(piercing) ^
      const DeepCollectionEquality().hash(incendiary) ^
      runtimeType.hashCode;
}

extension $PersonalStatsAttackingPublic$Attacking$AmmunitionExtension
    on PersonalStatsAttackingPublic$Attacking$Ammunition {
  PersonalStatsAttackingPublic$Attacking$Ammunition copyWith({
    int? total,
    int? special,
    int? hollowPoint,
    int? tracer,
    int? piercing,
    int? incendiary,
  }) {
    return PersonalStatsAttackingPublic$Attacking$Ammunition(
      total: total ?? this.total,
      special: special ?? this.special,
      hollowPoint: hollowPoint ?? this.hollowPoint,
      tracer: tracer ?? this.tracer,
      piercing: piercing ?? this.piercing,
      incendiary: incendiary ?? this.incendiary,
    );
  }

  PersonalStatsAttackingPublic$Attacking$Ammunition copyWithWrapped({
    Wrapped<int>? total,
    Wrapped<int>? special,
    Wrapped<int>? hollowPoint,
    Wrapped<int>? tracer,
    Wrapped<int>? piercing,
    Wrapped<int>? incendiary,
  }) {
    return PersonalStatsAttackingPublic$Attacking$Ammunition(
      total: (total != null ? total.value : this.total),
      special: (special != null ? special.value : this.special),
      hollowPoint: (hollowPoint != null ? hollowPoint.value : this.hollowPoint),
      tracer: (tracer != null ? tracer.value : this.tracer),
      piercing: (piercing != null ? piercing.value : this.piercing),
      incendiary: (incendiary != null ? incendiary.value : this.incendiary),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsAttackingPublic$Attacking$Faction {
  const PersonalStatsAttackingPublic$Attacking$Faction({
    required this.respect,
    required this.retaliations,
    required this.rankedWarHits,
    required this.raidHits,
    required this.territory,
  });

  factory PersonalStatsAttackingPublic$Attacking$Faction.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$PersonalStatsAttackingPublic$Attacking$FactionFromJson(json);

  static const toJsonFactory = _$PersonalStatsAttackingPublic$Attacking$FactionToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsAttackingPublic$Attacking$FactionToJson(this);

  @JsonKey(name: 'respect')
  final int respect;
  @JsonKey(name: 'retaliations')
  final int retaliations;
  @JsonKey(name: 'ranked_war_hits')
  final int rankedWarHits;
  @JsonKey(name: 'raid_hits')
  final int raidHits;
  @JsonKey(name: 'territory')
  final PersonalStatsAttackingPublic$Attacking$Faction$Territory territory;
  static const fromJsonFactory = _$PersonalStatsAttackingPublic$Attacking$FactionFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsAttackingPublic$Attacking$Faction &&
            (identical(other.respect, respect) ||
                const DeepCollectionEquality().equals(
                  other.respect,
                  respect,
                )) &&
            (identical(other.retaliations, retaliations) ||
                const DeepCollectionEquality().equals(
                  other.retaliations,
                  retaliations,
                )) &&
            (identical(other.rankedWarHits, rankedWarHits) ||
                const DeepCollectionEquality().equals(
                  other.rankedWarHits,
                  rankedWarHits,
                )) &&
            (identical(other.raidHits, raidHits) ||
                const DeepCollectionEquality().equals(
                  other.raidHits,
                  raidHits,
                )) &&
            (identical(other.territory, territory) ||
                const DeepCollectionEquality().equals(
                  other.territory,
                  territory,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(respect) ^
      const DeepCollectionEquality().hash(retaliations) ^
      const DeepCollectionEquality().hash(rankedWarHits) ^
      const DeepCollectionEquality().hash(raidHits) ^
      const DeepCollectionEquality().hash(territory) ^
      runtimeType.hashCode;
}

extension $PersonalStatsAttackingPublic$Attacking$FactionExtension on PersonalStatsAttackingPublic$Attacking$Faction {
  PersonalStatsAttackingPublic$Attacking$Faction copyWith({
    int? respect,
    int? retaliations,
    int? rankedWarHits,
    int? raidHits,
    PersonalStatsAttackingPublic$Attacking$Faction$Territory? territory,
  }) {
    return PersonalStatsAttackingPublic$Attacking$Faction(
      respect: respect ?? this.respect,
      retaliations: retaliations ?? this.retaliations,
      rankedWarHits: rankedWarHits ?? this.rankedWarHits,
      raidHits: raidHits ?? this.raidHits,
      territory: territory ?? this.territory,
    );
  }

  PersonalStatsAttackingPublic$Attacking$Faction copyWithWrapped({
    Wrapped<int>? respect,
    Wrapped<int>? retaliations,
    Wrapped<int>? rankedWarHits,
    Wrapped<int>? raidHits,
    Wrapped<PersonalStatsAttackingPublic$Attacking$Faction$Territory>? territory,
  }) {
    return PersonalStatsAttackingPublic$Attacking$Faction(
      respect: (respect != null ? respect.value : this.respect),
      retaliations: (retaliations != null ? retaliations.value : this.retaliations),
      rankedWarHits: (rankedWarHits != null ? rankedWarHits.value : this.rankedWarHits),
      raidHits: (raidHits != null ? raidHits.value : this.raidHits),
      territory: (territory != null ? territory.value : this.territory),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsAttackingExtended$Attacking$Attacks {
  const PersonalStatsAttackingExtended$Attacking$Attacks({
    required this.won,
    required this.lost,
    required this.stalemate,
    required this.assist,
    required this.stealth,
  });

  factory PersonalStatsAttackingExtended$Attacking$Attacks.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$PersonalStatsAttackingExtended$Attacking$AttacksFromJson(json);

  static const toJsonFactory = _$PersonalStatsAttackingExtended$Attacking$AttacksToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsAttackingExtended$Attacking$AttacksToJson(this);

  @JsonKey(name: 'won')
  final int won;
  @JsonKey(name: 'lost')
  final int lost;
  @JsonKey(name: 'stalemate')
  final int stalemate;
  @JsonKey(name: 'assist')
  final int assist;
  @JsonKey(name: 'stealth')
  final int stealth;
  static const fromJsonFactory = _$PersonalStatsAttackingExtended$Attacking$AttacksFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsAttackingExtended$Attacking$Attacks &&
            (identical(other.won, won) || const DeepCollectionEquality().equals(other.won, won)) &&
            (identical(other.lost, lost) || const DeepCollectionEquality().equals(other.lost, lost)) &&
            (identical(other.stalemate, stalemate) ||
                const DeepCollectionEquality().equals(
                  other.stalemate,
                  stalemate,
                )) &&
            (identical(other.assist, assist) || const DeepCollectionEquality().equals(other.assist, assist)) &&
            (identical(other.stealth, stealth) || const DeepCollectionEquality().equals(other.stealth, stealth)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(won) ^
      const DeepCollectionEquality().hash(lost) ^
      const DeepCollectionEquality().hash(stalemate) ^
      const DeepCollectionEquality().hash(assist) ^
      const DeepCollectionEquality().hash(stealth) ^
      runtimeType.hashCode;
}

extension $PersonalStatsAttackingExtended$Attacking$AttacksExtension
    on PersonalStatsAttackingExtended$Attacking$Attacks {
  PersonalStatsAttackingExtended$Attacking$Attacks copyWith({
    int? won,
    int? lost,
    int? stalemate,
    int? assist,
    int? stealth,
  }) {
    return PersonalStatsAttackingExtended$Attacking$Attacks(
      won: won ?? this.won,
      lost: lost ?? this.lost,
      stalemate: stalemate ?? this.stalemate,
      assist: assist ?? this.assist,
      stealth: stealth ?? this.stealth,
    );
  }

  PersonalStatsAttackingExtended$Attacking$Attacks copyWithWrapped({
    Wrapped<int>? won,
    Wrapped<int>? lost,
    Wrapped<int>? stalemate,
    Wrapped<int>? assist,
    Wrapped<int>? stealth,
  }) {
    return PersonalStatsAttackingExtended$Attacking$Attacks(
      won: (won != null ? won.value : this.won),
      lost: (lost != null ? lost.value : this.lost),
      stalemate: (stalemate != null ? stalemate.value : this.stalemate),
      assist: (assist != null ? assist.value : this.assist),
      stealth: (stealth != null ? stealth.value : this.stealth),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsAttackingExtended$Attacking$Defends {
  const PersonalStatsAttackingExtended$Attacking$Defends({
    required this.won,
    required this.lost,
    required this.stalemate,
    required this.total,
  });

  factory PersonalStatsAttackingExtended$Attacking$Defends.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$PersonalStatsAttackingExtended$Attacking$DefendsFromJson(json);

  static const toJsonFactory = _$PersonalStatsAttackingExtended$Attacking$DefendsToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsAttackingExtended$Attacking$DefendsToJson(this);

  @JsonKey(name: 'won')
  final int won;
  @JsonKey(name: 'lost')
  final int lost;
  @JsonKey(name: 'stalemate')
  final int stalemate;
  @JsonKey(name: 'total')
  final int total;
  static const fromJsonFactory = _$PersonalStatsAttackingExtended$Attacking$DefendsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsAttackingExtended$Attacking$Defends &&
            (identical(other.won, won) || const DeepCollectionEquality().equals(other.won, won)) &&
            (identical(other.lost, lost) || const DeepCollectionEquality().equals(other.lost, lost)) &&
            (identical(other.stalemate, stalemate) ||
                const DeepCollectionEquality().equals(
                  other.stalemate,
                  stalemate,
                )) &&
            (identical(other.total, total) || const DeepCollectionEquality().equals(other.total, total)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(won) ^
      const DeepCollectionEquality().hash(lost) ^
      const DeepCollectionEquality().hash(stalemate) ^
      const DeepCollectionEquality().hash(total) ^
      runtimeType.hashCode;
}

extension $PersonalStatsAttackingExtended$Attacking$DefendsExtension
    on PersonalStatsAttackingExtended$Attacking$Defends {
  PersonalStatsAttackingExtended$Attacking$Defends copyWith({
    int? won,
    int? lost,
    int? stalemate,
    int? total,
  }) {
    return PersonalStatsAttackingExtended$Attacking$Defends(
      won: won ?? this.won,
      lost: lost ?? this.lost,
      stalemate: stalemate ?? this.stalemate,
      total: total ?? this.total,
    );
  }

  PersonalStatsAttackingExtended$Attacking$Defends copyWithWrapped({
    Wrapped<int>? won,
    Wrapped<int>? lost,
    Wrapped<int>? stalemate,
    Wrapped<int>? total,
  }) {
    return PersonalStatsAttackingExtended$Attacking$Defends(
      won: (won != null ? won.value : this.won),
      lost: (lost != null ? lost.value : this.lost),
      stalemate: (stalemate != null ? stalemate.value : this.stalemate),
      total: (total != null ? total.value : this.total),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsAttackingExtended$Attacking$Escapes {
  const PersonalStatsAttackingExtended$Attacking$Escapes({
    required this.player,
    required this.foes,
  });

  factory PersonalStatsAttackingExtended$Attacking$Escapes.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$PersonalStatsAttackingExtended$Attacking$EscapesFromJson(json);

  static const toJsonFactory = _$PersonalStatsAttackingExtended$Attacking$EscapesToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsAttackingExtended$Attacking$EscapesToJson(this);

  @JsonKey(name: 'player')
  final int player;
  @JsonKey(name: 'foes')
  final int foes;
  static const fromJsonFactory = _$PersonalStatsAttackingExtended$Attacking$EscapesFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsAttackingExtended$Attacking$Escapes &&
            (identical(other.player, player) || const DeepCollectionEquality().equals(other.player, player)) &&
            (identical(other.foes, foes) || const DeepCollectionEquality().equals(other.foes, foes)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(player) ^ const DeepCollectionEquality().hash(foes) ^ runtimeType.hashCode;
}

extension $PersonalStatsAttackingExtended$Attacking$EscapesExtension
    on PersonalStatsAttackingExtended$Attacking$Escapes {
  PersonalStatsAttackingExtended$Attacking$Escapes copyWith({
    int? player,
    int? foes,
  }) {
    return PersonalStatsAttackingExtended$Attacking$Escapes(
      player: player ?? this.player,
      foes: foes ?? this.foes,
    );
  }

  PersonalStatsAttackingExtended$Attacking$Escapes copyWithWrapped({
    Wrapped<int>? player,
    Wrapped<int>? foes,
  }) {
    return PersonalStatsAttackingExtended$Attacking$Escapes(
      player: (player != null ? player.value : this.player),
      foes: (foes != null ? foes.value : this.foes),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsAttackingExtended$Attacking$Killstreak {
  const PersonalStatsAttackingExtended$Attacking$Killstreak({
    required this.best,
    required this.current,
  });

  factory PersonalStatsAttackingExtended$Attacking$Killstreak.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$PersonalStatsAttackingExtended$Attacking$KillstreakFromJson(json);

  static const toJsonFactory = _$PersonalStatsAttackingExtended$Attacking$KillstreakToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsAttackingExtended$Attacking$KillstreakToJson(this);

  @JsonKey(name: 'best')
  final int best;
  @JsonKey(name: 'current')
  final int current;
  static const fromJsonFactory = _$PersonalStatsAttackingExtended$Attacking$KillstreakFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsAttackingExtended$Attacking$Killstreak &&
            (identical(other.best, best) || const DeepCollectionEquality().equals(other.best, best)) &&
            (identical(other.current, current) || const DeepCollectionEquality().equals(other.current, current)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(best) ^ const DeepCollectionEquality().hash(current) ^ runtimeType.hashCode;
}

extension $PersonalStatsAttackingExtended$Attacking$KillstreakExtension
    on PersonalStatsAttackingExtended$Attacking$Killstreak {
  PersonalStatsAttackingExtended$Attacking$Killstreak copyWith({
    int? best,
    int? current,
  }) {
    return PersonalStatsAttackingExtended$Attacking$Killstreak(
      best: best ?? this.best,
      current: current ?? this.current,
    );
  }

  PersonalStatsAttackingExtended$Attacking$Killstreak copyWithWrapped({
    Wrapped<int>? best,
    Wrapped<int>? current,
  }) {
    return PersonalStatsAttackingExtended$Attacking$Killstreak(
      best: (best != null ? best.value : this.best),
      current: (current != null ? current.value : this.current),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsAttackingExtended$Attacking$Hits {
  const PersonalStatsAttackingExtended$Attacking$Hits({
    required this.success,
    required this.miss,
    required this.critical,
    required this.oneHitKills,
  });

  factory PersonalStatsAttackingExtended$Attacking$Hits.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$PersonalStatsAttackingExtended$Attacking$HitsFromJson(json);

  static const toJsonFactory = _$PersonalStatsAttackingExtended$Attacking$HitsToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsAttackingExtended$Attacking$HitsToJson(this);

  @JsonKey(name: 'success')
  final int success;
  @JsonKey(name: 'miss')
  final int miss;
  @JsonKey(name: 'critical')
  final int critical;
  @JsonKey(name: 'one_hit_kills')
  final int oneHitKills;
  static const fromJsonFactory = _$PersonalStatsAttackingExtended$Attacking$HitsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsAttackingExtended$Attacking$Hits &&
            (identical(other.success, success) ||
                const DeepCollectionEquality().equals(
                  other.success,
                  success,
                )) &&
            (identical(other.miss, miss) || const DeepCollectionEquality().equals(other.miss, miss)) &&
            (identical(other.critical, critical) ||
                const DeepCollectionEquality().equals(
                  other.critical,
                  critical,
                )) &&
            (identical(other.oneHitKills, oneHitKills) ||
                const DeepCollectionEquality().equals(
                  other.oneHitKills,
                  oneHitKills,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(success) ^
      const DeepCollectionEquality().hash(miss) ^
      const DeepCollectionEquality().hash(critical) ^
      const DeepCollectionEquality().hash(oneHitKills) ^
      runtimeType.hashCode;
}

extension $PersonalStatsAttackingExtended$Attacking$HitsExtension on PersonalStatsAttackingExtended$Attacking$Hits {
  PersonalStatsAttackingExtended$Attacking$Hits copyWith({
    int? success,
    int? miss,
    int? critical,
    int? oneHitKills,
  }) {
    return PersonalStatsAttackingExtended$Attacking$Hits(
      success: success ?? this.success,
      miss: miss ?? this.miss,
      critical: critical ?? this.critical,
      oneHitKills: oneHitKills ?? this.oneHitKills,
    );
  }

  PersonalStatsAttackingExtended$Attacking$Hits copyWithWrapped({
    Wrapped<int>? success,
    Wrapped<int>? miss,
    Wrapped<int>? critical,
    Wrapped<int>? oneHitKills,
  }) {
    return PersonalStatsAttackingExtended$Attacking$Hits(
      success: (success != null ? success.value : this.success),
      miss: (miss != null ? miss.value : this.miss),
      critical: (critical != null ? critical.value : this.critical),
      oneHitKills: (oneHitKills != null ? oneHitKills.value : this.oneHitKills),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsAttackingExtended$Attacking$Damage {
  const PersonalStatsAttackingExtended$Attacking$Damage({
    required this.total,
    required this.best,
  });

  factory PersonalStatsAttackingExtended$Attacking$Damage.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$PersonalStatsAttackingExtended$Attacking$DamageFromJson(json);

  static const toJsonFactory = _$PersonalStatsAttackingExtended$Attacking$DamageToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsAttackingExtended$Attacking$DamageToJson(this);

  @JsonKey(name: 'total')
  final int total;
  @JsonKey(name: 'best')
  final int best;
  static const fromJsonFactory = _$PersonalStatsAttackingExtended$Attacking$DamageFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsAttackingExtended$Attacking$Damage &&
            (identical(other.total, total) || const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.best, best) || const DeepCollectionEquality().equals(other.best, best)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(total) ^ const DeepCollectionEquality().hash(best) ^ runtimeType.hashCode;
}

extension $PersonalStatsAttackingExtended$Attacking$DamageExtension on PersonalStatsAttackingExtended$Attacking$Damage {
  PersonalStatsAttackingExtended$Attacking$Damage copyWith({
    int? total,
    int? best,
  }) {
    return PersonalStatsAttackingExtended$Attacking$Damage(
      total: total ?? this.total,
      best: best ?? this.best,
    );
  }

  PersonalStatsAttackingExtended$Attacking$Damage copyWithWrapped({
    Wrapped<int>? total,
    Wrapped<int>? best,
  }) {
    return PersonalStatsAttackingExtended$Attacking$Damage(
      total: (total != null ? total.value : this.total),
      best: (best != null ? best.value : this.best),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsAttackingExtended$Attacking$Networth {
  const PersonalStatsAttackingExtended$Attacking$Networth({
    required this.moneyMugged,
    required this.largestMug,
    required this.itemsLooted,
  });

  factory PersonalStatsAttackingExtended$Attacking$Networth.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$PersonalStatsAttackingExtended$Attacking$NetworthFromJson(json);

  static const toJsonFactory = _$PersonalStatsAttackingExtended$Attacking$NetworthToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsAttackingExtended$Attacking$NetworthToJson(this);

  @JsonKey(name: 'money_mugged')
  final int moneyMugged;
  @JsonKey(name: 'largest_mug')
  final int largestMug;
  @JsonKey(name: 'items_looted')
  final int itemsLooted;
  static const fromJsonFactory = _$PersonalStatsAttackingExtended$Attacking$NetworthFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsAttackingExtended$Attacking$Networth &&
            (identical(other.moneyMugged, moneyMugged) ||
                const DeepCollectionEquality().equals(
                  other.moneyMugged,
                  moneyMugged,
                )) &&
            (identical(other.largestMug, largestMug) ||
                const DeepCollectionEquality().equals(
                  other.largestMug,
                  largestMug,
                )) &&
            (identical(other.itemsLooted, itemsLooted) ||
                const DeepCollectionEquality().equals(
                  other.itemsLooted,
                  itemsLooted,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(moneyMugged) ^
      const DeepCollectionEquality().hash(largestMug) ^
      const DeepCollectionEquality().hash(itemsLooted) ^
      runtimeType.hashCode;
}

extension $PersonalStatsAttackingExtended$Attacking$NetworthExtension
    on PersonalStatsAttackingExtended$Attacking$Networth {
  PersonalStatsAttackingExtended$Attacking$Networth copyWith({
    int? moneyMugged,
    int? largestMug,
    int? itemsLooted,
  }) {
    return PersonalStatsAttackingExtended$Attacking$Networth(
      moneyMugged: moneyMugged ?? this.moneyMugged,
      largestMug: largestMug ?? this.largestMug,
      itemsLooted: itemsLooted ?? this.itemsLooted,
    );
  }

  PersonalStatsAttackingExtended$Attacking$Networth copyWithWrapped({
    Wrapped<int>? moneyMugged,
    Wrapped<int>? largestMug,
    Wrapped<int>? itemsLooted,
  }) {
    return PersonalStatsAttackingExtended$Attacking$Networth(
      moneyMugged: (moneyMugged != null ? moneyMugged.value : this.moneyMugged),
      largestMug: (largestMug != null ? largestMug.value : this.largestMug),
      itemsLooted: (itemsLooted != null ? itemsLooted.value : this.itemsLooted),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsAttackingExtended$Attacking$Ammunition {
  const PersonalStatsAttackingExtended$Attacking$Ammunition({
    required this.total,
    required this.special,
    required this.hollowPoint,
    required this.tracer,
    required this.piercing,
    required this.incendiary,
  });

  factory PersonalStatsAttackingExtended$Attacking$Ammunition.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$PersonalStatsAttackingExtended$Attacking$AmmunitionFromJson(json);

  static const toJsonFactory = _$PersonalStatsAttackingExtended$Attacking$AmmunitionToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsAttackingExtended$Attacking$AmmunitionToJson(this);

  @JsonKey(name: 'total')
  final int total;
  @JsonKey(name: 'special')
  final int special;
  @JsonKey(name: 'hollow_point')
  final int hollowPoint;
  @JsonKey(name: 'tracer')
  final int tracer;
  @JsonKey(name: 'piercing')
  final int piercing;
  @JsonKey(name: 'incendiary')
  final int incendiary;
  static const fromJsonFactory = _$PersonalStatsAttackingExtended$Attacking$AmmunitionFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsAttackingExtended$Attacking$Ammunition &&
            (identical(other.total, total) || const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.special, special) ||
                const DeepCollectionEquality().equals(
                  other.special,
                  special,
                )) &&
            (identical(other.hollowPoint, hollowPoint) ||
                const DeepCollectionEquality().equals(
                  other.hollowPoint,
                  hollowPoint,
                )) &&
            (identical(other.tracer, tracer) || const DeepCollectionEquality().equals(other.tracer, tracer)) &&
            (identical(other.piercing, piercing) ||
                const DeepCollectionEquality().equals(
                  other.piercing,
                  piercing,
                )) &&
            (identical(other.incendiary, incendiary) ||
                const DeepCollectionEquality().equals(
                  other.incendiary,
                  incendiary,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(special) ^
      const DeepCollectionEquality().hash(hollowPoint) ^
      const DeepCollectionEquality().hash(tracer) ^
      const DeepCollectionEquality().hash(piercing) ^
      const DeepCollectionEquality().hash(incendiary) ^
      runtimeType.hashCode;
}

extension $PersonalStatsAttackingExtended$Attacking$AmmunitionExtension
    on PersonalStatsAttackingExtended$Attacking$Ammunition {
  PersonalStatsAttackingExtended$Attacking$Ammunition copyWith({
    int? total,
    int? special,
    int? hollowPoint,
    int? tracer,
    int? piercing,
    int? incendiary,
  }) {
    return PersonalStatsAttackingExtended$Attacking$Ammunition(
      total: total ?? this.total,
      special: special ?? this.special,
      hollowPoint: hollowPoint ?? this.hollowPoint,
      tracer: tracer ?? this.tracer,
      piercing: piercing ?? this.piercing,
      incendiary: incendiary ?? this.incendiary,
    );
  }

  PersonalStatsAttackingExtended$Attacking$Ammunition copyWithWrapped({
    Wrapped<int>? total,
    Wrapped<int>? special,
    Wrapped<int>? hollowPoint,
    Wrapped<int>? tracer,
    Wrapped<int>? piercing,
    Wrapped<int>? incendiary,
  }) {
    return PersonalStatsAttackingExtended$Attacking$Ammunition(
      total: (total != null ? total.value : this.total),
      special: (special != null ? special.value : this.special),
      hollowPoint: (hollowPoint != null ? hollowPoint.value : this.hollowPoint),
      tracer: (tracer != null ? tracer.value : this.tracer),
      piercing: (piercing != null ? piercing.value : this.piercing),
      incendiary: (incendiary != null ? incendiary.value : this.incendiary),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsAttackingExtended$Attacking$Faction {
  const PersonalStatsAttackingExtended$Attacking$Faction({
    required this.respect,
    required this.retaliations,
    required this.rankedWarHits,
    required this.raidHits,
    required this.territory,
  });

  factory PersonalStatsAttackingExtended$Attacking$Faction.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$PersonalStatsAttackingExtended$Attacking$FactionFromJson(json);

  static const toJsonFactory = _$PersonalStatsAttackingExtended$Attacking$FactionToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsAttackingExtended$Attacking$FactionToJson(this);

  @JsonKey(name: 'respect')
  final int respect;
  @JsonKey(name: 'retaliations')
  final int retaliations;
  @JsonKey(name: 'ranked_war_hits')
  final int rankedWarHits;
  @JsonKey(name: 'raid_hits')
  final int raidHits;
  @JsonKey(name: 'territory')
  final PersonalStatsAttackingExtended$Attacking$Faction$Territory territory;
  static const fromJsonFactory = _$PersonalStatsAttackingExtended$Attacking$FactionFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsAttackingExtended$Attacking$Faction &&
            (identical(other.respect, respect) ||
                const DeepCollectionEquality().equals(
                  other.respect,
                  respect,
                )) &&
            (identical(other.retaliations, retaliations) ||
                const DeepCollectionEquality().equals(
                  other.retaliations,
                  retaliations,
                )) &&
            (identical(other.rankedWarHits, rankedWarHits) ||
                const DeepCollectionEquality().equals(
                  other.rankedWarHits,
                  rankedWarHits,
                )) &&
            (identical(other.raidHits, raidHits) ||
                const DeepCollectionEquality().equals(
                  other.raidHits,
                  raidHits,
                )) &&
            (identical(other.territory, territory) ||
                const DeepCollectionEquality().equals(
                  other.territory,
                  territory,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(respect) ^
      const DeepCollectionEquality().hash(retaliations) ^
      const DeepCollectionEquality().hash(rankedWarHits) ^
      const DeepCollectionEquality().hash(raidHits) ^
      const DeepCollectionEquality().hash(territory) ^
      runtimeType.hashCode;
}

extension $PersonalStatsAttackingExtended$Attacking$FactionExtension
    on PersonalStatsAttackingExtended$Attacking$Faction {
  PersonalStatsAttackingExtended$Attacking$Faction copyWith({
    int? respect,
    int? retaliations,
    int? rankedWarHits,
    int? raidHits,
    PersonalStatsAttackingExtended$Attacking$Faction$Territory? territory,
  }) {
    return PersonalStatsAttackingExtended$Attacking$Faction(
      respect: respect ?? this.respect,
      retaliations: retaliations ?? this.retaliations,
      rankedWarHits: rankedWarHits ?? this.rankedWarHits,
      raidHits: raidHits ?? this.raidHits,
      territory: territory ?? this.territory,
    );
  }

  PersonalStatsAttackingExtended$Attacking$Faction copyWithWrapped({
    Wrapped<int>? respect,
    Wrapped<int>? retaliations,
    Wrapped<int>? rankedWarHits,
    Wrapped<int>? raidHits,
    Wrapped<PersonalStatsAttackingExtended$Attacking$Faction$Territory>? territory,
  }) {
    return PersonalStatsAttackingExtended$Attacking$Faction(
      respect: (respect != null ? respect.value : this.respect),
      retaliations: (retaliations != null ? retaliations.value : this.retaliations),
      rankedWarHits: (rankedWarHits != null ? rankedWarHits.value : this.rankedWarHits),
      raidHits: (raidHits != null ? raidHits.value : this.raidHits),
      territory: (territory != null ? territory.value : this.territory),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsAttackingPopular$Attacking$Attacks {
  const PersonalStatsAttackingPopular$Attacking$Attacks({
    required this.won,
    required this.lost,
    required this.stalemate,
    required this.assist,
  });

  factory PersonalStatsAttackingPopular$Attacking$Attacks.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$PersonalStatsAttackingPopular$Attacking$AttacksFromJson(json);

  static const toJsonFactory = _$PersonalStatsAttackingPopular$Attacking$AttacksToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsAttackingPopular$Attacking$AttacksToJson(this);

  @JsonKey(name: 'won')
  final int won;
  @JsonKey(name: 'lost')
  final int lost;
  @JsonKey(name: 'stalemate')
  final int stalemate;
  @JsonKey(name: 'assist')
  final int assist;
  static const fromJsonFactory = _$PersonalStatsAttackingPopular$Attacking$AttacksFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsAttackingPopular$Attacking$Attacks &&
            (identical(other.won, won) || const DeepCollectionEquality().equals(other.won, won)) &&
            (identical(other.lost, lost) || const DeepCollectionEquality().equals(other.lost, lost)) &&
            (identical(other.stalemate, stalemate) ||
                const DeepCollectionEquality().equals(
                  other.stalemate,
                  stalemate,
                )) &&
            (identical(other.assist, assist) || const DeepCollectionEquality().equals(other.assist, assist)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(won) ^
      const DeepCollectionEquality().hash(lost) ^
      const DeepCollectionEquality().hash(stalemate) ^
      const DeepCollectionEquality().hash(assist) ^
      runtimeType.hashCode;
}

extension $PersonalStatsAttackingPopular$Attacking$AttacksExtension on PersonalStatsAttackingPopular$Attacking$Attacks {
  PersonalStatsAttackingPopular$Attacking$Attacks copyWith({
    int? won,
    int? lost,
    int? stalemate,
    int? assist,
  }) {
    return PersonalStatsAttackingPopular$Attacking$Attacks(
      won: won ?? this.won,
      lost: lost ?? this.lost,
      stalemate: stalemate ?? this.stalemate,
      assist: assist ?? this.assist,
    );
  }

  PersonalStatsAttackingPopular$Attacking$Attacks copyWithWrapped({
    Wrapped<int>? won,
    Wrapped<int>? lost,
    Wrapped<int>? stalemate,
    Wrapped<int>? assist,
  }) {
    return PersonalStatsAttackingPopular$Attacking$Attacks(
      won: (won != null ? won.value : this.won),
      lost: (lost != null ? lost.value : this.lost),
      stalemate: (stalemate != null ? stalemate.value : this.stalemate),
      assist: (assist != null ? assist.value : this.assist),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsAttackingPopular$Attacking$Defends {
  const PersonalStatsAttackingPopular$Attacking$Defends({
    required this.won,
    required this.lost,
    required this.stalemate,
  });

  factory PersonalStatsAttackingPopular$Attacking$Defends.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$PersonalStatsAttackingPopular$Attacking$DefendsFromJson(json);

  static const toJsonFactory = _$PersonalStatsAttackingPopular$Attacking$DefendsToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsAttackingPopular$Attacking$DefendsToJson(this);

  @JsonKey(name: 'won')
  final int won;
  @JsonKey(name: 'lost')
  final int lost;
  @JsonKey(name: 'stalemate')
  final int stalemate;
  static const fromJsonFactory = _$PersonalStatsAttackingPopular$Attacking$DefendsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsAttackingPopular$Attacking$Defends &&
            (identical(other.won, won) || const DeepCollectionEquality().equals(other.won, won)) &&
            (identical(other.lost, lost) || const DeepCollectionEquality().equals(other.lost, lost)) &&
            (identical(other.stalemate, stalemate) ||
                const DeepCollectionEquality().equals(
                  other.stalemate,
                  stalemate,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(won) ^
      const DeepCollectionEquality().hash(lost) ^
      const DeepCollectionEquality().hash(stalemate) ^
      runtimeType.hashCode;
}

extension $PersonalStatsAttackingPopular$Attacking$DefendsExtension on PersonalStatsAttackingPopular$Attacking$Defends {
  PersonalStatsAttackingPopular$Attacking$Defends copyWith({
    int? won,
    int? lost,
    int? stalemate,
  }) {
    return PersonalStatsAttackingPopular$Attacking$Defends(
      won: won ?? this.won,
      lost: lost ?? this.lost,
      stalemate: stalemate ?? this.stalemate,
    );
  }

  PersonalStatsAttackingPopular$Attacking$Defends copyWithWrapped({
    Wrapped<int>? won,
    Wrapped<int>? lost,
    Wrapped<int>? stalemate,
  }) {
    return PersonalStatsAttackingPopular$Attacking$Defends(
      won: (won != null ? won.value : this.won),
      lost: (lost != null ? lost.value : this.lost),
      stalemate: (stalemate != null ? stalemate.value : this.stalemate),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsAttackingPopular$Attacking$Escapes {
  const PersonalStatsAttackingPopular$Attacking$Escapes({
    required this.player,
    required this.foes,
  });

  factory PersonalStatsAttackingPopular$Attacking$Escapes.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$PersonalStatsAttackingPopular$Attacking$EscapesFromJson(json);

  static const toJsonFactory = _$PersonalStatsAttackingPopular$Attacking$EscapesToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsAttackingPopular$Attacking$EscapesToJson(this);

  @JsonKey(name: 'player')
  final int player;
  @JsonKey(name: 'foes')
  final int foes;
  static const fromJsonFactory = _$PersonalStatsAttackingPopular$Attacking$EscapesFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsAttackingPopular$Attacking$Escapes &&
            (identical(other.player, player) || const DeepCollectionEquality().equals(other.player, player)) &&
            (identical(other.foes, foes) || const DeepCollectionEquality().equals(other.foes, foes)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(player) ^ const DeepCollectionEquality().hash(foes) ^ runtimeType.hashCode;
}

extension $PersonalStatsAttackingPopular$Attacking$EscapesExtension on PersonalStatsAttackingPopular$Attacking$Escapes {
  PersonalStatsAttackingPopular$Attacking$Escapes copyWith({
    int? player,
    int? foes,
  }) {
    return PersonalStatsAttackingPopular$Attacking$Escapes(
      player: player ?? this.player,
      foes: foes ?? this.foes,
    );
  }

  PersonalStatsAttackingPopular$Attacking$Escapes copyWithWrapped({
    Wrapped<int>? player,
    Wrapped<int>? foes,
  }) {
    return PersonalStatsAttackingPopular$Attacking$Escapes(
      player: (player != null ? player.value : this.player),
      foes: (foes != null ? foes.value : this.foes),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsAttackingPopular$Attacking$Killstreak {
  const PersonalStatsAttackingPopular$Attacking$Killstreak({
    required this.best,
  });

  factory PersonalStatsAttackingPopular$Attacking$Killstreak.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$PersonalStatsAttackingPopular$Attacking$KillstreakFromJson(json);

  static const toJsonFactory = _$PersonalStatsAttackingPopular$Attacking$KillstreakToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsAttackingPopular$Attacking$KillstreakToJson(this);

  @JsonKey(name: 'best')
  final int best;
  static const fromJsonFactory = _$PersonalStatsAttackingPopular$Attacking$KillstreakFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsAttackingPopular$Attacking$Killstreak &&
            (identical(other.best, best) || const DeepCollectionEquality().equals(other.best, best)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => const DeepCollectionEquality().hash(best) ^ runtimeType.hashCode;
}

extension $PersonalStatsAttackingPopular$Attacking$KillstreakExtension
    on PersonalStatsAttackingPopular$Attacking$Killstreak {
  PersonalStatsAttackingPopular$Attacking$Killstreak copyWith({int? best}) {
    return PersonalStatsAttackingPopular$Attacking$Killstreak(
      best: best ?? this.best,
    );
  }

  PersonalStatsAttackingPopular$Attacking$Killstreak copyWithWrapped({
    Wrapped<int>? best,
  }) {
    return PersonalStatsAttackingPopular$Attacking$Killstreak(
      best: (best != null ? best.value : this.best),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsAttackingPopular$Attacking$Hits {
  const PersonalStatsAttackingPopular$Attacking$Hits({
    required this.success,
    required this.miss,
    required this.critical,
    required this.oneHitKills,
  });

  factory PersonalStatsAttackingPopular$Attacking$Hits.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$PersonalStatsAttackingPopular$Attacking$HitsFromJson(json);

  static const toJsonFactory = _$PersonalStatsAttackingPopular$Attacking$HitsToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsAttackingPopular$Attacking$HitsToJson(this);

  @JsonKey(name: 'success')
  final int success;
  @JsonKey(name: 'miss')
  final int miss;
  @JsonKey(name: 'critical')
  final int critical;
  @JsonKey(name: 'one_hit_kills')
  final int oneHitKills;
  static const fromJsonFactory = _$PersonalStatsAttackingPopular$Attacking$HitsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsAttackingPopular$Attacking$Hits &&
            (identical(other.success, success) ||
                const DeepCollectionEquality().equals(
                  other.success,
                  success,
                )) &&
            (identical(other.miss, miss) || const DeepCollectionEquality().equals(other.miss, miss)) &&
            (identical(other.critical, critical) ||
                const DeepCollectionEquality().equals(
                  other.critical,
                  critical,
                )) &&
            (identical(other.oneHitKills, oneHitKills) ||
                const DeepCollectionEquality().equals(
                  other.oneHitKills,
                  oneHitKills,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(success) ^
      const DeepCollectionEquality().hash(miss) ^
      const DeepCollectionEquality().hash(critical) ^
      const DeepCollectionEquality().hash(oneHitKills) ^
      runtimeType.hashCode;
}

extension $PersonalStatsAttackingPopular$Attacking$HitsExtension on PersonalStatsAttackingPopular$Attacking$Hits {
  PersonalStatsAttackingPopular$Attacking$Hits copyWith({
    int? success,
    int? miss,
    int? critical,
    int? oneHitKills,
  }) {
    return PersonalStatsAttackingPopular$Attacking$Hits(
      success: success ?? this.success,
      miss: miss ?? this.miss,
      critical: critical ?? this.critical,
      oneHitKills: oneHitKills ?? this.oneHitKills,
    );
  }

  PersonalStatsAttackingPopular$Attacking$Hits copyWithWrapped({
    Wrapped<int>? success,
    Wrapped<int>? miss,
    Wrapped<int>? critical,
    Wrapped<int>? oneHitKills,
  }) {
    return PersonalStatsAttackingPopular$Attacking$Hits(
      success: (success != null ? success.value : this.success),
      miss: (miss != null ? miss.value : this.miss),
      critical: (critical != null ? critical.value : this.critical),
      oneHitKills: (oneHitKills != null ? oneHitKills.value : this.oneHitKills),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsAttackingPopular$Attacking$Damage {
  const PersonalStatsAttackingPopular$Attacking$Damage({
    required this.total,
    required this.best,
  });

  factory PersonalStatsAttackingPopular$Attacking$Damage.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$PersonalStatsAttackingPopular$Attacking$DamageFromJson(json);

  static const toJsonFactory = _$PersonalStatsAttackingPopular$Attacking$DamageToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsAttackingPopular$Attacking$DamageToJson(this);

  @JsonKey(name: 'total')
  final int total;
  @JsonKey(name: 'best')
  final int best;
  static const fromJsonFactory = _$PersonalStatsAttackingPopular$Attacking$DamageFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsAttackingPopular$Attacking$Damage &&
            (identical(other.total, total) || const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.best, best) || const DeepCollectionEquality().equals(other.best, best)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(total) ^ const DeepCollectionEquality().hash(best) ^ runtimeType.hashCode;
}

extension $PersonalStatsAttackingPopular$Attacking$DamageExtension on PersonalStatsAttackingPopular$Attacking$Damage {
  PersonalStatsAttackingPopular$Attacking$Damage copyWith({
    int? total,
    int? best,
  }) {
    return PersonalStatsAttackingPopular$Attacking$Damage(
      total: total ?? this.total,
      best: best ?? this.best,
    );
  }

  PersonalStatsAttackingPopular$Attacking$Damage copyWithWrapped({
    Wrapped<int>? total,
    Wrapped<int>? best,
  }) {
    return PersonalStatsAttackingPopular$Attacking$Damage(
      total: (total != null ? total.value : this.total),
      best: (best != null ? best.value : this.best),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsAttackingPopular$Attacking$Networth {
  const PersonalStatsAttackingPopular$Attacking$Networth({
    required this.moneyMugged,
    required this.largestMug,
    required this.itemsLooted,
  });

  factory PersonalStatsAttackingPopular$Attacking$Networth.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$PersonalStatsAttackingPopular$Attacking$NetworthFromJson(json);

  static const toJsonFactory = _$PersonalStatsAttackingPopular$Attacking$NetworthToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsAttackingPopular$Attacking$NetworthToJson(this);

  @JsonKey(name: 'money_mugged')
  final int moneyMugged;
  @JsonKey(name: 'largest_mug')
  final int largestMug;
  @JsonKey(name: 'items_looted')
  final int itemsLooted;
  static const fromJsonFactory = _$PersonalStatsAttackingPopular$Attacking$NetworthFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsAttackingPopular$Attacking$Networth &&
            (identical(other.moneyMugged, moneyMugged) ||
                const DeepCollectionEquality().equals(
                  other.moneyMugged,
                  moneyMugged,
                )) &&
            (identical(other.largestMug, largestMug) ||
                const DeepCollectionEquality().equals(
                  other.largestMug,
                  largestMug,
                )) &&
            (identical(other.itemsLooted, itemsLooted) ||
                const DeepCollectionEquality().equals(
                  other.itemsLooted,
                  itemsLooted,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(moneyMugged) ^
      const DeepCollectionEquality().hash(largestMug) ^
      const DeepCollectionEquality().hash(itemsLooted) ^
      runtimeType.hashCode;
}

extension $PersonalStatsAttackingPopular$Attacking$NetworthExtension
    on PersonalStatsAttackingPopular$Attacking$Networth {
  PersonalStatsAttackingPopular$Attacking$Networth copyWith({
    int? moneyMugged,
    int? largestMug,
    int? itemsLooted,
  }) {
    return PersonalStatsAttackingPopular$Attacking$Networth(
      moneyMugged: moneyMugged ?? this.moneyMugged,
      largestMug: largestMug ?? this.largestMug,
      itemsLooted: itemsLooted ?? this.itemsLooted,
    );
  }

  PersonalStatsAttackingPopular$Attacking$Networth copyWithWrapped({
    Wrapped<int>? moneyMugged,
    Wrapped<int>? largestMug,
    Wrapped<int>? itemsLooted,
  }) {
    return PersonalStatsAttackingPopular$Attacking$Networth(
      moneyMugged: (moneyMugged != null ? moneyMugged.value : this.moneyMugged),
      largestMug: (largestMug != null ? largestMug.value : this.largestMug),
      itemsLooted: (itemsLooted != null ? itemsLooted.value : this.itemsLooted),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsAttackingPopular$Attacking$Ammunition {
  const PersonalStatsAttackingPopular$Attacking$Ammunition({
    required this.total,
    required this.special,
    required this.hollowPoint,
    required this.tracer,
    required this.piercing,
    required this.incendiary,
  });

  factory PersonalStatsAttackingPopular$Attacking$Ammunition.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$PersonalStatsAttackingPopular$Attacking$AmmunitionFromJson(json);

  static const toJsonFactory = _$PersonalStatsAttackingPopular$Attacking$AmmunitionToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsAttackingPopular$Attacking$AmmunitionToJson(this);

  @JsonKey(name: 'total')
  final int total;
  @JsonKey(name: 'special')
  final int special;
  @JsonKey(name: 'hollow_point')
  final int hollowPoint;
  @JsonKey(name: 'tracer')
  final int tracer;
  @JsonKey(name: 'piercing')
  final int piercing;
  @JsonKey(name: 'incendiary')
  final int incendiary;
  static const fromJsonFactory = _$PersonalStatsAttackingPopular$Attacking$AmmunitionFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsAttackingPopular$Attacking$Ammunition &&
            (identical(other.total, total) || const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.special, special) ||
                const DeepCollectionEquality().equals(
                  other.special,
                  special,
                )) &&
            (identical(other.hollowPoint, hollowPoint) ||
                const DeepCollectionEquality().equals(
                  other.hollowPoint,
                  hollowPoint,
                )) &&
            (identical(other.tracer, tracer) || const DeepCollectionEquality().equals(other.tracer, tracer)) &&
            (identical(other.piercing, piercing) ||
                const DeepCollectionEquality().equals(
                  other.piercing,
                  piercing,
                )) &&
            (identical(other.incendiary, incendiary) ||
                const DeepCollectionEquality().equals(
                  other.incendiary,
                  incendiary,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(special) ^
      const DeepCollectionEquality().hash(hollowPoint) ^
      const DeepCollectionEquality().hash(tracer) ^
      const DeepCollectionEquality().hash(piercing) ^
      const DeepCollectionEquality().hash(incendiary) ^
      runtimeType.hashCode;
}

extension $PersonalStatsAttackingPopular$Attacking$AmmunitionExtension
    on PersonalStatsAttackingPopular$Attacking$Ammunition {
  PersonalStatsAttackingPopular$Attacking$Ammunition copyWith({
    int? total,
    int? special,
    int? hollowPoint,
    int? tracer,
    int? piercing,
    int? incendiary,
  }) {
    return PersonalStatsAttackingPopular$Attacking$Ammunition(
      total: total ?? this.total,
      special: special ?? this.special,
      hollowPoint: hollowPoint ?? this.hollowPoint,
      tracer: tracer ?? this.tracer,
      piercing: piercing ?? this.piercing,
      incendiary: incendiary ?? this.incendiary,
    );
  }

  PersonalStatsAttackingPopular$Attacking$Ammunition copyWithWrapped({
    Wrapped<int>? total,
    Wrapped<int>? special,
    Wrapped<int>? hollowPoint,
    Wrapped<int>? tracer,
    Wrapped<int>? piercing,
    Wrapped<int>? incendiary,
  }) {
    return PersonalStatsAttackingPopular$Attacking$Ammunition(
      total: (total != null ? total.value : this.total),
      special: (special != null ? special.value : this.special),
      hollowPoint: (hollowPoint != null ? hollowPoint.value : this.hollowPoint),
      tracer: (tracer != null ? tracer.value : this.tracer),
      piercing: (piercing != null ? piercing.value : this.piercing),
      incendiary: (incendiary != null ? incendiary.value : this.incendiary),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsAttackingPopular$Attacking$Faction {
  const PersonalStatsAttackingPopular$Attacking$Faction({
    required this.respect,
    required this.rankedWarHits,
  });

  factory PersonalStatsAttackingPopular$Attacking$Faction.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$PersonalStatsAttackingPopular$Attacking$FactionFromJson(json);

  static const toJsonFactory = _$PersonalStatsAttackingPopular$Attacking$FactionToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsAttackingPopular$Attacking$FactionToJson(this);

  @JsonKey(name: 'respect')
  final int respect;
  @JsonKey(name: 'ranked_war_hits')
  final int rankedWarHits;
  static const fromJsonFactory = _$PersonalStatsAttackingPopular$Attacking$FactionFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsAttackingPopular$Attacking$Faction &&
            (identical(other.respect, respect) ||
                const DeepCollectionEquality().equals(
                  other.respect,
                  respect,
                )) &&
            (identical(other.rankedWarHits, rankedWarHits) ||
                const DeepCollectionEquality().equals(
                  other.rankedWarHits,
                  rankedWarHits,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(respect) ^
      const DeepCollectionEquality().hash(rankedWarHits) ^
      runtimeType.hashCode;
}

extension $PersonalStatsAttackingPopular$Attacking$FactionExtension on PersonalStatsAttackingPopular$Attacking$Faction {
  PersonalStatsAttackingPopular$Attacking$Faction copyWith({
    int? respect,
    int? rankedWarHits,
  }) {
    return PersonalStatsAttackingPopular$Attacking$Faction(
      respect: respect ?? this.respect,
      rankedWarHits: rankedWarHits ?? this.rankedWarHits,
    );
  }

  PersonalStatsAttackingPopular$Attacking$Faction copyWithWrapped({
    Wrapped<int>? respect,
    Wrapped<int>? rankedWarHits,
  }) {
    return PersonalStatsAttackingPopular$Attacking$Faction(
      respect: (respect != null ? respect.value : this.respect),
      rankedWarHits: (rankedWarHits != null ? rankedWarHits.value : this.rankedWarHits),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionRankedWarReportResponse$Rankedwarreport$Factions$Item {
  const FactionRankedWarReportResponse$Rankedwarreport$Factions$Item({
    required this.id,
    required this.name,
    required this.score,
    required this.attacks,
    required this.rank,
    required this.rewards,
    required this.members,
  });

  factory FactionRankedWarReportResponse$Rankedwarreport$Factions$Item.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$FactionRankedWarReportResponse$Rankedwarreport$Factions$ItemFromJson(
        json,
      );

  static const toJsonFactory = _$FactionRankedWarReportResponse$Rankedwarreport$Factions$ItemToJson;
  Map<String, dynamic> toJson() => _$FactionRankedWarReportResponse$Rankedwarreport$Factions$ItemToJson(
        this,
      );

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'score')
  final int score;
  @JsonKey(name: 'attacks')
  final int attacks;
  @JsonKey(name: 'rank')
  final FactionRankedWarReportResponse$Rankedwarreport$Factions$Item$Rank rank;
  @JsonKey(name: 'rewards')
  final FactionRankedWarReportResponse$Rankedwarreport$Factions$Item$Rewards rewards;
  @JsonKey(name: 'members')
  final List<FactionRankedWarReportResponse$Rankedwarreport$Factions$Item$Members$Item> members;
  static const fromJsonFactory = _$FactionRankedWarReportResponse$Rankedwarreport$Factions$ItemFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionRankedWarReportResponse$Rankedwarreport$Factions$Item &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.score, score) || const DeepCollectionEquality().equals(other.score, score)) &&
            (identical(other.attacks, attacks) ||
                const DeepCollectionEquality().equals(
                  other.attacks,
                  attacks,
                )) &&
            (identical(other.rank, rank) || const DeepCollectionEquality().equals(other.rank, rank)) &&
            (identical(other.rewards, rewards) ||
                const DeepCollectionEquality().equals(
                  other.rewards,
                  rewards,
                )) &&
            (identical(other.members, members) || const DeepCollectionEquality().equals(other.members, members)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(score) ^
      const DeepCollectionEquality().hash(attacks) ^
      const DeepCollectionEquality().hash(rank) ^
      const DeepCollectionEquality().hash(rewards) ^
      const DeepCollectionEquality().hash(members) ^
      runtimeType.hashCode;
}

extension $FactionRankedWarReportResponse$Rankedwarreport$Factions$ItemExtension
    on FactionRankedWarReportResponse$Rankedwarreport$Factions$Item {
  FactionRankedWarReportResponse$Rankedwarreport$Factions$Item copyWith({
    int? id,
    String? name,
    int? score,
    int? attacks,
    FactionRankedWarReportResponse$Rankedwarreport$Factions$Item$Rank? rank,
    FactionRankedWarReportResponse$Rankedwarreport$Factions$Item$Rewards? rewards,
    List<FactionRankedWarReportResponse$Rankedwarreport$Factions$Item$Members$Item>? members,
  }) {
    return FactionRankedWarReportResponse$Rankedwarreport$Factions$Item(
      id: id ?? this.id,
      name: name ?? this.name,
      score: score ?? this.score,
      attacks: attacks ?? this.attacks,
      rank: rank ?? this.rank,
      rewards: rewards ?? this.rewards,
      members: members ?? this.members,
    );
  }

  FactionRankedWarReportResponse$Rankedwarreport$Factions$Item copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<String>? name,
    Wrapped<int>? score,
    Wrapped<int>? attacks,
    Wrapped<FactionRankedWarReportResponse$Rankedwarreport$Factions$Item$Rank>? rank,
    Wrapped<FactionRankedWarReportResponse$Rankedwarreport$Factions$Item$Rewards>? rewards,
    Wrapped<List<FactionRankedWarReportResponse$Rankedwarreport$Factions$Item$Members$Item>>? members,
  }) {
    return FactionRankedWarReportResponse$Rankedwarreport$Factions$Item(
      id: (id != null ? id.value : this.id),
      name: (name != null ? name.value : this.name),
      score: (score != null ? score.value : this.score),
      attacks: (attacks != null ? attacks.value : this.attacks),
      rank: (rank != null ? rank.value : this.rank),
      rewards: (rewards != null ? rewards.value : this.rewards),
      members: (members != null ? members.value : this.members),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class KeyInfoResponse$Info$Selections {
  const KeyInfoResponse$Info$Selections({
    required this.company,
    required this.faction,
    required this.market,
    required this.property,
    required this.torn,
    required this.user,
    required this.racing,
    required this.forum,
    required this.key,
  });

  factory KeyInfoResponse$Info$Selections.fromJson(Map<String, dynamic> json) =>
      _$KeyInfoResponse$Info$SelectionsFromJson(json);

  static const toJsonFactory = _$KeyInfoResponse$Info$SelectionsToJson;
  Map<String, dynamic> toJson() => _$KeyInfoResponse$Info$SelectionsToJson(this);

  @JsonKey(name: 'company', defaultValue: <String>[])
  final List<String> company;
  @JsonKey(name: 'faction', defaultValue: <FactionSelectionName>[])
  final List<FactionSelectionName> faction;
  @JsonKey(name: 'market', defaultValue: <MarketSelectionName>[])
  final List<MarketSelectionName> market;
  @JsonKey(name: 'property', defaultValue: <String>[])
  final List<String> property;
  @JsonKey(name: 'torn', defaultValue: <TornSelectionName>[])
  final List<TornSelectionName> torn;
  @JsonKey(name: 'user', defaultValue: <UserSelectionName>[])
  final List<UserSelectionName> user;
  @JsonKey(name: 'racing', defaultValue: <RacingSelectionName>[])
  final List<RacingSelectionName> racing;
  @JsonKey(name: 'forum', defaultValue: <ForumSelectionName>[])
  final List<ForumSelectionName> forum;
  @JsonKey(name: 'key', defaultValue: <KeySelectionName>[])
  final List<KeySelectionName> key;
  static const fromJsonFactory = _$KeyInfoResponse$Info$SelectionsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is KeyInfoResponse$Info$Selections &&
            (identical(other.company, company) ||
                const DeepCollectionEquality().equals(
                  other.company,
                  company,
                )) &&
            (identical(other.faction, faction) ||
                const DeepCollectionEquality().equals(
                  other.faction,
                  faction,
                )) &&
            (identical(other.market, market) || const DeepCollectionEquality().equals(other.market, market)) &&
            (identical(other.property, property) ||
                const DeepCollectionEquality().equals(
                  other.property,
                  property,
                )) &&
            (identical(other.torn, torn) || const DeepCollectionEquality().equals(other.torn, torn)) &&
            (identical(other.user, user) || const DeepCollectionEquality().equals(other.user, user)) &&
            (identical(other.racing, racing) || const DeepCollectionEquality().equals(other.racing, racing)) &&
            (identical(other.forum, forum) || const DeepCollectionEquality().equals(other.forum, forum)) &&
            (identical(other.key, key) || const DeepCollectionEquality().equals(other.key, key)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(company) ^
      const DeepCollectionEquality().hash(faction) ^
      const DeepCollectionEquality().hash(market) ^
      const DeepCollectionEquality().hash(property) ^
      const DeepCollectionEquality().hash(torn) ^
      const DeepCollectionEquality().hash(user) ^
      const DeepCollectionEquality().hash(racing) ^
      const DeepCollectionEquality().hash(forum) ^
      const DeepCollectionEquality().hash(key) ^
      runtimeType.hashCode;
}

extension $KeyInfoResponse$Info$SelectionsExtension on KeyInfoResponse$Info$Selections {
  KeyInfoResponse$Info$Selections copyWith({
    List<String>? company,
    List<FactionSelectionName>? faction,
    List<MarketSelectionName>? market,
    List<String>? property,
    List<TornSelectionName>? torn,
    List<UserSelectionName>? user,
    List<RacingSelectionName>? racing,
    List<ForumSelectionName>? forum,
    List<KeySelectionName>? key,
  }) {
    return KeyInfoResponse$Info$Selections(
      company: company ?? this.company,
      faction: faction ?? this.faction,
      market: market ?? this.market,
      property: property ?? this.property,
      torn: torn ?? this.torn,
      user: user ?? this.user,
      racing: racing ?? this.racing,
      forum: forum ?? this.forum,
      key: key ?? this.key,
    );
  }

  KeyInfoResponse$Info$Selections copyWithWrapped({
    Wrapped<List<String>>? company,
    Wrapped<List<FactionSelectionName>>? faction,
    Wrapped<List<MarketSelectionName>>? market,
    Wrapped<List<String>>? property,
    Wrapped<List<TornSelectionName>>? torn,
    Wrapped<List<UserSelectionName>>? user,
    Wrapped<List<RacingSelectionName>>? racing,
    Wrapped<List<ForumSelectionName>>? forum,
    Wrapped<List<KeySelectionName>>? key,
  }) {
    return KeyInfoResponse$Info$Selections(
      company: (company != null ? company.value : this.company),
      faction: (faction != null ? faction.value : this.faction),
      market: (market != null ? market.value : this.market),
      property: (property != null ? property.value : this.property),
      torn: (torn != null ? torn.value : this.torn),
      user: (user != null ? user.value : this.user),
      racing: (racing != null ? racing.value : this.racing),
      forum: (forum != null ? forum.value : this.forum),
      key: (key != null ? key.value : this.key),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class KeyInfoResponse$Info$Access {
  const KeyInfoResponse$Info$Access({
    required this.level,
    required this.type,
    required this.faction,
    this.factionId,
    required this.company,
    this.companyId,
  });

  factory KeyInfoResponse$Info$Access.fromJson(Map<String, dynamic> json) =>
      _$KeyInfoResponse$Info$AccessFromJson(json);

  static const toJsonFactory = _$KeyInfoResponse$Info$AccessToJson;
  Map<String, dynamic> toJson() => _$KeyInfoResponse$Info$AccessToJson(this);

  @JsonKey(name: 'level')
  final int level;
  @JsonKey(
    name: 'type',
    toJson: apiKeyAccessTypeEnumToJson,
    fromJson: apiKeyAccessTypeEnumFromJson,
  )
  final enums.ApiKeyAccessTypeEnum type;
  @JsonKey(name: 'faction')
  final bool faction;
  @JsonKey(name: 'faction_id')
  final dynamic factionId;
  @JsonKey(name: 'company')
  final bool company;
  @JsonKey(name: 'company_id')
  final dynamic companyId;
  static const fromJsonFactory = _$KeyInfoResponse$Info$AccessFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is KeyInfoResponse$Info$Access &&
            (identical(other.level, level) || const DeepCollectionEquality().equals(other.level, level)) &&
            (identical(other.type, type) || const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.faction, faction) ||
                const DeepCollectionEquality().equals(
                  other.faction,
                  faction,
                )) &&
            (identical(other.factionId, factionId) ||
                const DeepCollectionEquality().equals(
                  other.factionId,
                  factionId,
                )) &&
            (identical(other.company, company) ||
                const DeepCollectionEquality().equals(
                  other.company,
                  company,
                )) &&
            (identical(other.companyId, companyId) ||
                const DeepCollectionEquality().equals(
                  other.companyId,
                  companyId,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(level) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(faction) ^
      const DeepCollectionEquality().hash(factionId) ^
      const DeepCollectionEquality().hash(company) ^
      const DeepCollectionEquality().hash(companyId) ^
      runtimeType.hashCode;
}

extension $KeyInfoResponse$Info$AccessExtension on KeyInfoResponse$Info$Access {
  KeyInfoResponse$Info$Access copyWith({
    int? level,
    enums.ApiKeyAccessTypeEnum? type,
    bool? faction,
    dynamic factionId,
    bool? company,
    dynamic companyId,
  }) {
    return KeyInfoResponse$Info$Access(
      level: level ?? this.level,
      type: type ?? this.type,
      faction: faction ?? this.faction,
      factionId: factionId ?? this.factionId,
      company: company ?? this.company,
      companyId: companyId ?? this.companyId,
    );
  }

  KeyInfoResponse$Info$Access copyWithWrapped({
    Wrapped<int>? level,
    Wrapped<enums.ApiKeyAccessTypeEnum>? type,
    Wrapped<bool>? faction,
    Wrapped<dynamic>? factionId,
    Wrapped<bool>? company,
    Wrapped<dynamic>? companyId,
  }) {
    return KeyInfoResponse$Info$Access(
      level: (level != null ? level.value : this.level),
      type: (type != null ? type.value : this.type),
      faction: (faction != null ? faction.value : this.faction),
      factionId: (factionId != null ? factionId.value : this.factionId),
      company: (company != null ? company.value : this.company),
      companyId: (companyId != null ? companyId.value : this.companyId),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserRacingRecordsResponse$Racingrecords$Item$Track {
  const UserRacingRecordsResponse$Racingrecords$Item$Track({
    required this.id,
    required this.name,
  });

  factory UserRacingRecordsResponse$Racingrecords$Item$Track.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$UserRacingRecordsResponse$Racingrecords$Item$TrackFromJson(json);

  static const toJsonFactory = _$UserRacingRecordsResponse$Racingrecords$Item$TrackToJson;
  Map<String, dynamic> toJson() => _$UserRacingRecordsResponse$Racingrecords$Item$TrackToJson(this);

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'name')
  final String name;
  static const fromJsonFactory = _$UserRacingRecordsResponse$Racingrecords$Item$TrackFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserRacingRecordsResponse$Racingrecords$Item$Track &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^ const DeepCollectionEquality().hash(name) ^ runtimeType.hashCode;
}

extension $UserRacingRecordsResponse$Racingrecords$Item$TrackExtension
    on UserRacingRecordsResponse$Racingrecords$Item$Track {
  UserRacingRecordsResponse$Racingrecords$Item$Track copyWith({
    int? id,
    String? name,
  }) {
    return UserRacingRecordsResponse$Racingrecords$Item$Track(
      id: id ?? this.id,
      name: name ?? this.name,
    );
  }

  UserRacingRecordsResponse$Racingrecords$Item$Track copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<String>? name,
  }) {
    return UserRacingRecordsResponse$Racingrecords$Item$Track(
      id: (id != null ? id.value : this.id),
      name: (name != null ? name.value : this.name),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class UserRacingRecordsResponse$Racingrecords$Item$Records$Item {
  const UserRacingRecordsResponse$Racingrecords$Item$Records$Item({
    required this.carId,
    required this.carName,
    required this.lapTime,
  });

  factory UserRacingRecordsResponse$Racingrecords$Item$Records$Item.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$UserRacingRecordsResponse$Racingrecords$Item$Records$ItemFromJson(json);

  static const toJsonFactory = _$UserRacingRecordsResponse$Racingrecords$Item$Records$ItemToJson;
  Map<String, dynamic> toJson() => _$UserRacingRecordsResponse$Racingrecords$Item$Records$ItemToJson(this);

  @JsonKey(name: 'car_id')
  final int carId;
  @JsonKey(name: 'car_name')
  final String carName;
  @JsonKey(name: 'lap_time')
  final int lapTime;
  static const fromJsonFactory = _$UserRacingRecordsResponse$Racingrecords$Item$Records$ItemFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserRacingRecordsResponse$Racingrecords$Item$Records$Item &&
            (identical(other.carId, carId) || const DeepCollectionEquality().equals(other.carId, carId)) &&
            (identical(other.carName, carName) ||
                const DeepCollectionEquality().equals(
                  other.carName,
                  carName,
                )) &&
            (identical(other.lapTime, lapTime) || const DeepCollectionEquality().equals(other.lapTime, lapTime)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(carId) ^
      const DeepCollectionEquality().hash(carName) ^
      const DeepCollectionEquality().hash(lapTime) ^
      runtimeType.hashCode;
}

extension $UserRacingRecordsResponse$Racingrecords$Item$Records$ItemExtension
    on UserRacingRecordsResponse$Racingrecords$Item$Records$Item {
  UserRacingRecordsResponse$Racingrecords$Item$Records$Item copyWith({
    int? carId,
    String? carName,
    int? lapTime,
  }) {
    return UserRacingRecordsResponse$Racingrecords$Item$Records$Item(
      carId: carId ?? this.carId,
      carName: carName ?? this.carName,
      lapTime: lapTime ?? this.lapTime,
    );
  }

  UserRacingRecordsResponse$Racingrecords$Item$Records$Item copyWithWrapped({
    Wrapped<int>? carId,
    Wrapped<String>? carName,
    Wrapped<int>? lapTime,
  }) {
    return UserRacingRecordsResponse$Racingrecords$Item$Records$Item(
      carId: (carId != null ? carId.value : this.carId),
      carName: (carName != null ? carName.value : this.carName),
      lapTime: (lapTime != null ? lapTime.value : this.lapTime),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsOther$Other$Activity$Streak {
  const PersonalStatsOther$Other$Activity$Streak({
    required this.best,
    required this.current,
  });

  factory PersonalStatsOther$Other$Activity$Streak.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$PersonalStatsOther$Other$Activity$StreakFromJson(json);

  static const toJsonFactory = _$PersonalStatsOther$Other$Activity$StreakToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsOther$Other$Activity$StreakToJson(this);

  @JsonKey(name: 'best')
  final int best;
  @JsonKey(name: 'current')
  final int current;
  static const fromJsonFactory = _$PersonalStatsOther$Other$Activity$StreakFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsOther$Other$Activity$Streak &&
            (identical(other.best, best) || const DeepCollectionEquality().equals(other.best, best)) &&
            (identical(other.current, current) || const DeepCollectionEquality().equals(other.current, current)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(best) ^ const DeepCollectionEquality().hash(current) ^ runtimeType.hashCode;
}

extension $PersonalStatsOther$Other$Activity$StreakExtension on PersonalStatsOther$Other$Activity$Streak {
  PersonalStatsOther$Other$Activity$Streak copyWith({int? best, int? current}) {
    return PersonalStatsOther$Other$Activity$Streak(
      best: best ?? this.best,
      current: current ?? this.current,
    );
  }

  PersonalStatsOther$Other$Activity$Streak copyWithWrapped({
    Wrapped<int>? best,
    Wrapped<int>? current,
  }) {
    return PersonalStatsOther$Other$Activity$Streak(
      best: (best != null ? best.value : this.best),
      current: (current != null ? current.value : this.current),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsOtherPopular$Other$Activity$Streak {
  const PersonalStatsOtherPopular$Other$Activity$Streak({
    required this.best,
    required this.current,
  });

  factory PersonalStatsOtherPopular$Other$Activity$Streak.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$PersonalStatsOtherPopular$Other$Activity$StreakFromJson(json);

  static const toJsonFactory = _$PersonalStatsOtherPopular$Other$Activity$StreakToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsOtherPopular$Other$Activity$StreakToJson(this);

  @JsonKey(name: 'best')
  final int best;
  @JsonKey(name: 'current')
  final int current;
  static const fromJsonFactory = _$PersonalStatsOtherPopular$Other$Activity$StreakFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsOtherPopular$Other$Activity$Streak &&
            (identical(other.best, best) || const DeepCollectionEquality().equals(other.best, best)) &&
            (identical(other.current, current) || const DeepCollectionEquality().equals(other.current, current)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(best) ^ const DeepCollectionEquality().hash(current) ^ runtimeType.hashCode;
}

extension $PersonalStatsOtherPopular$Other$Activity$StreakExtension on PersonalStatsOtherPopular$Other$Activity$Streak {
  PersonalStatsOtherPopular$Other$Activity$Streak copyWith({
    int? best,
    int? current,
  }) {
    return PersonalStatsOtherPopular$Other$Activity$Streak(
      best: best ?? this.best,
      current: current ?? this.current,
    );
  }

  PersonalStatsOtherPopular$Other$Activity$Streak copyWithWrapped({
    Wrapped<int>? best,
    Wrapped<int>? current,
  }) {
    return PersonalStatsOtherPopular$Other$Activity$Streak(
      best: (best != null ? best.value : this.best),
      current: (current != null ? current.value : this.current),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsTrading$Trading$Items$Bought {
  const PersonalStatsTrading$Trading$Items$Bought({
    required this.market,
    required this.shops,
  });

  factory PersonalStatsTrading$Trading$Items$Bought.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$PersonalStatsTrading$Trading$Items$BoughtFromJson(json);

  static const toJsonFactory = _$PersonalStatsTrading$Trading$Items$BoughtToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsTrading$Trading$Items$BoughtToJson(this);

  @JsonKey(name: 'market')
  final int market;
  @JsonKey(name: 'shops')
  final int shops;
  static const fromJsonFactory = _$PersonalStatsTrading$Trading$Items$BoughtFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsTrading$Trading$Items$Bought &&
            (identical(other.market, market) || const DeepCollectionEquality().equals(other.market, market)) &&
            (identical(other.shops, shops) || const DeepCollectionEquality().equals(other.shops, shops)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(market) ^ const DeepCollectionEquality().hash(shops) ^ runtimeType.hashCode;
}

extension $PersonalStatsTrading$Trading$Items$BoughtExtension on PersonalStatsTrading$Trading$Items$Bought {
  PersonalStatsTrading$Trading$Items$Bought copyWith({
    int? market,
    int? shops,
  }) {
    return PersonalStatsTrading$Trading$Items$Bought(
      market: market ?? this.market,
      shops: shops ?? this.shops,
    );
  }

  PersonalStatsTrading$Trading$Items$Bought copyWithWrapped({
    Wrapped<int>? market,
    Wrapped<int>? shops,
  }) {
    return PersonalStatsTrading$Trading$Items$Bought(
      market: (market != null ? market.value : this.market),
      shops: (shops != null ? shops.value : this.shops),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsTrading$Trading$Items$Auctions {
  const PersonalStatsTrading$Trading$Items$Auctions({
    required this.won,
    required this.sold,
  });

  factory PersonalStatsTrading$Trading$Items$Auctions.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$PersonalStatsTrading$Trading$Items$AuctionsFromJson(json);

  static const toJsonFactory = _$PersonalStatsTrading$Trading$Items$AuctionsToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsTrading$Trading$Items$AuctionsToJson(this);

  @JsonKey(name: 'won')
  final int won;
  @JsonKey(name: 'sold')
  final int sold;
  static const fromJsonFactory = _$PersonalStatsTrading$Trading$Items$AuctionsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsTrading$Trading$Items$Auctions &&
            (identical(other.won, won) || const DeepCollectionEquality().equals(other.won, won)) &&
            (identical(other.sold, sold) || const DeepCollectionEquality().equals(other.sold, sold)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(won) ^ const DeepCollectionEquality().hash(sold) ^ runtimeType.hashCode;
}

extension $PersonalStatsTrading$Trading$Items$AuctionsExtension on PersonalStatsTrading$Trading$Items$Auctions {
  PersonalStatsTrading$Trading$Items$Auctions copyWith({int? won, int? sold}) {
    return PersonalStatsTrading$Trading$Items$Auctions(
      won: won ?? this.won,
      sold: sold ?? this.sold,
    );
  }

  PersonalStatsTrading$Trading$Items$Auctions copyWithWrapped({
    Wrapped<int>? won,
    Wrapped<int>? sold,
  }) {
    return PersonalStatsTrading$Trading$Items$Auctions(
      won: (won != null ? won.value : this.won),
      sold: (sold != null ? sold.value : this.sold),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsAttackingPublic$Attacking$Faction$Territory {
  const PersonalStatsAttackingPublic$Attacking$Faction$Territory({
    required this.wallJoins,
    required this.wallClears,
    required this.wallTime,
  });

  factory PersonalStatsAttackingPublic$Attacking$Faction$Territory.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$PersonalStatsAttackingPublic$Attacking$Faction$TerritoryFromJson(json);

  static const toJsonFactory = _$PersonalStatsAttackingPublic$Attacking$Faction$TerritoryToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsAttackingPublic$Attacking$Faction$TerritoryToJson(this);

  @JsonKey(name: 'wall_joins')
  final int wallJoins;
  @JsonKey(name: 'wall_clears')
  final int wallClears;
  @JsonKey(name: 'wall_time')
  final int wallTime;
  static const fromJsonFactory = _$PersonalStatsAttackingPublic$Attacking$Faction$TerritoryFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsAttackingPublic$Attacking$Faction$Territory &&
            (identical(other.wallJoins, wallJoins) ||
                const DeepCollectionEquality().equals(
                  other.wallJoins,
                  wallJoins,
                )) &&
            (identical(other.wallClears, wallClears) ||
                const DeepCollectionEquality().equals(
                  other.wallClears,
                  wallClears,
                )) &&
            (identical(other.wallTime, wallTime) ||
                const DeepCollectionEquality().equals(
                  other.wallTime,
                  wallTime,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(wallJoins) ^
      const DeepCollectionEquality().hash(wallClears) ^
      const DeepCollectionEquality().hash(wallTime) ^
      runtimeType.hashCode;
}

extension $PersonalStatsAttackingPublic$Attacking$Faction$TerritoryExtension
    on PersonalStatsAttackingPublic$Attacking$Faction$Territory {
  PersonalStatsAttackingPublic$Attacking$Faction$Territory copyWith({
    int? wallJoins,
    int? wallClears,
    int? wallTime,
  }) {
    return PersonalStatsAttackingPublic$Attacking$Faction$Territory(
      wallJoins: wallJoins ?? this.wallJoins,
      wallClears: wallClears ?? this.wallClears,
      wallTime: wallTime ?? this.wallTime,
    );
  }

  PersonalStatsAttackingPublic$Attacking$Faction$Territory copyWithWrapped({
    Wrapped<int>? wallJoins,
    Wrapped<int>? wallClears,
    Wrapped<int>? wallTime,
  }) {
    return PersonalStatsAttackingPublic$Attacking$Faction$Territory(
      wallJoins: (wallJoins != null ? wallJoins.value : this.wallJoins),
      wallClears: (wallClears != null ? wallClears.value : this.wallClears),
      wallTime: (wallTime != null ? wallTime.value : this.wallTime),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalStatsAttackingExtended$Attacking$Faction$Territory {
  const PersonalStatsAttackingExtended$Attacking$Faction$Territory({
    required this.wallJoins,
    required this.wallClears,
    required this.wallTime,
  });

  factory PersonalStatsAttackingExtended$Attacking$Faction$Territory.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$PersonalStatsAttackingExtended$Attacking$Faction$TerritoryFromJson(
        json,
      );

  static const toJsonFactory = _$PersonalStatsAttackingExtended$Attacking$Faction$TerritoryToJson;
  Map<String, dynamic> toJson() => _$PersonalStatsAttackingExtended$Attacking$Faction$TerritoryToJson(this);

  @JsonKey(name: 'wall_joins')
  final int wallJoins;
  @JsonKey(name: 'wall_clears')
  final int wallClears;
  @JsonKey(name: 'wall_time')
  final int wallTime;
  static const fromJsonFactory = _$PersonalStatsAttackingExtended$Attacking$Faction$TerritoryFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalStatsAttackingExtended$Attacking$Faction$Territory &&
            (identical(other.wallJoins, wallJoins) ||
                const DeepCollectionEquality().equals(
                  other.wallJoins,
                  wallJoins,
                )) &&
            (identical(other.wallClears, wallClears) ||
                const DeepCollectionEquality().equals(
                  other.wallClears,
                  wallClears,
                )) &&
            (identical(other.wallTime, wallTime) ||
                const DeepCollectionEquality().equals(
                  other.wallTime,
                  wallTime,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(wallJoins) ^
      const DeepCollectionEquality().hash(wallClears) ^
      const DeepCollectionEquality().hash(wallTime) ^
      runtimeType.hashCode;
}

extension $PersonalStatsAttackingExtended$Attacking$Faction$TerritoryExtension
    on PersonalStatsAttackingExtended$Attacking$Faction$Territory {
  PersonalStatsAttackingExtended$Attacking$Faction$Territory copyWith({
    int? wallJoins,
    int? wallClears,
    int? wallTime,
  }) {
    return PersonalStatsAttackingExtended$Attacking$Faction$Territory(
      wallJoins: wallJoins ?? this.wallJoins,
      wallClears: wallClears ?? this.wallClears,
      wallTime: wallTime ?? this.wallTime,
    );
  }

  PersonalStatsAttackingExtended$Attacking$Faction$Territory copyWithWrapped({
    Wrapped<int>? wallJoins,
    Wrapped<int>? wallClears,
    Wrapped<int>? wallTime,
  }) {
    return PersonalStatsAttackingExtended$Attacking$Faction$Territory(
      wallJoins: (wallJoins != null ? wallJoins.value : this.wallJoins),
      wallClears: (wallClears != null ? wallClears.value : this.wallClears),
      wallTime: (wallTime != null ? wallTime.value : this.wallTime),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionRankedWarReportResponse$Rankedwarreport$Factions$Item$Rank {
  const FactionRankedWarReportResponse$Rankedwarreport$Factions$Item$Rank({
    required this.before,
    required this.after,
  });

  factory FactionRankedWarReportResponse$Rankedwarreport$Factions$Item$Rank.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$FactionRankedWarReportResponse$Rankedwarreport$Factions$Item$RankFromJson(
        json,
      );

  static const toJsonFactory = _$FactionRankedWarReportResponse$Rankedwarreport$Factions$Item$RankToJson;
  Map<String, dynamic> toJson() => _$FactionRankedWarReportResponse$Rankedwarreport$Factions$Item$RankToJson(
        this,
      );

  @JsonKey(name: 'before')
  final String before;
  @JsonKey(name: 'after')
  final String after;
  static const fromJsonFactory = _$FactionRankedWarReportResponse$Rankedwarreport$Factions$Item$RankFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionRankedWarReportResponse$Rankedwarreport$Factions$Item$Rank &&
            (identical(other.before, before) || const DeepCollectionEquality().equals(other.before, before)) &&
            (identical(other.after, after) || const DeepCollectionEquality().equals(other.after, after)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(before) ^ const DeepCollectionEquality().hash(after) ^ runtimeType.hashCode;
}

extension $FactionRankedWarReportResponse$Rankedwarreport$Factions$Item$RankExtension
    on FactionRankedWarReportResponse$Rankedwarreport$Factions$Item$Rank {
  FactionRankedWarReportResponse$Rankedwarreport$Factions$Item$Rank copyWith({
    String? before,
    String? after,
  }) {
    return FactionRankedWarReportResponse$Rankedwarreport$Factions$Item$Rank(
      before: before ?? this.before,
      after: after ?? this.after,
    );
  }

  FactionRankedWarReportResponse$Rankedwarreport$Factions$Item$Rank copyWithWrapped(
      {Wrapped<String>? before, Wrapped<String>? after}) {
    return FactionRankedWarReportResponse$Rankedwarreport$Factions$Item$Rank(
      before: (before != null ? before.value : this.before),
      after: (after != null ? after.value : this.after),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionRankedWarReportResponse$Rankedwarreport$Factions$Item$Rewards {
  const FactionRankedWarReportResponse$Rankedwarreport$Factions$Item$Rewards({
    required this.respect,
    required this.points,
    required this.items,
  });

  factory FactionRankedWarReportResponse$Rankedwarreport$Factions$Item$Rewards.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$FactionRankedWarReportResponse$Rankedwarreport$Factions$Item$RewardsFromJson(
        json,
      );

  static const toJsonFactory = _$FactionRankedWarReportResponse$Rankedwarreport$Factions$Item$RewardsToJson;
  Map<String, dynamic> toJson() => _$FactionRankedWarReportResponse$Rankedwarreport$Factions$Item$RewardsToJson(
        this,
      );

  @JsonKey(name: 'respect')
  final int respect;
  @JsonKey(name: 'points')
  final int points;
  @JsonKey(name: 'items')
  final List<FactionRankedWarReportResponse$Rankedwarreport$Factions$Item$Rewards$Items$Item> items;
  static const fromJsonFactory = _$FactionRankedWarReportResponse$Rankedwarreport$Factions$Item$RewardsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionRankedWarReportResponse$Rankedwarreport$Factions$Item$Rewards &&
            (identical(other.respect, respect) ||
                const DeepCollectionEquality().equals(
                  other.respect,
                  respect,
                )) &&
            (identical(other.points, points) || const DeepCollectionEquality().equals(other.points, points)) &&
            (identical(other.items, items) || const DeepCollectionEquality().equals(other.items, items)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(respect) ^
      const DeepCollectionEquality().hash(points) ^
      const DeepCollectionEquality().hash(items) ^
      runtimeType.hashCode;
}

extension $FactionRankedWarReportResponse$Rankedwarreport$Factions$Item$RewardsExtension
    on FactionRankedWarReportResponse$Rankedwarreport$Factions$Item$Rewards {
  FactionRankedWarReportResponse$Rankedwarreport$Factions$Item$Rewards copyWith({
    int? respect,
    int? points,
    List<FactionRankedWarReportResponse$Rankedwarreport$Factions$Item$Rewards$Items$Item>? items,
  }) {
    return FactionRankedWarReportResponse$Rankedwarreport$Factions$Item$Rewards(
      respect: respect ?? this.respect,
      points: points ?? this.points,
      items: items ?? this.items,
    );
  }

  FactionRankedWarReportResponse$Rankedwarreport$Factions$Item$Rewards copyWithWrapped({
    Wrapped<int>? respect,
    Wrapped<int>? points,
    Wrapped<List<FactionRankedWarReportResponse$Rankedwarreport$Factions$Item$Rewards$Items$Item>>? items,
  }) {
    return FactionRankedWarReportResponse$Rankedwarreport$Factions$Item$Rewards(
      respect: (respect != null ? respect.value : this.respect),
      points: (points != null ? points.value : this.points),
      items: (items != null ? items.value : this.items),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionRankedWarReportResponse$Rankedwarreport$Factions$Item$Members$Item {
  const FactionRankedWarReportResponse$Rankedwarreport$Factions$Item$Members$Item({
    required this.id,
    required this.name,
    required this.level,
    required this.attacks,
    required this.score,
  });

  factory FactionRankedWarReportResponse$Rankedwarreport$Factions$Item$Members$Item.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$FactionRankedWarReportResponse$Rankedwarreport$Factions$Item$Members$ItemFromJson(
        json,
      );

  static const toJsonFactory = _$FactionRankedWarReportResponse$Rankedwarreport$Factions$Item$Members$ItemToJson;
  Map<String, dynamic> toJson() => _$FactionRankedWarReportResponse$Rankedwarreport$Factions$Item$Members$ItemToJson(
        this,
      );

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'level')
  final int level;
  @JsonKey(name: 'attacks')
  final int attacks;
  @JsonKey(name: 'score')
  final double score;
  static const fromJsonFactory = _$FactionRankedWarReportResponse$Rankedwarreport$Factions$Item$Members$ItemFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionRankedWarReportResponse$Rankedwarreport$Factions$Item$Members$Item &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.level, level) || const DeepCollectionEquality().equals(other.level, level)) &&
            (identical(other.attacks, attacks) ||
                const DeepCollectionEquality().equals(
                  other.attacks,
                  attacks,
                )) &&
            (identical(other.score, score) || const DeepCollectionEquality().equals(other.score, score)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(level) ^
      const DeepCollectionEquality().hash(attacks) ^
      const DeepCollectionEquality().hash(score) ^
      runtimeType.hashCode;
}

extension $FactionRankedWarReportResponse$Rankedwarreport$Factions$Item$Members$ItemExtension
    on FactionRankedWarReportResponse$Rankedwarreport$Factions$Item$Members$Item {
  FactionRankedWarReportResponse$Rankedwarreport$Factions$Item$Members$Item copyWith(
      {int? id, String? name, int? level, int? attacks, double? score}) {
    return FactionRankedWarReportResponse$Rankedwarreport$Factions$Item$Members$Item(
      id: id ?? this.id,
      name: name ?? this.name,
      level: level ?? this.level,
      attacks: attacks ?? this.attacks,
      score: score ?? this.score,
    );
  }

  FactionRankedWarReportResponse$Rankedwarreport$Factions$Item$Members$Item copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<String>? name,
    Wrapped<int>? level,
    Wrapped<int>? attacks,
    Wrapped<double>? score,
  }) {
    return FactionRankedWarReportResponse$Rankedwarreport$Factions$Item$Members$Item(
      id: (id != null ? id.value : this.id),
      name: (name != null ? name.value : this.name),
      level: (level != null ? level.value : this.level),
      attacks: (attacks != null ? attacks.value : this.attacks),
      score: (score != null ? score.value : this.score),
    );
  }
}

@JsonSerializable(explicitToJson: true)
class FactionRankedWarReportResponse$Rankedwarreport$Factions$Item$Rewards$Items$Item {
  const FactionRankedWarReportResponse$Rankedwarreport$Factions$Item$Rewards$Items$Item({
    required this.id,
    required this.name,
    required this.quantity,
  });

  factory FactionRankedWarReportResponse$Rankedwarreport$Factions$Item$Rewards$Items$Item.fromJson(
    Map<String, dynamic> json,
  ) =>
      _$FactionRankedWarReportResponse$Rankedwarreport$Factions$Item$Rewards$Items$ItemFromJson(
        json,
      );

  static const toJsonFactory = _$FactionRankedWarReportResponse$Rankedwarreport$Factions$Item$Rewards$Items$ItemToJson;
  Map<String, dynamic> toJson() =>
      _$FactionRankedWarReportResponse$Rankedwarreport$Factions$Item$Rewards$Items$ItemToJson(
        this,
      );

  @JsonKey(name: 'id')
  final int id;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'quantity')
  final int quantity;
  static const fromJsonFactory =
      _$FactionRankedWarReportResponse$Rankedwarreport$Factions$Item$Rewards$Items$ItemFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FactionRankedWarReportResponse$Rankedwarreport$Factions$Item$Rewards$Items$Item &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.quantity, quantity) ||
                const DeepCollectionEquality().equals(
                  other.quantity,
                  quantity,
                )));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(quantity) ^
      runtimeType.hashCode;
}

extension $FactionRankedWarReportResponse$Rankedwarreport$Factions$Item$Rewards$Items$ItemExtension
    on FactionRankedWarReportResponse$Rankedwarreport$Factions$Item$Rewards$Items$Item {
  FactionRankedWarReportResponse$Rankedwarreport$Factions$Item$Rewards$Items$Item copyWith(
      {int? id, String? name, int? quantity}) {
    return FactionRankedWarReportResponse$Rankedwarreport$Factions$Item$Rewards$Items$Item(
      id: id ?? this.id,
      name: name ?? this.name,
      quantity: quantity ?? this.quantity,
    );
  }

  FactionRankedWarReportResponse$Rankedwarreport$Factions$Item$Rewards$Items$Item copyWithWrapped({
    Wrapped<int>? id,
    Wrapped<String>? name,
    Wrapped<int>? quantity,
  }) {
    return FactionRankedWarReportResponse$Rankedwarreport$Factions$Item$Rewards$Items$Item(
      id: (id != null ? id.value : this.id),
      name: (name != null ? name.value : this.name),
      quantity: (quantity != null ? quantity.value : this.quantity),
    );
  }
}

String? raceClassEnumNullableToJson(enums.RaceClassEnum? raceClassEnum) {
  return raceClassEnum?.value;
}

String? raceClassEnumToJson(enums.RaceClassEnum raceClassEnum) {
  return raceClassEnum.value;
}

enums.RaceClassEnum raceClassEnumFromJson(
  Object? raceClassEnum, [
  enums.RaceClassEnum? defaultValue,
]) {
  return enums.RaceClassEnum.values.firstWhereOrNull(
        (e) => e.value == raceClassEnum,
      ) ??
      defaultValue ??
      enums.RaceClassEnum.swaggerGeneratedUnknown;
}

enums.RaceClassEnum? raceClassEnumNullableFromJson(
  Object? raceClassEnum, [
  enums.RaceClassEnum? defaultValue,
]) {
  if (raceClassEnum == null) {
    return null;
  }
  return enums.RaceClassEnum.values.firstWhereOrNull(
        (e) => e.value == raceClassEnum,
      ) ??
      defaultValue;
}

String raceClassEnumExplodedListToJson(
  List<enums.RaceClassEnum>? raceClassEnum,
) {
  return raceClassEnum?.map((e) => e.value!).join(',') ?? '';
}

List<String> raceClassEnumListToJson(List<enums.RaceClassEnum>? raceClassEnum) {
  if (raceClassEnum == null) {
    return [];
  }

  return raceClassEnum.map((e) => e.value!).toList();
}

List<enums.RaceClassEnum> raceClassEnumListFromJson(
  List? raceClassEnum, [
  List<enums.RaceClassEnum>? defaultValue,
]) {
  if (raceClassEnum == null) {
    return defaultValue ?? [];
  }

  return raceClassEnum.map((e) => raceClassEnumFromJson(e.toString())).toList();
}

List<enums.RaceClassEnum>? raceClassEnumNullableListFromJson(
  List? raceClassEnum, [
  List<enums.RaceClassEnum>? defaultValue,
]) {
  if (raceClassEnum == null) {
    return defaultValue;
  }

  return raceClassEnum.map((e) => raceClassEnumFromJson(e.toString())).toList();
}

String? countryEnumNullableToJson(enums.CountryEnum? countryEnum) {
  return countryEnum?.value;
}

String? countryEnumToJson(enums.CountryEnum countryEnum) {
  return countryEnum.value;
}

enums.CountryEnum countryEnumFromJson(
  Object? countryEnum, [
  enums.CountryEnum? defaultValue,
]) {
  return enums.CountryEnum.values.firstWhereOrNull(
        (e) => e.value == countryEnum,
      ) ??
      defaultValue ??
      enums.CountryEnum.swaggerGeneratedUnknown;
}

enums.CountryEnum? countryEnumNullableFromJson(
  Object? countryEnum, [
  enums.CountryEnum? defaultValue,
]) {
  if (countryEnum == null) {
    return null;
  }
  return enums.CountryEnum.values.firstWhereOrNull(
        (e) => e.value == countryEnum,
      ) ??
      defaultValue;
}

String countryEnumExplodedListToJson(List<enums.CountryEnum>? countryEnum) {
  return countryEnum?.map((e) => e.value!).join(',') ?? '';
}

List<String> countryEnumListToJson(List<enums.CountryEnum>? countryEnum) {
  if (countryEnum == null) {
    return [];
  }

  return countryEnum.map((e) => e.value!).toList();
}

List<enums.CountryEnum> countryEnumListFromJson(
  List? countryEnum, [
  List<enums.CountryEnum>? defaultValue,
]) {
  if (countryEnum == null) {
    return defaultValue ?? [];
  }

  return countryEnum.map((e) => countryEnumFromJson(e.toString())).toList();
}

List<enums.CountryEnum>? countryEnumNullableListFromJson(
  List? countryEnum, [
  List<enums.CountryEnum>? defaultValue,
]) {
  if (countryEnum == null) {
    return defaultValue;
  }

  return countryEnum.map((e) => countryEnumFromJson(e.toString())).toList();
}

String? reportTypeEnumNullableToJson(enums.ReportTypeEnum? reportTypeEnum) {
  return reportTypeEnum?.value;
}

String? reportTypeEnumToJson(enums.ReportTypeEnum reportTypeEnum) {
  return reportTypeEnum.value;
}

enums.ReportTypeEnum reportTypeEnumFromJson(
  Object? reportTypeEnum, [
  enums.ReportTypeEnum? defaultValue,
]) {
  return enums.ReportTypeEnum.values.firstWhereOrNull(
        (e) => e.value == reportTypeEnum,
      ) ??
      defaultValue ??
      enums.ReportTypeEnum.swaggerGeneratedUnknown;
}

enums.ReportTypeEnum? reportTypeEnumNullableFromJson(
  Object? reportTypeEnum, [
  enums.ReportTypeEnum? defaultValue,
]) {
  if (reportTypeEnum == null) {
    return null;
  }
  return enums.ReportTypeEnum.values.firstWhereOrNull(
        (e) => e.value == reportTypeEnum,
      ) ??
      defaultValue;
}

String reportTypeEnumExplodedListToJson(
  List<enums.ReportTypeEnum>? reportTypeEnum,
) {
  return reportTypeEnum?.map((e) => e.value!).join(',') ?? '';
}

List<String> reportTypeEnumListToJson(
  List<enums.ReportTypeEnum>? reportTypeEnum,
) {
  if (reportTypeEnum == null) {
    return [];
  }

  return reportTypeEnum.map((e) => e.value!).toList();
}

List<enums.ReportTypeEnum> reportTypeEnumListFromJson(
  List? reportTypeEnum, [
  List<enums.ReportTypeEnum>? defaultValue,
]) {
  if (reportTypeEnum == null) {
    return defaultValue ?? [];
  }

  return reportTypeEnum.map((e) => reportTypeEnumFromJson(e.toString())).toList();
}

List<enums.ReportTypeEnum>? reportTypeEnumNullableListFromJson(
  List? reportTypeEnum, [
  List<enums.ReportTypeEnum>? defaultValue,
]) {
  if (reportTypeEnum == null) {
    return defaultValue;
  }

  return reportTypeEnum.map((e) => reportTypeEnumFromJson(e.toString())).toList();
}

String? apiKeyAccessTypeEnumNullableToJson(
  enums.ApiKeyAccessTypeEnum? apiKeyAccessTypeEnum,
) {
  return apiKeyAccessTypeEnum?.value;
}

String? apiKeyAccessTypeEnumToJson(
  enums.ApiKeyAccessTypeEnum apiKeyAccessTypeEnum,
) {
  return apiKeyAccessTypeEnum.value;
}

enums.ApiKeyAccessTypeEnum apiKeyAccessTypeEnumFromJson(
  Object? apiKeyAccessTypeEnum, [
  enums.ApiKeyAccessTypeEnum? defaultValue,
]) {
  return enums.ApiKeyAccessTypeEnum.values.firstWhereOrNull(
        (e) => e.value == apiKeyAccessTypeEnum,
      ) ??
      defaultValue ??
      enums.ApiKeyAccessTypeEnum.swaggerGeneratedUnknown;
}

enums.ApiKeyAccessTypeEnum? apiKeyAccessTypeEnumNullableFromJson(
  Object? apiKeyAccessTypeEnum, [
  enums.ApiKeyAccessTypeEnum? defaultValue,
]) {
  if (apiKeyAccessTypeEnum == null) {
    return null;
  }
  return enums.ApiKeyAccessTypeEnum.values.firstWhereOrNull(
        (e) => e.value == apiKeyAccessTypeEnum,
      ) ??
      defaultValue;
}

String apiKeyAccessTypeEnumExplodedListToJson(
  List<enums.ApiKeyAccessTypeEnum>? apiKeyAccessTypeEnum,
) {
  return apiKeyAccessTypeEnum?.map((e) => e.value!).join(',') ?? '';
}

List<String> apiKeyAccessTypeEnumListToJson(
  List<enums.ApiKeyAccessTypeEnum>? apiKeyAccessTypeEnum,
) {
  if (apiKeyAccessTypeEnum == null) {
    return [];
  }

  return apiKeyAccessTypeEnum.map((e) => e.value!).toList();
}

List<enums.ApiKeyAccessTypeEnum> apiKeyAccessTypeEnumListFromJson(
  List? apiKeyAccessTypeEnum, [
  List<enums.ApiKeyAccessTypeEnum>? defaultValue,
]) {
  if (apiKeyAccessTypeEnum == null) {
    return defaultValue ?? [];
  }

  return apiKeyAccessTypeEnum.map((e) => apiKeyAccessTypeEnumFromJson(e.toString())).toList();
}

List<enums.ApiKeyAccessTypeEnum>? apiKeyAccessTypeEnumNullableListFromJson(
  List? apiKeyAccessTypeEnum, [
  List<enums.ApiKeyAccessTypeEnum>? defaultValue,
]) {
  if (apiKeyAccessTypeEnum == null) {
    return defaultValue;
  }

  return apiKeyAccessTypeEnum.map((e) => apiKeyAccessTypeEnumFromJson(e.toString())).toList();
}

String? factionTerritoryEnumNullableToJson(
  enums.FactionTerritoryEnum? factionTerritoryEnum,
) {
  return factionTerritoryEnum?.value;
}

String? factionTerritoryEnumToJson(
  enums.FactionTerritoryEnum factionTerritoryEnum,
) {
  return factionTerritoryEnum.value;
}

enums.FactionTerritoryEnum factionTerritoryEnumFromJson(
  Object? factionTerritoryEnum, [
  enums.FactionTerritoryEnum? defaultValue,
]) {
  return enums.FactionTerritoryEnum.values.firstWhereOrNull(
        (e) => e.value == factionTerritoryEnum,
      ) ??
      defaultValue ??
      enums.FactionTerritoryEnum.swaggerGeneratedUnknown;
}

enums.FactionTerritoryEnum? factionTerritoryEnumNullableFromJson(
  Object? factionTerritoryEnum, [
  enums.FactionTerritoryEnum? defaultValue,
]) {
  if (factionTerritoryEnum == null) {
    return null;
  }
  return enums.FactionTerritoryEnum.values.firstWhereOrNull(
        (e) => e.value == factionTerritoryEnum,
      ) ??
      defaultValue;
}

String factionTerritoryEnumExplodedListToJson(
  List<enums.FactionTerritoryEnum>? factionTerritoryEnum,
) {
  return factionTerritoryEnum?.map((e) => e.value!).join(',') ?? '';
}

List<String> factionTerritoryEnumListToJson(
  List<enums.FactionTerritoryEnum>? factionTerritoryEnum,
) {
  if (factionTerritoryEnum == null) {
    return [];
  }

  return factionTerritoryEnum.map((e) => e.value!).toList();
}

List<enums.FactionTerritoryEnum> factionTerritoryEnumListFromJson(
  List? factionTerritoryEnum, [
  List<enums.FactionTerritoryEnum>? defaultValue,
]) {
  if (factionTerritoryEnum == null) {
    return defaultValue ?? [];
  }

  return factionTerritoryEnum.map((e) => factionTerritoryEnumFromJson(e.toString())).toList();
}

List<enums.FactionTerritoryEnum>? factionTerritoryEnumNullableListFromJson(
  List? factionTerritoryEnum, [
  List<enums.FactionTerritoryEnum>? defaultValue,
]) {
  if (factionTerritoryEnum == null) {
    return defaultValue;
  }

  return factionTerritoryEnum.map((e) => factionTerritoryEnumFromJson(e.toString())).toList();
}

String? factionStatEnumNullableToJson(enums.FactionStatEnum? factionStatEnum) {
  return factionStatEnum?.value;
}

String? factionStatEnumToJson(enums.FactionStatEnum factionStatEnum) {
  return factionStatEnum.value;
}

enums.FactionStatEnum factionStatEnumFromJson(
  Object? factionStatEnum, [
  enums.FactionStatEnum? defaultValue,
]) {
  return enums.FactionStatEnum.values.firstWhereOrNull(
        (e) => e.value == factionStatEnum,
      ) ??
      defaultValue ??
      enums.FactionStatEnum.swaggerGeneratedUnknown;
}

enums.FactionStatEnum? factionStatEnumNullableFromJson(
  Object? factionStatEnum, [
  enums.FactionStatEnum? defaultValue,
]) {
  if (factionStatEnum == null) {
    return null;
  }
  return enums.FactionStatEnum.values.firstWhereOrNull(
        (e) => e.value == factionStatEnum,
      ) ??
      defaultValue;
}

String factionStatEnumExplodedListToJson(
  List<enums.FactionStatEnum>? factionStatEnum,
) {
  return factionStatEnum?.map((e) => e.value!).join(',') ?? '';
}

List<String> factionStatEnumListToJson(
  List<enums.FactionStatEnum>? factionStatEnum,
) {
  if (factionStatEnum == null) {
    return [];
  }

  return factionStatEnum.map((e) => e.value!).toList();
}

List<enums.FactionStatEnum> factionStatEnumListFromJson(
  List? factionStatEnum, [
  List<enums.FactionStatEnum>? defaultValue,
]) {
  if (factionStatEnum == null) {
    return defaultValue ?? [];
  }

  return factionStatEnum.map((e) => factionStatEnumFromJson(e.toString())).toList();
}

List<enums.FactionStatEnum>? factionStatEnumNullableListFromJson(
  List? factionStatEnum, [
  List<enums.FactionStatEnum>? defaultValue,
]) {
  if (factionStatEnum == null) {
    return defaultValue;
  }

  return factionStatEnum.map((e) => factionStatEnumFromJson(e.toString())).toList();
}

String? factionBranchStateEnumNullableToJson(
  enums.FactionBranchStateEnum? factionBranchStateEnum,
) {
  return factionBranchStateEnum?.value;
}

String? factionBranchStateEnumToJson(
  enums.FactionBranchStateEnum factionBranchStateEnum,
) {
  return factionBranchStateEnum.value;
}

enums.FactionBranchStateEnum factionBranchStateEnumFromJson(
  Object? factionBranchStateEnum, [
  enums.FactionBranchStateEnum? defaultValue,
]) {
  return enums.FactionBranchStateEnum.values.firstWhereOrNull(
        (e) => e.value == factionBranchStateEnum,
      ) ??
      defaultValue ??
      enums.FactionBranchStateEnum.swaggerGeneratedUnknown;
}

enums.FactionBranchStateEnum? factionBranchStateEnumNullableFromJson(
  Object? factionBranchStateEnum, [
  enums.FactionBranchStateEnum? defaultValue,
]) {
  if (factionBranchStateEnum == null) {
    return null;
  }
  return enums.FactionBranchStateEnum.values.firstWhereOrNull(
        (e) => e.value == factionBranchStateEnum,
      ) ??
      defaultValue;
}

String factionBranchStateEnumExplodedListToJson(
  List<enums.FactionBranchStateEnum>? factionBranchStateEnum,
) {
  return factionBranchStateEnum?.map((e) => e.value!).join(',') ?? '';
}

List<String> factionBranchStateEnumListToJson(
  List<enums.FactionBranchStateEnum>? factionBranchStateEnum,
) {
  if (factionBranchStateEnum == null) {
    return [];
  }

  return factionBranchStateEnum.map((e) => e.value!).toList();
}

List<enums.FactionBranchStateEnum> factionBranchStateEnumListFromJson(
  List? factionBranchStateEnum, [
  List<enums.FactionBranchStateEnum>? defaultValue,
]) {
  if (factionBranchStateEnum == null) {
    return defaultValue ?? [];
  }

  return factionBranchStateEnum.map((e) => factionBranchStateEnumFromJson(e.toString())).toList();
}

List<enums.FactionBranchStateEnum>? factionBranchStateEnumNullableListFromJson(
  List? factionBranchStateEnum, [
  List<enums.FactionBranchStateEnum>? defaultValue,
]) {
  if (factionBranchStateEnum == null) {
    return defaultValue;
  }

  return factionBranchStateEnum.map((e) => factionBranchStateEnumFromJson(e.toString())).toList();
}

String? racingRaceTypeEnumNullableToJson(
  enums.RacingRaceTypeEnum? racingRaceTypeEnum,
) {
  return racingRaceTypeEnum?.value;
}

String? racingRaceTypeEnumToJson(enums.RacingRaceTypeEnum racingRaceTypeEnum) {
  return racingRaceTypeEnum.value;
}

enums.RacingRaceTypeEnum racingRaceTypeEnumFromJson(
  Object? racingRaceTypeEnum, [
  enums.RacingRaceTypeEnum? defaultValue,
]) {
  return enums.RacingRaceTypeEnum.values.firstWhereOrNull(
        (e) => e.value == racingRaceTypeEnum,
      ) ??
      defaultValue ??
      enums.RacingRaceTypeEnum.swaggerGeneratedUnknown;
}

enums.RacingRaceTypeEnum? racingRaceTypeEnumNullableFromJson(
  Object? racingRaceTypeEnum, [
  enums.RacingRaceTypeEnum? defaultValue,
]) {
  if (racingRaceTypeEnum == null) {
    return null;
  }
  return enums.RacingRaceTypeEnum.values.firstWhereOrNull(
        (e) => e.value == racingRaceTypeEnum,
      ) ??
      defaultValue;
}

String racingRaceTypeEnumExplodedListToJson(
  List<enums.RacingRaceTypeEnum>? racingRaceTypeEnum,
) {
  return racingRaceTypeEnum?.map((e) => e.value!).join(',') ?? '';
}

List<String> racingRaceTypeEnumListToJson(
  List<enums.RacingRaceTypeEnum>? racingRaceTypeEnum,
) {
  if (racingRaceTypeEnum == null) {
    return [];
  }

  return racingRaceTypeEnum.map((e) => e.value!).toList();
}

List<enums.RacingRaceTypeEnum> racingRaceTypeEnumListFromJson(
  List? racingRaceTypeEnum, [
  List<enums.RacingRaceTypeEnum>? defaultValue,
]) {
  if (racingRaceTypeEnum == null) {
    return defaultValue ?? [];
  }

  return racingRaceTypeEnum.map((e) => racingRaceTypeEnumFromJson(e.toString())).toList();
}

List<enums.RacingRaceTypeEnum>? racingRaceTypeEnumNullableListFromJson(
  List? racingRaceTypeEnum, [
  List<enums.RacingRaceTypeEnum>? defaultValue,
]) {
  if (racingRaceTypeEnum == null) {
    return defaultValue;
  }

  return racingRaceTypeEnum.map((e) => racingRaceTypeEnumFromJson(e.toString())).toList();
}

String? marketSpecializedBazaarCategoryEnumNullableToJson(
  enums.MarketSpecializedBazaarCategoryEnum? marketSpecializedBazaarCategoryEnum,
) {
  return marketSpecializedBazaarCategoryEnum?.value;
}

String? marketSpecializedBazaarCategoryEnumToJson(
  enums.MarketSpecializedBazaarCategoryEnum marketSpecializedBazaarCategoryEnum,
) {
  return marketSpecializedBazaarCategoryEnum.value;
}

enums.MarketSpecializedBazaarCategoryEnum marketSpecializedBazaarCategoryEnumFromJson(
  Object? marketSpecializedBazaarCategoryEnum, [
  enums.MarketSpecializedBazaarCategoryEnum? defaultValue,
]) {
  return enums.MarketSpecializedBazaarCategoryEnum.values.firstWhereOrNull(
        (e) => e.value == marketSpecializedBazaarCategoryEnum,
      ) ??
      defaultValue ??
      enums.MarketSpecializedBazaarCategoryEnum.swaggerGeneratedUnknown;
}

enums.MarketSpecializedBazaarCategoryEnum? marketSpecializedBazaarCategoryEnumNullableFromJson(
  Object? marketSpecializedBazaarCategoryEnum, [
  enums.MarketSpecializedBazaarCategoryEnum? defaultValue,
]) {
  if (marketSpecializedBazaarCategoryEnum == null) {
    return null;
  }
  return enums.MarketSpecializedBazaarCategoryEnum.values.firstWhereOrNull(
        (e) => e.value == marketSpecializedBazaarCategoryEnum,
      ) ??
      defaultValue;
}

String marketSpecializedBazaarCategoryEnumExplodedListToJson(
  List<enums.MarketSpecializedBazaarCategoryEnum>? marketSpecializedBazaarCategoryEnum,
) {
  return marketSpecializedBazaarCategoryEnum?.map((e) => e.value!).join(',') ?? '';
}

List<String> marketSpecializedBazaarCategoryEnumListToJson(
  List<enums.MarketSpecializedBazaarCategoryEnum>? marketSpecializedBazaarCategoryEnum,
) {
  if (marketSpecializedBazaarCategoryEnum == null) {
    return [];
  }

  return marketSpecializedBazaarCategoryEnum.map((e) => e.value!).toList();
}

List<enums.MarketSpecializedBazaarCategoryEnum> marketSpecializedBazaarCategoryEnumListFromJson(
  List? marketSpecializedBazaarCategoryEnum, [
  List<enums.MarketSpecializedBazaarCategoryEnum>? defaultValue,
]) {
  if (marketSpecializedBazaarCategoryEnum == null) {
    return defaultValue ?? [];
  }

  return marketSpecializedBazaarCategoryEnum
      .map((e) => marketSpecializedBazaarCategoryEnumFromJson(e.toString()))
      .toList();
}

List<enums.MarketSpecializedBazaarCategoryEnum>? marketSpecializedBazaarCategoryEnumNullableListFromJson(
  List? marketSpecializedBazaarCategoryEnum, [
  List<enums.MarketSpecializedBazaarCategoryEnum>? defaultValue,
]) {
  if (marketSpecializedBazaarCategoryEnum == null) {
    return defaultValue;
  }

  return marketSpecializedBazaarCategoryEnum
      .map((e) => marketSpecializedBazaarCategoryEnumFromJson(e.toString()))
      .toList();
}

String? factionPositionAbilityEnumNullableToJson(
  enums.FactionPositionAbilityEnum? factionPositionAbilityEnum,
) {
  return factionPositionAbilityEnum?.value;
}

String? factionPositionAbilityEnumToJson(
  enums.FactionPositionAbilityEnum factionPositionAbilityEnum,
) {
  return factionPositionAbilityEnum.value;
}

enums.FactionPositionAbilityEnum factionPositionAbilityEnumFromJson(
  Object? factionPositionAbilityEnum, [
  enums.FactionPositionAbilityEnum? defaultValue,
]) {
  return enums.FactionPositionAbilityEnum.values.firstWhereOrNull(
        (e) => e.value == factionPositionAbilityEnum,
      ) ??
      defaultValue ??
      enums.FactionPositionAbilityEnum.swaggerGeneratedUnknown;
}

enums.FactionPositionAbilityEnum? factionPositionAbilityEnumNullableFromJson(
  Object? factionPositionAbilityEnum, [
  enums.FactionPositionAbilityEnum? defaultValue,
]) {
  if (factionPositionAbilityEnum == null) {
    return null;
  }
  return enums.FactionPositionAbilityEnum.values.firstWhereOrNull(
        (e) => e.value == factionPositionAbilityEnum,
      ) ??
      defaultValue;
}

String factionPositionAbilityEnumExplodedListToJson(
  List<enums.FactionPositionAbilityEnum>? factionPositionAbilityEnum,
) {
  return factionPositionAbilityEnum?.map((e) => e.value!).join(',') ?? '';
}

List<String> factionPositionAbilityEnumListToJson(
  List<enums.FactionPositionAbilityEnum>? factionPositionAbilityEnum,
) {
  if (factionPositionAbilityEnum == null) {
    return [];
  }

  return factionPositionAbilityEnum.map((e) => e.value!).toList();
}

List<enums.FactionPositionAbilityEnum> factionPositionAbilityEnumListFromJson(
  List? factionPositionAbilityEnum, [
  List<enums.FactionPositionAbilityEnum>? defaultValue,
]) {
  if (factionPositionAbilityEnum == null) {
    return defaultValue ?? [];
  }

  return factionPositionAbilityEnum.map((e) => factionPositionAbilityEnumFromJson(e.toString())).toList();
}

List<enums.FactionPositionAbilityEnum>? factionPositionAbilityEnumNullableListFromJson(
  List? factionPositionAbilityEnum, [
  List<enums.FactionPositionAbilityEnum>? defaultValue,
]) {
  if (factionPositionAbilityEnum == null) {
    return defaultValue;
  }

  return factionPositionAbilityEnum.map((e) => factionPositionAbilityEnumFromJson(e.toString())).toList();
}

String? factionOrganizedCrimePayoutTypeNullableToJson(
  enums.FactionOrganizedCrimePayoutType? factionOrganizedCrimePayoutType,
) {
  return factionOrganizedCrimePayoutType?.value;
}

String? factionOrganizedCrimePayoutTypeToJson(
  enums.FactionOrganizedCrimePayoutType factionOrganizedCrimePayoutType,
) {
  return factionOrganizedCrimePayoutType.value;
}

enums.FactionOrganizedCrimePayoutType factionOrganizedCrimePayoutTypeFromJson(
  Object? factionOrganizedCrimePayoutType, [
  enums.FactionOrganizedCrimePayoutType? defaultValue,
]) {
  return enums.FactionOrganizedCrimePayoutType.values.firstWhereOrNull(
        (e) => e.value == factionOrganizedCrimePayoutType,
      ) ??
      defaultValue ??
      enums.FactionOrganizedCrimePayoutType.swaggerGeneratedUnknown;
}

enums.FactionOrganizedCrimePayoutType? factionOrganizedCrimePayoutTypeNullableFromJson(
  Object? factionOrganizedCrimePayoutType, [
  enums.FactionOrganizedCrimePayoutType? defaultValue,
]) {
  if (factionOrganizedCrimePayoutType == null) {
    return null;
  }
  return enums.FactionOrganizedCrimePayoutType.values.firstWhereOrNull(
        (e) => e.value == factionOrganizedCrimePayoutType,
      ) ??
      defaultValue;
}

String factionOrganizedCrimePayoutTypeExplodedListToJson(
  List<enums.FactionOrganizedCrimePayoutType>? factionOrganizedCrimePayoutType,
) {
  return factionOrganizedCrimePayoutType?.map((e) => e.value!).join(',') ?? '';
}

List<String> factionOrganizedCrimePayoutTypeListToJson(
  List<enums.FactionOrganizedCrimePayoutType>? factionOrganizedCrimePayoutType,
) {
  if (factionOrganizedCrimePayoutType == null) {
    return [];
  }

  return factionOrganizedCrimePayoutType.map((e) => e.value!).toList();
}

List<enums.FactionOrganizedCrimePayoutType> factionOrganizedCrimePayoutTypeListFromJson(
  List? factionOrganizedCrimePayoutType, [
  List<enums.FactionOrganizedCrimePayoutType>? defaultValue,
]) {
  if (factionOrganizedCrimePayoutType == null) {
    return defaultValue ?? [];
  }

  return factionOrganizedCrimePayoutType.map((e) => factionOrganizedCrimePayoutTypeFromJson(e.toString())).toList();
}

List<enums.FactionOrganizedCrimePayoutType>? factionOrganizedCrimePayoutTypeNullableListFromJson(
  List? factionOrganizedCrimePayoutType, [
  List<enums.FactionOrganizedCrimePayoutType>? defaultValue,
]) {
  if (factionOrganizedCrimePayoutType == null) {
    return defaultValue;
  }

  return factionOrganizedCrimePayoutType.map((e) => factionOrganizedCrimePayoutTypeFromJson(e.toString())).toList();
}

String? tornRacketTypeNullableToJson(enums.TornRacketType? tornRacketType) {
  return tornRacketType?.value;
}

String? tornRacketTypeToJson(enums.TornRacketType tornRacketType) {
  return tornRacketType.value;
}

enums.TornRacketType tornRacketTypeFromJson(
  Object? tornRacketType, [
  enums.TornRacketType? defaultValue,
]) {
  return enums.TornRacketType.values.firstWhereOrNull(
        (e) => e.value == tornRacketType,
      ) ??
      defaultValue ??
      enums.TornRacketType.swaggerGeneratedUnknown;
}

enums.TornRacketType? tornRacketTypeNullableFromJson(
  Object? tornRacketType, [
  enums.TornRacketType? defaultValue,
]) {
  if (tornRacketType == null) {
    return null;
  }
  return enums.TornRacketType.values.firstWhereOrNull(
        (e) => e.value == tornRacketType,
      ) ??
      defaultValue;
}

String tornRacketTypeExplodedListToJson(
  List<enums.TornRacketType>? tornRacketType,
) {
  return tornRacketType?.map((e) => e.value!).join(',') ?? '';
}

List<String> tornRacketTypeListToJson(
  List<enums.TornRacketType>? tornRacketType,
) {
  if (tornRacketType == null) {
    return [];
  }

  return tornRacketType.map((e) => e.value!).toList();
}

List<enums.TornRacketType> tornRacketTypeListFromJson(
  List? tornRacketType, [
  List<enums.TornRacketType>? defaultValue,
]) {
  if (tornRacketType == null) {
    return defaultValue ?? [];
  }

  return tornRacketType.map((e) => tornRacketTypeFromJson(e.toString())).toList();
}

List<enums.TornRacketType>? tornRacketTypeNullableListFromJson(
  List? tornRacketType, [
  List<enums.TornRacketType>? defaultValue,
]) {
  if (tornRacketType == null) {
    return defaultValue;
  }

  return tornRacketType.map((e) => tornRacketTypeFromJson(e.toString())).toList();
}

String? factionNewsCategoryNullableToJson(
  enums.FactionNewsCategory? factionNewsCategory,
) {
  return factionNewsCategory?.value;
}

String? factionNewsCategoryToJson(
  enums.FactionNewsCategory factionNewsCategory,
) {
  return factionNewsCategory.value;
}

enums.FactionNewsCategory factionNewsCategoryFromJson(
  Object? factionNewsCategory, [
  enums.FactionNewsCategory? defaultValue,
]) {
  return enums.FactionNewsCategory.values.firstWhereOrNull(
        (e) => e.value == factionNewsCategory,
      ) ??
      defaultValue ??
      enums.FactionNewsCategory.swaggerGeneratedUnknown;
}

enums.FactionNewsCategory? factionNewsCategoryNullableFromJson(
  Object? factionNewsCategory, [
  enums.FactionNewsCategory? defaultValue,
]) {
  if (factionNewsCategory == null) {
    return null;
  }
  return enums.FactionNewsCategory.values.firstWhereOrNull(
        (e) => e.value == factionNewsCategory,
      ) ??
      defaultValue;
}

String factionNewsCategoryExplodedListToJson(
  List<enums.FactionNewsCategory>? factionNewsCategory,
) {
  return factionNewsCategory?.map((e) => e.value!).join(',') ?? '';
}

List<String> factionNewsCategoryListToJson(
  List<enums.FactionNewsCategory>? factionNewsCategory,
) {
  if (factionNewsCategory == null) {
    return [];
  }

  return factionNewsCategory.map((e) => e.value!).toList();
}

List<enums.FactionNewsCategory> factionNewsCategoryListFromJson(
  List? factionNewsCategory, [
  List<enums.FactionNewsCategory>? defaultValue,
]) {
  if (factionNewsCategory == null) {
    return defaultValue ?? [];
  }

  return factionNewsCategory.map((e) => factionNewsCategoryFromJson(e.toString())).toList();
}

List<enums.FactionNewsCategory>? factionNewsCategoryNullableListFromJson(
  List? factionNewsCategory, [
  List<enums.FactionNewsCategory>? defaultValue,
]) {
  if (factionNewsCategory == null) {
    return defaultValue;
  }

  return factionNewsCategory.map((e) => factionNewsCategoryFromJson(e.toString())).toList();
}

String? factionRankEnumNullableToJson(enums.FactionRankEnum? factionRankEnum) {
  return factionRankEnum?.value;
}

String? factionRankEnumToJson(enums.FactionRankEnum factionRankEnum) {
  return factionRankEnum.value;
}

enums.FactionRankEnum factionRankEnumFromJson(
  Object? factionRankEnum, [
  enums.FactionRankEnum? defaultValue,
]) {
  return enums.FactionRankEnum.values.firstWhereOrNull(
        (e) => e.value == factionRankEnum,
      ) ??
      defaultValue ??
      enums.FactionRankEnum.swaggerGeneratedUnknown;
}

enums.FactionRankEnum? factionRankEnumNullableFromJson(
  Object? factionRankEnum, [
  enums.FactionRankEnum? defaultValue,
]) {
  if (factionRankEnum == null) {
    return null;
  }
  return enums.FactionRankEnum.values.firstWhereOrNull(
        (e) => e.value == factionRankEnum,
      ) ??
      defaultValue;
}

String factionRankEnumExplodedListToJson(
  List<enums.FactionRankEnum>? factionRankEnum,
) {
  return factionRankEnum?.map((e) => e.value!).join(',') ?? '';
}

List<String> factionRankEnumListToJson(
  List<enums.FactionRankEnum>? factionRankEnum,
) {
  if (factionRankEnum == null) {
    return [];
  }

  return factionRankEnum.map((e) => e.value!).toList();
}

List<enums.FactionRankEnum> factionRankEnumListFromJson(
  List? factionRankEnum, [
  List<enums.FactionRankEnum>? defaultValue,
]) {
  if (factionRankEnum == null) {
    return defaultValue ?? [];
  }

  return factionRankEnum.map((e) => factionRankEnumFromJson(e.toString())).toList();
}

List<enums.FactionRankEnum>? factionRankEnumNullableListFromJson(
  List? factionRankEnum, [
  List<enums.FactionRankEnum>? defaultValue,
]) {
  if (factionRankEnum == null) {
    return defaultValue;
  }

  return factionRankEnum.map((e) => factionRankEnumFromJson(e.toString())).toList();
}

String? userCrimeUniquesRewardAmmoEnumNullableToJson(
  enums.UserCrimeUniquesRewardAmmoEnum? userCrimeUniquesRewardAmmoEnum,
) {
  return userCrimeUniquesRewardAmmoEnum?.value;
}

String? userCrimeUniquesRewardAmmoEnumToJson(
  enums.UserCrimeUniquesRewardAmmoEnum userCrimeUniquesRewardAmmoEnum,
) {
  return userCrimeUniquesRewardAmmoEnum.value;
}

enums.UserCrimeUniquesRewardAmmoEnum userCrimeUniquesRewardAmmoEnumFromJson(
  Object? userCrimeUniquesRewardAmmoEnum, [
  enums.UserCrimeUniquesRewardAmmoEnum? defaultValue,
]) {
  return enums.UserCrimeUniquesRewardAmmoEnum.values.firstWhereOrNull(
        (e) => e.value == userCrimeUniquesRewardAmmoEnum,
      ) ??
      defaultValue ??
      enums.UserCrimeUniquesRewardAmmoEnum.swaggerGeneratedUnknown;
}

enums.UserCrimeUniquesRewardAmmoEnum? userCrimeUniquesRewardAmmoEnumNullableFromJson(
  Object? userCrimeUniquesRewardAmmoEnum, [
  enums.UserCrimeUniquesRewardAmmoEnum? defaultValue,
]) {
  if (userCrimeUniquesRewardAmmoEnum == null) {
    return null;
  }
  return enums.UserCrimeUniquesRewardAmmoEnum.values.firstWhereOrNull(
        (e) => e.value == userCrimeUniquesRewardAmmoEnum,
      ) ??
      defaultValue;
}

String userCrimeUniquesRewardAmmoEnumExplodedListToJson(
  List<enums.UserCrimeUniquesRewardAmmoEnum>? userCrimeUniquesRewardAmmoEnum,
) {
  return userCrimeUniquesRewardAmmoEnum?.map((e) => e.value!).join(',') ?? '';
}

List<String> userCrimeUniquesRewardAmmoEnumListToJson(
  List<enums.UserCrimeUniquesRewardAmmoEnum>? userCrimeUniquesRewardAmmoEnum,
) {
  if (userCrimeUniquesRewardAmmoEnum == null) {
    return [];
  }

  return userCrimeUniquesRewardAmmoEnum.map((e) => e.value!).toList();
}

List<enums.UserCrimeUniquesRewardAmmoEnum> userCrimeUniquesRewardAmmoEnumListFromJson(
  List? userCrimeUniquesRewardAmmoEnum, [
  List<enums.UserCrimeUniquesRewardAmmoEnum>? defaultValue,
]) {
  if (userCrimeUniquesRewardAmmoEnum == null) {
    return defaultValue ?? [];
  }

  return userCrimeUniquesRewardAmmoEnum.map((e) => userCrimeUniquesRewardAmmoEnumFromJson(e.toString())).toList();
}

List<enums.UserCrimeUniquesRewardAmmoEnum>? userCrimeUniquesRewardAmmoEnumNullableListFromJson(
  List? userCrimeUniquesRewardAmmoEnum, [
  List<enums.UserCrimeUniquesRewardAmmoEnum>? defaultValue,
]) {
  if (userCrimeUniquesRewardAmmoEnum == null) {
    return defaultValue;
  }

  return userCrimeUniquesRewardAmmoEnum.map((e) => userCrimeUniquesRewardAmmoEnumFromJson(e.toString())).toList();
}

String? raceStatusEnumNullableToJson(enums.RaceStatusEnum? raceStatusEnum) {
  return raceStatusEnum?.value;
}

String? raceStatusEnumToJson(enums.RaceStatusEnum raceStatusEnum) {
  return raceStatusEnum.value;
}

enums.RaceStatusEnum raceStatusEnumFromJson(
  Object? raceStatusEnum, [
  enums.RaceStatusEnum? defaultValue,
]) {
  return enums.RaceStatusEnum.values.firstWhereOrNull(
        (e) => e.value == raceStatusEnum,
      ) ??
      defaultValue ??
      enums.RaceStatusEnum.swaggerGeneratedUnknown;
}

enums.RaceStatusEnum? raceStatusEnumNullableFromJson(
  Object? raceStatusEnum, [
  enums.RaceStatusEnum? defaultValue,
]) {
  if (raceStatusEnum == null) {
    return null;
  }
  return enums.RaceStatusEnum.values.firstWhereOrNull(
        (e) => e.value == raceStatusEnum,
      ) ??
      defaultValue;
}

String raceStatusEnumExplodedListToJson(
  List<enums.RaceStatusEnum>? raceStatusEnum,
) {
  return raceStatusEnum?.map((e) => e.value!).join(',') ?? '';
}

List<String> raceStatusEnumListToJson(
  List<enums.RaceStatusEnum>? raceStatusEnum,
) {
  if (raceStatusEnum == null) {
    return [];
  }

  return raceStatusEnum.map((e) => e.value!).toList();
}

List<enums.RaceStatusEnum> raceStatusEnumListFromJson(
  List? raceStatusEnum, [
  List<enums.RaceStatusEnum>? defaultValue,
]) {
  if (raceStatusEnum == null) {
    return defaultValue ?? [];
  }

  return raceStatusEnum.map((e) => raceStatusEnumFromJson(e.toString())).toList();
}

List<enums.RaceStatusEnum>? raceStatusEnumNullableListFromJson(
  List? raceStatusEnum, [
  List<enums.RaceStatusEnum>? defaultValue,
]) {
  if (raceStatusEnum == null) {
    return defaultValue;
  }

  return raceStatusEnum.map((e) => raceStatusEnumFromJson(e.toString())).toList();
}

String? tornHofCategoryNullableToJson(enums.TornHofCategory? tornHofCategory) {
  return tornHofCategory?.value;
}

String? tornHofCategoryToJson(enums.TornHofCategory tornHofCategory) {
  return tornHofCategory.value;
}

enums.TornHofCategory tornHofCategoryFromJson(
  Object? tornHofCategory, [
  enums.TornHofCategory? defaultValue,
]) {
  return enums.TornHofCategory.values.firstWhereOrNull(
        (e) => e.value == tornHofCategory,
      ) ??
      defaultValue ??
      enums.TornHofCategory.swaggerGeneratedUnknown;
}

enums.TornHofCategory? tornHofCategoryNullableFromJson(
  Object? tornHofCategory, [
  enums.TornHofCategory? defaultValue,
]) {
  if (tornHofCategory == null) {
    return null;
  }
  return enums.TornHofCategory.values.firstWhereOrNull(
        (e) => e.value == tornHofCategory,
      ) ??
      defaultValue;
}

String tornHofCategoryExplodedListToJson(
  List<enums.TornHofCategory>? tornHofCategory,
) {
  return tornHofCategory?.map((e) => e.value!).join(',') ?? '';
}

List<String> tornHofCategoryListToJson(
  List<enums.TornHofCategory>? tornHofCategory,
) {
  if (tornHofCategory == null) {
    return [];
  }

  return tornHofCategory.map((e) => e.value!).toList();
}

List<enums.TornHofCategory> tornHofCategoryListFromJson(
  List? tornHofCategory, [
  List<enums.TornHofCategory>? defaultValue,
]) {
  if (tornHofCategory == null) {
    return defaultValue ?? [];
  }

  return tornHofCategory.map((e) => tornHofCategoryFromJson(e.toString())).toList();
}

List<enums.TornHofCategory>? tornHofCategoryNullableListFromJson(
  List? tornHofCategory, [
  List<enums.TornHofCategory>? defaultValue,
]) {
  if (tornHofCategory == null) {
    return defaultValue;
  }

  return tornHofCategory.map((e) => tornHofCategoryFromJson(e.toString())).toList();
}

String? tornFactionHofCategoryNullableToJson(
  enums.TornFactionHofCategory? tornFactionHofCategory,
) {
  return tornFactionHofCategory?.value;
}

String? tornFactionHofCategoryToJson(
  enums.TornFactionHofCategory tornFactionHofCategory,
) {
  return tornFactionHofCategory.value;
}

enums.TornFactionHofCategory tornFactionHofCategoryFromJson(
  Object? tornFactionHofCategory, [
  enums.TornFactionHofCategory? defaultValue,
]) {
  return enums.TornFactionHofCategory.values.firstWhereOrNull(
        (e) => e.value == tornFactionHofCategory,
      ) ??
      defaultValue ??
      enums.TornFactionHofCategory.swaggerGeneratedUnknown;
}

enums.TornFactionHofCategory? tornFactionHofCategoryNullableFromJson(
  Object? tornFactionHofCategory, [
  enums.TornFactionHofCategory? defaultValue,
]) {
  if (tornFactionHofCategory == null) {
    return null;
  }
  return enums.TornFactionHofCategory.values.firstWhereOrNull(
        (e) => e.value == tornFactionHofCategory,
      ) ??
      defaultValue;
}

String tornFactionHofCategoryExplodedListToJson(
  List<enums.TornFactionHofCategory>? tornFactionHofCategory,
) {
  return tornFactionHofCategory?.map((e) => e.value!).join(',') ?? '';
}

List<String> tornFactionHofCategoryListToJson(
  List<enums.TornFactionHofCategory>? tornFactionHofCategory,
) {
  if (tornFactionHofCategory == null) {
    return [];
  }

  return tornFactionHofCategory.map((e) => e.value!).toList();
}

List<enums.TornFactionHofCategory> tornFactionHofCategoryListFromJson(
  List? tornFactionHofCategory, [
  List<enums.TornFactionHofCategory>? defaultValue,
]) {
  if (tornFactionHofCategory == null) {
    return defaultValue ?? [];
  }

  return tornFactionHofCategory.map((e) => tornFactionHofCategoryFromJson(e.toString())).toList();
}

List<enums.TornFactionHofCategory>? tornFactionHofCategoryNullableListFromJson(
  List? tornFactionHofCategory, [
  List<enums.TornFactionHofCategory>? defaultValue,
]) {
  if (tornFactionHofCategory == null) {
    return defaultValue;
  }

  return tornFactionHofCategory.map((e) => tornFactionHofCategoryFromJson(e.toString())).toList();
}

String? factionTerritoryWarResultEnumNullableToJson(
  enums.FactionTerritoryWarResultEnum? factionTerritoryWarResultEnum,
) {
  return factionTerritoryWarResultEnum?.value;
}

String? factionTerritoryWarResultEnumToJson(
  enums.FactionTerritoryWarResultEnum factionTerritoryWarResultEnum,
) {
  return factionTerritoryWarResultEnum.value;
}

enums.FactionTerritoryWarResultEnum factionTerritoryWarResultEnumFromJson(
  Object? factionTerritoryWarResultEnum, [
  enums.FactionTerritoryWarResultEnum? defaultValue,
]) {
  return enums.FactionTerritoryWarResultEnum.values.firstWhereOrNull(
        (e) => e.value == factionTerritoryWarResultEnum,
      ) ??
      defaultValue ??
      enums.FactionTerritoryWarResultEnum.swaggerGeneratedUnknown;
}

enums.FactionTerritoryWarResultEnum? factionTerritoryWarResultEnumNullableFromJson(
  Object? factionTerritoryWarResultEnum, [
  enums.FactionTerritoryWarResultEnum? defaultValue,
]) {
  if (factionTerritoryWarResultEnum == null) {
    return null;
  }
  return enums.FactionTerritoryWarResultEnum.values.firstWhereOrNull(
        (e) => e.value == factionTerritoryWarResultEnum,
      ) ??
      defaultValue;
}

String factionTerritoryWarResultEnumExplodedListToJson(
  List<enums.FactionTerritoryWarResultEnum>? factionTerritoryWarResultEnum,
) {
  return factionTerritoryWarResultEnum?.map((e) => e.value!).join(',') ?? '';
}

List<String> factionTerritoryWarResultEnumListToJson(
  List<enums.FactionTerritoryWarResultEnum>? factionTerritoryWarResultEnum,
) {
  if (factionTerritoryWarResultEnum == null) {
    return [];
  }

  return factionTerritoryWarResultEnum.map((e) => e.value!).toList();
}

List<enums.FactionTerritoryWarResultEnum> factionTerritoryWarResultEnumListFromJson(
  List? factionTerritoryWarResultEnum, [
  List<enums.FactionTerritoryWarResultEnum>? defaultValue,
]) {
  if (factionTerritoryWarResultEnum == null) {
    return defaultValue ?? [];
  }

  return factionTerritoryWarResultEnum.map((e) => factionTerritoryWarResultEnumFromJson(e.toString())).toList();
}

List<enums.FactionTerritoryWarResultEnum>? factionTerritoryWarResultEnumNullableListFromJson(
  List? factionTerritoryWarResultEnum, [
  List<enums.FactionTerritoryWarResultEnum>? defaultValue,
]) {
  if (factionTerritoryWarResultEnum == null) {
    return defaultValue;
  }

  return factionTerritoryWarResultEnum.map((e) => factionTerritoryWarResultEnumFromJson(e.toString())).toList();
}

String? factionAttackResultNullableToJson(
  enums.FactionAttackResult? factionAttackResult,
) {
  return factionAttackResult?.value;
}

String? factionAttackResultToJson(
  enums.FactionAttackResult factionAttackResult,
) {
  return factionAttackResult.value;
}

enums.FactionAttackResult factionAttackResultFromJson(
  Object? factionAttackResult, [
  enums.FactionAttackResult? defaultValue,
]) {
  return enums.FactionAttackResult.values.firstWhereOrNull(
        (e) => e.value == factionAttackResult,
      ) ??
      defaultValue ??
      enums.FactionAttackResult.swaggerGeneratedUnknown;
}

enums.FactionAttackResult? factionAttackResultNullableFromJson(
  Object? factionAttackResult, [
  enums.FactionAttackResult? defaultValue,
]) {
  if (factionAttackResult == null) {
    return null;
  }
  return enums.FactionAttackResult.values.firstWhereOrNull(
        (e) => e.value == factionAttackResult,
      ) ??
      defaultValue;
}

String factionAttackResultExplodedListToJson(
  List<enums.FactionAttackResult>? factionAttackResult,
) {
  return factionAttackResult?.map((e) => e.value!).join(',') ?? '';
}

List<String> factionAttackResultListToJson(
  List<enums.FactionAttackResult>? factionAttackResult,
) {
  if (factionAttackResult == null) {
    return [];
  }

  return factionAttackResult.map((e) => e.value!).toList();
}

List<enums.FactionAttackResult> factionAttackResultListFromJson(
  List? factionAttackResult, [
  List<enums.FactionAttackResult>? defaultValue,
]) {
  if (factionAttackResult == null) {
    return defaultValue ?? [];
  }

  return factionAttackResult.map((e) => factionAttackResultFromJson(e.toString())).toList();
}

List<enums.FactionAttackResult>? factionAttackResultNullableListFromJson(
  List? factionAttackResult, [
  List<enums.FactionAttackResult>? defaultValue,
]) {
  if (factionAttackResult == null) {
    return defaultValue;
  }

  return factionAttackResult.map((e) => factionAttackResultFromJson(e.toString())).toList();
}

String? raceCarUpgradeCategoryNullableToJson(
  enums.RaceCarUpgradeCategory? raceCarUpgradeCategory,
) {
  return raceCarUpgradeCategory?.value;
}

String? raceCarUpgradeCategoryToJson(
  enums.RaceCarUpgradeCategory raceCarUpgradeCategory,
) {
  return raceCarUpgradeCategory.value;
}

enums.RaceCarUpgradeCategory raceCarUpgradeCategoryFromJson(
  Object? raceCarUpgradeCategory, [
  enums.RaceCarUpgradeCategory? defaultValue,
]) {
  return enums.RaceCarUpgradeCategory.values.firstWhereOrNull(
        (e) => e.value == raceCarUpgradeCategory,
      ) ??
      defaultValue ??
      enums.RaceCarUpgradeCategory.swaggerGeneratedUnknown;
}

enums.RaceCarUpgradeCategory? raceCarUpgradeCategoryNullableFromJson(
  Object? raceCarUpgradeCategory, [
  enums.RaceCarUpgradeCategory? defaultValue,
]) {
  if (raceCarUpgradeCategory == null) {
    return null;
  }
  return enums.RaceCarUpgradeCategory.values.firstWhereOrNull(
        (e) => e.value == raceCarUpgradeCategory,
      ) ??
      defaultValue;
}

String raceCarUpgradeCategoryExplodedListToJson(
  List<enums.RaceCarUpgradeCategory>? raceCarUpgradeCategory,
) {
  return raceCarUpgradeCategory?.map((e) => e.value!).join(',') ?? '';
}

List<String> raceCarUpgradeCategoryListToJson(
  List<enums.RaceCarUpgradeCategory>? raceCarUpgradeCategory,
) {
  if (raceCarUpgradeCategory == null) {
    return [];
  }

  return raceCarUpgradeCategory.map((e) => e.value!).toList();
}

List<enums.RaceCarUpgradeCategory> raceCarUpgradeCategoryListFromJson(
  List? raceCarUpgradeCategory, [
  List<enums.RaceCarUpgradeCategory>? defaultValue,
]) {
  if (raceCarUpgradeCategory == null) {
    return defaultValue ?? [];
  }

  return raceCarUpgradeCategory.map((e) => raceCarUpgradeCategoryFromJson(e.toString())).toList();
}

List<enums.RaceCarUpgradeCategory>? raceCarUpgradeCategoryNullableListFromJson(
  List? raceCarUpgradeCategory, [
  List<enums.RaceCarUpgradeCategory>? defaultValue,
]) {
  if (raceCarUpgradeCategory == null) {
    return defaultValue;
  }

  return raceCarUpgradeCategory.map((e) => raceCarUpgradeCategoryFromJson(e.toString())).toList();
}

String? jobPositionArmyEnumNullableToJson(
  enums.JobPositionArmyEnum? jobPositionArmyEnum,
) {
  return jobPositionArmyEnum?.value;
}

String? jobPositionArmyEnumToJson(
  enums.JobPositionArmyEnum jobPositionArmyEnum,
) {
  return jobPositionArmyEnum.value;
}

enums.JobPositionArmyEnum jobPositionArmyEnumFromJson(
  Object? jobPositionArmyEnum, [
  enums.JobPositionArmyEnum? defaultValue,
]) {
  return enums.JobPositionArmyEnum.values.firstWhereOrNull(
        (e) => e.value == jobPositionArmyEnum,
      ) ??
      defaultValue ??
      enums.JobPositionArmyEnum.swaggerGeneratedUnknown;
}

enums.JobPositionArmyEnum? jobPositionArmyEnumNullableFromJson(
  Object? jobPositionArmyEnum, [
  enums.JobPositionArmyEnum? defaultValue,
]) {
  if (jobPositionArmyEnum == null) {
    return null;
  }
  return enums.JobPositionArmyEnum.values.firstWhereOrNull(
        (e) => e.value == jobPositionArmyEnum,
      ) ??
      defaultValue;
}

String jobPositionArmyEnumExplodedListToJson(
  List<enums.JobPositionArmyEnum>? jobPositionArmyEnum,
) {
  return jobPositionArmyEnum?.map((e) => e.value!).join(',') ?? '';
}

List<String> jobPositionArmyEnumListToJson(
  List<enums.JobPositionArmyEnum>? jobPositionArmyEnum,
) {
  if (jobPositionArmyEnum == null) {
    return [];
  }

  return jobPositionArmyEnum.map((e) => e.value!).toList();
}

List<enums.JobPositionArmyEnum> jobPositionArmyEnumListFromJson(
  List? jobPositionArmyEnum, [
  List<enums.JobPositionArmyEnum>? defaultValue,
]) {
  if (jobPositionArmyEnum == null) {
    return defaultValue ?? [];
  }

  return jobPositionArmyEnum.map((e) => jobPositionArmyEnumFromJson(e.toString())).toList();
}

List<enums.JobPositionArmyEnum>? jobPositionArmyEnumNullableListFromJson(
  List? jobPositionArmyEnum, [
  List<enums.JobPositionArmyEnum>? defaultValue,
]) {
  if (jobPositionArmyEnum == null) {
    return defaultValue;
  }

  return jobPositionArmyEnum.map((e) => jobPositionArmyEnumFromJson(e.toString())).toList();
}

String? jobPositionGrocerEnumNullableToJson(
  enums.JobPositionGrocerEnum? jobPositionGrocerEnum,
) {
  return jobPositionGrocerEnum?.value;
}

String? jobPositionGrocerEnumToJson(
  enums.JobPositionGrocerEnum jobPositionGrocerEnum,
) {
  return jobPositionGrocerEnum.value;
}

enums.JobPositionGrocerEnum jobPositionGrocerEnumFromJson(
  Object? jobPositionGrocerEnum, [
  enums.JobPositionGrocerEnum? defaultValue,
]) {
  return enums.JobPositionGrocerEnum.values.firstWhereOrNull(
        (e) => e.value == jobPositionGrocerEnum,
      ) ??
      defaultValue ??
      enums.JobPositionGrocerEnum.swaggerGeneratedUnknown;
}

enums.JobPositionGrocerEnum? jobPositionGrocerEnumNullableFromJson(
  Object? jobPositionGrocerEnum, [
  enums.JobPositionGrocerEnum? defaultValue,
]) {
  if (jobPositionGrocerEnum == null) {
    return null;
  }
  return enums.JobPositionGrocerEnum.values.firstWhereOrNull(
        (e) => e.value == jobPositionGrocerEnum,
      ) ??
      defaultValue;
}

String jobPositionGrocerEnumExplodedListToJson(
  List<enums.JobPositionGrocerEnum>? jobPositionGrocerEnum,
) {
  return jobPositionGrocerEnum?.map((e) => e.value!).join(',') ?? '';
}

List<String> jobPositionGrocerEnumListToJson(
  List<enums.JobPositionGrocerEnum>? jobPositionGrocerEnum,
) {
  if (jobPositionGrocerEnum == null) {
    return [];
  }

  return jobPositionGrocerEnum.map((e) => e.value!).toList();
}

List<enums.JobPositionGrocerEnum> jobPositionGrocerEnumListFromJson(
  List? jobPositionGrocerEnum, [
  List<enums.JobPositionGrocerEnum>? defaultValue,
]) {
  if (jobPositionGrocerEnum == null) {
    return defaultValue ?? [];
  }

  return jobPositionGrocerEnum.map((e) => jobPositionGrocerEnumFromJson(e.toString())).toList();
}

List<enums.JobPositionGrocerEnum>? jobPositionGrocerEnumNullableListFromJson(
  List? jobPositionGrocerEnum, [
  List<enums.JobPositionGrocerEnum>? defaultValue,
]) {
  if (jobPositionGrocerEnum == null) {
    return defaultValue;
  }

  return jobPositionGrocerEnum.map((e) => jobPositionGrocerEnumFromJson(e.toString())).toList();
}

String? weaponBonusEnumNullableToJson(enums.WeaponBonusEnum? weaponBonusEnum) {
  return weaponBonusEnum?.value;
}

String? weaponBonusEnumToJson(enums.WeaponBonusEnum weaponBonusEnum) {
  return weaponBonusEnum.value;
}

enums.WeaponBonusEnum weaponBonusEnumFromJson(
  Object? weaponBonusEnum, [
  enums.WeaponBonusEnum? defaultValue,
]) {
  return enums.WeaponBonusEnum.values.firstWhereOrNull(
        (e) => e.value == weaponBonusEnum,
      ) ??
      defaultValue ??
      enums.WeaponBonusEnum.swaggerGeneratedUnknown;
}

enums.WeaponBonusEnum? weaponBonusEnumNullableFromJson(
  Object? weaponBonusEnum, [
  enums.WeaponBonusEnum? defaultValue,
]) {
  if (weaponBonusEnum == null) {
    return null;
  }
  return enums.WeaponBonusEnum.values.firstWhereOrNull(
        (e) => e.value == weaponBonusEnum,
      ) ??
      defaultValue;
}

String weaponBonusEnumExplodedListToJson(
  List<enums.WeaponBonusEnum>? weaponBonusEnum,
) {
  return weaponBonusEnum?.map((e) => e.value!).join(',') ?? '';
}

List<String> weaponBonusEnumListToJson(
  List<enums.WeaponBonusEnum>? weaponBonusEnum,
) {
  if (weaponBonusEnum == null) {
    return [];
  }

  return weaponBonusEnum.map((e) => e.value!).toList();
}

List<enums.WeaponBonusEnum> weaponBonusEnumListFromJson(
  List? weaponBonusEnum, [
  List<enums.WeaponBonusEnum>? defaultValue,
]) {
  if (weaponBonusEnum == null) {
    return defaultValue ?? [];
  }

  return weaponBonusEnum.map((e) => weaponBonusEnumFromJson(e.toString())).toList();
}

List<enums.WeaponBonusEnum>? weaponBonusEnumNullableListFromJson(
  List? weaponBonusEnum, [
  List<enums.WeaponBonusEnum>? defaultValue,
]) {
  if (weaponBonusEnum == null) {
    return defaultValue;
  }

  return weaponBonusEnum.map((e) => weaponBonusEnumFromJson(e.toString())).toList();
}

String? userListEnumNullableToJson(enums.UserListEnum? userListEnum) {
  return userListEnum?.value;
}

String? userListEnumToJson(enums.UserListEnum userListEnum) {
  return userListEnum.value;
}

enums.UserListEnum userListEnumFromJson(
  Object? userListEnum, [
  enums.UserListEnum? defaultValue,
]) {
  return enums.UserListEnum.values.firstWhereOrNull(
        (e) => e.value == userListEnum,
      ) ??
      defaultValue ??
      enums.UserListEnum.swaggerGeneratedUnknown;
}

enums.UserListEnum? userListEnumNullableFromJson(
  Object? userListEnum, [
  enums.UserListEnum? defaultValue,
]) {
  if (userListEnum == null) {
    return null;
  }
  return enums.UserListEnum.values.firstWhereOrNull(
        (e) => e.value == userListEnum,
      ) ??
      defaultValue;
}

String userListEnumExplodedListToJson(List<enums.UserListEnum>? userListEnum) {
  return userListEnum?.map((e) => e.value!).join(',') ?? '';
}

List<String> userListEnumListToJson(List<enums.UserListEnum>? userListEnum) {
  if (userListEnum == null) {
    return [];
  }

  return userListEnum.map((e) => e.value!).toList();
}

List<enums.UserListEnum> userListEnumListFromJson(
  List? userListEnum, [
  List<enums.UserListEnum>? defaultValue,
]) {
  if (userListEnum == null) {
    return defaultValue ?? [];
  }

  return userListEnum.map((e) => userListEnumFromJson(e.toString())).toList();
}

List<enums.UserListEnum>? userListEnumNullableListFromJson(
  List? userListEnum, [
  List<enums.UserListEnum>? defaultValue,
]) {
  if (userListEnum == null) {
    return defaultValue;
  }

  return userListEnum.map((e) => userListEnumFromJson(e.toString())).toList();
}

String? jobPositionCasinoEnumNullableToJson(
  enums.JobPositionCasinoEnum? jobPositionCasinoEnum,
) {
  return jobPositionCasinoEnum?.value;
}

String? jobPositionCasinoEnumToJson(
  enums.JobPositionCasinoEnum jobPositionCasinoEnum,
) {
  return jobPositionCasinoEnum.value;
}

enums.JobPositionCasinoEnum jobPositionCasinoEnumFromJson(
  Object? jobPositionCasinoEnum, [
  enums.JobPositionCasinoEnum? defaultValue,
]) {
  return enums.JobPositionCasinoEnum.values.firstWhereOrNull(
        (e) => e.value == jobPositionCasinoEnum,
      ) ??
      defaultValue ??
      enums.JobPositionCasinoEnum.swaggerGeneratedUnknown;
}

enums.JobPositionCasinoEnum? jobPositionCasinoEnumNullableFromJson(
  Object? jobPositionCasinoEnum, [
  enums.JobPositionCasinoEnum? defaultValue,
]) {
  if (jobPositionCasinoEnum == null) {
    return null;
  }
  return enums.JobPositionCasinoEnum.values.firstWhereOrNull(
        (e) => e.value == jobPositionCasinoEnum,
      ) ??
      defaultValue;
}

String jobPositionCasinoEnumExplodedListToJson(
  List<enums.JobPositionCasinoEnum>? jobPositionCasinoEnum,
) {
  return jobPositionCasinoEnum?.map((e) => e.value!).join(',') ?? '';
}

List<String> jobPositionCasinoEnumListToJson(
  List<enums.JobPositionCasinoEnum>? jobPositionCasinoEnum,
) {
  if (jobPositionCasinoEnum == null) {
    return [];
  }

  return jobPositionCasinoEnum.map((e) => e.value!).toList();
}

List<enums.JobPositionCasinoEnum> jobPositionCasinoEnumListFromJson(
  List? jobPositionCasinoEnum, [
  List<enums.JobPositionCasinoEnum>? defaultValue,
]) {
  if (jobPositionCasinoEnum == null) {
    return defaultValue ?? [];
  }

  return jobPositionCasinoEnum.map((e) => jobPositionCasinoEnumFromJson(e.toString())).toList();
}

List<enums.JobPositionCasinoEnum>? jobPositionCasinoEnumNullableListFromJson(
  List? jobPositionCasinoEnum, [
  List<enums.JobPositionCasinoEnum>? defaultValue,
]) {
  if (jobPositionCasinoEnum == null) {
    return defaultValue;
  }

  return jobPositionCasinoEnum.map((e) => jobPositionCasinoEnumFromJson(e.toString())).toList();
}

String? attackFinishingHitEffectNullableToJson(
  enums.AttackFinishingHitEffect? attackFinishingHitEffect,
) {
  return attackFinishingHitEffect?.value;
}

String? attackFinishingHitEffectToJson(
  enums.AttackFinishingHitEffect attackFinishingHitEffect,
) {
  return attackFinishingHitEffect.value;
}

enums.AttackFinishingHitEffect attackFinishingHitEffectFromJson(
  Object? attackFinishingHitEffect, [
  enums.AttackFinishingHitEffect? defaultValue,
]) {
  return enums.AttackFinishingHitEffect.values.firstWhereOrNull(
        (e) => e.value == attackFinishingHitEffect,
      ) ??
      defaultValue ??
      enums.AttackFinishingHitEffect.swaggerGeneratedUnknown;
}

enums.AttackFinishingHitEffect? attackFinishingHitEffectNullableFromJson(
  Object? attackFinishingHitEffect, [
  enums.AttackFinishingHitEffect? defaultValue,
]) {
  if (attackFinishingHitEffect == null) {
    return null;
  }
  return enums.AttackFinishingHitEffect.values.firstWhereOrNull(
        (e) => e.value == attackFinishingHitEffect,
      ) ??
      defaultValue;
}

String attackFinishingHitEffectExplodedListToJson(
  List<enums.AttackFinishingHitEffect>? attackFinishingHitEffect,
) {
  return attackFinishingHitEffect?.map((e) => e.value!).join(',') ?? '';
}

List<String> attackFinishingHitEffectListToJson(
  List<enums.AttackFinishingHitEffect>? attackFinishingHitEffect,
) {
  if (attackFinishingHitEffect == null) {
    return [];
  }

  return attackFinishingHitEffect.map((e) => e.value!).toList();
}

List<enums.AttackFinishingHitEffect> attackFinishingHitEffectListFromJson(
  List? attackFinishingHitEffect, [
  List<enums.AttackFinishingHitEffect>? defaultValue,
]) {
  if (attackFinishingHitEffect == null) {
    return defaultValue ?? [];
  }

  return attackFinishingHitEffect.map((e) => attackFinishingHitEffectFromJson(e.toString())).toList();
}

List<enums.AttackFinishingHitEffect>? attackFinishingHitEffectNullableListFromJson(
  List? attackFinishingHitEffect, [
  List<enums.AttackFinishingHitEffect>? defaultValue,
]) {
  if (attackFinishingHitEffect == null) {
    return defaultValue;
  }

  return attackFinishingHitEffect.map((e) => attackFinishingHitEffectFromJson(e.toString())).toList();
}

String? jobPositionMedicalEnumNullableToJson(
  enums.JobPositionMedicalEnum? jobPositionMedicalEnum,
) {
  return jobPositionMedicalEnum?.value;
}

String? jobPositionMedicalEnumToJson(
  enums.JobPositionMedicalEnum jobPositionMedicalEnum,
) {
  return jobPositionMedicalEnum.value;
}

enums.JobPositionMedicalEnum jobPositionMedicalEnumFromJson(
  Object? jobPositionMedicalEnum, [
  enums.JobPositionMedicalEnum? defaultValue,
]) {
  return enums.JobPositionMedicalEnum.values.firstWhereOrNull(
        (e) => e.value == jobPositionMedicalEnum,
      ) ??
      defaultValue ??
      enums.JobPositionMedicalEnum.swaggerGeneratedUnknown;
}

enums.JobPositionMedicalEnum? jobPositionMedicalEnumNullableFromJson(
  Object? jobPositionMedicalEnum, [
  enums.JobPositionMedicalEnum? defaultValue,
]) {
  if (jobPositionMedicalEnum == null) {
    return null;
  }
  return enums.JobPositionMedicalEnum.values.firstWhereOrNull(
        (e) => e.value == jobPositionMedicalEnum,
      ) ??
      defaultValue;
}

String jobPositionMedicalEnumExplodedListToJson(
  List<enums.JobPositionMedicalEnum>? jobPositionMedicalEnum,
) {
  return jobPositionMedicalEnum?.map((e) => e.value!).join(',') ?? '';
}

List<String> jobPositionMedicalEnumListToJson(
  List<enums.JobPositionMedicalEnum>? jobPositionMedicalEnum,
) {
  if (jobPositionMedicalEnum == null) {
    return [];
  }

  return jobPositionMedicalEnum.map((e) => e.value!).toList();
}

List<enums.JobPositionMedicalEnum> jobPositionMedicalEnumListFromJson(
  List? jobPositionMedicalEnum, [
  List<enums.JobPositionMedicalEnum>? defaultValue,
]) {
  if (jobPositionMedicalEnum == null) {
    return defaultValue ?? [];
  }

  return jobPositionMedicalEnum.map((e) => jobPositionMedicalEnumFromJson(e.toString())).toList();
}

List<enums.JobPositionMedicalEnum>? jobPositionMedicalEnumNullableListFromJson(
  List? jobPositionMedicalEnum, [
  List<enums.JobPositionMedicalEnum>? defaultValue,
]) {
  if (jobPositionMedicalEnum == null) {
    return defaultValue;
  }

  return jobPositionMedicalEnum.map((e) => jobPositionMedicalEnumFromJson(e.toString())).toList();
}

String? jobPositionLawEnumNullableToJson(
  enums.JobPositionLawEnum? jobPositionLawEnum,
) {
  return jobPositionLawEnum?.value;
}

String? jobPositionLawEnumToJson(enums.JobPositionLawEnum jobPositionLawEnum) {
  return jobPositionLawEnum.value;
}

enums.JobPositionLawEnum jobPositionLawEnumFromJson(
  Object? jobPositionLawEnum, [
  enums.JobPositionLawEnum? defaultValue,
]) {
  return enums.JobPositionLawEnum.values.firstWhereOrNull(
        (e) => e.value == jobPositionLawEnum,
      ) ??
      defaultValue ??
      enums.JobPositionLawEnum.swaggerGeneratedUnknown;
}

enums.JobPositionLawEnum? jobPositionLawEnumNullableFromJson(
  Object? jobPositionLawEnum, [
  enums.JobPositionLawEnum? defaultValue,
]) {
  if (jobPositionLawEnum == null) {
    return null;
  }
  return enums.JobPositionLawEnum.values.firstWhereOrNull(
        (e) => e.value == jobPositionLawEnum,
      ) ??
      defaultValue;
}

String jobPositionLawEnumExplodedListToJson(
  List<enums.JobPositionLawEnum>? jobPositionLawEnum,
) {
  return jobPositionLawEnum?.map((e) => e.value!).join(',') ?? '';
}

List<String> jobPositionLawEnumListToJson(
  List<enums.JobPositionLawEnum>? jobPositionLawEnum,
) {
  if (jobPositionLawEnum == null) {
    return [];
  }

  return jobPositionLawEnum.map((e) => e.value!).toList();
}

List<enums.JobPositionLawEnum> jobPositionLawEnumListFromJson(
  List? jobPositionLawEnum, [
  List<enums.JobPositionLawEnum>? defaultValue,
]) {
  if (jobPositionLawEnum == null) {
    return defaultValue ?? [];
  }

  return jobPositionLawEnum.map((e) => jobPositionLawEnumFromJson(e.toString())).toList();
}

List<enums.JobPositionLawEnum>? jobPositionLawEnumNullableListFromJson(
  List? jobPositionLawEnum, [
  List<enums.JobPositionLawEnum>? defaultValue,
]) {
  if (jobPositionLawEnum == null) {
    return defaultValue;
  }

  return jobPositionLawEnum.map((e) => jobPositionLawEnumFromJson(e.toString())).toList();
}

String? jobPositionEducationEnumNullableToJson(
  enums.JobPositionEducationEnum? jobPositionEducationEnum,
) {
  return jobPositionEducationEnum?.value;
}

String? jobPositionEducationEnumToJson(
  enums.JobPositionEducationEnum jobPositionEducationEnum,
) {
  return jobPositionEducationEnum.value;
}

enums.JobPositionEducationEnum jobPositionEducationEnumFromJson(
  Object? jobPositionEducationEnum, [
  enums.JobPositionEducationEnum? defaultValue,
]) {
  return enums.JobPositionEducationEnum.values.firstWhereOrNull(
        (e) => e.value == jobPositionEducationEnum,
      ) ??
      defaultValue ??
      enums.JobPositionEducationEnum.swaggerGeneratedUnknown;
}

enums.JobPositionEducationEnum? jobPositionEducationEnumNullableFromJson(
  Object? jobPositionEducationEnum, [
  enums.JobPositionEducationEnum? defaultValue,
]) {
  if (jobPositionEducationEnum == null) {
    return null;
  }
  return enums.JobPositionEducationEnum.values.firstWhereOrNull(
        (e) => e.value == jobPositionEducationEnum,
      ) ??
      defaultValue;
}

String jobPositionEducationEnumExplodedListToJson(
  List<enums.JobPositionEducationEnum>? jobPositionEducationEnum,
) {
  return jobPositionEducationEnum?.map((e) => e.value!).join(',') ?? '';
}

List<String> jobPositionEducationEnumListToJson(
  List<enums.JobPositionEducationEnum>? jobPositionEducationEnum,
) {
  if (jobPositionEducationEnum == null) {
    return [];
  }

  return jobPositionEducationEnum.map((e) => e.value!).toList();
}

List<enums.JobPositionEducationEnum> jobPositionEducationEnumListFromJson(
  List? jobPositionEducationEnum, [
  List<enums.JobPositionEducationEnum>? defaultValue,
]) {
  if (jobPositionEducationEnum == null) {
    return defaultValue ?? [];
  }

  return jobPositionEducationEnum.map((e) => jobPositionEducationEnumFromJson(e.toString())).toList();
}

List<enums.JobPositionEducationEnum>? jobPositionEducationEnumNullableListFromJson(
  List? jobPositionEducationEnum, [
  List<enums.JobPositionEducationEnum>? defaultValue,
]) {
  if (jobPositionEducationEnum == null) {
    return defaultValue;
  }

  return jobPositionEducationEnum.map((e) => jobPositionEducationEnumFromJson(e.toString())).toList();
}

String? raceCarUpgradeSubCategoryNullableToJson(
  enums.RaceCarUpgradeSubCategory? raceCarUpgradeSubCategory,
) {
  return raceCarUpgradeSubCategory?.value;
}

String? raceCarUpgradeSubCategoryToJson(
  enums.RaceCarUpgradeSubCategory raceCarUpgradeSubCategory,
) {
  return raceCarUpgradeSubCategory.value;
}

enums.RaceCarUpgradeSubCategory raceCarUpgradeSubCategoryFromJson(
  Object? raceCarUpgradeSubCategory, [
  enums.RaceCarUpgradeSubCategory? defaultValue,
]) {
  return enums.RaceCarUpgradeSubCategory.values.firstWhereOrNull(
        (e) => e.value == raceCarUpgradeSubCategory,
      ) ??
      defaultValue ??
      enums.RaceCarUpgradeSubCategory.swaggerGeneratedUnknown;
}

enums.RaceCarUpgradeSubCategory? raceCarUpgradeSubCategoryNullableFromJson(
  Object? raceCarUpgradeSubCategory, [
  enums.RaceCarUpgradeSubCategory? defaultValue,
]) {
  if (raceCarUpgradeSubCategory == null) {
    return null;
  }
  return enums.RaceCarUpgradeSubCategory.values.firstWhereOrNull(
        (e) => e.value == raceCarUpgradeSubCategory,
      ) ??
      defaultValue;
}

String raceCarUpgradeSubCategoryExplodedListToJson(
  List<enums.RaceCarUpgradeSubCategory>? raceCarUpgradeSubCategory,
) {
  return raceCarUpgradeSubCategory?.map((e) => e.value!).join(',') ?? '';
}

List<String> raceCarUpgradeSubCategoryListToJson(
  List<enums.RaceCarUpgradeSubCategory>? raceCarUpgradeSubCategory,
) {
  if (raceCarUpgradeSubCategory == null) {
    return [];
  }

  return raceCarUpgradeSubCategory.map((e) => e.value!).toList();
}

List<enums.RaceCarUpgradeSubCategory> raceCarUpgradeSubCategoryListFromJson(
  List? raceCarUpgradeSubCategory, [
  List<enums.RaceCarUpgradeSubCategory>? defaultValue,
]) {
  if (raceCarUpgradeSubCategory == null) {
    return defaultValue ?? [];
  }

  return raceCarUpgradeSubCategory.map((e) => raceCarUpgradeSubCategoryFromJson(e.toString())).toList();
}

List<enums.RaceCarUpgradeSubCategory>? raceCarUpgradeSubCategoryNullableListFromJson(
  List? raceCarUpgradeSubCategory, [
  List<enums.RaceCarUpgradeSubCategory>? defaultValue,
]) {
  if (raceCarUpgradeSubCategory == null) {
    return defaultValue;
  }

  return raceCarUpgradeSubCategory.map((e) => raceCarUpgradeSubCategoryFromJson(e.toString())).toList();
}

String? factionApplicationStatusEnumNullableToJson(
  enums.FactionApplicationStatusEnum? factionApplicationStatusEnum,
) {
  return factionApplicationStatusEnum?.value;
}

String? factionApplicationStatusEnumToJson(
  enums.FactionApplicationStatusEnum factionApplicationStatusEnum,
) {
  return factionApplicationStatusEnum.value;
}

enums.FactionApplicationStatusEnum factionApplicationStatusEnumFromJson(
  Object? factionApplicationStatusEnum, [
  enums.FactionApplicationStatusEnum? defaultValue,
]) {
  return enums.FactionApplicationStatusEnum.values.firstWhereOrNull(
        (e) => e.value == factionApplicationStatusEnum,
      ) ??
      defaultValue ??
      enums.FactionApplicationStatusEnum.swaggerGeneratedUnknown;
}

enums.FactionApplicationStatusEnum? factionApplicationStatusEnumNullableFromJson(
  Object? factionApplicationStatusEnum, [
  enums.FactionApplicationStatusEnum? defaultValue,
]) {
  if (factionApplicationStatusEnum == null) {
    return null;
  }
  return enums.FactionApplicationStatusEnum.values.firstWhereOrNull(
        (e) => e.value == factionApplicationStatusEnum,
      ) ??
      defaultValue;
}

String factionApplicationStatusEnumExplodedListToJson(
  List<enums.FactionApplicationStatusEnum>? factionApplicationStatusEnum,
) {
  return factionApplicationStatusEnum?.map((e) => e.value!).join(',') ?? '';
}

List<String> factionApplicationStatusEnumListToJson(
  List<enums.FactionApplicationStatusEnum>? factionApplicationStatusEnum,
) {
  if (factionApplicationStatusEnum == null) {
    return [];
  }

  return factionApplicationStatusEnum.map((e) => e.value!).toList();
}

List<enums.FactionApplicationStatusEnum> factionApplicationStatusEnumListFromJson(
  List? factionApplicationStatusEnum, [
  List<enums.FactionApplicationStatusEnum>? defaultValue,
]) {
  if (factionApplicationStatusEnum == null) {
    return defaultValue ?? [];
  }

  return factionApplicationStatusEnum.map((e) => factionApplicationStatusEnumFromJson(e.toString())).toList();
}

List<enums.FactionApplicationStatusEnum>? factionApplicationStatusEnumNullableListFromJson(
  List? factionApplicationStatusEnum, [
  List<enums.FactionApplicationStatusEnum>? defaultValue,
]) {
  if (factionApplicationStatusEnum == null) {
    return defaultValue;
  }

  return factionApplicationStatusEnum.map((e) => factionApplicationStatusEnumFromJson(e.toString())).toList();
}

String? factionRankedWarsCategoryEnumNullableToJson(
  enums.FactionRankedWarsCategoryEnum? factionRankedWarsCategoryEnum,
) {
  return factionRankedWarsCategoryEnum?.value;
}

String? factionRankedWarsCategoryEnumToJson(
  enums.FactionRankedWarsCategoryEnum factionRankedWarsCategoryEnum,
) {
  return factionRankedWarsCategoryEnum.value;
}

enums.FactionRankedWarsCategoryEnum factionRankedWarsCategoryEnumFromJson(
  Object? factionRankedWarsCategoryEnum, [
  enums.FactionRankedWarsCategoryEnum? defaultValue,
]) {
  return enums.FactionRankedWarsCategoryEnum.values.firstWhereOrNull(
        (e) => e.value == factionRankedWarsCategoryEnum,
      ) ??
      defaultValue ??
      enums.FactionRankedWarsCategoryEnum.swaggerGeneratedUnknown;
}

enums.FactionRankedWarsCategoryEnum? factionRankedWarsCategoryEnumNullableFromJson(
  Object? factionRankedWarsCategoryEnum, [
  enums.FactionRankedWarsCategoryEnum? defaultValue,
]) {
  if (factionRankedWarsCategoryEnum == null) {
    return null;
  }
  return enums.FactionRankedWarsCategoryEnum.values.firstWhereOrNull(
        (e) => e.value == factionRankedWarsCategoryEnum,
      ) ??
      defaultValue;
}

String factionRankedWarsCategoryEnumExplodedListToJson(
  List<enums.FactionRankedWarsCategoryEnum>? factionRankedWarsCategoryEnum,
) {
  return factionRankedWarsCategoryEnum?.map((e) => e.value!).join(',') ?? '';
}

List<String> factionRankedWarsCategoryEnumListToJson(
  List<enums.FactionRankedWarsCategoryEnum>? factionRankedWarsCategoryEnum,
) {
  if (factionRankedWarsCategoryEnum == null) {
    return [];
  }

  return factionRankedWarsCategoryEnum.map((e) => e.value!).toList();
}

List<enums.FactionRankedWarsCategoryEnum> factionRankedWarsCategoryEnumListFromJson(
  List? factionRankedWarsCategoryEnum, [
  List<enums.FactionRankedWarsCategoryEnum>? defaultValue,
]) {
  if (factionRankedWarsCategoryEnum == null) {
    return defaultValue ?? [];
  }

  return factionRankedWarsCategoryEnum.map((e) => factionRankedWarsCategoryEnumFromJson(e.toString())).toList();
}

List<enums.FactionRankedWarsCategoryEnum>? factionRankedWarsCategoryEnumNullableListFromJson(
  List? factionRankedWarsCategoryEnum, [
  List<enums.FactionRankedWarsCategoryEnum>? defaultValue,
]) {
  if (factionRankedWarsCategoryEnum == null) {
    return defaultValue;
  }

  return factionRankedWarsCategoryEnum.map((e) => factionRankedWarsCategoryEnumFromJson(e.toString())).toList();
}

String? factionTerritoryWarsCategoryEnumNullableToJson(
  enums.FactionTerritoryWarsCategoryEnum? factionTerritoryWarsCategoryEnum,
) {
  return factionTerritoryWarsCategoryEnum?.value;
}

String? factionTerritoryWarsCategoryEnumToJson(
  enums.FactionTerritoryWarsCategoryEnum factionTerritoryWarsCategoryEnum,
) {
  return factionTerritoryWarsCategoryEnum.value;
}

enums.FactionTerritoryWarsCategoryEnum factionTerritoryWarsCategoryEnumFromJson(
  Object? factionTerritoryWarsCategoryEnum, [
  enums.FactionTerritoryWarsCategoryEnum? defaultValue,
]) {
  return enums.FactionTerritoryWarsCategoryEnum.values.firstWhereOrNull(
        (e) => e.value == factionTerritoryWarsCategoryEnum,
      ) ??
      defaultValue ??
      enums.FactionTerritoryWarsCategoryEnum.swaggerGeneratedUnknown;
}

enums.FactionTerritoryWarsCategoryEnum? factionTerritoryWarsCategoryEnumNullableFromJson(
  Object? factionTerritoryWarsCategoryEnum, [
  enums.FactionTerritoryWarsCategoryEnum? defaultValue,
]) {
  if (factionTerritoryWarsCategoryEnum == null) {
    return null;
  }
  return enums.FactionTerritoryWarsCategoryEnum.values.firstWhereOrNull(
        (e) => e.value == factionTerritoryWarsCategoryEnum,
      ) ??
      defaultValue;
}

String factionTerritoryWarsCategoryEnumExplodedListToJson(
  List<enums.FactionTerritoryWarsCategoryEnum>? factionTerritoryWarsCategoryEnum,
) {
  return factionTerritoryWarsCategoryEnum?.map((e) => e.value!).join(',') ?? '';
}

List<String> factionTerritoryWarsCategoryEnumListToJson(
  List<enums.FactionTerritoryWarsCategoryEnum>? factionTerritoryWarsCategoryEnum,
) {
  if (factionTerritoryWarsCategoryEnum == null) {
    return [];
  }

  return factionTerritoryWarsCategoryEnum.map((e) => e.value!).toList();
}

List<enums.FactionTerritoryWarsCategoryEnum> factionTerritoryWarsCategoryEnumListFromJson(
  List? factionTerritoryWarsCategoryEnum, [
  List<enums.FactionTerritoryWarsCategoryEnum>? defaultValue,
]) {
  if (factionTerritoryWarsCategoryEnum == null) {
    return defaultValue ?? [];
  }

  return factionTerritoryWarsCategoryEnum.map((e) => factionTerritoryWarsCategoryEnumFromJson(e.toString())).toList();
}

List<enums.FactionTerritoryWarsCategoryEnum>? factionTerritoryWarsCategoryEnumNullableListFromJson(
  List? factionTerritoryWarsCategoryEnum, [
  List<enums.FactionTerritoryWarsCategoryEnum>? defaultValue,
]) {
  if (factionTerritoryWarsCategoryEnum == null) {
    return defaultValue;
  }

  return factionTerritoryWarsCategoryEnum.map((e) => factionTerritoryWarsCategoryEnumFromJson(e.toString())).toList();
}

String? factionCrimeUserOutcomeNullableToJson(
  enums.FactionCrimeUserOutcome? factionCrimeUserOutcome,
) {
  return factionCrimeUserOutcome?.value;
}

String? factionCrimeUserOutcomeToJson(
  enums.FactionCrimeUserOutcome factionCrimeUserOutcome,
) {
  return factionCrimeUserOutcome.value;
}

enums.FactionCrimeUserOutcome factionCrimeUserOutcomeFromJson(
  Object? factionCrimeUserOutcome, [
  enums.FactionCrimeUserOutcome? defaultValue,
]) {
  return enums.FactionCrimeUserOutcome.values.firstWhereOrNull(
        (e) => e.value == factionCrimeUserOutcome,
      ) ??
      defaultValue ??
      enums.FactionCrimeUserOutcome.swaggerGeneratedUnknown;
}

enums.FactionCrimeUserOutcome? factionCrimeUserOutcomeNullableFromJson(
  Object? factionCrimeUserOutcome, [
  enums.FactionCrimeUserOutcome? defaultValue,
]) {
  if (factionCrimeUserOutcome == null) {
    return null;
  }
  return enums.FactionCrimeUserOutcome.values.firstWhereOrNull(
        (e) => e.value == factionCrimeUserOutcome,
      ) ??
      defaultValue;
}

String factionCrimeUserOutcomeExplodedListToJson(
  List<enums.FactionCrimeUserOutcome>? factionCrimeUserOutcome,
) {
  return factionCrimeUserOutcome?.map((e) => e.value!).join(',') ?? '';
}

List<String> factionCrimeUserOutcomeListToJson(
  List<enums.FactionCrimeUserOutcome>? factionCrimeUserOutcome,
) {
  if (factionCrimeUserOutcome == null) {
    return [];
  }

  return factionCrimeUserOutcome.map((e) => e.value!).toList();
}

List<enums.FactionCrimeUserOutcome> factionCrimeUserOutcomeListFromJson(
  List? factionCrimeUserOutcome, [
  List<enums.FactionCrimeUserOutcome>? defaultValue,
]) {
  if (factionCrimeUserOutcome == null) {
    return defaultValue ?? [];
  }

  return factionCrimeUserOutcome.map((e) => factionCrimeUserOutcomeFromJson(e.toString())).toList();
}

List<enums.FactionCrimeUserOutcome>? factionCrimeUserOutcomeNullableListFromJson(
  List? factionCrimeUserOutcome, [
  List<enums.FactionCrimeUserOutcome>? defaultValue,
]) {
  if (factionCrimeUserOutcome == null) {
    return defaultValue;
  }

  return factionCrimeUserOutcome.map((e) => factionCrimeUserOutcomeFromJson(e.toString())).toList();
}

int? forumFeedTypeEnumNullableToJson(
  enums.ForumFeedTypeEnum? forumFeedTypeEnum,
) {
  return forumFeedTypeEnum?.value;
}

int? forumFeedTypeEnumToJson(enums.ForumFeedTypeEnum forumFeedTypeEnum) {
  return forumFeedTypeEnum.value;
}

enums.ForumFeedTypeEnum forumFeedTypeEnumFromJson(
  Object? forumFeedTypeEnum, [
  enums.ForumFeedTypeEnum? defaultValue,
]) {
  return enums.ForumFeedTypeEnum.values.firstWhereOrNull(
        (e) => e.value == forumFeedTypeEnum,
      ) ??
      defaultValue ??
      enums.ForumFeedTypeEnum.swaggerGeneratedUnknown;
}

enums.ForumFeedTypeEnum? forumFeedTypeEnumNullableFromJson(
  Object? forumFeedTypeEnum, [
  enums.ForumFeedTypeEnum? defaultValue,
]) {
  if (forumFeedTypeEnum == null) {
    return null;
  }
  return enums.ForumFeedTypeEnum.values.firstWhereOrNull(
        (e) => e.value == forumFeedTypeEnum,
      ) ??
      defaultValue;
}

String forumFeedTypeEnumExplodedListToJson(
  List<enums.ForumFeedTypeEnum>? forumFeedTypeEnum,
) {
  return forumFeedTypeEnum?.map((e) => e.value!).join(',') ?? '';
}

List<int> forumFeedTypeEnumListToJson(
  List<enums.ForumFeedTypeEnum>? forumFeedTypeEnum,
) {
  if (forumFeedTypeEnum == null) {
    return [];
  }

  return forumFeedTypeEnum.map((e) => e.value!).toList();
}

List<enums.ForumFeedTypeEnum> forumFeedTypeEnumListFromJson(
  List? forumFeedTypeEnum, [
  List<enums.ForumFeedTypeEnum>? defaultValue,
]) {
  if (forumFeedTypeEnum == null) {
    return defaultValue ?? [];
  }

  return forumFeedTypeEnum.map((e) => forumFeedTypeEnumFromJson(e.toString())).toList();
}

List<enums.ForumFeedTypeEnum>? forumFeedTypeEnumNullableListFromJson(
  List? forumFeedTypeEnum, [
  List<enums.ForumFeedTypeEnum>? defaultValue,
]) {
  if (forumFeedTypeEnum == null) {
    return defaultValue;
  }

  return forumFeedTypeEnum.map((e) => forumFeedTypeEnumFromJson(e.toString())).toList();
}

String? reviveSettingNullableToJson(enums.ReviveSetting? reviveSetting) {
  return reviveSetting?.value;
}

String? reviveSettingToJson(enums.ReviveSetting reviveSetting) {
  return reviveSetting.value;
}

enums.ReviveSetting reviveSettingFromJson(
  Object? reviveSetting, [
  enums.ReviveSetting? defaultValue,
]) {
  return enums.ReviveSetting.values.firstWhereOrNull(
        (e) => e.value == reviveSetting,
      ) ??
      defaultValue ??
      enums.ReviveSetting.swaggerGeneratedUnknown;
}

enums.ReviveSetting? reviveSettingNullableFromJson(
  Object? reviveSetting, [
  enums.ReviveSetting? defaultValue,
]) {
  if (reviveSetting == null) {
    return null;
  }
  return enums.ReviveSetting.values.firstWhereOrNull(
        (e) => e.value == reviveSetting,
      ) ??
      defaultValue;
}

String reviveSettingExplodedListToJson(
  List<enums.ReviveSetting>? reviveSetting,
) {
  return reviveSetting?.map((e) => e.value!).join(',') ?? '';
}

List<String> reviveSettingListToJson(List<enums.ReviveSetting>? reviveSetting) {
  if (reviveSetting == null) {
    return [];
  }

  return reviveSetting.map((e) => e.value!).toList();
}

List<enums.ReviveSetting> reviveSettingListFromJson(
  List? reviveSetting, [
  List<enums.ReviveSetting>? defaultValue,
]) {
  if (reviveSetting == null) {
    return defaultValue ?? [];
  }

  return reviveSetting.map((e) => reviveSettingFromJson(e.toString())).toList();
}

List<enums.ReviveSetting>? reviveSettingNullableListFromJson(
  List? reviveSetting, [
  List<enums.ReviveSetting>? defaultValue,
]) {
  if (reviveSetting == null) {
    return defaultValue;
  }

  return reviveSetting.map((e) => reviveSettingFromJson(e.toString())).toList();
}

String? factionWarfareTypeEnumNullableToJson(
  enums.FactionWarfareTypeEnum? factionWarfareTypeEnum,
) {
  return factionWarfareTypeEnum?.value;
}

String? factionWarfareTypeEnumToJson(
  enums.FactionWarfareTypeEnum factionWarfareTypeEnum,
) {
  return factionWarfareTypeEnum.value;
}

enums.FactionWarfareTypeEnum factionWarfareTypeEnumFromJson(
  Object? factionWarfareTypeEnum, [
  enums.FactionWarfareTypeEnum? defaultValue,
]) {
  return enums.FactionWarfareTypeEnum.values.firstWhereOrNull(
        (e) => e.value == factionWarfareTypeEnum,
      ) ??
      defaultValue ??
      enums.FactionWarfareTypeEnum.swaggerGeneratedUnknown;
}

enums.FactionWarfareTypeEnum? factionWarfareTypeEnumNullableFromJson(
  Object? factionWarfareTypeEnum, [
  enums.FactionWarfareTypeEnum? defaultValue,
]) {
  if (factionWarfareTypeEnum == null) {
    return null;
  }
  return enums.FactionWarfareTypeEnum.values.firstWhereOrNull(
        (e) => e.value == factionWarfareTypeEnum,
      ) ??
      defaultValue;
}

String factionWarfareTypeEnumExplodedListToJson(
  List<enums.FactionWarfareTypeEnum>? factionWarfareTypeEnum,
) {
  return factionWarfareTypeEnum?.map((e) => e.value!).join(',') ?? '';
}

List<String> factionWarfareTypeEnumListToJson(
  List<enums.FactionWarfareTypeEnum>? factionWarfareTypeEnum,
) {
  if (factionWarfareTypeEnum == null) {
    return [];
  }

  return factionWarfareTypeEnum.map((e) => e.value!).toList();
}

List<enums.FactionWarfareTypeEnum> factionWarfareTypeEnumListFromJson(
  List? factionWarfareTypeEnum, [
  List<enums.FactionWarfareTypeEnum>? defaultValue,
]) {
  if (factionWarfareTypeEnum == null) {
    return defaultValue ?? [];
  }

  return factionWarfareTypeEnum.map((e) => factionWarfareTypeEnumFromJson(e.toString())).toList();
}

List<enums.FactionWarfareTypeEnum>? factionWarfareTypeEnumNullableListFromJson(
  List? factionWarfareTypeEnum, [
  List<enums.FactionWarfareTypeEnum>? defaultValue,
]) {
  if (factionWarfareTypeEnum == null) {
    return defaultValue;
  }

  return factionWarfareTypeEnum.map((e) => factionWarfareTypeEnumFromJson(e.toString())).toList();
}

String? propertyModificationEnumNullableToJson(
  enums.PropertyModificationEnum? propertyModificationEnum,
) {
  return propertyModificationEnum?.value;
}

String? propertyModificationEnumToJson(
  enums.PropertyModificationEnum propertyModificationEnum,
) {
  return propertyModificationEnum.value;
}

enums.PropertyModificationEnum propertyModificationEnumFromJson(
  Object? propertyModificationEnum, [
  enums.PropertyModificationEnum? defaultValue,
]) {
  return enums.PropertyModificationEnum.values.firstWhereOrNull(
        (e) => e.value == propertyModificationEnum,
      ) ??
      defaultValue ??
      enums.PropertyModificationEnum.swaggerGeneratedUnknown;
}

enums.PropertyModificationEnum? propertyModificationEnumNullableFromJson(
  Object? propertyModificationEnum, [
  enums.PropertyModificationEnum? defaultValue,
]) {
  if (propertyModificationEnum == null) {
    return null;
  }
  return enums.PropertyModificationEnum.values.firstWhereOrNull(
        (e) => e.value == propertyModificationEnum,
      ) ??
      defaultValue;
}

String propertyModificationEnumExplodedListToJson(
  List<enums.PropertyModificationEnum>? propertyModificationEnum,
) {
  return propertyModificationEnum?.map((e) => e.value!).join(',') ?? '';
}

List<String> propertyModificationEnumListToJson(
  List<enums.PropertyModificationEnum>? propertyModificationEnum,
) {
  if (propertyModificationEnum == null) {
    return [];
  }

  return propertyModificationEnum.map((e) => e.value!).toList();
}

List<enums.PropertyModificationEnum> propertyModificationEnumListFromJson(
  List? propertyModificationEnum, [
  List<enums.PropertyModificationEnum>? defaultValue,
]) {
  if (propertyModificationEnum == null) {
    return defaultValue ?? [];
  }

  return propertyModificationEnum.map((e) => propertyModificationEnumFromJson(e.toString())).toList();
}

List<enums.PropertyModificationEnum>? propertyModificationEnumNullableListFromJson(
  List? propertyModificationEnum, [
  List<enums.PropertyModificationEnum>? defaultValue,
]) {
  if (propertyModificationEnum == null) {
    return defaultValue;
  }

  return propertyModificationEnum.map((e) => propertyModificationEnumFromJson(e.toString())).toList();
}

String? propertyStaffEnumNullableToJson(
  enums.PropertyStaffEnum? propertyStaffEnum,
) {
  return propertyStaffEnum?.value;
}

String? propertyStaffEnumToJson(enums.PropertyStaffEnum propertyStaffEnum) {
  return propertyStaffEnum.value;
}

enums.PropertyStaffEnum propertyStaffEnumFromJson(
  Object? propertyStaffEnum, [
  enums.PropertyStaffEnum? defaultValue,
]) {
  return enums.PropertyStaffEnum.values.firstWhereOrNull(
        (e) => e.value == propertyStaffEnum,
      ) ??
      defaultValue ??
      enums.PropertyStaffEnum.swaggerGeneratedUnknown;
}

enums.PropertyStaffEnum? propertyStaffEnumNullableFromJson(
  Object? propertyStaffEnum, [
  enums.PropertyStaffEnum? defaultValue,
]) {
  if (propertyStaffEnum == null) {
    return null;
  }
  return enums.PropertyStaffEnum.values.firstWhereOrNull(
        (e) => e.value == propertyStaffEnum,
      ) ??
      defaultValue;
}

String propertyStaffEnumExplodedListToJson(
  List<enums.PropertyStaffEnum>? propertyStaffEnum,
) {
  return propertyStaffEnum?.map((e) => e.value!).join(',') ?? '';
}

List<String> propertyStaffEnumListToJson(
  List<enums.PropertyStaffEnum>? propertyStaffEnum,
) {
  if (propertyStaffEnum == null) {
    return [];
  }

  return propertyStaffEnum.map((e) => e.value!).toList();
}

List<enums.PropertyStaffEnum> propertyStaffEnumListFromJson(
  List? propertyStaffEnum, [
  List<enums.PropertyStaffEnum>? defaultValue,
]) {
  if (propertyStaffEnum == null) {
    return defaultValue ?? [];
  }

  return propertyStaffEnum.map((e) => propertyStaffEnumFromJson(e.toString())).toList();
}

List<enums.PropertyStaffEnum>? propertyStaffEnumNullableListFromJson(
  List? propertyStaffEnum, [
  List<enums.PropertyStaffEnum>? defaultValue,
]) {
  if (propertyStaffEnum == null) {
    return defaultValue;
  }

  return propertyStaffEnum.map((e) => propertyStaffEnumFromJson(e.toString())).toList();
}

String? factionCrimeStatusEnumNullableToJson(
  enums.FactionCrimeStatusEnum? factionCrimeStatusEnum,
) {
  return factionCrimeStatusEnum?.value;
}

String? factionCrimeStatusEnumToJson(
  enums.FactionCrimeStatusEnum factionCrimeStatusEnum,
) {
  return factionCrimeStatusEnum.value;
}

enums.FactionCrimeStatusEnum factionCrimeStatusEnumFromJson(
  Object? factionCrimeStatusEnum, [
  enums.FactionCrimeStatusEnum? defaultValue,
]) {
  return enums.FactionCrimeStatusEnum.values.firstWhereOrNull(
        (e) => e.value == factionCrimeStatusEnum,
      ) ??
      defaultValue ??
      enums.FactionCrimeStatusEnum.swaggerGeneratedUnknown;
}

enums.FactionCrimeStatusEnum? factionCrimeStatusEnumNullableFromJson(
  Object? factionCrimeStatusEnum, [
  enums.FactionCrimeStatusEnum? defaultValue,
]) {
  if (factionCrimeStatusEnum == null) {
    return null;
  }
  return enums.FactionCrimeStatusEnum.values.firstWhereOrNull(
        (e) => e.value == factionCrimeStatusEnum,
      ) ??
      defaultValue;
}

String factionCrimeStatusEnumExplodedListToJson(
  List<enums.FactionCrimeStatusEnum>? factionCrimeStatusEnum,
) {
  return factionCrimeStatusEnum?.map((e) => e.value!).join(',') ?? '';
}

List<String> factionCrimeStatusEnumListToJson(
  List<enums.FactionCrimeStatusEnum>? factionCrimeStatusEnum,
) {
  if (factionCrimeStatusEnum == null) {
    return [];
  }

  return factionCrimeStatusEnum.map((e) => e.value!).toList();
}

List<enums.FactionCrimeStatusEnum> factionCrimeStatusEnumListFromJson(
  List? factionCrimeStatusEnum, [
  List<enums.FactionCrimeStatusEnum>? defaultValue,
]) {
  if (factionCrimeStatusEnum == null) {
    return defaultValue ?? [];
  }

  return factionCrimeStatusEnum.map((e) => factionCrimeStatusEnumFromJson(e.toString())).toList();
}

List<enums.FactionCrimeStatusEnum>? factionCrimeStatusEnumNullableListFromJson(
  List? factionCrimeStatusEnum, [
  List<enums.FactionCrimeStatusEnum>? defaultValue,
]) {
  if (factionCrimeStatusEnum == null) {
    return defaultValue;
  }

  return factionCrimeStatusEnum.map((e) => factionCrimeStatusEnumFromJson(e.toString())).toList();
}

String? attackActionEnumNullableToJson(
  enums.AttackActionEnum? attackActionEnum,
) {
  return attackActionEnum?.value;
}

String? attackActionEnumToJson(enums.AttackActionEnum attackActionEnum) {
  return attackActionEnum.value;
}

enums.AttackActionEnum attackActionEnumFromJson(
  Object? attackActionEnum, [
  enums.AttackActionEnum? defaultValue,
]) {
  return enums.AttackActionEnum.values.firstWhereOrNull(
        (e) => e.value == attackActionEnum,
      ) ??
      defaultValue ??
      enums.AttackActionEnum.swaggerGeneratedUnknown;
}

enums.AttackActionEnum? attackActionEnumNullableFromJson(
  Object? attackActionEnum, [
  enums.AttackActionEnum? defaultValue,
]) {
  if (attackActionEnum == null) {
    return null;
  }
  return enums.AttackActionEnum.values.firstWhereOrNull(
        (e) => e.value == attackActionEnum,
      ) ??
      defaultValue;
}

String attackActionEnumExplodedListToJson(
  List<enums.AttackActionEnum>? attackActionEnum,
) {
  return attackActionEnum?.map((e) => e.value!).join(',') ?? '';
}

List<String> attackActionEnumListToJson(
  List<enums.AttackActionEnum>? attackActionEnum,
) {
  if (attackActionEnum == null) {
    return [];
  }

  return attackActionEnum.map((e) => e.value!).toList();
}

List<enums.AttackActionEnum> attackActionEnumListFromJson(
  List? attackActionEnum, [
  List<enums.AttackActionEnum>? defaultValue,
]) {
  if (attackActionEnum == null) {
    return defaultValue ?? [];
  }

  return attackActionEnum.map((e) => attackActionEnumFromJson(e.toString())).toList();
}

List<enums.AttackActionEnum>? attackActionEnumNullableListFromJson(
  List? attackActionEnum, [
  List<enums.AttackActionEnum>? defaultValue,
]) {
  if (attackActionEnum == null) {
    return defaultValue;
  }

  return attackActionEnum.map((e) => attackActionEnumFromJson(e.toString())).toList();
}

String? tornItemAmmoTypeEnumNullableToJson(
  enums.TornItemAmmoTypeEnum? tornItemAmmoTypeEnum,
) {
  return tornItemAmmoTypeEnum?.value;
}

String? tornItemAmmoTypeEnumToJson(
  enums.TornItemAmmoTypeEnum tornItemAmmoTypeEnum,
) {
  return tornItemAmmoTypeEnum.value;
}

enums.TornItemAmmoTypeEnum tornItemAmmoTypeEnumFromJson(
  Object? tornItemAmmoTypeEnum, [
  enums.TornItemAmmoTypeEnum? defaultValue,
]) {
  return enums.TornItemAmmoTypeEnum.values.firstWhereOrNull(
        (e) => e.value == tornItemAmmoTypeEnum,
      ) ??
      defaultValue ??
      enums.TornItemAmmoTypeEnum.swaggerGeneratedUnknown;
}

enums.TornItemAmmoTypeEnum? tornItemAmmoTypeEnumNullableFromJson(
  Object? tornItemAmmoTypeEnum, [
  enums.TornItemAmmoTypeEnum? defaultValue,
]) {
  if (tornItemAmmoTypeEnum == null) {
    return null;
  }
  return enums.TornItemAmmoTypeEnum.values.firstWhereOrNull(
        (e) => e.value == tornItemAmmoTypeEnum,
      ) ??
      defaultValue;
}

String tornItemAmmoTypeEnumExplodedListToJson(
  List<enums.TornItemAmmoTypeEnum>? tornItemAmmoTypeEnum,
) {
  return tornItemAmmoTypeEnum?.map((e) => e.value!).join(',') ?? '';
}

List<String> tornItemAmmoTypeEnumListToJson(
  List<enums.TornItemAmmoTypeEnum>? tornItemAmmoTypeEnum,
) {
  if (tornItemAmmoTypeEnum == null) {
    return [];
  }

  return tornItemAmmoTypeEnum.map((e) => e.value!).toList();
}

List<enums.TornItemAmmoTypeEnum> tornItemAmmoTypeEnumListFromJson(
  List? tornItemAmmoTypeEnum, [
  List<enums.TornItemAmmoTypeEnum>? defaultValue,
]) {
  if (tornItemAmmoTypeEnum == null) {
    return defaultValue ?? [];
  }

  return tornItemAmmoTypeEnum.map((e) => tornItemAmmoTypeEnumFromJson(e.toString())).toList();
}

List<enums.TornItemAmmoTypeEnum>? tornItemAmmoTypeEnumNullableListFromJson(
  List? tornItemAmmoTypeEnum, [
  List<enums.TornItemAmmoTypeEnum>? defaultValue,
]) {
  if (tornItemAmmoTypeEnum == null) {
    return defaultValue;
  }

  return tornItemAmmoTypeEnum.map((e) => tornItemAmmoTypeEnumFromJson(e.toString())).toList();
}

String? tornItemWeaponTypeEnumNullableToJson(
  enums.TornItemWeaponTypeEnum? tornItemWeaponTypeEnum,
) {
  return tornItemWeaponTypeEnum?.value;
}

String? tornItemWeaponTypeEnumToJson(
  enums.TornItemWeaponTypeEnum tornItemWeaponTypeEnum,
) {
  return tornItemWeaponTypeEnum.value;
}

enums.TornItemWeaponTypeEnum tornItemWeaponTypeEnumFromJson(
  Object? tornItemWeaponTypeEnum, [
  enums.TornItemWeaponTypeEnum? defaultValue,
]) {
  return enums.TornItemWeaponTypeEnum.values.firstWhereOrNull(
        (e) => e.value == tornItemWeaponTypeEnum,
      ) ??
      defaultValue ??
      enums.TornItemWeaponTypeEnum.swaggerGeneratedUnknown;
}

enums.TornItemWeaponTypeEnum? tornItemWeaponTypeEnumNullableFromJson(
  Object? tornItemWeaponTypeEnum, [
  enums.TornItemWeaponTypeEnum? defaultValue,
]) {
  if (tornItemWeaponTypeEnum == null) {
    return null;
  }
  return enums.TornItemWeaponTypeEnum.values.firstWhereOrNull(
        (e) => e.value == tornItemWeaponTypeEnum,
      ) ??
      defaultValue;
}

String tornItemWeaponTypeEnumExplodedListToJson(
  List<enums.TornItemWeaponTypeEnum>? tornItemWeaponTypeEnum,
) {
  return tornItemWeaponTypeEnum?.map((e) => e.value!).join(',') ?? '';
}

List<String> tornItemWeaponTypeEnumListToJson(
  List<enums.TornItemWeaponTypeEnum>? tornItemWeaponTypeEnum,
) {
  if (tornItemWeaponTypeEnum == null) {
    return [];
  }

  return tornItemWeaponTypeEnum.map((e) => e.value!).toList();
}

List<enums.TornItemWeaponTypeEnum> tornItemWeaponTypeEnumListFromJson(
  List? tornItemWeaponTypeEnum, [
  List<enums.TornItemWeaponTypeEnum>? defaultValue,
]) {
  if (tornItemWeaponTypeEnum == null) {
    return defaultValue ?? [];
  }

  return tornItemWeaponTypeEnum.map((e) => tornItemWeaponTypeEnumFromJson(e.toString())).toList();
}

List<enums.TornItemWeaponTypeEnum>? tornItemWeaponTypeEnumNullableListFromJson(
  List? tornItemWeaponTypeEnum, [
  List<enums.TornItemWeaponTypeEnum>? defaultValue,
]) {
  if (tornItemWeaponTypeEnum == null) {
    return defaultValue;
  }

  return tornItemWeaponTypeEnum.map((e) => tornItemWeaponTypeEnumFromJson(e.toString())).toList();
}

String? tornItemWeaponCategoryEnumNullableToJson(
  enums.TornItemWeaponCategoryEnum? tornItemWeaponCategoryEnum,
) {
  return tornItemWeaponCategoryEnum?.value;
}

String? tornItemWeaponCategoryEnumToJson(
  enums.TornItemWeaponCategoryEnum tornItemWeaponCategoryEnum,
) {
  return tornItemWeaponCategoryEnum.value;
}

enums.TornItemWeaponCategoryEnum tornItemWeaponCategoryEnumFromJson(
  Object? tornItemWeaponCategoryEnum, [
  enums.TornItemWeaponCategoryEnum? defaultValue,
]) {
  return enums.TornItemWeaponCategoryEnum.values.firstWhereOrNull(
        (e) => e.value == tornItemWeaponCategoryEnum,
      ) ??
      defaultValue ??
      enums.TornItemWeaponCategoryEnum.swaggerGeneratedUnknown;
}

enums.TornItemWeaponCategoryEnum? tornItemWeaponCategoryEnumNullableFromJson(
  Object? tornItemWeaponCategoryEnum, [
  enums.TornItemWeaponCategoryEnum? defaultValue,
]) {
  if (tornItemWeaponCategoryEnum == null) {
    return null;
  }
  return enums.TornItemWeaponCategoryEnum.values.firstWhereOrNull(
        (e) => e.value == tornItemWeaponCategoryEnum,
      ) ??
      defaultValue;
}

String tornItemWeaponCategoryEnumExplodedListToJson(
  List<enums.TornItemWeaponCategoryEnum>? tornItemWeaponCategoryEnum,
) {
  return tornItemWeaponCategoryEnum?.map((e) => e.value!).join(',') ?? '';
}

List<String> tornItemWeaponCategoryEnumListToJson(
  List<enums.TornItemWeaponCategoryEnum>? tornItemWeaponCategoryEnum,
) {
  if (tornItemWeaponCategoryEnum == null) {
    return [];
  }

  return tornItemWeaponCategoryEnum.map((e) => e.value!).toList();
}

List<enums.TornItemWeaponCategoryEnum> tornItemWeaponCategoryEnumListFromJson(
  List? tornItemWeaponCategoryEnum, [
  List<enums.TornItemWeaponCategoryEnum>? defaultValue,
]) {
  if (tornItemWeaponCategoryEnum == null) {
    return defaultValue ?? [];
  }

  return tornItemWeaponCategoryEnum.map((e) => tornItemWeaponCategoryEnumFromJson(e.toString())).toList();
}

List<enums.TornItemWeaponCategoryEnum>? tornItemWeaponCategoryEnumNullableListFromJson(
  List? tornItemWeaponCategoryEnum, [
  List<enums.TornItemWeaponCategoryEnum>? defaultValue,
]) {
  if (tornItemWeaponCategoryEnum == null) {
    return defaultValue;
  }

  return tornItemWeaponCategoryEnum.map((e) => tornItemWeaponCategoryEnumFromJson(e.toString())).toList();
}

String? tornItemTypeEnumNullableToJson(
  enums.TornItemTypeEnum? tornItemTypeEnum,
) {
  return tornItemTypeEnum?.value;
}

String? tornItemTypeEnumToJson(enums.TornItemTypeEnum tornItemTypeEnum) {
  return tornItemTypeEnum.value;
}

enums.TornItemTypeEnum tornItemTypeEnumFromJson(
  Object? tornItemTypeEnum, [
  enums.TornItemTypeEnum? defaultValue,
]) {
  return enums.TornItemTypeEnum.values.firstWhereOrNull(
        (e) => e.value == tornItemTypeEnum,
      ) ??
      defaultValue ??
      enums.TornItemTypeEnum.swaggerGeneratedUnknown;
}

enums.TornItemTypeEnum? tornItemTypeEnumNullableFromJson(
  Object? tornItemTypeEnum, [
  enums.TornItemTypeEnum? defaultValue,
]) {
  if (tornItemTypeEnum == null) {
    return null;
  }
  return enums.TornItemTypeEnum.values.firstWhereOrNull(
        (e) => e.value == tornItemTypeEnum,
      ) ??
      defaultValue;
}

String tornItemTypeEnumExplodedListToJson(
  List<enums.TornItemTypeEnum>? tornItemTypeEnum,
) {
  return tornItemTypeEnum?.map((e) => e.value!).join(',') ?? '';
}

List<String> tornItemTypeEnumListToJson(
  List<enums.TornItemTypeEnum>? tornItemTypeEnum,
) {
  if (tornItemTypeEnum == null) {
    return [];
  }

  return tornItemTypeEnum.map((e) => e.value!).toList();
}

List<enums.TornItemTypeEnum> tornItemTypeEnumListFromJson(
  List? tornItemTypeEnum, [
  List<enums.TornItemTypeEnum>? defaultValue,
]) {
  if (tornItemTypeEnum == null) {
    return defaultValue ?? [];
  }

  return tornItemTypeEnum.map((e) => tornItemTypeEnumFromJson(e.toString())).toList();
}

List<enums.TornItemTypeEnum>? tornItemTypeEnumNullableListFromJson(
  List? tornItemTypeEnum, [
  List<enums.TornItemTypeEnum>? defaultValue,
]) {
  if (tornItemTypeEnum == null) {
    return defaultValue;
  }

  return tornItemTypeEnum.map((e) => tornItemTypeEnumFromJson(e.toString())).toList();
}

String? tornItemCategoryNullableToJson(
  enums.TornItemCategory? tornItemCategory,
) {
  return tornItemCategory?.value;
}

String? tornItemCategoryToJson(enums.TornItemCategory tornItemCategory) {
  return tornItemCategory.value;
}

enums.TornItemCategory tornItemCategoryFromJson(
  Object? tornItemCategory, [
  enums.TornItemCategory? defaultValue,
]) {
  return enums.TornItemCategory.values.firstWhereOrNull(
        (e) => e.value == tornItemCategory,
      ) ??
      defaultValue ??
      enums.TornItemCategory.swaggerGeneratedUnknown;
}

enums.TornItemCategory? tornItemCategoryNullableFromJson(
  Object? tornItemCategory, [
  enums.TornItemCategory? defaultValue,
]) {
  if (tornItemCategory == null) {
    return null;
  }
  return enums.TornItemCategory.values.firstWhereOrNull(
        (e) => e.value == tornItemCategory,
      ) ??
      defaultValue;
}

String tornItemCategoryExplodedListToJson(
  List<enums.TornItemCategory>? tornItemCategory,
) {
  return tornItemCategory?.map((e) => e.value!).join(',') ?? '';
}

List<String> tornItemCategoryListToJson(
  List<enums.TornItemCategory>? tornItemCategory,
) {
  if (tornItemCategory == null) {
    return [];
  }

  return tornItemCategory.map((e) => e.value!).toList();
}

List<enums.TornItemCategory> tornItemCategoryListFromJson(
  List? tornItemCategory, [
  List<enums.TornItemCategory>? defaultValue,
]) {
  if (tornItemCategory == null) {
    return defaultValue ?? [];
  }

  return tornItemCategory.map((e) => tornItemCategoryFromJson(e.toString())).toList();
}

List<enums.TornItemCategory>? tornItemCategoryNullableListFromJson(
  List? tornItemCategory, [
  List<enums.TornItemCategory>? defaultValue,
]) {
  if (tornItemCategory == null) {
    return defaultValue;
  }

  return tornItemCategory.map((e) => tornItemCategoryFromJson(e.toString())).toList();
}

String? tornItemArmorCoveragePartEnumNullableToJson(
  enums.TornItemArmorCoveragePartEnum? tornItemArmorCoveragePartEnum,
) {
  return tornItemArmorCoveragePartEnum?.value;
}

String? tornItemArmorCoveragePartEnumToJson(
  enums.TornItemArmorCoveragePartEnum tornItemArmorCoveragePartEnum,
) {
  return tornItemArmorCoveragePartEnum.value;
}

enums.TornItemArmorCoveragePartEnum tornItemArmorCoveragePartEnumFromJson(
  Object? tornItemArmorCoveragePartEnum, [
  enums.TornItemArmorCoveragePartEnum? defaultValue,
]) {
  return enums.TornItemArmorCoveragePartEnum.values.firstWhereOrNull(
        (e) => e.value == tornItemArmorCoveragePartEnum,
      ) ??
      defaultValue ??
      enums.TornItemArmorCoveragePartEnum.swaggerGeneratedUnknown;
}

enums.TornItemArmorCoveragePartEnum? tornItemArmorCoveragePartEnumNullableFromJson(
  Object? tornItemArmorCoveragePartEnum, [
  enums.TornItemArmorCoveragePartEnum? defaultValue,
]) {
  if (tornItemArmorCoveragePartEnum == null) {
    return null;
  }
  return enums.TornItemArmorCoveragePartEnum.values.firstWhereOrNull(
        (e) => e.value == tornItemArmorCoveragePartEnum,
      ) ??
      defaultValue;
}

String tornItemArmorCoveragePartEnumExplodedListToJson(
  List<enums.TornItemArmorCoveragePartEnum>? tornItemArmorCoveragePartEnum,
) {
  return tornItemArmorCoveragePartEnum?.map((e) => e.value!).join(',') ?? '';
}

List<String> tornItemArmorCoveragePartEnumListToJson(
  List<enums.TornItemArmorCoveragePartEnum>? tornItemArmorCoveragePartEnum,
) {
  if (tornItemArmorCoveragePartEnum == null) {
    return [];
  }

  return tornItemArmorCoveragePartEnum.map((e) => e.value!).toList();
}

List<enums.TornItemArmorCoveragePartEnum> tornItemArmorCoveragePartEnumListFromJson(
  List? tornItemArmorCoveragePartEnum, [
  List<enums.TornItemArmorCoveragePartEnum>? defaultValue,
]) {
  if (tornItemArmorCoveragePartEnum == null) {
    return defaultValue ?? [];
  }

  return tornItemArmorCoveragePartEnum.map((e) => tornItemArmorCoveragePartEnumFromJson(e.toString())).toList();
}

List<enums.TornItemArmorCoveragePartEnum>? tornItemArmorCoveragePartEnumNullableListFromJson(
  List? tornItemArmorCoveragePartEnum, [
  List<enums.TornItemArmorCoveragePartEnum>? defaultValue,
]) {
  if (tornItemArmorCoveragePartEnum == null) {
    return defaultValue;
  }

  return tornItemArmorCoveragePartEnum.map((e) => tornItemArmorCoveragePartEnumFromJson(e.toString())).toList();
}

String? userPropertyDetailsExtendedStatusNullableToJson(
  enums.UserPropertyDetailsExtendedStatus? userPropertyDetailsExtendedStatus,
) {
  return userPropertyDetailsExtendedStatus?.value;
}

String? userPropertyDetailsExtendedStatusToJson(
  enums.UserPropertyDetailsExtendedStatus userPropertyDetailsExtendedStatus,
) {
  return userPropertyDetailsExtendedStatus.value;
}

enums.UserPropertyDetailsExtendedStatus userPropertyDetailsExtendedStatusFromJson(
  Object? userPropertyDetailsExtendedStatus, [
  enums.UserPropertyDetailsExtendedStatus? defaultValue,
]) {
  return enums.UserPropertyDetailsExtendedStatus.values.firstWhereOrNull(
        (e) => e.value == userPropertyDetailsExtendedStatus,
      ) ??
      defaultValue ??
      enums.UserPropertyDetailsExtendedStatus.swaggerGeneratedUnknown;
}

enums.UserPropertyDetailsExtendedStatus? userPropertyDetailsExtendedStatusNullableFromJson(
  Object? userPropertyDetailsExtendedStatus, [
  enums.UserPropertyDetailsExtendedStatus? defaultValue,
]) {
  if (userPropertyDetailsExtendedStatus == null) {
    return null;
  }
  return enums.UserPropertyDetailsExtendedStatus.values.firstWhereOrNull(
        (e) => e.value == userPropertyDetailsExtendedStatus,
      ) ??
      defaultValue;
}

String userPropertyDetailsExtendedStatusExplodedListToJson(
  List<enums.UserPropertyDetailsExtendedStatus>? userPropertyDetailsExtendedStatus,
) {
  return userPropertyDetailsExtendedStatus?.map((e) => e.value!).join(',') ?? '';
}

List<String> userPropertyDetailsExtendedStatusListToJson(
  List<enums.UserPropertyDetailsExtendedStatus>? userPropertyDetailsExtendedStatus,
) {
  if (userPropertyDetailsExtendedStatus == null) {
    return [];
  }

  return userPropertyDetailsExtendedStatus.map((e) => e.value!).toList();
}

List<enums.UserPropertyDetailsExtendedStatus> userPropertyDetailsExtendedStatusListFromJson(
  List? userPropertyDetailsExtendedStatus, [
  List<enums.UserPropertyDetailsExtendedStatus>? defaultValue,
]) {
  if (userPropertyDetailsExtendedStatus == null) {
    return defaultValue ?? [];
  }

  return userPropertyDetailsExtendedStatus.map((e) => userPropertyDetailsExtendedStatusFromJson(e.toString())).toList();
}

List<enums.UserPropertyDetailsExtendedStatus>? userPropertyDetailsExtendedStatusNullableListFromJson(
  List? userPropertyDetailsExtendedStatus, [
  List<enums.UserPropertyDetailsExtendedStatus>? defaultValue,
]) {
  if (userPropertyDetailsExtendedStatus == null) {
    return defaultValue;
  }

  return userPropertyDetailsExtendedStatus.map((e) => userPropertyDetailsExtendedStatusFromJson(e.toString())).toList();
}

String? userPropertyDetailsExtendedRentedStatusNullableToJson(
  enums.UserPropertyDetailsExtendedRentedStatus? userPropertyDetailsExtendedRentedStatus,
) {
  return userPropertyDetailsExtendedRentedStatus?.value;
}

String? userPropertyDetailsExtendedRentedStatusToJson(
  enums.UserPropertyDetailsExtendedRentedStatus userPropertyDetailsExtendedRentedStatus,
) {
  return userPropertyDetailsExtendedRentedStatus.value;
}

enums.UserPropertyDetailsExtendedRentedStatus userPropertyDetailsExtendedRentedStatusFromJson(
  Object? userPropertyDetailsExtendedRentedStatus, [
  enums.UserPropertyDetailsExtendedRentedStatus? defaultValue,
]) {
  return enums.UserPropertyDetailsExtendedRentedStatus.values.firstWhereOrNull(
        (e) => e.value == userPropertyDetailsExtendedRentedStatus,
      ) ??
      defaultValue ??
      enums.UserPropertyDetailsExtendedRentedStatus.swaggerGeneratedUnknown;
}

enums.UserPropertyDetailsExtendedRentedStatus? userPropertyDetailsExtendedRentedStatusNullableFromJson(
  Object? userPropertyDetailsExtendedRentedStatus, [
  enums.UserPropertyDetailsExtendedRentedStatus? defaultValue,
]) {
  if (userPropertyDetailsExtendedRentedStatus == null) {
    return null;
  }
  return enums.UserPropertyDetailsExtendedRentedStatus.values.firstWhereOrNull(
        (e) => e.value == userPropertyDetailsExtendedRentedStatus,
      ) ??
      defaultValue;
}

String userPropertyDetailsExtendedRentedStatusExplodedListToJson(
  List<enums.UserPropertyDetailsExtendedRentedStatus>? userPropertyDetailsExtendedRentedStatus,
) {
  return userPropertyDetailsExtendedRentedStatus?.map((e) => e.value!).join(',') ?? '';
}

List<String> userPropertyDetailsExtendedRentedStatusListToJson(
  List<enums.UserPropertyDetailsExtendedRentedStatus>? userPropertyDetailsExtendedRentedStatus,
) {
  if (userPropertyDetailsExtendedRentedStatus == null) {
    return [];
  }

  return userPropertyDetailsExtendedRentedStatus.map((e) => e.value!).toList();
}

List<enums.UserPropertyDetailsExtendedRentedStatus> userPropertyDetailsExtendedRentedStatusListFromJson(
  List? userPropertyDetailsExtendedRentedStatus, [
  List<enums.UserPropertyDetailsExtendedRentedStatus>? defaultValue,
]) {
  if (userPropertyDetailsExtendedRentedStatus == null) {
    return defaultValue ?? [];
  }

  return userPropertyDetailsExtendedRentedStatus
      .map((e) => userPropertyDetailsExtendedRentedStatusFromJson(e.toString()))
      .toList();
}

List<enums.UserPropertyDetailsExtendedRentedStatus>? userPropertyDetailsExtendedRentedStatusNullableListFromJson(
  List? userPropertyDetailsExtendedRentedStatus, [
  List<enums.UserPropertyDetailsExtendedRentedStatus>? defaultValue,
]) {
  if (userPropertyDetailsExtendedRentedStatus == null) {
    return defaultValue;
  }

  return userPropertyDetailsExtendedRentedStatus
      .map((e) => userPropertyDetailsExtendedRentedStatusFromJson(e.toString()))
      .toList();
}

String? userPropertyDetailsExtendedForRentStatusNullableToJson(
  enums.UserPropertyDetailsExtendedForRentStatus? userPropertyDetailsExtendedForRentStatus,
) {
  return userPropertyDetailsExtendedForRentStatus?.value;
}

String? userPropertyDetailsExtendedForRentStatusToJson(
  enums.UserPropertyDetailsExtendedForRentStatus userPropertyDetailsExtendedForRentStatus,
) {
  return userPropertyDetailsExtendedForRentStatus.value;
}

enums.UserPropertyDetailsExtendedForRentStatus userPropertyDetailsExtendedForRentStatusFromJson(
  Object? userPropertyDetailsExtendedForRentStatus, [
  enums.UserPropertyDetailsExtendedForRentStatus? defaultValue,
]) {
  return enums.UserPropertyDetailsExtendedForRentStatus.values.firstWhereOrNull(
        (e) => e.value == userPropertyDetailsExtendedForRentStatus,
      ) ??
      defaultValue ??
      enums.UserPropertyDetailsExtendedForRentStatus.swaggerGeneratedUnknown;
}

enums.UserPropertyDetailsExtendedForRentStatus? userPropertyDetailsExtendedForRentStatusNullableFromJson(
  Object? userPropertyDetailsExtendedForRentStatus, [
  enums.UserPropertyDetailsExtendedForRentStatus? defaultValue,
]) {
  if (userPropertyDetailsExtendedForRentStatus == null) {
    return null;
  }
  return enums.UserPropertyDetailsExtendedForRentStatus.values.firstWhereOrNull(
        (e) => e.value == userPropertyDetailsExtendedForRentStatus,
      ) ??
      defaultValue;
}

String userPropertyDetailsExtendedForRentStatusExplodedListToJson(
  List<enums.UserPropertyDetailsExtendedForRentStatus>? userPropertyDetailsExtendedForRentStatus,
) {
  return userPropertyDetailsExtendedForRentStatus?.map((e) => e.value!).join(',') ?? '';
}

List<String> userPropertyDetailsExtendedForRentStatusListToJson(
  List<enums.UserPropertyDetailsExtendedForRentStatus>? userPropertyDetailsExtendedForRentStatus,
) {
  if (userPropertyDetailsExtendedForRentStatus == null) {
    return [];
  }

  return userPropertyDetailsExtendedForRentStatus.map((e) => e.value!).toList();
}

List<enums.UserPropertyDetailsExtendedForRentStatus> userPropertyDetailsExtendedForRentStatusListFromJson(
  List? userPropertyDetailsExtendedForRentStatus, [
  List<enums.UserPropertyDetailsExtendedForRentStatus>? defaultValue,
]) {
  if (userPropertyDetailsExtendedForRentStatus == null) {
    return defaultValue ?? [];
  }

  return userPropertyDetailsExtendedForRentStatus
      .map(
        (e) => userPropertyDetailsExtendedForRentStatusFromJson(e.toString()),
      )
      .toList();
}

List<enums.UserPropertyDetailsExtendedForRentStatus>? userPropertyDetailsExtendedForRentStatusNullableListFromJson(
  List? userPropertyDetailsExtendedForRentStatus, [
  List<enums.UserPropertyDetailsExtendedForRentStatus>? defaultValue,
]) {
  if (userPropertyDetailsExtendedForRentStatus == null) {
    return defaultValue;
  }

  return userPropertyDetailsExtendedForRentStatus
      .map(
        (e) => userPropertyDetailsExtendedForRentStatusFromJson(e.toString()),
      )
      .toList();
}

String? userPropertyDetailsExtendedForSaleStatusNullableToJson(
  enums.UserPropertyDetailsExtendedForSaleStatus? userPropertyDetailsExtendedForSaleStatus,
) {
  return userPropertyDetailsExtendedForSaleStatus?.value;
}

String? userPropertyDetailsExtendedForSaleStatusToJson(
  enums.UserPropertyDetailsExtendedForSaleStatus userPropertyDetailsExtendedForSaleStatus,
) {
  return userPropertyDetailsExtendedForSaleStatus.value;
}

enums.UserPropertyDetailsExtendedForSaleStatus userPropertyDetailsExtendedForSaleStatusFromJson(
  Object? userPropertyDetailsExtendedForSaleStatus, [
  enums.UserPropertyDetailsExtendedForSaleStatus? defaultValue,
]) {
  return enums.UserPropertyDetailsExtendedForSaleStatus.values.firstWhereOrNull(
        (e) => e.value == userPropertyDetailsExtendedForSaleStatus,
      ) ??
      defaultValue ??
      enums.UserPropertyDetailsExtendedForSaleStatus.swaggerGeneratedUnknown;
}

enums.UserPropertyDetailsExtendedForSaleStatus? userPropertyDetailsExtendedForSaleStatusNullableFromJson(
  Object? userPropertyDetailsExtendedForSaleStatus, [
  enums.UserPropertyDetailsExtendedForSaleStatus? defaultValue,
]) {
  if (userPropertyDetailsExtendedForSaleStatus == null) {
    return null;
  }
  return enums.UserPropertyDetailsExtendedForSaleStatus.values.firstWhereOrNull(
        (e) => e.value == userPropertyDetailsExtendedForSaleStatus,
      ) ??
      defaultValue;
}

String userPropertyDetailsExtendedForSaleStatusExplodedListToJson(
  List<enums.UserPropertyDetailsExtendedForSaleStatus>? userPropertyDetailsExtendedForSaleStatus,
) {
  return userPropertyDetailsExtendedForSaleStatus?.map((e) => e.value!).join(',') ?? '';
}

List<String> userPropertyDetailsExtendedForSaleStatusListToJson(
  List<enums.UserPropertyDetailsExtendedForSaleStatus>? userPropertyDetailsExtendedForSaleStatus,
) {
  if (userPropertyDetailsExtendedForSaleStatus == null) {
    return [];
  }

  return userPropertyDetailsExtendedForSaleStatus.map((e) => e.value!).toList();
}

List<enums.UserPropertyDetailsExtendedForSaleStatus> userPropertyDetailsExtendedForSaleStatusListFromJson(
  List? userPropertyDetailsExtendedForSaleStatus, [
  List<enums.UserPropertyDetailsExtendedForSaleStatus>? defaultValue,
]) {
  if (userPropertyDetailsExtendedForSaleStatus == null) {
    return defaultValue ?? [];
  }

  return userPropertyDetailsExtendedForSaleStatus
      .map(
        (e) => userPropertyDetailsExtendedForSaleStatusFromJson(e.toString()),
      )
      .toList();
}

List<enums.UserPropertyDetailsExtendedForSaleStatus>? userPropertyDetailsExtendedForSaleStatusNullableListFromJson(
  List? userPropertyDetailsExtendedForSaleStatus, [
  List<enums.UserPropertyDetailsExtendedForSaleStatus>? defaultValue,
]) {
  if (userPropertyDetailsExtendedForSaleStatus == null) {
    return defaultValue;
  }

  return userPropertyDetailsExtendedForSaleStatus
      .map(
        (e) => userPropertyDetailsExtendedForSaleStatusFromJson(e.toString()),
      )
      .toList();
}

String? personalStatsCategoryEnumNullableToJson(
  enums.PersonalStatsCategoryEnum? personalStatsCategoryEnum,
) {
  return personalStatsCategoryEnum?.value;
}

String? personalStatsCategoryEnumToJson(
  enums.PersonalStatsCategoryEnum personalStatsCategoryEnum,
) {
  return personalStatsCategoryEnum.value;
}

enums.PersonalStatsCategoryEnum personalStatsCategoryEnumFromJson(
  Object? personalStatsCategoryEnum, [
  enums.PersonalStatsCategoryEnum? defaultValue,
]) {
  return enums.PersonalStatsCategoryEnum.values.firstWhereOrNull(
        (e) => e.value == personalStatsCategoryEnum,
      ) ??
      defaultValue ??
      enums.PersonalStatsCategoryEnum.swaggerGeneratedUnknown;
}

enums.PersonalStatsCategoryEnum? personalStatsCategoryEnumNullableFromJson(
  Object? personalStatsCategoryEnum, [
  enums.PersonalStatsCategoryEnum? defaultValue,
]) {
  if (personalStatsCategoryEnum == null) {
    return null;
  }
  return enums.PersonalStatsCategoryEnum.values.firstWhereOrNull(
        (e) => e.value == personalStatsCategoryEnum,
      ) ??
      defaultValue;
}

String personalStatsCategoryEnumExplodedListToJson(
  List<enums.PersonalStatsCategoryEnum>? personalStatsCategoryEnum,
) {
  return personalStatsCategoryEnum?.map((e) => e.value!).join(',') ?? '';
}

List<String> personalStatsCategoryEnumListToJson(
  List<enums.PersonalStatsCategoryEnum>? personalStatsCategoryEnum,
) {
  if (personalStatsCategoryEnum == null) {
    return [];
  }

  return personalStatsCategoryEnum.map((e) => e.value!).toList();
}

List<enums.PersonalStatsCategoryEnum> personalStatsCategoryEnumListFromJson(
  List? personalStatsCategoryEnum, [
  List<enums.PersonalStatsCategoryEnum>? defaultValue,
]) {
  if (personalStatsCategoryEnum == null) {
    return defaultValue ?? [];
  }

  return personalStatsCategoryEnum.map((e) => personalStatsCategoryEnumFromJson(e.toString())).toList();
}

List<enums.PersonalStatsCategoryEnum>? personalStatsCategoryEnumNullableListFromJson(
  List? personalStatsCategoryEnum, [
  List<enums.PersonalStatsCategoryEnum>? defaultValue,
]) {
  if (personalStatsCategoryEnum == null) {
    return defaultValue;
  }

  return personalStatsCategoryEnum.map((e) => personalStatsCategoryEnumFromJson(e.toString())).toList();
}

String? personalStatsStatNameNullableToJson(
  enums.PersonalStatsStatName? personalStatsStatName,
) {
  return personalStatsStatName?.value;
}

String? personalStatsStatNameToJson(
  enums.PersonalStatsStatName personalStatsStatName,
) {
  return personalStatsStatName.value;
}

enums.PersonalStatsStatName personalStatsStatNameFromJson(
  Object? personalStatsStatName, [
  enums.PersonalStatsStatName? defaultValue,
]) {
  return enums.PersonalStatsStatName.values.firstWhereOrNull(
        (e) => e.value == personalStatsStatName,
      ) ??
      defaultValue ??
      enums.PersonalStatsStatName.swaggerGeneratedUnknown;
}

enums.PersonalStatsStatName? personalStatsStatNameNullableFromJson(
  Object? personalStatsStatName, [
  enums.PersonalStatsStatName? defaultValue,
]) {
  if (personalStatsStatName == null) {
    return null;
  }
  return enums.PersonalStatsStatName.values.firstWhereOrNull(
        (e) => e.value == personalStatsStatName,
      ) ??
      defaultValue;
}

String personalStatsStatNameExplodedListToJson(
  List<enums.PersonalStatsStatName>? personalStatsStatName,
) {
  return personalStatsStatName?.map((e) => e.value!).join(',') ?? '';
}

List<String> personalStatsStatNameListToJson(
  List<enums.PersonalStatsStatName>? personalStatsStatName,
) {
  if (personalStatsStatName == null) {
    return [];
  }

  return personalStatsStatName.map((e) => e.value!).toList();
}

List<enums.PersonalStatsStatName> personalStatsStatNameListFromJson(
  List? personalStatsStatName, [
  List<enums.PersonalStatsStatName>? defaultValue,
]) {
  if (personalStatsStatName == null) {
    return defaultValue ?? [];
  }

  return personalStatsStatName.map((e) => personalStatsStatNameFromJson(e.toString())).toList();
}

List<enums.PersonalStatsStatName>? personalStatsStatNameNullableListFromJson(
  List? personalStatsStatName, [
  List<enums.PersonalStatsStatName>? defaultValue,
]) {
  if (personalStatsStatName == null) {
    return defaultValue;
  }

  return personalStatsStatName.map((e) => personalStatsStatNameFromJson(e.toString())).toList();
}

String? apiSortNullableToJson(enums.ApiSort? apiSort) {
  return apiSort?.value;
}

String? apiSortToJson(enums.ApiSort apiSort) {
  return apiSort.value;
}

enums.ApiSort apiSortFromJson(Object? apiSort, [enums.ApiSort? defaultValue]) {
  return enums.ApiSort.values.firstWhereOrNull((e) => e.value == apiSort) ??
      defaultValue ??
      enums.ApiSort.swaggerGeneratedUnknown;
}

enums.ApiSort? apiSortNullableFromJson(
  Object? apiSort, [
  enums.ApiSort? defaultValue,
]) {
  if (apiSort == null) {
    return null;
  }
  return enums.ApiSort.values.firstWhereOrNull((e) => e.value == apiSort) ?? defaultValue;
}

String apiSortExplodedListToJson(List<enums.ApiSort>? apiSort) {
  return apiSort?.map((e) => e.value!).join(',') ?? '';
}

List<String> apiSortListToJson(List<enums.ApiSort>? apiSort) {
  if (apiSort == null) {
    return [];
  }

  return apiSort.map((e) => e.value!).toList();
}

List<enums.ApiSort> apiSortListFromJson(
  List? apiSort, [
  List<enums.ApiSort>? defaultValue,
]) {
  if (apiSort == null) {
    return defaultValue ?? [];
  }

  return apiSort.map((e) => apiSortFromJson(e.toString())).toList();
}

List<enums.ApiSort>? apiSortNullableListFromJson(
  List? apiSort, [
  List<enums.ApiSort>? defaultValue,
]) {
  if (apiSort == null) {
    return defaultValue;
  }

  return apiSort.map((e) => apiSortFromJson(e.toString())).toList();
}

String? apiSortDescNullableToJson(enums.ApiSortDesc? apiSortDesc) {
  return apiSortDesc?.value;
}

String? apiSortDescToJson(enums.ApiSortDesc apiSortDesc) {
  return apiSortDesc.value;
}

enums.ApiSortDesc apiSortDescFromJson(
  Object? apiSortDesc, [
  enums.ApiSortDesc? defaultValue,
]) {
  return enums.ApiSortDesc.values.firstWhereOrNull(
        (e) => e.value == apiSortDesc,
      ) ??
      defaultValue ??
      enums.ApiSortDesc.swaggerGeneratedUnknown;
}

enums.ApiSortDesc? apiSortDescNullableFromJson(
  Object? apiSortDesc, [
  enums.ApiSortDesc? defaultValue,
]) {
  if (apiSortDesc == null) {
    return null;
  }
  return enums.ApiSortDesc.values.firstWhereOrNull(
        (e) => e.value == apiSortDesc,
      ) ??
      defaultValue;
}

String apiSortDescExplodedListToJson(List<enums.ApiSortDesc>? apiSortDesc) {
  return apiSortDesc?.map((e) => e.value!).join(',') ?? '';
}

List<String> apiSortDescListToJson(List<enums.ApiSortDesc>? apiSortDesc) {
  if (apiSortDesc == null) {
    return [];
  }

  return apiSortDesc.map((e) => e.value!).toList();
}

List<enums.ApiSortDesc> apiSortDescListFromJson(
  List? apiSortDesc, [
  List<enums.ApiSortDesc>? defaultValue,
]) {
  if (apiSortDesc == null) {
    return defaultValue ?? [];
  }

  return apiSortDesc.map((e) => apiSortDescFromJson(e.toString())).toList();
}

List<enums.ApiSortDesc>? apiSortDescNullableListFromJson(
  List? apiSortDesc, [
  List<enums.ApiSortDesc>? defaultValue,
]) {
  if (apiSortDesc == null) {
    return defaultValue;
  }

  return apiSortDesc.map((e) => apiSortDescFromJson(e.toString())).toList();
}

String? apiSortAscNullableToJson(enums.ApiSortAsc? apiSortAsc) {
  return apiSortAsc?.value;
}

String? apiSortAscToJson(enums.ApiSortAsc apiSortAsc) {
  return apiSortAsc.value;
}

enums.ApiSortAsc apiSortAscFromJson(
  Object? apiSortAsc, [
  enums.ApiSortAsc? defaultValue,
]) {
  return enums.ApiSortAsc.values.firstWhereOrNull(
        (e) => e.value == apiSortAsc,
      ) ??
      defaultValue ??
      enums.ApiSortAsc.swaggerGeneratedUnknown;
}

enums.ApiSortAsc? apiSortAscNullableFromJson(
  Object? apiSortAsc, [
  enums.ApiSortAsc? defaultValue,
]) {
  if (apiSortAsc == null) {
    return null;
  }
  return enums.ApiSortAsc.values.firstWhereOrNull(
        (e) => e.value == apiSortAsc,
      ) ??
      defaultValue;
}

String apiSortAscExplodedListToJson(List<enums.ApiSortAsc>? apiSortAsc) {
  return apiSortAsc?.map((e) => e.value!).join(',') ?? '';
}

List<String> apiSortAscListToJson(List<enums.ApiSortAsc>? apiSortAsc) {
  if (apiSortAsc == null) {
    return [];
  }

  return apiSortAsc.map((e) => e.value!).toList();
}

List<enums.ApiSortAsc> apiSortAscListFromJson(
  List? apiSortAsc, [
  List<enums.ApiSortAsc>? defaultValue,
]) {
  if (apiSortAsc == null) {
    return defaultValue ?? [];
  }

  return apiSortAsc.map((e) => apiSortAscFromJson(e.toString())).toList();
}

List<enums.ApiSortAsc>? apiSortAscNullableListFromJson(
  List? apiSortAsc, [
  List<enums.ApiSortAsc>? defaultValue,
]) {
  if (apiSortAsc == null) {
    return defaultValue;
  }

  return apiSortAsc.map((e) => apiSortAscFromJson(e.toString())).toList();
}

String? apiStripTagsTrueNullableToJson(
  enums.ApiStripTagsTrue? apiStripTagsTrue,
) {
  return apiStripTagsTrue?.value;
}

String? apiStripTagsTrueToJson(enums.ApiStripTagsTrue apiStripTagsTrue) {
  return apiStripTagsTrue.value;
}

enums.ApiStripTagsTrue apiStripTagsTrueFromJson(
  Object? apiStripTagsTrue, [
  enums.ApiStripTagsTrue? defaultValue,
]) {
  return enums.ApiStripTagsTrue.values.firstWhereOrNull(
        (e) => e.value == apiStripTagsTrue,
      ) ??
      defaultValue ??
      enums.ApiStripTagsTrue.swaggerGeneratedUnknown;
}

enums.ApiStripTagsTrue? apiStripTagsTrueNullableFromJson(
  Object? apiStripTagsTrue, [
  enums.ApiStripTagsTrue? defaultValue,
]) {
  if (apiStripTagsTrue == null) {
    return null;
  }
  return enums.ApiStripTagsTrue.values.firstWhereOrNull(
        (e) => e.value == apiStripTagsTrue,
      ) ??
      defaultValue;
}

String apiStripTagsTrueExplodedListToJson(
  List<enums.ApiStripTagsTrue>? apiStripTagsTrue,
) {
  return apiStripTagsTrue?.map((e) => e.value!).join(',') ?? '';
}

List<String> apiStripTagsTrueListToJson(
  List<enums.ApiStripTagsTrue>? apiStripTagsTrue,
) {
  if (apiStripTagsTrue == null) {
    return [];
  }

  return apiStripTagsTrue.map((e) => e.value!).toList();
}

List<enums.ApiStripTagsTrue> apiStripTagsTrueListFromJson(
  List? apiStripTagsTrue, [
  List<enums.ApiStripTagsTrue>? defaultValue,
]) {
  if (apiStripTagsTrue == null) {
    return defaultValue ?? [];
  }

  return apiStripTagsTrue.map((e) => apiStripTagsTrueFromJson(e.toString())).toList();
}

List<enums.ApiStripTagsTrue>? apiStripTagsTrueNullableListFromJson(
  List? apiStripTagsTrue, [
  List<enums.ApiStripTagsTrue>? defaultValue,
]) {
  if (apiStripTagsTrue == null) {
    return defaultValue;
  }

  return apiStripTagsTrue.map((e) => apiStripTagsTrueFromJson(e.toString())).toList();
}

String? apiStripTagsFalseNullableToJson(
  enums.ApiStripTagsFalse? apiStripTagsFalse,
) {
  return apiStripTagsFalse?.value;
}

String? apiStripTagsFalseToJson(enums.ApiStripTagsFalse apiStripTagsFalse) {
  return apiStripTagsFalse.value;
}

enums.ApiStripTagsFalse apiStripTagsFalseFromJson(
  Object? apiStripTagsFalse, [
  enums.ApiStripTagsFalse? defaultValue,
]) {
  return enums.ApiStripTagsFalse.values.firstWhereOrNull(
        (e) => e.value == apiStripTagsFalse,
      ) ??
      defaultValue ??
      enums.ApiStripTagsFalse.swaggerGeneratedUnknown;
}

enums.ApiStripTagsFalse? apiStripTagsFalseNullableFromJson(
  Object? apiStripTagsFalse, [
  enums.ApiStripTagsFalse? defaultValue,
]) {
  if (apiStripTagsFalse == null) {
    return null;
  }
  return enums.ApiStripTagsFalse.values.firstWhereOrNull(
        (e) => e.value == apiStripTagsFalse,
      ) ??
      defaultValue;
}

String apiStripTagsFalseExplodedListToJson(
  List<enums.ApiStripTagsFalse>? apiStripTagsFalse,
) {
  return apiStripTagsFalse?.map((e) => e.value!).join(',') ?? '';
}

List<String> apiStripTagsFalseListToJson(
  List<enums.ApiStripTagsFalse>? apiStripTagsFalse,
) {
  if (apiStripTagsFalse == null) {
    return [];
  }

  return apiStripTagsFalse.map((e) => e.value!).toList();
}

List<enums.ApiStripTagsFalse> apiStripTagsFalseListFromJson(
  List? apiStripTagsFalse, [
  List<enums.ApiStripTagsFalse>? defaultValue,
]) {
  if (apiStripTagsFalse == null) {
    return defaultValue ?? [];
  }

  return apiStripTagsFalse.map((e) => apiStripTagsFalseFromJson(e.toString())).toList();
}

List<enums.ApiStripTagsFalse>? apiStripTagsFalseNullableListFromJson(
  List? apiStripTagsFalse, [
  List<enums.ApiStripTagsFalse>? defaultValue,
]) {
  if (apiStripTagsFalse == null) {
    return defaultValue;
  }

  return apiStripTagsFalse.map((e) => apiStripTagsFalseFromJson(e.toString())).toList();
}

String? apiStripTagsNullableToJson(enums.ApiStripTags? apiStripTags) {
  return apiStripTags?.value;
}

String? apiStripTagsToJson(enums.ApiStripTags apiStripTags) {
  return apiStripTags.value;
}

enums.ApiStripTags apiStripTagsFromJson(
  Object? apiStripTags, [
  enums.ApiStripTags? defaultValue,
]) {
  return enums.ApiStripTags.values.firstWhereOrNull(
        (e) => e.value == apiStripTags,
      ) ??
      defaultValue ??
      enums.ApiStripTags.swaggerGeneratedUnknown;
}

enums.ApiStripTags? apiStripTagsNullableFromJson(
  Object? apiStripTags, [
  enums.ApiStripTags? defaultValue,
]) {
  if (apiStripTags == null) {
    return null;
  }
  return enums.ApiStripTags.values.firstWhereOrNull(
        (e) => e.value == apiStripTags,
      ) ??
      defaultValue;
}

String apiStripTagsExplodedListToJson(List<enums.ApiStripTags>? apiStripTags) {
  return apiStripTags?.map((e) => e.value!).join(',') ?? '';
}

List<String> apiStripTagsListToJson(List<enums.ApiStripTags>? apiStripTags) {
  if (apiStripTags == null) {
    return [];
  }

  return apiStripTags.map((e) => e.value!).toList();
}

List<enums.ApiStripTags> apiStripTagsListFromJson(
  List? apiStripTags, [
  List<enums.ApiStripTags>? defaultValue,
]) {
  if (apiStripTags == null) {
    return defaultValue ?? [];
  }

  return apiStripTags.map((e) => apiStripTagsFromJson(e.toString())).toList();
}

List<enums.ApiStripTags>? apiStripTagsNullableListFromJson(
  List? apiStripTags, [
  List<enums.ApiStripTags>? defaultValue,
]) {
  if (apiStripTags == null) {
    return defaultValue;
  }

  return apiStripTags.map((e) => apiStripTagsFromJson(e.toString())).toList();
}

String? factionContributorsGetCatNullableToJson(
  enums.FactionContributorsGetCat? factionContributorsGetCat,
) {
  return factionContributorsGetCat?.value;
}

String? factionContributorsGetCatToJson(
  enums.FactionContributorsGetCat factionContributorsGetCat,
) {
  return factionContributorsGetCat.value;
}

enums.FactionContributorsGetCat factionContributorsGetCatFromJson(
  Object? factionContributorsGetCat, [
  enums.FactionContributorsGetCat? defaultValue,
]) {
  return enums.FactionContributorsGetCat.values.firstWhereOrNull(
        (e) => e.value == factionContributorsGetCat,
      ) ??
      defaultValue ??
      enums.FactionContributorsGetCat.swaggerGeneratedUnknown;
}

enums.FactionContributorsGetCat? factionContributorsGetCatNullableFromJson(
  Object? factionContributorsGetCat, [
  enums.FactionContributorsGetCat? defaultValue,
]) {
  if (factionContributorsGetCat == null) {
    return null;
  }
  return enums.FactionContributorsGetCat.values.firstWhereOrNull(
        (e) => e.value == factionContributorsGetCat,
      ) ??
      defaultValue;
}

String factionContributorsGetCatExplodedListToJson(
  List<enums.FactionContributorsGetCat>? factionContributorsGetCat,
) {
  return factionContributorsGetCat?.map((e) => e.value!).join(',') ?? '';
}

List<String> factionContributorsGetCatListToJson(
  List<enums.FactionContributorsGetCat>? factionContributorsGetCat,
) {
  if (factionContributorsGetCat == null) {
    return [];
  }

  return factionContributorsGetCat.map((e) => e.value!).toList();
}

List<enums.FactionContributorsGetCat> factionContributorsGetCatListFromJson(
  List? factionContributorsGetCat, [
  List<enums.FactionContributorsGetCat>? defaultValue,
]) {
  if (factionContributorsGetCat == null) {
    return defaultValue ?? [];
  }

  return factionContributorsGetCat.map((e) => factionContributorsGetCatFromJson(e.toString())).toList();
}

List<enums.FactionContributorsGetCat>? factionContributorsGetCatNullableListFromJson(
  List? factionContributorsGetCat, [
  List<enums.FactionContributorsGetCat>? defaultValue,
]) {
  if (factionContributorsGetCat == null) {
    return defaultValue;
  }

  return factionContributorsGetCat.map((e) => factionContributorsGetCatFromJson(e.toString())).toList();
}

String? factionCrimesGetCatNullableToJson(
  enums.FactionCrimesGetCat? factionCrimesGetCat,
) {
  return factionCrimesGetCat?.value;
}

String? factionCrimesGetCatToJson(
  enums.FactionCrimesGetCat factionCrimesGetCat,
) {
  return factionCrimesGetCat.value;
}

enums.FactionCrimesGetCat factionCrimesGetCatFromJson(
  Object? factionCrimesGetCat, [
  enums.FactionCrimesGetCat? defaultValue,
]) {
  return enums.FactionCrimesGetCat.values.firstWhereOrNull(
        (e) => e.value == factionCrimesGetCat,
      ) ??
      defaultValue ??
      enums.FactionCrimesGetCat.swaggerGeneratedUnknown;
}

enums.FactionCrimesGetCat? factionCrimesGetCatNullableFromJson(
  Object? factionCrimesGetCat, [
  enums.FactionCrimesGetCat? defaultValue,
]) {
  if (factionCrimesGetCat == null) {
    return null;
  }
  return enums.FactionCrimesGetCat.values.firstWhereOrNull(
        (e) => e.value == factionCrimesGetCat,
      ) ??
      defaultValue;
}

String factionCrimesGetCatExplodedListToJson(
  List<enums.FactionCrimesGetCat>? factionCrimesGetCat,
) {
  return factionCrimesGetCat?.map((e) => e.value!).join(',') ?? '';
}

List<String> factionCrimesGetCatListToJson(
  List<enums.FactionCrimesGetCat>? factionCrimesGetCat,
) {
  if (factionCrimesGetCat == null) {
    return [];
  }

  return factionCrimesGetCat.map((e) => e.value!).toList();
}

List<enums.FactionCrimesGetCat> factionCrimesGetCatListFromJson(
  List? factionCrimesGetCat, [
  List<enums.FactionCrimesGetCat>? defaultValue,
]) {
  if (factionCrimesGetCat == null) {
    return defaultValue ?? [];
  }

  return factionCrimesGetCat.map((e) => factionCrimesGetCatFromJson(e.toString())).toList();
}

List<enums.FactionCrimesGetCat>? factionCrimesGetCatNullableListFromJson(
  List? factionCrimesGetCat, [
  List<enums.FactionCrimesGetCat>? defaultValue,
]) {
  if (factionCrimesGetCat == null) {
    return defaultValue;
  }

  return factionCrimesGetCat.map((e) => factionCrimesGetCatFromJson(e.toString())).toList();
}

String? factionCrimesGetFiltersNullableToJson(
  enums.FactionCrimesGetFilters? factionCrimesGetFilters,
) {
  return factionCrimesGetFilters?.value;
}

String? factionCrimesGetFiltersToJson(
  enums.FactionCrimesGetFilters factionCrimesGetFilters,
) {
  return factionCrimesGetFilters.value;
}

enums.FactionCrimesGetFilters factionCrimesGetFiltersFromJson(
  Object? factionCrimesGetFilters, [
  enums.FactionCrimesGetFilters? defaultValue,
]) {
  return enums.FactionCrimesGetFilters.values.firstWhereOrNull(
        (e) => e.value == factionCrimesGetFilters,
      ) ??
      defaultValue ??
      enums.FactionCrimesGetFilters.swaggerGeneratedUnknown;
}

enums.FactionCrimesGetFilters? factionCrimesGetFiltersNullableFromJson(
  Object? factionCrimesGetFilters, [
  enums.FactionCrimesGetFilters? defaultValue,
]) {
  if (factionCrimesGetFilters == null) {
    return null;
  }
  return enums.FactionCrimesGetFilters.values.firstWhereOrNull(
        (e) => e.value == factionCrimesGetFilters,
      ) ??
      defaultValue;
}

String factionCrimesGetFiltersExplodedListToJson(
  List<enums.FactionCrimesGetFilters>? factionCrimesGetFilters,
) {
  return factionCrimesGetFilters?.map((e) => e.value!).join(',') ?? '';
}

List<String> factionCrimesGetFiltersListToJson(
  List<enums.FactionCrimesGetFilters>? factionCrimesGetFilters,
) {
  if (factionCrimesGetFilters == null) {
    return [];
  }

  return factionCrimesGetFilters.map((e) => e.value!).toList();
}

List<enums.FactionCrimesGetFilters> factionCrimesGetFiltersListFromJson(
  List? factionCrimesGetFilters, [
  List<enums.FactionCrimesGetFilters>? defaultValue,
]) {
  if (factionCrimesGetFilters == null) {
    return defaultValue ?? [];
  }

  return factionCrimesGetFilters.map((e) => factionCrimesGetFiltersFromJson(e.toString())).toList();
}

List<enums.FactionCrimesGetFilters>? factionCrimesGetFiltersNullableListFromJson(
  List? factionCrimesGetFilters, [
  List<enums.FactionCrimesGetFilters>? defaultValue,
]) {
  if (factionCrimesGetFilters == null) {
    return defaultValue;
  }

  return factionCrimesGetFilters.map((e) => factionCrimesGetFiltersFromJson(e.toString())).toList();
}

String? factionGetFiltersNullableToJson(
  enums.FactionGetFilters? factionGetFilters,
) {
  return factionGetFilters?.value;
}

String? factionGetFiltersToJson(enums.FactionGetFilters factionGetFilters) {
  return factionGetFilters.value;
}

enums.FactionGetFilters factionGetFiltersFromJson(
  Object? factionGetFilters, [
  enums.FactionGetFilters? defaultValue,
]) {
  return enums.FactionGetFilters.values.firstWhereOrNull(
        (e) => e.value == factionGetFilters,
      ) ??
      defaultValue ??
      enums.FactionGetFilters.swaggerGeneratedUnknown;
}

enums.FactionGetFilters? factionGetFiltersNullableFromJson(
  Object? factionGetFilters, [
  enums.FactionGetFilters? defaultValue,
]) {
  if (factionGetFilters == null) {
    return null;
  }
  return enums.FactionGetFilters.values.firstWhereOrNull(
        (e) => e.value == factionGetFilters,
      ) ??
      defaultValue;
}

String factionGetFiltersExplodedListToJson(
  List<enums.FactionGetFilters>? factionGetFilters,
) {
  return factionGetFilters?.map((e) => e.value!).join(',') ?? '';
}

List<String> factionGetFiltersListToJson(
  List<enums.FactionGetFilters>? factionGetFilters,
) {
  if (factionGetFilters == null) {
    return [];
  }

  return factionGetFilters.map((e) => e.value!).toList();
}

List<enums.FactionGetFilters> factionGetFiltersListFromJson(
  List? factionGetFilters, [
  List<enums.FactionGetFilters>? defaultValue,
]) {
  if (factionGetFilters == null) {
    return defaultValue ?? [];
  }

  return factionGetFilters.map((e) => factionGetFiltersFromJson(e.toString())).toList();
}

List<enums.FactionGetFilters>? factionGetFiltersNullableListFromJson(
  List? factionGetFilters, [
  List<enums.FactionGetFilters>? defaultValue,
]) {
  if (factionGetFilters == null) {
    return defaultValue;
  }

  return factionGetFilters.map((e) => factionGetFiltersFromJson(e.toString())).toList();
}

String? marketGetSortNullableToJson(enums.MarketGetSort? marketGetSort) {
  return marketGetSort?.value;
}

String? marketGetSortToJson(enums.MarketGetSort marketGetSort) {
  return marketGetSort.value;
}

enums.MarketGetSort marketGetSortFromJson(
  Object? marketGetSort, [
  enums.MarketGetSort? defaultValue,
]) {
  return enums.MarketGetSort.values.firstWhereOrNull(
        (e) => e.value == marketGetSort,
      ) ??
      defaultValue ??
      enums.MarketGetSort.swaggerGeneratedUnknown;
}

enums.MarketGetSort? marketGetSortNullableFromJson(
  Object? marketGetSort, [
  enums.MarketGetSort? defaultValue,
]) {
  if (marketGetSort == null) {
    return null;
  }
  return enums.MarketGetSort.values.firstWhereOrNull(
        (e) => e.value == marketGetSort,
      ) ??
      defaultValue;
}

String marketGetSortExplodedListToJson(
  List<enums.MarketGetSort>? marketGetSort,
) {
  return marketGetSort?.map((e) => e.value!).join(',') ?? '';
}

List<String> marketGetSortListToJson(List<enums.MarketGetSort>? marketGetSort) {
  if (marketGetSort == null) {
    return [];
  }

  return marketGetSort.map((e) => e.value!).toList();
}

List<enums.MarketGetSort> marketGetSortListFromJson(
  List? marketGetSort, [
  List<enums.MarketGetSort>? defaultValue,
]) {
  if (marketGetSort == null) {
    return defaultValue ?? [];
  }

  return marketGetSort.map((e) => marketGetSortFromJson(e.toString())).toList();
}

List<enums.MarketGetSort>? marketGetSortNullableListFromJson(
  List? marketGetSort, [
  List<enums.MarketGetSort>? defaultValue,
]) {
  if (marketGetSort == null) {
    return defaultValue;
  }

  return marketGetSort.map((e) => marketGetSortFromJson(e.toString())).toList();
}

typedef $JsonFactory<T> = T Function(Map<String, dynamic> json);

class $CustomJsonDecoder {
  $CustomJsonDecoder(this.factories);

  final Map<Type, $JsonFactory> factories;

  dynamic decode<T>(dynamic entity) {
    if (entity is Iterable) {
      return _decodeList<T>(entity);
    }

    if (entity is T) {
      return entity;
    }

    if (isTypeOf<T, Map>()) {
      return entity;
    }

    if (isTypeOf<T, Iterable>()) {
      return entity;
    }

    if (entity is Map<String, dynamic>) {
      return _decodeMap<T>(entity);
    }

    return entity;
  }

  T _decodeMap<T>(Map<String, dynamic> values) {
    final jsonFactory = factories[T];
    if (jsonFactory == null || jsonFactory is! $JsonFactory<T>) {
      return throw "Could not find factory for type $T. Is '$T: $T.fromJsonFactory' included in the CustomJsonDecoder instance creation in bootstrapper.dart?";
    }

    return jsonFactory(values);
  }

  List<T> _decodeList<T>(Iterable values) => values.where((v) => v != null).map<T>((v) => decode<T>(v) as T).toList();
}

class $JsonSerializableConverter extends chopper.JsonConverter {
  @override
  FutureOr<chopper.Response<ResultType>> convertResponse<ResultType, Item>(
    chopper.Response response,
  ) async {
    if (response.bodyString.isEmpty) {
      // In rare cases, when let's say 204 (no content) is returned -
      // we cannot decode the missing json with the result type specified
      return chopper.Response(response.base, null, error: response.error);
    }

    if (ResultType == String) {
      return response.copyWith();
    }

    if (ResultType == DateTime) {
      return response.copyWith(
        body: DateTime.parse((response.body as String).replaceAll('"', '')) as ResultType,
      );
    }

    final jsonRes = await super.convertResponse(response);
    return jsonRes.copyWith<ResultType>(
      body: $jsonDecoder.decode<Item>(jsonRes.body) as ResultType,
    );
  }
}

final $jsonDecoder = $CustomJsonDecoder(generatedMapping);

// ignore: unused_element
String? _dateToJson(DateTime? date) {
  if (date == null) {
    return null;
  }

  final year = date.year.toString();
  final month = date.month < 10 ? '0${date.month}' : date.month.toString();
  final day = date.day < 10 ? '0${date.day}' : date.day.toString();

  return '$year-$month-$day';
}

class Wrapped<T> {
  final T value;
  const Wrapped.value(this.value);
}
